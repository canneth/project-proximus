
.vsteensy/build/firmware.elf:     file format elf32-littlearm

SYMBOL TABLE:
60000000 l    d  .text.progmem	00000000 .text.progmem
00000000 l    d  .text.itcm	00000000 .text.itcm
0000dfa0 l    d  .fini	00000000 .fini
0000dfa4 l    d  .ARM.exidx	00000000 .ARM.exidx
0000dfac l    d  .text.itcm.padding	00000000 .text.itcm.padding
20000000 l    d  .data	00000000 .data
20001c50 l    d  .bss	00000000 .bss
20200000 l    d  .bss.dma	00000000 .bss.dma
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 bootdata.c
00000000 l    df *ABS*	00000000 startup.c
00002f34 l       .text.itcm	00000000 _MSP
00000000 l    df *ABS*	00000000 usb.c
00003a2c l     F .text.itcm	0000005c schedule_transfer
00003a88 l     F .text.itcm	00000036 run_callbacks
00003ac0 l     F .text.itcm	000000a4 endpoint0_transmit.constprop.1
00003b64 l     F .text.itcm	00000698 isr
200023c4 l     O .bss	00000004 endpointN_notify_mask
200023c8 l     O .bss	00000001 sof_usage
200023d4 l     O .bss	00000004 endpoint0_notify_mask
200023d8 l     O .bss	00000001 usb_reboot_timer
200023e0 l     O .bss	00000008 endpoint0_setupdata
200023e8 l     O .bss	00000008 reply_buffer
200023f0 l     O .bss	00000008 endpoint0_buffer
00000000 l    df *ABS*	00000000 analog.c
20002408 l     O .bss	00000001 calibrating
00000000 l    df *ABS*	00000000 tempmon.c
2000240c l     O .bss	00000004 s_hotTemp
20002410 l     O .bss	00000004 s_hot_ROOM
20002414 l     O .bss	00000004 s_roomC_hotC
20002418 l     O .bss	00000004 s_hotCount
00000000 l    df *ABS*	00000000 usb_desc.c
600016dc l     O .text.progmem	0000000a qualifier_descriptor
20001264 l     O .data	00000012 device_descriptor
00000000 l    df *ABS*	00000000 c:/progra~2/arduino/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/fpv5-d16/crti.o
00000000 l    df *ABS*	00000000 c:/progra~2/arduino/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/fpv5-d16/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00000020 l     F .text.itcm	00000000 __do_global_dtors_aux
20001c50 l       .bss	00000000 completed.8605
00000044 l     F .text.itcm	00000000 frame_dummy
20001c54 l       .bss	00000000 object.8610
60001740 l     O .text.progmem	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
000002a8 l     F .text.itcm	00000084 _GLOBAL__sub_I_robot
00000000 l    df *ABS*	00000000 LegStanceController.cpp
00000000 l    df *ABS*	00000000 Leg.cpp
00000000 l    df *ABS*	00000000 MyMath.cpp
00000000 l    df *ABS*	00000000 MasterController.cpp
00000000 l    df *ABS*	00000000 GaitConfig.cpp
00000000 l    df *ABS*	00000000 IMU.cpp
00000000 l    df *ABS*	00000000 Robot.cpp
00000000 l    df *ABS*	00000000 LegSwingController.cpp
20000048 l     O .data	000000b7 project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 Command.cpp
00000000 l    df *ABS*	00000000 GaitController.cpp
20000160 l     O .data	0000004f project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)::__PRETTY_FUNCTION__
200001b0 l     O .data	00000044 project_namespace::GaitController::calculateGaitPhaseIndex(int)::__PRETTY_FUNCTION__
20000394 l     O .data	00000053 project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 PWMServo.cpp
00000000 l    df *ABS*	00000000 SparkFun_BNO080_Arduino_Library.cpp
00001f58 l     F .text.itcm	00000068 BNO080::printHeader() [clone .part.7]
00001fc0 l     F .text.itcm	000001e4 BNO080::printPacket() [clone .part.6]
00000000 l    df *ABS*	00000000 WireIMXRT.cpp
00000000 l    df *ABS*	00000000 SPI.cpp
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
00003028 l     F .text.itcm	0000006c rx_queue_transfer
00003094 l     F .text.itcm	000000b4 rx_event
00003148 l     F .text.itcm	00000098 usb_serial_flush_callback
000031e0 l     F .text.itcm	0000017c usb_serial_write.part.1
200021e8 l     O .bss	00000010 rx_index
200021f8 l     O .bss	00000002 tx_packet_size
200021fa l     O .bss	00000001 tx_noautoflush
200021fb l     O .bss	00000001 tx_head
20002200 l     O .bss	00000100 rx_transfer
20002300 l     O .bss	00000001 rx_tail
20002304 l     O .bss	00000009 rx_list
2000230e l     O .bss	00000002 rx_packet_size
20200000 l     O .bss.dma	00001000 rx_buffer
20201000 l     O .bss.dma	00002000 txbuffer
20002310 l     O .bss	00000010 rx_count
20002320 l     O .bss	00000004 rx_available
20002324 l     O .bss	00000001 rx_head
20002325 l     O .bss	00000001 transmit_previous_timeout
20002326 l     O .bss	00000002 tx_available
20002340 l     O .bss	00000080 tx_transfer
00000000 l    df *ABS*	00000000 clockspeed.c
00000000 l    df *ABS*	00000000 delay.c
00000000 l    df *ABS*	00000000 pwm.c
20000600 l     O .data	0000000c CSWTCH.13
2000060c l     O .data	0000000c CSWTCH.14
2000060c l     O .data	0000000c CSWTCH.17
20000600 l     O .data	0000000c CSWTCH.16
00000000 l    df *ABS*	00000000 digital.c
00004a78 l     F .text.itcm	00000024 digitalWrite.part.0
00004a9c l     F .text.itcm	0000001c digitalRead.part.1
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 yield.cpp
2000241c l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 s_sin.c
00000000 l    df *ABS*	00000000 sf_cos.c
00000000 l    df *ABS*	00000000 sf_sin.c
00000000 l    df *ABS*	00000000 w_acos.c
00000000 l    df *ABS*	00000000 w_asin.c
00000000 l    df *ABS*	00000000 w_atan2.c
00000000 l    df *ABS*	00000000 w_pow.c
00000000 l    df *ABS*	00000000 w_sqrt.c
00000000 l    df *ABS*	00000000 wf_atan2.c
00000000 l    df *ABS*	00000000 wf_sqrt.c
00000000 l    df *ABS*	00000000 e_acos.c
00000000 l    df *ABS*	00000000 e_asin.c
00000000 l    df *ABS*	00000000 e_atan2.c
00000000 l    df *ABS*	00000000 e_pow.c
00000000 l    df *ABS*	00000000 e_rem_pio2.c
20000954 l     O .data	00000080 npio2_hw
200009d4 l     O .data	00000108 two_over_pi
00000000 l    df *ABS*	00000000 e_sqrt.c
00000000 l    df *ABS*	00000000 ef_atan2.c
00000000 l    df *ABS*	00000000 ef_rem_pio2.c
20000adc l     O .data	00000080 npio2_hw
20000b5c l     O .data	00000318 two_over_pi
00000000 l    df *ABS*	00000000 ef_sqrt.c
00000000 l    df *ABS*	00000000 k_cos.c
00000000 l    df *ABS*	00000000 k_rem_pio2.c
20000e74 l     O .data	00000010 init_jk
20000e88 l     O .data	00000040 PIo2
00000000 l    df *ABS*	00000000 k_sin.c
00000000 l    df *ABS*	00000000 kf_cos.c
00000000 l    df *ABS*	00000000 kf_rem_pio2.c
20000ec8 l     O .data	0000000c init_jk
20000ed4 l     O .data	0000002c PIo2
00000000 l    df *ABS*	00000000 kf_sin.c
00000000 l    df *ABS*	00000000 s_atan.c
20000f00 l     O .data	00000020 atanlo
20000f20 l     O .data	00000020 atanhi
00000000 l    df *ABS*	00000000 s_fabs.c
00000000 l    df *ABS*	00000000 s_finite.c
00000000 l    df *ABS*	00000000 s_floor.c
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 s_nan.c
00000000 l    df *ABS*	00000000 s_rint.c
20000f40 l     O .data	00000010 TWO52
00000000 l    df *ABS*	00000000 s_scalbn.c
00000000 l    df *ABS*	00000000 sf_atan.c
20000f50 l     O .data	00000010 atanlo
20000f60 l     O .data	00000010 atanhi
00000000 l    df *ABS*	00000000 sf_fabs.c
00000000 l    df *ABS*	00000000 sf_floor.c
00000000 l    df *ABS*	00000000 sf_scalbn.c
00000000 l    df *ABS*	00000000 s_copysign.c
00000000 l    df *ABS*	00000000 sf_copysign.c
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 fiprintf.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 vfprintf.c
20000fc0 l     O .data	00000010 zeroes.7258
20001010 l     O .data	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfprintf.c
0000a9d0 l     F .text.itcm	00000078 __sprint_r.part.0
0000b844 l     F .text.itcm	0000006a __sbprintf
20001020 l     O .data	00000010 zeroes.7252
20001030 l     O .data	00000010 blanks.7251
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0000b9c0 l     F .text.itcm	00000128 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0000c8ec l     F .text.itcm	000000f0 __sinit.part.1
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 mprec.c
20001248 l     O .data	0000000c p05.6087
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 impure.c
200012a8 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
00000000 l       *UND*	00000000 __fini_array_end
00000000 l       *UND*	00000000 __bss_start__
00000000 l       *UND*	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 __fini_array_start
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __libc_fini
00000000 l       *UND*	00000000 __stack
600016f8 l     F .text.progmem	00000008 __pwm_init_veneer
60001700 l     F .text.progmem	00000008 __startup_early_hook_veneer
60001708 l     F .text.progmem	00000008 __startup_late_hook_veneer
60001710 l     F .text.progmem	00000008 __main_veneer
60001718 l     F .text.progmem	00000008 __set_arm_clock_veneer
60001720 l     F .text.progmem	00000008 __memset_veneer
60001728 l     F .text.progmem	00000008 ____libc_init_array_veneer
60001730 l     F .text.progmem	00000008 __usb_init_serialnumber_veneer
60001738 l     F .text.progmem	00000008 __delay_veneer
0000df90 l     F .text.itcm	00000008 ___init_veneer
00000d9c g     F .text.itcm	000000e4 project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)
00003598 g     F .text.itcm	0000000c usb_serial_available
00002b0c g     F .text.itcm	00000054 BNO080::dataAvailable()
0000dbfc g     F .text.itcm	00000024 _isatty_r
00001ec8 g     F .text.itcm	00000062 PWMServo::write(int)
00002f40 g     F .text.itcm	00000002 startup_default_late_hook
0000802c g     F .text.itcm	0000000e fabs
0000dc20 g     F .text.itcm	0000002c _lseek_r
00004bb8  w    F .text.itcm	000000a0 yield
00005558 g     F .text.itcm	000000a8 sqrt
00001a80 g     F .text.itcm	00000006 project_namespace::Command::getGaitYawSpeed()
200023cc g     O .bss	00000004 usb_timer1_callback
60001638 g     O .text.progmem	00000018 usb_string_manufacturer_name_default
2000243c g     O .bss	0000001c HardwareSerial::serial_event_handler_checks
000025d0 g     F .text.itcm	0000006c BNO080::waitForI2C()
00001b58 g     F .text.itcm	000000a4 project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)
0000da78 g     F .text.itcm	00000054 _wcrtomb_r
00001770 g     F .text.itcm	00000054 project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()
000012a4 g     F .text.itcm	00000006 project_namespace::Robot::setBodyPitch(float)
00004e74 g     F .text.itcm	00000020 Print::println()
0000d8a4 g     F .text.itcm	00000020 __sseek
0000c9dc g     F .text.itcm	0000000a __sinit
0000d9cc g     F .text.itcm	000000ac __swbuf_r
00001a70 g     F .text.itcm	0000000e project_namespace::Command::getBodyVelocity()
00008ef8 g     F .text.itcm	00000002 __malloc_unlock
00001bfc g     F .text.itcm	0000009c project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)
600014ac g     F .text.progmem	00000058 analog_init
00000440 g     F .text.itcm	00000050 project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)
00001a0c g     F .text.itcm	00000034 project_namespace::Command::Command()
2000125c g     O .data	00000004 F_CPU_ACTUAL
00004f8c g     F .text.itcm	00000028 HardwareSerial::processSerialEvents()
00008d90 g     F .text.itcm	000000c6 memmove
00004d88 g     F .text.itcm	00000098 MillisTimer::runFromTimer()
00000908 g     F .text.itcm	00000494 project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)
0000d220 g     F .text.itcm	0000004c _Balloc
00001ab0 g     F .text.itcm	0000002c project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)
20002434 g     O .bss	00000001 EventResponder::runningFromYield
00000ee4 g     F .text.itcm	0000005a project_namespace::IMU::getGyro()
20000560 g     O .data	000000a0 pwm_pin_info
00008754 g     F .text.itcm	0000000c __errno
60001000 g     O .text.progmem	00000020 ImageVectorTable
20002420 g     O .bss	00000004 EventResponder::firstInterrupt
00004344 g     F .text.itcm	00000004 usb_transfer_status
00001a0c g     F .text.itcm	00000034 project_namespace::Command::Command()
00000ed8 g     F .text.itcm	00000006 project_namespace::GaitConfig::setSwingHeight(float)
00006ad4 g     F .text.itcm	00000298 __ieee754_rem_pio2f
2000128e g     O .data	00000001 usb_enable_serial_event_processing
20001260 g     O .data	00000001 analog_write_res
000017c8 g     F .text.itcm	00000244 project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)
20002070 g     O .bss	00000040 imu
00004e58  w    F .text.itcm	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
0000dbd4 g     F .text.itcm	00000028 _fstat_r
20000618 g     O .data	00000280 digital_pin_to_info_PGM
00001c98 g     F .text.itcm	0000004e project_namespace::GaitController::calculateContactPattern(int)
20004284 g     O .bss	00000004 errno
00008050 g     F .text.itcm	00000118 floor
0000dfa0 g       .text.itcm	00000000 _etext
20001c50 g       .bss	00000000 _sbss
00000ed0 g     F .text.itcm	00000006 project_namespace::GaitConfig::getSwingHeight()
00004ac4 g     F .text.itcm	0000000c digitalRead
60001750 g       *ABS*	00000000 _stextload
00000168 g     F .text.itcm	00000140 loop
00004438 g     F .text.itcm	000000b0 flexpwmWrite
000041fc g     F .text.itcm	00000064 usb_config_rx
00005608 g     F .text.itcm	000000b0 sqrtf
00004d20 g     F .text.itcm	00000068 MillisTimer::addToActiveList()
00006548 g     F .text.itcm	0000029c __ieee754_rem_pio2
20002424 g     O .bss	00000004 EventResponder::lastInterrupt
00002df0 g     F .text.itcm	00000134 memcpy
0000c8e0 g     F .text.itcm	0000000c _cleanup_r
00009460 g     F .text.itcm	00001570 _svfprintf_r
20002404 g     O .bss	00000004 systick_millis_count
00002c78 g     F .text.itcm	0000003c TwoWire::wait_idle()
00002558 g     F .text.itcm	0000003a BNO080::getGyroY()
0000dc78 g     F .text.itcm	00000000 .hidden __aeabi_uldivmod
200023f8 g     O .bss	00000001 usb_configuration
60000000 g     O .text.progmem	00000200 FlexSPI_NOR_Config
00004670 g     F .text.itcm	000000c8 analogWrite
60001638  w    O .text.progmem	00000018 usb_string_manufacturer_name
0000300c  w    F .text.itcm	0000000a _fstat
00001f38  w    F .text.itcm	0000001e TwoWire::read()
00002dd4  w    F .text.itcm	0000001c EventResponder::triggerEvent(int, void*)
00008718 g     F .text.itcm	0000003c __assert_func
20001158 g     O .data	000000c8 __mprec_tens
600013c0 g     F .text.progmem	000000ec usb_init
00006e10 g     F .text.itcm	00000120 __kernel_cos
00000440 g     F .text.itcm	00000050 project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)
00001398 g     F .text.itcm	0000006a project_namespace::Robot::updateStancePolygon()
20002464 g     O .bss	00000004 __malloc_top_pad
20004280 g     O .bss	00000004 systick_safe_read
00002b60 g     F .text.itcm	00000118 TwoWire::force_clock()
aaaaaaaf g       *ABS*	00000000 _flexram_bank_config
000023f0 g     F .text.itcm	0000003a BNO080::getQuatI()
0000d074 g     F .text.itcm	0000001c _localeconv_r
00001adc g     F .text.itcm	0000007c project_namespace::GaitController::calculateGaitPhaseIndex(int)
000024e0 g     F .text.itcm	0000003a BNO080::getQuatRadianAccuracy()
0000cd1c g     F .text.itcm	00000304 __sfvwrite_r
0000d39c g     F .text.itcm	00000012 __i2b
20000000 g       .data	00000000 _sdata
60001698 g     O .text.progmem	00000043 usb_config_descriptor_480
0000dca8 g     F .text.itcm	000002e2 .hidden __udivmoddi4
00001a48 g     F .text.itcm	00000006 project_namespace::Command::getStancePolygonWidth()
000092dc g     F .text.itcm	00000024 _sbrk_r
00002f3c g     F .text.itcm	00000002 startup_default_early_hook
60001034 g     F .text.progmem	00000268 ResetHandler
00003618 g     F .text.itcm	00000020 usb_serial_getchar
20002ac0 g     O .bss	00000008 usb_cdc_line_coding
00004ab8 g     F .text.itcm	0000000a digitalWrite
00008574 g     F .text.itcm	0000000e fabsf
2000242c g     O .bss	00000004 EventResponder::lastYield
0000dc4c g     F .text.itcm	0000002c _read_r
20001d70 g     O .bss	00000030 command
000024a4 g     F .text.itcm	0000003a BNO080::getQuatReal()
0000db50 g     F .text.itcm	00000084 _fclose_r
20002460 g     O .bss	00000004 __malloc_max_sbrked_mem
00004ad0 g     F .text.itcm	00000080 pinMode
000075b0 g     F .text.itcm	000000b0 __kernel_sin
000012ac g     F .text.itcm	00000006 project_namespace::Robot::setBodyYaw(float)
00001a68 g     F .text.itcm	00000006 project_namespace::Command::getBodyYaw()
20280000 g       .bss.dma	00000000 _heap_end
0000251c g     F .text.itcm	0000003a BNO080::getGyroX()
00003018  w    F .text.itcm	00000004 _isatty
200012a0 g     O .data	00000001 __fdlib_version
20002430 g     O .bss	00000004 EventResponder::firstYield
00008efc g     F .text.itcm	000003de _realloc_r
00008788 g     F .text.itcm	00000050 __libc_init_array
00007d94 g     F .text.itcm	00000090 __kernel_sinf
00001f2c  w    F .text.itcm	0000000c TwoWire::available()
0000ca88 g     F .text.itcm	00000026 _fputwc_r
20001220 g     O .data	00000028 __mprec_bigtens
00003024  w    F .text.itcm	00000004 abort
00002f44  w    F .text.itcm	0000008c HardFault_HandlerC
00002cb4 g     F .text.itcm	00000120 TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
00004e40  w    F .text.itcm	00000004 usb_serial_class::clear()
00002fd0 g     F .text.itcm	00000030 _sbrk
6000f6fc g       *ABS*	00000000 _sdataload
0000d630 g     F .text.itcm	00000042 __mcmp
20002438 g     O .bss	00000004 MillisTimer::listWaiting
20001254 g     O .data	00000004 __brkval
20002328 g     O .bss	00000001 usb_cdc_line_rtsdtr
600016e8 g     F .text.progmem	00000000 _init
0000335c g     F .text.itcm	00000002 usb_serial_reset
00005058 g     F .text.itcm	00000090 cosf
20001fb0 g     O .bss	000000c0 master_controller
000021a4 g     F .text.itcm	0000024c BNO080::parseInputReport()
60001654 g     O .text.progmem	00000043 usb_config_descriptor_12
00006f30 g     F .text.itcm	0000067c __kernel_rem_pio2
00004738 g     F .text.itcm	00000068 analogWriteFrequency
200042c0 g       .bss	00000000 _ebss
00001aac g     F .text.itcm	00000004 project_namespace::Command::setMode(project_namespace::Mode)
00008180 g     F .text.itcm	0000011c rint
0000157c g     F .text.itcm	000001f4 project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)
0000d300 g     F .text.itcm	00000040 __hi0bits
20203050 g       .bss.dma	00000000 _heap_start
00007660 g     F .text.itcm	00000104 __kernel_cosf
00000eb4 g     F .text.itcm	00000014 project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()
000045dc g     F .text.itcm	00000094 quadtimerFrequency
00005be0 g     F .text.itcm	000001dc __ieee754_atan2
00000002 g       *ABS*	00000000 _itcm_block_count
20003000 g     O .bss	00000020 endpoint0_transfer_data
000047a0 g     F .text.itcm	000002b8 pwm_init
00001a50 g     F .text.itcm	00000006 project_namespace::Command::getStanceHeight()
000008e8 g     F .text.itcm	0000001e project_namespace::MasterController::MasterController(project_namespace::IMU&)
00001aa4 g     F .text.itcm	00000006 project_namespace::Command::setSwingHeight(float)
6000135c g     F .text.progmem	00000064 usb_pll_start
0000d4e0 g     F .text.itcm	000000a0 __pow5mult
6000102c g     O .text.progmem	00000008 vector_table
00000000  w      *UND*	00000000 __deregister_frame_info
20003020 g     O .bss	00000020 endpoint0_transfer_ack
20002ac8 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
000042f8 g     F .text.itcm	00000028 usb_transmit
00004e20 g     F .text.itcm	00000020 systick_isr
0000141c g     F .text.itcm	00000006 project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)
20001290 g     O .data	00000010 Serial
20002458 g     O .bss	00000001 HardwareSerial::serial_event_handlers_active
00004e60  w    F .text.itcm	00000006 usb_serial_class::write(unsigned char)
00002f3c  w    F .text.itcm	00000002 startup_early_hook
00005978 g     F .text.itcm	00000264 __ieee754_asin
00003554 g     F .text.itcm	00000044 usb_serial_peekchar
0000c9e8 g     F .text.itcm	00000002 __sfp_lock_acquire
0000d180 g     F .text.itcm	00000000 memchr
00003768 g     F .text.itcm	000002c4 set_arm_clock
200023fc g     O .bss	00000004 systick_cycle_count
20001278 g     O .data	00000016 usb_string_serial_number_default
0000cb4c g     F .text.itcm	000001d0 _free_r
000087d8 g     F .text.itcm	0000001c __locale_mb_cur_max
00001a60 g     F .text.itcm	00000006 project_namespace::Command::getBodyPitch()
00001e38 g     F .text.itcm	00000008 PWMServo::PWMServo()
00004e50  w    F .text.itcm	00000004 usb_serial_class::flush()
00000eac g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitSwingDurationInTicks()
00000330 g     F .text.itcm	00000110 project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)
00002594 g     F .text.itcm	0000003a BNO080::getGyroZ()
20001c4c g     O .data	00000004 __malloc_sbrk_base
00004e48  w    F .text.itcm	00000004 usb_serial_class::read()
0000123c g     F .text.itcm	00000020 project_namespace::Robot::getFootPositionsWrtBodyTrue()
00004fb8 g     F .text.itcm	000000a0 sin
0000301c  w    F .text.itcm	00000006 _lseek
0000242c g     F .text.itcm	0000003a BNO080::getQuatJ()
0000d580 g     F .text.itcm	000000ae __lshift
000042c8 g     F .text.itcm	0000002e usb_prepare_transfer
000052d4 g     F .text.itcm	00000004 atan2
00002f24 g     F .text.itcm	00000018 unused_interrupt_vector
0000d8cc g     F .text.itcm	00000100 __ssprint_r
200023c0 g     O .bss	00000004 usb_timer0_callback
60001504 g     F .text.progmem	0000011c tempmon_init
00004e68  w    F .text.itcm	0000000c serialEvent()
000006d0 g     F .text.itcm	0000003e project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
000035a4 g     F .text.itcm	00000074 usb_serial_flush_input
0000d3b0 g     F .text.itcm	00000130 __multiply
00005dc0 g     F .text.itcm	00000784 __ieee754_pow
20001c70 g     O .bss	000000ff sprintf_buffer
000052d8 g     F .text.itcm	00000280 pow
00003638 g     F .text.itcm	0000002c usb_serial_putchar
00000024 g       *ABS*	00000000 _teensy_model_identifier
20002468 g     O .bss	00000028 __malloc_current_mallinfo
0000d788 g     F .text.itcm	000000ba __d2b
00001414 g     F .text.itcm	00000008 project_namespace::Robot::setStanceHeight(float)
00001e40 g     F .text.itcm	00000088 PWMServo::attach(int, int, int)
0000db2c g     F .text.itcm	00000024 _close_r
00001ce8 g     F .text.itcm	00000150 project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)
20000904  w    O .data	00000028 vtable for usb_serial_class
20001da0 g     O .bss	00000210 robot
20002400 g     O .bss	00000004 scale_cpu_cycles_to_microseconds
000008e8 g     F .text.itcm	0000001e project_namespace::MasterController::MasterController(project_namespace::IMU&)
00002468 g     F .text.itcm	0000003a BNO080::getQuatK()
0000b8f8 g     F .text.itcm	000000c8 __swsetup_r
20002428 g     O .bss	00000004 MillisTimer::listActive
0000df8c  w    F .text.itcm	00000002 .hidden __aeabi_ldiv0
00001ab0 g     F .text.itcm	0000002c project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)
20001840 g     O .data	00000408 __malloc_av_
0000d844 g     F .text.itcm	00000022 __sread
000036c8 g     F .text.itcm	000000a0 usb_serial_flush_output
00000fbc g     F .text.itcm	00000280 project_namespace::Robot::Robot()
00008ef4 g     F .text.itcm	00000002 __malloc_lock
00008614 g     F .text.itcm	000000d0 scalbnf
20002800 g     O .bss	000002c0 _VectorsRam
0000c8b4 g     F .text.itcm	0000002c _fflush_r
0000dacc g     F .text.itcm	0000005e _calloc_r
200023d0 g     O .bss	00000001 usb_high_speed
00008e58 g     F .text.itcm	0000009a memset
00006d6c g     F .text.itcm	000000a2 __ieee754_sqrtf
00000d9c g     F .text.itcm	000000e4 project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)
00004ba8 g     F .text.itcm	00000010 main
2000245c g     O .bss	00000004 __malloc_max_total_mem
0000278c g     F .text.itcm	00000380 BNO080::receivePacket()
0000263c g     F .text.itcm	00000150 BNO080::getData(unsigned short)
20203000 g     O .bss.dma	00000043 usb_descriptor_buffer
20001c6c g     O .bss	00000004 last_time
0000d8c4 g     F .text.itcm	00000008 __sclose
00008168 g     F .text.itcm	00000004 matherr
00004b50 g     F .text.itcm	00000058 usb_init_serialnumber
60001748 g       .text.progmem	00000000 __init_array_end
0000bae8 g     F .text.itcm	00000c84 _dtoa_r
000087f4 g     F .text.itcm	00000570 _malloc_r
0000b8b0 g     F .text.itcm	0000001a __ascii_wctomb
200003e8  w    O .data	00000010 SPIClass::beginTransaction(SPISettings)::clk_sel
00004c58 g     F .text.itcm	00000080 EventResponder::triggerEventNotImmediate()
00000031 g       *ABS*	00000000 __rtc_localtime
0000141c g     F .text.itcm	00000006 project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)
0000cab0 g     F .text.itcm	0000009c _malloc_trim_r
60001650 g     O .text.progmem	00000004 string0
00003664 g     F .text.itcm	00000018 usb_serial_write
0000803c g     F .text.itcm	00000010 finite
0000032c g     F .text.itcm	00000004 project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)
00002f40  w    F .text.itcm	00000002 startup_late_hook
000044e8 g     F .text.itcm	000000f4 flexpwmFrequency
00000ea4 g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitNumberOfPhases()
00004e4c  w    F .text.itcm	00000004 usb_serial_class::available()
00000f40 g     F .text.itcm	0000007a project_namespace::IMU::getHeadingQuaternion()
20004000 g     O .bss	00000280 endpoint_queue_head
60001620  w    O .text.progmem	00000016 usb_string_product_name
00000ee0 g     F .text.itcm	00000004 project_namespace::IMU::IMU(BNO080&)
000086e4 g     F .text.itcm	0000001a copysign
00004348 g     F .text.itcm	000000cc delay
0000dfa0 g     F .fini	00000000 _fini
60001020 g     O .text.progmem	0000000c BootData
00008700 g     F .text.itcm	00000018 copysignf
00007e28 g     F .text.itcm	00000204 atan
00009300 g     F .text.itcm	0000004c sprintf
00004f24 g     F .text.itcm	00000016 Print::print(long)
00004414 g     F .text.itcm	00000024 Panic_Temp_isr
00000eb0 g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitCycleDurationInTicks()
0000129c g     F .text.itcm	00000006 project_namespace::Robot::setBodyRoll(float)
00001a40 g     F .text.itcm	00000006 project_namespace::Command::getStancePolygonLength()
0000b8cc g     F .text.itcm	0000002c _write_r
00004a58 g     F .text.itcm	00000020 analogWriteRes
00005228 g     F .text.itcm	000000ac asin
200016d0 g     O .data	00000004 _impure_ptr
0000c76c g     F .text.itcm	00000148 __sflush_r
000082a0 g     F .text.itcm	0000011c scalbn
00005600 g     F .text.itcm	00000004 atan2f
60001740 g       .text.progmem	00000000 __preinit_array_end
200020b0 g     O .bss	00000130 imu_hardware
0000140c g     F .text.itcm	00000008 project_namespace::Robot::setStancePolygonWidth(float)
00008d64 g     F .text.itcm	0000002a __ascii_mbtowc
000012b4 g     F .text.itcm	00000032 project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)
0000007c g     F .text.itcm	000000ec setup
20000898 g     O .data	0000006c usb_descriptor_list
00000ea8 g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitStanceDurationInTicks()
00001404 g     F .text.itcm	00000008 project_namespace::Robot::setStancePolygonLength(float)
000050e8 g     F .text.itcm	00000094 sinf
00008170 g     F .text.itcm	00000010 nan
0000125c g     F .text.itcm	00000020 project_namespace::Robot::getFootPositionsWrtBodyAssumingNoBodyRPY()
00001a90 g     F .text.itcm	00000004 project_namespace::Command::getMode()
000067e4 g     F .text.itcm	00000184 __ieee754_sqrt
0000127c g     F .text.itcm	00000020 project_namespace::Robot::getFootPositionsWrtBodyAtRest()
0000d090 g     F .text.itcm	0000005e __swhatbuf_r
20070000 g       .bss.dma	00000000 _estack
0000367c g     F .text.itcm	0000004c usb_serial_write_buffer_free
00000490 g     F .text.itcm	000001c0 project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
00003360 g     F .text.itcm	00000108 usb_serial_configure
200021e0 g     O .bss	00000008 PWMServo::attachedpins
00004e94  w    F .text.itcm	0000000e _write
20001c50 g       .data	00000000 _edata
0000c9f0 g     F .text.itcm	00000098 __fputwc
00004e54  w    F .text.itcm	00000004 usb_serial_class::availableForWrite()
00001304 g     F .text.itcm	00000092 project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)
00004f3c g     F .text.itcm	0000004e ultoa
0000d868 g     F .text.itcm	0000003c __swrite
00004cd8 g     F .text.itcm	00000044 EventResponder::runFromInterrupt()
20001c48 g     O .data	00000004 __malloc_trim_threshold
00004e44  w    F .text.itcm	00000004 usb_serial_class::peek()
00008760 g     F .text.itcm	00000028 fiprintf
0000aa48 g     F .text.itcm	00000dfc _vfiprintf_r
0000d020 g     F .text.itcm	00000052 _fwalk_reent
0000d674 g     F .text.itcm	00000114 __mdiff
00001424 g     F .text.itcm	00000158 project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)
0000c9ec g     F .text.itcm	00000002 __sfp_lock_release
000083bc g     F .text.itcm	000001b8 atanf
00000710  w    F .text.itcm	0000009e Eigen::Matrix<float, 3, 3, 0, 3, 3>& Eigen::Matrix<float, 3, 3, 0, 3, 3>::operator=<Eigen::Quaternion<float, 0> >(Eigen::RotationBase<Eigen::Quaternion<float, 0>, 3> const&)
00001a58 g     F .text.itcm	00000006 project_namespace::Command::getBodyRoll()
20001040 g     O .data	00000101 _ctype_
00003000  w    F .text.itcm	00000004 _read
0000df8c  w    F .text.itcm	00000002 .hidden __aeabi_idiv0
60001740 g       .text.progmem	00000000 __init_array_start
20001258 g     O .data	00000004 F_BUS_ACTUAL
0000032c g     F .text.itcm	00000004 project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)
00007764 g     F .text.itcm	00000630 __kernel_rem_pio2f
0000d0f0 g     F .text.itcm	00000088 __smakebuf_r
00000000 g       .text.itcm	00000000 _stext
00000ec8 g     F .text.itcm	00000004 project_namespace::GaitConfig::getLegStanceDurationInTicks()
00009380 g     F .text.itcm	000000dc strlen
60001620 g     O .text.progmem	00000016 usb_string_product_name_default
00000e80 g     F .text.itcm	00000024 project_namespace::GaitConfig::getContactSchedule()
00001a88 g     F .text.itcm	00000006 project_namespace::Command::getSwingHeight()
00000ee0 g     F .text.itcm	00000004 project_namespace::IMU::IMU(BNO080&)
00001e38 g     F .text.itcm	00000008 PWMServo::PWMServo()
00008584 g     F .text.itcm	00000090 floorf
6000129c g     F .text.progmem	000000c0 configure_cache
00001a94 g     F .text.itcm	0000000e project_namespace::Command::setBodyVelocity(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
0000517c g     F .text.itcm	000000ac acos
00000000  w      *UND*	00000000 _Jv_RegisterClasses
60001740 g       .text.progmem	00000000 __preinit_array_start
00004320 g     F .text.itcm	00000024 usb_receive
0000d340 g     F .text.itcm	0000005a __lo0bits
00011340 g       *ABS*	00000000 _flashimagelen
000007b0 g     F .text.itcm	00000138 project_namespace::MyMath::eulerToMatrix(float, float, float)
00000000  w      *UND*	00000000 __register_frame_info
00000650 g     F .text.itcm	00000080 project_namespace::Leg::moveLegToJointAngles(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
00004d1c g     F .text.itcm	00000004 pendablesrvreq_isr
200016d4 g     O .data	0000016c __global_locale
00000fbc g     F .text.itcm	00000280 project_namespace::Robot::Robot()
000012e8 g     F .text.itcm	0000001a project_namespace::Robot::setContactPattern(Eigen::Matrix<int, 4, 1, 0, 4, 1>)
00003468 g     F .text.itcm	000000ec usb_serial_read
00004ea4 g     F .text.itcm	0000007e Print::printNumber(unsigned long, unsigned char, unsigned char)
00004260 g     F .text.itcm	00000068 usb_config_tx
00003004  w    F .text.itcm	00000006 _close
00000ecc g     F .text.itcm	00000004 project_namespace::GaitConfig::getLegSwingDurationInTicks()
000056b8 g     F .text.itcm	000002bc __ieee754_acos
0000d280 g     F .text.itcm	00000080 __multadd
0000d26c g     F .text.itcm	00000012 _Bfree
00006968 g     F .text.itcm	0000016c __ieee754_atan2f
20001278  w    O .data	00000016 usb_string_serial_number



Disassembly of section .text.progmem:

60000000 <FlexSPI_NOR_Config>:
60000000:	FCFB...V........
	...
60000044:	.............. .
	...
60000080:	.....2.&........
60000090:	...$............
	...
600000b0:	................
	...
600000d0:	 ...............
	...
60000100:	................
60000110:	..... ..........
	...
60000130:	`...............
	...
600001c0:	................
600001d0:	................
	...
60000200:	................
60000210:	................
60000220:	................
60000230:	................
60000240:	................
60000250:	................
60000260:	................
60000270:	................
60000280:	................
60000290:	................
600002a0:	................
600002b0:	................
600002c0:	................
600002d0:	................
600002e0:	................
600002f0:	................
60000300:	................
60000310:	................
60000320:	................
60000330:	................
60000340:	................
60000350:	................
60000360:	................
60000370:	................
60000380:	................
60000390:	................
600003a0:	................
600003b0:	................
600003c0:	................
600003d0:	................
600003e0:	................
600003f0:	................
60000400:	................
60000410:	................
60000420:	................
60000430:	................
60000440:	................
60000450:	................
60000460:	................
60000470:	................
60000480:	................
60000490:	................
600004a0:	................
600004b0:	................
600004c0:	................
600004d0:	................
600004e0:	................
600004f0:	................
60000500:	................
60000510:	................
60000520:	................
60000530:	................
60000540:	................
60000550:	................
60000560:	................
60000570:	................
60000580:	................
60000590:	................
600005a0:	................
600005b0:	................
600005c0:	................
600005d0:	................
600005e0:	................
600005f0:	................
60000600:	................
60000610:	................
60000620:	................
60000630:	................
60000640:	................
60000650:	................
60000660:	................
60000670:	................
60000680:	................
60000690:	................
600006a0:	................
600006b0:	................
600006c0:	................
600006d0:	................
600006e0:	................
600006f0:	................
60000700:	................
60000710:	................
60000720:	................
60000730:	................
60000740:	................
60000750:	................
60000760:	................
60000770:	................
60000780:	................
60000790:	................
600007a0:	................
600007b0:	................
600007c0:	................
600007d0:	................
600007e0:	................
600007f0:	................
60000800:	................
60000810:	................
60000820:	................
60000830:	................
60000840:	................
60000850:	................
60000860:	................
60000870:	................
60000880:	................
60000890:	................
600008a0:	................
600008b0:	................
600008c0:	................
600008d0:	................
600008e0:	................
600008f0:	................
60000900:	................
60000910:	................
60000920:	................
60000930:	................
60000940:	................
60000950:	................
60000960:	................
60000970:	................
60000980:	................
60000990:	................
600009a0:	................
600009b0:	................
600009c0:	................
600009d0:	................
600009e0:	................
600009f0:	................
60000a00:	................
60000a10:	................
60000a20:	................
60000a30:	................
60000a40:	................
60000a50:	................
60000a60:	................
60000a70:	................
60000a80:	................
60000a90:	................
60000aa0:	................
60000ab0:	................
60000ac0:	................
60000ad0:	................
60000ae0:	................
60000af0:	................
60000b00:	................
60000b10:	................
60000b20:	................
60000b30:	................
60000b40:	................
60000b50:	................
60000b60:	................
60000b70:	................
60000b80:	................
60000b90:	................
60000ba0:	................
60000bb0:	................
60000bc0:	................
60000bd0:	................
60000be0:	................
60000bf0:	................
60000c00:	................
60000c10:	................
60000c20:	................
60000c30:	................
60000c40:	................
60000c50:	................
60000c60:	................
60000c70:	................
60000c80:	................
60000c90:	................
60000ca0:	................
60000cb0:	................
60000cc0:	................
60000cd0:	................
60000ce0:	................
60000cf0:	................
60000d00:	................
60000d10:	................
60000d20:	................
60000d30:	................
60000d40:	................
60000d50:	................
60000d60:	................
60000d70:	................
60000d80:	................
60000d90:	................
60000da0:	................
60000db0:	................
60000dc0:	................
60000dd0:	................
60000de0:	................
60000df0:	................
60000e00:	................
60000e10:	................
60000e20:	................
60000e30:	................
60000e40:	................
60000e50:	................
60000e60:	................
60000e70:	................
60000e80:	................
60000e90:	................
60000ea0:	................
60000eb0:	................
60000ec0:	................
60000ed0:	................
60000ee0:	................
60000ef0:	................
60000f00:	................
60000f10:	................
60000f20:	................
60000f30:	................
60000f40:	................
60000f50:	................
60000f60:	................
60000f70:	................
60000f80:	................
60000f90:	................
60000fa0:	................
60000fb0:	................
60000fc0:	................
60000fd0:	................
60000fe0:	................
60000ff0:	................

60001000 <ImageVectorTable>:
60001000:	.. @,..`........
60001010:	 ..`...`........

60001020 <BootData>:
60001020:	...`@.......

6000102c <vector_table>:
6000102c:	... 5..`

60001034 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001034:	ldr	r3, [pc, #464]	; (60001208 <ResetHandler+0x1d4>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001036:	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103a:	ldr	r2, [pc, #464]	; (6000120c <ResetHandler+0x1d8>)
	IOMUXC_GPR_GPR16 = 0x00200007;
6000103c:	ldr	r0, [pc, #464]	; (60001210 <ResetHandler+0x1dc>)
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103e:	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001040:	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001042:	ldr	r2, [pc, #464]	; (60001214 <ResetHandler+0x1e0>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001044:	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001046:	mov	sp, r2
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001048:	ldr	r2, [pc, #460]	; (60001218 <ResetHandler+0x1e4>)
6000104a:	ldr	r1, [pc, #464]	; (6000121c <ResetHandler+0x1e8>)
6000104c:	cmp	r2, r1
6000104e:	beq.n	60001070 <ResetHandler+0x3c>
	while (dest < dest_end) {
60001050:	ldr	r3, [pc, #460]	; (60001220 <ResetHandler+0x1ec>)
60001052:	cmp	r2, r3
60001054:	bcs.n	60001070 <ResetHandler+0x3c>
60001056:	mvns	r4, r2
60001058:	mov	r0, r1
6000105a:	add	r3, r4
6000105c:	bic.w	r3, r3, #3
60001060:	adds	r3, #4
60001062:	add	r3, r1
		*dest++ = *src++;
60001064:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001068:	cmp	r0, r3
		*dest++ = *src++;
6000106a:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000106e:	bne.n	60001064 <ResetHandler+0x30>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001070:	ldr	r2, [pc, #432]	; (60001224 <ResetHandler+0x1f0>)
60001072:	ldr	r1, [pc, #436]	; (60001228 <ResetHandler+0x1f4>)
60001074:	cmp	r2, r1
60001076:	beq.n	60001098 <ResetHandler+0x64>
	while (dest < dest_end) {
60001078:	ldr	r3, [pc, #432]	; (6000122c <ResetHandler+0x1f8>)
6000107a:	cmp	r2, r3
6000107c:	bcs.n	60001098 <ResetHandler+0x64>
6000107e:	mvns	r4, r2
60001080:	mov	r0, r1
60001082:	add	r3, r4
60001084:	bic.w	r3, r3, #3
60001088:	adds	r3, #4
6000108a:	add	r3, r1
		*dest++ = *src++;
6000108c:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001090:	cmp	r0, r3
		*dest++ = *src++;
60001092:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001096:	bne.n	6000108c <ResetHandler+0x58>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001098:	ldr	r2, [pc, #404]	; (60001230 <ResetHandler+0x1fc>)
6000109a:	ldr	r3, [pc, #408]	; (60001234 <ResetHandler+0x200>)
6000109c:	cmp	r2, r3
6000109e:	bcs.n	600010b8 <ResetHandler+0x84>
600010a0:	mvns	r0, r2
600010a2:	mov	r1, r2
		*dest++ = 0;
600010a4:	movs	r4, #0
600010a6:	add	r3, r0
600010a8:	bic.w	r3, r3, #3
600010ac:	adds	r3, #4
600010ae:	add	r3, r2
600010b0:	str.w	r4, [r1], #4
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
600010b4:	cmp	r3, r1
600010b6:	bne.n	600010b0 <ResetHandler+0x7c>
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
600010b8:	ldr	r2, [pc, #380]	; (60001238 <ResetHandler+0x204>)
600010ba:	mov.w	r1, #15728640	; 0xf00000
600010be:	ldr	r3, [pc, #380]	; (6000123c <ResetHandler+0x208>)
600010c0:	str	r1, [r2, #0]
600010c2:	add.w	r1, r3, #704	; 0x2c0
600010c6:	ldr	r2, [pc, #376]	; (60001240 <ResetHandler+0x20c>)

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
600010c8:	str.w	r2, [r3, #4]!
600010cc:	cmp	r1, r3
600010ce:	bne.n	600010c8 <ResetHandler+0x94>
600010d0:	ldr	r3, [pc, #368]	; (60001244 <ResetHandler+0x210>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600010d2:	movs	r1, #128	; 0x80
600010d4:	ldr	r2, [pc, #368]	; (60001248 <ResetHandler+0x214>)
600010d6:	strb.w	r1, [r3], #1
600010da:	cmp	r3, r2
600010dc:	bne.n	600010d6 <ResetHandler+0xa2>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600010de:	ldr	r4, [pc, #364]	; (6000124c <ResetHandler+0x218>)
600010e0:	mov.w	r7, #2155905152	; 0x80808080
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600010e4:	ldr	r6, [pc, #360]	; (60001250 <ResetHandler+0x21c>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010e6:	mov.w	r2, #4294967295
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010ea:	ldr.w	sl, [pc, #420]	; 60001290 <ResetHandler+0x25c>
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600010ee:	movs	r5, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600010f0:	ldr.w	r9, [pc, #416]	; 60001294 <ResetHandler+0x260>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600010f4:	ldr.w	r8, [pc, #416]	; 60001298 <ResetHandler+0x264>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010f8:	ldr	r3, [pc, #344]	; (60001254 <ResetHandler+0x220>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010fa:	ldr	r1, [pc, #268]	; (60001208 <ResetHandler+0x1d4>)
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010fc:	str.w	sl, [r3]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001100:	str.w	r7, [r4, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001104:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001108:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000110c:	str.w	r8, [r4, #240]	; 0xf0
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
60001110:	ldr	r3, [r6, #28]
60001112:	bic.w	r3, r3, #127	; 0x7f
60001116:	orr.w	r3, r3, #64	; 0x40
6000111a:	str	r3, [r6, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
6000111c:	ldr	r3, [r6, #36]	; 0x24
6000111e:	bic.w	r3, r3, #127	; 0x7f
60001122:	orr.w	r3, r3, #64	; 0x40
60001126:	str	r3, [r6, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001128:	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
6000112a:	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
6000112c:	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
6000112e:	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
60001130:	bl	6000129c <configure_cache>
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001134:	ldr	r2, [pc, #288]	; (60001258 <ResetHandler+0x224>)
60001136:	movs	r0, #99	; 0x63
	SYST_CVR = 0;
60001138:	ldr	r3, [pc, #288]	; (6000125c <ResetHandler+0x228>)
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
6000113a:	ldr	r1, [pc, #292]	; (60001260 <ResetHandler+0x22c>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
6000113c:	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000113e:	movs	r2, #3
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001140:	str	r5, [r3, #0]
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
60001142:	str.w	r1, [sl, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001146:	str.w	r2, [r3, #-8]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000114a:	ldr	r1, [pc, #280]	; (60001264 <ResetHandler+0x230>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
6000114c:	ldr	r2, [pc, #280]	; (60001268 <ResetHandler+0x234>)

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
6000114e:	ldr	r0, [pc, #284]	; (6000126c <ResetHandler+0x238>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001150:	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001154:	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001156:	ldr	r2, [pc, #280]	; (60001270 <ResetHandler+0x23c>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001158:	orr.w	r3, r3, #16777216	; 0x1000000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
6000115c:	str.w	r0, [sl, #60]	; 0x3c
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001160:	ldr	r0, [pc, #272]	; (60001274 <ResetHandler+0x240>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001162:	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001164:	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001166:	ldr	r1, [pc, #272]	; (60001278 <ResetHandler+0x244>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001168:	orr.w	r3, r3, #1
6000116c:	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000116e:	ldr	r3, [r0, #0]
60001170:	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001172:	bl	6000135c <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001176:	str.w	r7, [r4, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
6000117a:	ldr	r0, [pc, #256]	; (6000127c <ResetHandler+0x248>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000117c:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001180:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001184:	str.w	r8, [r4, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001188:	bl	60001718 <__set_arm_clock_veneer>
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?
6000118c:	nop
6000118e:	nop
60001190:	nop
60001192:	nop

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001194:	ldr	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
60001196:	ldr	r2, [pc, #232]	; (60001280 <ResetHandler+0x24c>)
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001198:	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000119c:	ldr	r3, [pc, #228]	; (60001284 <ResetHandler+0x250>)
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000119e:	str	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
600011a0:	str	r5, [r2, #0]
	PIT_TCTRL0 = 0;
600011a2:	str.w	r5, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
600011a6:	str.w	r5, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
600011aa:	str.w	r5, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
600011ae:	str.w	r5, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
600011b2:	ldr	r2, [r3, #56]	; 0x38
600011b4:	lsls	r2, r2, #31
600011b6:	bmi.n	600011ca <ResetHandler+0x196>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011b8:	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
600011bc:	ldr	r1, [pc, #200]	; (60001288 <ResetHandler+0x254>)
600011be:	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011c0:	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
600011c2:	ldr	r2, [r3, #56]	; 0x38
600011c4:	orr.w	r2, r2, #1
600011c8:	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600011ca:	ldr	r2, [pc, #184]	; (60001284 <ResetHandler+0x250>)
600011cc:	ldr	r4, [pc, #188]	; (6000128c <ResetHandler+0x258>)
600011ce:	ldr	r3, [r2, #8]
600011d0:	orr.w	r3, r3, #65537	; 0x10001
600011d4:	str	r3, [r2, #8]

	startup_early_hook();
600011d6:	bl	60001700 <__startup_early_hook_veneer>
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
600011da:	ldr	r3, [r4, #0]
	while (millis() < 20) ; // wait at least 20ms before starting USB
600011dc:	cmp	r3, #19
600011de:	bls.n	600011da <ResetHandler+0x1a6>
	usb_init();
600011e0:	bl	600013c0 <usb_init>
	analog_init();
600011e4:	bl	600014ac <analog_init>
	pwm_init();
600011e8:	bl	600016f8 <__pwm_init_veneer>
	tempmon_init();
600011ec:	bl	60001504 <tempmon_init>

	startup_late_hook();
600011f0:	bl	60001708 <__startup_late_hook_veneer>
600011f4:	ldr	r3, [r4, #0]
	while (millis() < 300) ; // wait at least 300ms before calling user code
600011f6:	cmp.w	r3, #300	; 0x12c
600011fa:	bcc.n	600011f4 <ResetHandler+0x1c0>
	//printf("before C++ constructors\n");
	__libc_init_array();
600011fc:	bl	60001728 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
60001200:	bl	60001710 <__main_veneer>
60001204:	b.n	60001204 <ResetHandler+0x1d0>
60001206:	nop
60001208:	.word	0x400ac000
6000120c:	.word	0xaaaaaaaf
60001210:	.word	0x00200007
60001214:	.word	0x20070000
60001218:	.word	0x00000000
6000121c:	.word	0x60001750
60001220:	.word	0x0000dfa0
60001224:	.word	0x20000000
60001228:	.word	0x6000f6fc
6000122c:	.word	0x20001c50
60001230:	.word	0x20001c50
60001234:	.word	0x200042c0
60001238:	.word	0xe000ed88
6000123c:	.word	0x200027fc
60001240:	.word	0x00002f25
60001244:	.word	0xe000e400
60001248:	.word	0xe000e4a0
6000124c:	.word	0x400d8000
60001250:	.word	0x400fc000
60001254:	.word	0xe000ed08
60001258:	.word	0xe000e014
6000125c:	.word	0xe000e018
60001260:	.word	0x00004d1d
60001264:	.word	0xe000edfc
60001268:	.word	0x20200000
6000126c:	.word	0x00004e21
60001270:	.word	0xe0001000
60001274:	.word	0xe0001004
60001278:	.word	0x200023fc
6000127c:	.word	0x23c34600
60001280:	.word	0x40084000
60001284:	.word	0x400d4000
60001288:	.word	0x56c00000
6000128c:	.word	0x20002404
60001290:	.word	0x20002800
60001294:	.word	0x2018101b
60001298:	.word	0x13110d0c

6000129c <configure_cache>:
#define SIZE_64M	(SCB_MPU_RASR_SIZE(25) | SCB_MPU_RASR_ENABLE)
#define SIZE_256M	(SCB_MPU_RASR_SIZE(26) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
6000129c:	push	{r4, r5, r6, r7, lr}

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
6000129e:	ldr	r2, [pc, #116]	; (60001314 <configure_cache+0x78>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600012a0:	movs	r1, #0

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600012a2:	ldr	r3, [pc, #116]	; (60001318 <configure_cache+0x7c>)

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
600012a4:	mov.w	lr, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600012a8:	ldr	r0, [pc, #112]	; (6000131c <configure_cache+0x80>)

	// TODO: 32 byte sub-region at 0x00000000 with NOACCESS, to trap NULL pointer deref
	// TODO: protect access to power supply config
	// TODO: 32 byte sub-region at end of .bss section with NOACCESS, to trap stack overflow

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600012aa:	movs	r4, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600012ac:	ldr	r7, [pc, #112]	; (60001320 <configure_cache+0x84>)

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
600012ae:	ldr	r6, [pc, #116]	; (60001324 <configure_cache+0x88>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600012b0:	ldr	r5, [pc, #116]	; (60001328 <configure_cache+0x8c>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600012b2:	str	r1, [r0, #0]

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
600012b4:	str.w	lr, [r2]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600012b8:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
600012ba:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
600012bc:	ldr	r7, [pc, #108]	; (6000132c <configure_cache+0x90>)

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600012be:	str	r5, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600012c0:	ldr	r6, [pc, #108]	; (60001330 <configure_cache+0x94>)

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
600012c2:	ldr	r5, [pc, #112]	; (60001334 <configure_cache+0x98>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
600012c4:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600012c6:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600012c8:	ldr	r7, [pc, #108]	; (60001338 <configure_cache+0x9c>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
600012ca:	str	r5, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
600012cc:	ldr	r6, [pc, #108]	; (6000133c <configure_cache+0xa0>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600012ce:	ldr	r5, [pc, #112]	; (60001340 <configure_cache+0xa4>)

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600012d0:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
600012d2:	str	r6, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
600012d4:	ldr	r7, [pc, #108]	; (60001344 <configure_cache+0xa8>)

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600012d6:	str	r5, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600012d8:	ldr	r6, [pc, #108]	; (60001348 <configure_cache+0xac>)

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
600012da:	ldr	r5, [pc, #112]	; (6000134c <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
600012dc:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600012de:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_256M;
600012e0:	ldr	r7, [pc, #108]	; (60001350 <configure_cache+0xb4>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
600012e2:	str	r5, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_256M;

	SCB_MPU_RBAR = 0x70000000 | REGION(7); // FlexSPI2
600012e4:	ldr	r6, [pc, #108]	; (60001354 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | SIZE_16M;
600012e6:	ldr	r5, [pc, #112]	; (60001358 <configure_cache+0xbc>)

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_256M;
600012e8:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(7); // FlexSPI2
600012ea:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | SIZE_16M;
600012ec:	str	r5, [r3, #0]

	// TODO: 32 byte sub-region at 0x00000000 with NOACCESS, to trap NULL pointer deref
	// TODO: protect access to power supply config
	// TODO: 32 byte sub-region at end of .bss section with NOACCESS, to trap stack overflow

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600012ee:	str	r4, [r0, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
600012f0:	dsb	sy
	asm("isb");
600012f4:	isb	sy
	SCB_CACHE_ICIALLU = 0;
600012f8:	str.w	r1, [r3, #432]	; 0x1b0

	asm("dsb");
600012fc:	dsb	sy
	asm("isb");
60001300:	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
60001304:	ldr.w	r3, [r2, #-136]
60001308:	orr.w	r3, r3, #196608	; 0x30000
6000130c:	str.w	r3, [r2, #-136]
60001310:	pop	{r4, r5, r6, r7, pc}
60001312:	nop
60001314:	.word	0xe000ed9c
60001318:	.word	0xe000eda0
6000131c:	.word	0xe000ed94
60001320:	.word	0x03080025
60001324:	.word	0x00200011
60001328:	.word	0x07020021
6000132c:	.word	0x20000012
60001330:	.word	0x13080025
60001334:	.word	0x20200013
60001338:	.word	0x130b0027
6000133c:	.word	0x40000014
60001340:	.word	0x13100033
60001344:	.word	0x60000015
60001348:	.word	0x070b002f
6000134c:	.word	0x70000016
60001350:	.word	0x070b0035
60001354:	.word	0x70000017
60001358:	.word	0x030b002f

6000135c <usb_pll_start>:
}


FLASHMEM void usb_pll_start()
{
6000135c:	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
6000135e:	ldr	r2, [pc, #92]	; (600013bc <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001360:	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001362:	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001366:	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000136a:	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000136e:	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001372:	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001376:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001378:	tst.w	r3, #2
6000137c:	beq.n	6000138c <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000137e:	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001380:	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001382:	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001384:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001386:	tst.w	r3, #2
6000138a:	bne.n	6000137e <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
6000138c:	tst.w	r3, #8192	; 0x2000
60001390:	bne.n	60001396 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001392:	str	r5, [r2, #20]
			continue;
60001394:	b.n	60001376 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001396:	tst.w	r3, #4096	; 0x1000
6000139a:	bne.n	600013a0 <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000139c:	str	r6, [r2, #20]
			continue;
6000139e:	b.n	60001376 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
600013a0:	cmp	r3, #0
600013a2:	bge.n	60001376 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
600013a4:	tst.w	r3, #65536	; 0x10000
600013a8:	beq.n	600013ae <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600013aa:	str	r1, [r2, #24]
			continue;
600013ac:	b.n	60001376 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
600013ae:	lsls	r3, r3, #25
600013b0:	bmi.n	600013b6 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600013b2:	str	r7, [r2, #20]
			continue;
600013b4:	b.n	60001376 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
600013b6:	pop	{r4, r5, r6, r7}
600013b8:	bx	lr
600013ba:	nop
600013bc:	.word	0x400d8000

600013c0 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600013c0:	ldr	r3, [pc, #192]	; (60001484 <usb_init+0xc4>)
600013c2:	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
600013c6:	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600013c8:	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600013cc:	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
600013d0:	bl	60001730 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013d4:	ldr	r1, [pc, #176]	; (60001488 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600013d6:	ldr	r0, [pc, #180]	; (6000148c <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013d8:	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600013dc:	ldr	r4, [pc, #176]	; (60001490 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013de:	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600013e2:	ldr	r3, [pc, #176]	; (60001494 <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013e4:	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600013e8:	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600013ec:	ldr	r2, [r4, #0]
600013ee:	ands	r3, r2
600013f0:	cbnz	r3, 600013fa <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
600013f2:	ldr.w	r3, [r0, #424]	; 0x1a8
600013f6:	lsls	r2, r3, #30
600013f8:	beq.n	60001430 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
600013fa:	ldr	r3, [pc, #144]	; (6000148c <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
600013fc:	mov.w	r1, #2147483648	; 0x80000000
60001400:	ldr	r2, [pc, #140]	; (60001490 <usb_init+0xd0>)
60001402:	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001404:	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001406:	ldr.w	r1, [r3, #320]	; 0x140
6000140a:	orr.w	r1, r1, #2
6000140e:	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001412:	ldr.w	r3, [r2, #320]	; 0x140
60001416:	lsls	r3, r3, #30
60001418:	bmi.n	60001412 <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000141a:	mov.w	r0, #131072	; 0x20000
6000141e:	ldr	r1, [pc, #120]	; (60001498 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001420:	ldr	r3, [pc, #108]	; (60001490 <usb_init+0xd0>)
60001422:	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001426:	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001428:	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
6000142a:	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
6000142c:	bl	60001738 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001430:	ldr	r5, [pc, #104]	; (6000149c <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001432:	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001434:	ldr	r3, [pc, #88]	; (60001490 <usb_init+0xd0>)
60001436:	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000143a:	ldr	r4, [pc, #80]	; (6000148c <usb_init+0xcc>)
6000143c:	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000143e:	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001440:	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001442:	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001444:	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001446:	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000144a:	mov.w	r2, #640	; 0x280
6000144e:	bl	60001720 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001452:	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
60001456:	mov.w	r0, #4194304	; 0x400000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000145a:	movw	r3, #323	; 0x143
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
6000145e:	ldr	r2, [pc, #64]	; (600014a0 <usb_init+0xe0>)
60001460:	ldr	r1, [pc, #64]	; (600014a4 <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001462:	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001464:	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001466:	str.w	r5, [r4, #344]	; 0x158
6000146a:	str.w	r1, [r2, #516]	; 0x204
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000146e:	str.w	r3, [r4, #328]	; 0x148
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001472:	ldr	r2, [pc, #52]	; (600014a8 <usb_init+0xe8>)
60001474:	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001478:	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
6000147a:	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
6000147c:	str.w	r3, [r4, #320]	; 0x140
60001480:	pop	{r4, r5, r6, pc}
60001482:	nop
60001484:	.word	0x400d8000
60001488:	.word	0x400fc000
6000148c:	.word	0x402e0000
60001490:	.word	0x400d9000
60001494:	.word	0x001e1c00
60001498:	.word	0xe000e28c
6000149c:	.word	0x20004000
600014a0:	.word	0x20002800
600014a4:	.word	0x00003b65
600014a8:	.word	0xe000e10c

600014ac <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014ac:	ldr	r3, [pc, #68]	; (600014f4 <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014ae:	ldr	r1, [pc, #72]	; (600014f8 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014b0:	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600014b2:	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014b4:	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
600014b8:	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014ba:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014bc:	movw	r5, #1719	; 0x6b7
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
600014c0:	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
600014c2:	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
600014c4:	orr.w	r0, r0, #768	; 0x300
600014c8:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014ca:	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
600014cc:	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600014ce:	ldr	r3, [r2, #72]	; 0x48
600014d0:	lsls	r3, r3, #24
600014d2:	bmi.n	600014ce <analog_init+0x22>
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014d4:	ldr	r3, [pc, #36]	; (600014fc <analog_init+0x50>)
600014d6:	movw	r0, #1719	; 0x6b7
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
600014da:	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
600014dc:	mov	r2, r3
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014de:	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
600014e0:	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
600014e2:	ldr	r3, [r2, #72]	; 0x48
600014e4:	ands.w	r3, r3, #128	; 0x80
600014e8:	bne.n	600014e2 <analog_init+0x36>
	calibrating = 0;
600014ea:	ldr	r2, [pc, #20]	; (60001500 <analog_init+0x54>)
600014ec:	strb	r3, [r2, #0]
}
600014ee:	pop	{r4, r5}
600014f0:	bx	lr
600014f2:	nop
600014f4:	.word	0x400fc000
600014f8:	.word	0x400c4000
600014fc:	.word	0x400c8000
60001500:	.word	0x20002408

60001504 <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001504:	ldr	r2, [pc, #236]	; (600015f4 <tempmon_init+0xf0>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001506:	vmov.f32	s13, #57	; 0x41c80000  25.0

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
6000150a:	ldr	r1, [pc, #236]	; (600015f8 <tempmon_init+0xf4>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
6000150c:	movs	r0, #0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
6000150e:	ldr	r3, [r2, #0]
  asm volatile ("dsb":::"memory");
  while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001510:	push	{r4, r5, r6, r7, lr}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001512:	bic.w	r3, r3, #1

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001516:	movs	r4, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001518:	ldr.w	lr, [pc, #256]	; 6000161c <tempmon_init+0x118>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
6000151c:	str	r3, [r2, #0]

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
6000151e:	str.w	r4, [r2, #144]	; 0x90
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001522:	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
60001526:	ldr	r7, [pc, #212]	; (600015fc <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001528:	uxtb	r5, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
6000152a:	ubfx	r4, r3, #8, #12
6000152e:	ldr	r6, [pc, #208]	; (60001600 <tempmon_init+0xfc>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
60001530:	rsb	r3, r4, r3, lsr #20
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001534:	vmov	s15, r5
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001538:	sub.w	r1, r5, #85	; 0x55
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
6000153c:	str.w	r5, [lr]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001540:	vcvt.f32.s32	s14, s15
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001544:	add.w	r5, r3, r3, lsl #2
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001548:	vmov	s15, r4
6000154c:	mul.w	r1, r3, r1
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
60001550:	str	r3, [r7, #0]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001552:	add.w	r3, r3, r3, lsl #6
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001556:	vcvt.f32.s32	s10, s15
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000155a:	vmov	s15, r1
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000155e:	subs	r1, r1, r5
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001560:	vsub.f32	s13, s14, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001564:	vcvt.f32.u32	s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001568:	ldr	r5, [pc, #152]	; (60001604 <tempmon_init+0x100>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000156a:	vmov	s15, r1
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000156e:	add	r3, r1
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001570:	vstr	s13, [r5]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001574:	vcvt.f32.u32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001578:	str	r4, [r6, #0]
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000157a:	vdiv.f32	s11, s14, s13
6000157e:	ldr	r6, [pc, #136]	; (60001608 <tempmon_init+0x104>)
60001580:	ldr	r5, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001582:	ldr	r1, [pc, #136]	; (6000160c <tempmon_init+0x108>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001584:	ldr	r4, [pc, #136]	; (60001610 <tempmon_init+0x10c>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001586:	vdiv.f32	s12, s15, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000158a:	vmov	s15, r3
6000158e:	ldr	r3, [pc, #132]	; (60001614 <tempmon_init+0x110>)
60001590:	str.w	r3, [r6, #320]	; 0x140
60001594:	vcvt.f32.u32	s15, s15
60001598:	vdiv.f32	s14, s15, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000159c:	vadd.f32	s11, s11, s10
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015a0:	vadd.f32	s13, s12, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015a4:	vcvt.u32.f32	s11, s11
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015a8:	vcvt.u32.f32	s13, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015ac:	vmov	r3, s11
600015b0:	orr.w	r3, r5, r3, lsl #20
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015b4:	vmov	r5, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015b8:	vadd.f32	s15, s14, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015bc:	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015be:	and.w	r1, r1, r5, lsl #16
600015c2:	ldr.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015c6:	vcvt.u32.f32	s15, s15
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015ca:	orrs	r3, r1
600015cc:	str.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015d0:	vmov	r3, s15
600015d4:	ldr.w	r1, [r2, #272]	; 0x110
600015d8:	ubfx	r3, r3, #0, #12
600015dc:	orrs	r3, r1
600015de:	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
600015e2:	ldr	r3, [r2, #0]
600015e4:	orr.w	r3, r3, #2
600015e8:	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600015ea:	strb	r0, [r4, #0]
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600015ec:	ldr	r3, [pc, #40]	; (60001618 <tempmon_init+0x114>)
600015ee:	movs	r2, #1
600015f0:	str	r2, [r3, #0]
600015f2:	pop	{r4, r5, r6, r7, pc}
600015f4:	.word	0x400d8180
600015f8:	.word	0x401f4400
600015fc:	.word	0x20002414
60001600:	.word	0x20002418
60001604:	.word	0x20002410
60001608:	.word	0x20002800
6000160c:	.word	0x0fff0000
60001610:	.word	0xe000e440
60001614:	.word	0x00004415
60001618:	.word	0xe000e108
6000161c:	.word	0x2000240c

60001620 <usb_string_product_name_default>:
60001620:	..U.S.B. .S.e.r.
60001630:	i.a.l...

60001638 <usb_string_manufacturer_name_default>:
60001638:	..T.e.e.n.s.y.d.
60001648:	u.i.n.o.

60001650 <string0>:
60001650:	....

60001654 <usb_config_descriptor_12>:
60001654:	..C.....2.......
60001664:	...$....$....$..
60001674:	.$..............
60001684:	.........@......
60001694:	@...

60001698 <usb_config_descriptor_480>:
60001698:	..C.....2.......
600016a8:	...$....$....$..
600016b8:	.$..............
600016c8:	................
600016d8:	....

600016dc <qualifier_descriptor>:
600016dc:	.......@....

600016e8 <_init>:
600016e8:	push	{r3, r4, r5, r6, r7, lr}
600016ea:	nop
600016ec:	pop	{r3, r4, r5, r6, r7}
600016ee:	pop	{r3}
600016f0:	mov	lr, r3
600016f2:	bx	lr
600016f4:			; <UNDEFINED> instruction: 0xffffffff

600016f8 <__pwm_init_veneer>:
600016f8:	ldr.w	pc, [pc]	; 600016fc <__pwm_init_veneer+0x4>
600016fc:	.word	0x000047a1

60001700 <__startup_early_hook_veneer>:
60001700:	ldr.w	pc, [pc]	; 60001704 <__startup_early_hook_veneer+0x4>
60001704:	.word	0x00002f3d

60001708 <__startup_late_hook_veneer>:
60001708:	ldr.w	pc, [pc]	; 6000170c <__startup_late_hook_veneer+0x4>
6000170c:	.word	0x00002f41

60001710 <__main_veneer>:
60001710:	ldr.w	pc, [pc]	; 60001714 <__main_veneer+0x4>
60001714:	.word	0x00004ba9

60001718 <__set_arm_clock_veneer>:
60001718:	ldr.w	pc, [pc]	; 6000171c <__set_arm_clock_veneer+0x4>
6000171c:	.word	0x00003769

60001720 <__memset_veneer>:
60001720:	ldr.w	pc, [pc]	; 60001724 <__memset_veneer+0x4>
60001724:	.word	0x00008e59

60001728 <____libc_init_array_veneer>:
60001728:	ldr.w	pc, [pc]	; 6000172c <____libc_init_array_veneer+0x4>
6000172c:	.word	0x00008789

60001730 <__usb_init_serialnumber_veneer>:
60001730:	ldr.w	pc, [pc]	; 60001734 <__usb_init_serialnumber_veneer+0x4>
60001734:	.word	0x00004b51

60001738 <__delay_veneer>:
60001738:	ldr.w	pc, [pc]	; 6000173c <__delay_veneer+0x4>
6000173c:	.word	0x00004349

60001740 <__init_array_start>:
60001740:	.word	0x00000045
60001744:	.word	0x000002a9

60001748 <__init_array_end>:
60001748:	.word	0xffffffff
6000174c:	.word	0xffffffff

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
      20:	.word	0x4c05b510
		USB1_USBINTR = intr | USB_USBINTR_SRE;
      24:	ldrb	r3, [r4, #0]
      26:	cbnz	r3, 36 <__rtc_localtime+0x5>
	}
	__enable_irq();
      28:	ldr	r3, [pc, #16]	; (3c <__rtc_localtime+0xb>)
      2a:	cbz	r3, 32 <__rtc_localtime+0x1>
      2c:	.word	0xf3af4804
      30:	strh	r0, [r0, #0]
      32:	.short	0x2301
    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);

    return tmeas;
      34:	strb	r3, [r4, #0]
      36:	.short	0xbd10
      38:	adds	r0, r2, #1
      3a:	.short	0x2000
      3c:	movs	r0, r0
      3e:	movs	r0, r0
}
      40:	.word	0x0000dfa4

00000044 <frame_dummy>:
      44:	ldr	r3, [pc, #32]	; (68 <frame_dummy+0x24>)
      46:	push	{r4, lr}
      48:	.word	0x4908b11b
      4c:	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	nop.w
      52:	ldr	r0, [pc, #32]	; (74 <frame_dummy+0x30>)
      54:	ldr	r3, [r0, #0]
      56:	cbnz	r3, 5a <frame_dummy+0x16>
      58:	pop	{r4, pc}
      5a:	ldr	r3, [pc, #28]	; (78 <frame_dummy+0x34>)
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
  ADC2_CFG = mode1;
      5c:	cmp	r3, #0

    } else if (num >= 16) {
      mode |= ADC_CFG_AVGS(2);
      mode1 |= ADC_CFG_AVGS(2);

    } else if (num >= 8) {
      5e:	beq.n	58 <frame_dummy+0x14>
      60:	ldmia.w	sp!, {r4, lr}
      mode |= ADC_CFG_AVGS(1);
      64:	bx	r3
      mode1 |= ADC_CFG_AVGS(1);
      66:	.short	0xbf00
      68:	movs	r0, r0
    } else {
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
      6a:	movs	r0, r0
  ADC2_CFG = mode1;
  
  if(num >= 4){
      6c:	adds	r4, r2, #1
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
  ADC2_CFG = mode1;
      6e:	movs	r0, #0
    } else {
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
      70:	svc	164	; 0xa4
  ADC2_CFG = mode1;
      72:	movs	r0, r0
  
  if(num >= 4){
      74:	adds	r0, r2, #1
      ADC1_GC |= ADC_GC_AVGE;// turns on averaging
      ADC2_GC |= ADC_GC_AVGE;// turns on averaging
  }
}
      76:	movs	r0, #0
      78:	movs	r0, r0
	...

0000007c <setup>:
      7c:	.word	0x4c39b510
      80:	movs	r1, #1
      82:	movs	r0, #13
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 20000000; nn++) ;
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
	// digitalWrite(13, LOW);
    for (nn = 0; nn < 10000000; nn++) ;
      84:	.word	0xfd24f004
#elif defined(__arm__) && defined(TEENSYDUINO)
    static uint32_t attachedpins[]; // 1 bit per digital pin
#endif
  public:
    PWMServo();
    uint8_t attach(int pinArg) { return attach(pinArg, 544, 2400); }
      88:	add.w	r0, r4, #300	; 0x12c
      8c:	mov.w	r3, #2400	; 0x960
      90:	.word	0x7208f44f
      94:	movs	r1, #1
      96:	.short	0xf001
      98:	cdp2	5, 13, cr15, cr3, cr4, {0}
      9c:	.word	0xf44f7098
      a0:	str	r6, [r2, #48]	; 0x30
      a2:	mov.w	r2, #544	; 0x220
      a6:	movs	r1, #2
      a8:	bl	1e40 <PWMServo::attach(int, int, int)>
      ac:	add.w	r0, r4, #308	; 0x134
      b0:	mov.w	r3, #2400	; 0x960
      b4:	.word	0x7208f44f
      b8:	movs	r1, #3
      ba:	.short	0xf001
      bc:	cdp2	5, 12, cr15, cr1, cr4, {0}
      c0:	strb	r2, [r7, #2]
      c2:	.short	0xf44f
      c4:	str	r6, [r2, #48]	; 0x30
      c6:	.short	0xf44f
      c8:	strb	r0, [r1, #8]
      ca:	.short	0x2104
      cc:	bl	1e40 <PWMServo::attach(int, int, int)>
      d0:	.word	0x70bcf504
      d4:	mov.w	r3, #2400	; 0x960
      d8:	.word	0x7208f44f
      dc:	movs	r1, #5
      de:	bl	1e40 <PWMServo::attach(int, int, int)>
      e2:	.short	0xf504
      e4:	strb	r6, [r7, #2]
      e6:	.short	0xf44f
      e8:	str	r6, [r2, #48]	; 0x30
      ea:	mov.w	r2, #544	; 0x220
      ee:	movs	r1, #6
      f0:	.word	0xfea6f001
      f4:	add.w	r0, r4, #444	; 0x1bc
      f8:	.word	0x6316f44f
      fc:	mov.w	r2, #544	; 0x220
     100:	.word	0xf0012107
     104:	cdp2	5, 9, cr15, cr13, cr4, {0}
     108:	.word	0xf44f70e0
     10c:	str	r6, [r2, #48]	; 0x30
     10e:	mov.w	r2, #544	; 0x220
     112:	.short	0x2108
     114:	bl	1e40 <PWMServo::attach(int, int, int)>
     118:	.word	0x70e2f504
     11c:	mov.w	r3, #2400	; 0x960
     120:	.word	0x7208f44f
     124:	movs	r1, #9
     126:	.short	0xf001
     128:	cdp2	5, 8, cr15, cr11, cr4, {0}
     12c:	.word	0xf44f7001
     130:	str	r6, [r2, #48]	; 0x30
     132:	.short	0xf44f
     134:	strb	r0, [r1, #8]
     136:	.short	0x210a
     138:	bl	1e40 <PWMServo::attach(int, int, int)>
     13c:	add.w	r0, r4, #520	; 0x208
     140:	.word	0x6316f44f
     144:	mov.w	r2, #544	; 0x220
     148:	.word	0xf001210b
     14c:	cdp2	5, 7, cr15, cr9, cr4, {0}
     150:	strb	r3, [r0, #0]
     152:	.short	0xf44f
     154:	str	r6, [r2, #48]	; 0x30
     156:	mov.w	r2, #544	; 0x220
     15a:	movs	r1, #12
    imu.imu_hardware.enableRotationVector(Config::dt*1000); // For quaternion; send data update every 50ms
    imu.imu_hardware.enableLinearAccelerometer(Config::dt*1000); // Send data update every 50ms
    imu.imu_hardware.enableGyro(Config::dt*1000); // Send data update every 50ms
    */

}
     15c:	ldmia.w	sp!, {r4, lr}
     160:	b.w	1e40 <PWMServo::attach(int, int, int)>
     164:	adds	r0, r4, #6
     166:	.short	0x2000

00000168 <loop>:

void loop() {
     168:	push	{r4, r5, r7, lr}
     16a:	.short	0x4b46

    long current_time = millis();
    long delta_time = current_time - last_time;
     16c:	ldr	r2, [pc, #280]	; (288 <loop+0x120>)
    imu.imu_hardware.enableGyro(Config::dt*1000); // Send data update every 50ms
    */

}

void loop() {
     16e:	.short	0xed2d
     170:	ldrh	r0, [r1, #24]
     172:	.short	0xb09a
     174:	ldr	r5, [r3, #0]

    long current_time = millis();
    long delta_time = current_time - last_time;
    if (delta_time < (long(Config::dt*1000))) {
     176:	.short	0x6813
    imu.imu_hardware.enableGyro(Config::dt*1000); // Send data update every 50ms
    */

}

void loop() {
     178:	add	r7, sp, #88	; 0x58
     17a:	.short	0xb090

    long current_time = millis();
    long delta_time = current_time - last_time;
    if (delta_time < (long(Config::dt*1000))) {
     17c:	subs	r3, r5, r3
     17e:	.short	0x2b09
     180:	bgt.n	18c <loop+0x24>
        "%.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f",
        FL_x, FL_y, FL_z, FR_x, FR_y, FR_z, BL_x, BL_y, BL_z, BR_x, BR_y, BR_z
    );
    Serial.println(sprintf_buffer);

     182:	adds	r7, #16
     184:	mov	sp, r7
     186:	.short	0xecbd
     188:	ldrh	r0, [r1, #24]
     18a:	.short	0xbdb0
    if (delta_time < (long(Config::dt*1000))) {
        return;
    }
    last_time = current_time;

    command.setMode(Mode::TROT);
     18c:	movs	r1, #1
     18e:	ldr	r0, [pc, #252]	; (28c <loop+0x124>)
    long current_time = millis();
    long delta_time = current_time - last_time;
    if (delta_time < (long(Config::dt*1000))) {
        return;
    }
    last_time = current_time;
     190:	.word	0xf10d6015
     194:	lsls	r7, r4, #17

    command.setMode(Mode::TROT);
     196:	.short	0xf001
     198:	stc2	13, cr14, [r9], {159}	; 0x9f
    command.setSwingHeight(0.1);
     19c:	.word	0x483b0a3d
     1a0:	bic.w	r4, r4, #15
     1a4:	.word	0xfc7ef001
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
     1a8:	movs	r3, #0
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     1aa:	mov.w	r2, #1056964608	; 0x3f000000
    command.setBodyVelocity(Eigen::Vector3f(0.5, 0, 0));
     1ae:	.short	0x1d39
     1b0:	ldr	r0, [pc, #216]	; (28c <loop+0x124>)
      m_storage.data()[1] = y;
     1b2:	str	r3, [r7, #8]
      m_storage.data()[2] = z;
     1b4:	str	r3, [r7, #12]
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     1b6:	.short	0x607a
     1b8:	bl	1a94 <project_namespace::Command::setBodyVelocity(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    master_controller.stepOnce(robot, command);
     1bc:	.word	0x49354a33
     1c0:	ldr	r0, [pc, #212]	; (298 <loop+0x130>)
     1c2:	.short	0xf000
     1c4:			; <UNDEFINED> instruction: 0xfba14620

    // For serial logging purposes only
    Eigen::Matrix<float, 3, 4> all_foot_positions;
    all_foot_positions = robot.getFootPositionsWrtBodyTrue();
     1c8:	.word	0xf0014932
     1cc:	ldrh.w	lr, [r7, #-212]!
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     1d0:	.word	0xed947a00
     1d4:	add	r2, sp, #4
     1d6:	.short	0xed94
     1d8:	ldrh	r2, [r0, r0]
    float BR_z = all_foot_positions.col(3)(2);
    sprintf(
        sprintf_buffer,
        "%.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f",
        FL_x, FL_y, FL_z, FR_x, FR_y, FR_z, BL_x, BL_y, BL_z, BR_x, BR_y, BR_z
    );
     1da:	.short	0xeeb7
     1dc:	revsh	r7, r4
     1de:	.short	0xed94
     1e0:	ldr	r2, [pc, #12]	; (1f0 <loop+0x88>)
     1e2:	.short	0xeeb7
     1e4:	add	r2, sp, #808	; 0x328
     1e6:	.short	0xed94
     1e8:	subs	r2, #4
     1ea:	.short	0xeeb7
     1ec:	ldrh	r5, [r0, r3]
     1ee:	.short	0xed94
     1f0:	cmp	r2, #5
     1f2:	.short	0xeeb7
     1f4:	ldr	r2, [pc, #784]	; (508 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x78>)
     1f6:	vldr	s2, [r4, #24]
     1fa:	.short	0xeeb7
     1fc:	subs	r2, #195	; 0xc3
     1fe:	.short	0xed94
     200:	lsrs	r7, r0, #8
     202:	.short	0xeeb7
     204:	cmp	r2, #194	; 0xc2
     206:	.short	0xed94
     208:	ldrh	r0, [r1, #16]
     20a:	.short	0xeeb7
     20c:	subs	r1, r0, r3
     20e:	.short	0xed94
     210:	ldr	r2, [sp, #36]	; 0x24
     212:	.short	0xeeb7
     214:	lsrs	r0, r0, #11
     216:	.short	0xed94
     218:	ldrb	r2, [r1, #8]
     21a:	.short	0xeeb7
     21c:	ldrh	r0, [r1, #22]
     21e:	.short	0xed94
     220:	ldr	r3, [r1, #32]
     222:	.short	0xeeb7
     224:	ldr	r2, [sp, #804]	; 0x324
     226:	vcvt.f64.f32	d7, s14
     22a:	.short	0x491c
     22c:	vcvt.f64.f32	d6, s12
     230:	.word	0xec53481b
     234:	cmp	r3, #27
     236:	vstr	d0, [sp, #48]	; 0x30
     23a:	.short	0xed8d
     23c:	subs	r2, r1, r4
     23e:	.short	0xed8d
     240:	cmp	r3, #8
     242:	.short	0xed8d
     244:	subs	r3, #6
     246:	.short	0xed8d
     248:	ldr	r3, [pc, #16]	; (25c <loop+0xf4>)
     24a:	.short	0xed8d
     24c:	ldrh	r2, [r0, r4]
     24e:	.short	0xed8d
     250:	add	r3, sp, #0
     252:	vstr	d9, [sp, #64]	; 0x40
     256:	vstr	d8, [sp, #56]	; 0x38
     25a:	vstr	d6, [sp, #80]	; 0x50
     25e:	vstr	d7, [sp, #72]	; 0x48
     262:	.short	0xf009
     264:	str.w	r4, [sp, <undefined>]
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     268:	.word	0xf88af009
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     26c:	mov	r1, r0
     26e:	ldr	r0, [pc, #48]	; (2a0 <loop+0x138>)
     270:	bl	3664 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     274:	ldr	r0, [pc, #44]	; (2a4 <loop+0x13c>)
     276:	bl	4e74 <Print::println()>
    Serial.println(sprintf_buffer);

     27a:	adds	r7, #16
     27c:	mov	sp, r7
     27e:	vpop	{d8-d11}
     282:	pop	{r4, r5, r7, pc}
     284:	.word	0x20002404
     288:	adds	r4, r5, #1
     28a:	.short	0x2000
     28c:	adds	r0, r6, #5
     28e:	.short	0x2000
     290:	ldmia	r4!, {r0, r2, r3, r6, r7}
     292:	subs	r5, #204	; 0xcc
     294:	.word	0x20001da0
     298:	subs	r0, r6, #6
     29a:	.short	0x2000
     29c:	movs	r0, r0
     29e:	.short	0x2000
     2a0:	adds	r0, r6, #1
     2a2:	movs	r0, #0
     2a4:	.word	0x20001290

000002a8 <_GLOBAL__sub_I_robot>:
     2a8:	push	{r3, r4, r5, r6, r7, lr}
const int bl_tibia_servo_pin = 9;
const int br_coxa_servo_pin = 10;
const int br_femur_servo_pin = 11;
const int br_tibia_servo_pin = 12;

Robot robot;
     2aa:	.short	0x4819
#define CALIBRATE_STOP 5

#define MAX_PACKET_SIZE 128 //Packets can be up to 32k but we don't have that much RAM.
#define MAX_METADATA_SIZE 9 //This is in words. There can be many but we mostly only care about the first 9 (Qs, range, etc)

class BNO080
     2ac:	movs	r5, #12
     2ae:	bl	fbc <project_namespace::Robot::Robot()>
Command command;
     2b2:	ldr	r0, [pc, #96]	; (314 <_GLOBAL__sub_I_robot+0x6c>)
     2b4:	.word	0xfbaaf001
     2b8:	ldr	r3, [pc, #92]	; (318 <_GLOBAL__sub_I_robot+0x70>)
     2ba:	.short	0x220e
BNO080 imu_hardware;
IMU imu(imu_hardware);
     2bc:	ldr	r4, [pc, #92]	; (31c <_GLOBAL__sub_I_robot+0x74>)
     2be:	.short	0x2109
     2c0:	movs	r0, #4
     2c2:	.short	0xf8a3
     2c4:	movs	r1, #32
     2c6:	.short	0x270a
     2c8:	movs	r2, #0
     2ca:	.short	0xf8a3
     2cc:	str	r2, [r4, r4]
     2ce:	.short	0x2508
     2d0:	strh.w	r1, [r3, #296]	; 0x128
     2d4:	.word	0x012af8a3
     2d8:	mov	r1, r3
     2da:	.short	0x4620
     2dc:	strh.w	r2, [r3, #136]	; 0x88
     2e0:	.word	0x2084f8c3
     2e4:	strb.w	r2, [r3, #138]	; 0x8a
     2e8:	.word	0x20bcf883
     2ec:	strh.w	r7, [r3, #300]	; 0x12c
     2f0:	strh.w	r5, [r3, #292]	; 0x124
     2f4:	.word	0x5126f8a3
     2f8:	bl	ee0 <project_namespace::IMU::IMU(BNO080&)>
MasterController master_controller(imu);
     2fc:	.word	0x48084621
     300:	bl	8e8 <project_namespace::MasterController::MasterController(project_namespace::IMU&)>
     304:	ldr	r2, [pc, #28]	; (324 <_GLOBAL__sub_I_robot+0x7c>)

long last_time = millis();
     306:	.short	0x4b08
     308:	ldr	r2, [r2, #0]
     30a:	.short	0x601a
     30c:	pop	{r3, r4, r5, r6, r7, pc}
     30e:	nop
     310:	.word	0x20001da0
     314:	adds	r0, r6, #5
     316:	.short	0x2000
     318:	movs	r0, #176	; 0xb0
     31a:	.short	0x2000
     31c:	movs	r0, #112	; 0x70
     31e:	movs	r0, #0
     320:	.word	0x20001fb0
     324:	movs	r4, #4
     326:	.short	0x2000
     328:	adds	r4, r5, #1
     32a:	.short	0x2000

0000032c <project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)>:

using namespace project_namespace;

// CONSTRUCTORS
LegStanceController::LegStanceController(GaitConfig& gait_config_init):
    gait_config(gait_config_init)
     32c:	str	r1, [r0, #0]
{}
     32e:	.short	0x4770

00000330 <project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)>:

// METHODS
Eigen::Vector3f LegStanceController::calculateNewFootPosition(Robot& robot, Command& command, int leg_index) {
     330:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     334:	.word	0x8b08ed2d
     338:	sub	sp, #48	; 0x30
     33a:	.short	0xeddf
     33c:	ldrh	r7, [r7, #16]
    + new_foot_position: The x, y, z coordinates of the new foot position (wrt body) after a single tick.
    */
    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f current_foot_location_assuming_no_body_rpy;
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
     33e:	mov	r1, r2
LegStanceController::LegStanceController(GaitConfig& gait_config_init):
    gait_config(gait_config_init)
{}

// METHODS
Eigen::Vector3f LegStanceController::calculateNewFootPosition(Robot& robot, Command& command, int leg_index) {
     340:	.word	0xaf004604
     344:	sub	sp, #64	; 0x40
     346:	.short	0x461e
     348:	ldr.w	r8, [r7, #104]	; 0x68
     34c:	.word	0x050ff10d
     350:	vstr	s17, [r0]
                                || ((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && ( XprTypeIsRowMajor)) ? xpr.innerStride() : xpr.outerStride()),
             BlockRows==1 ? 1 : xpr.rows(),
             BlockCols==1 ? 1 : xpr.cols()),
        m_xpr(xpr),
        m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),
        m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0)
     354:	.word	0x0848eb08
      m_storage.data()[1] = y;
     358:	vstr	s17, [r0, #4]
     35c:	.word	0x050ff025
      m_storage.data()[2] = z;
     360:	vstr	s17, [r0, #8]
            0.0
    ).finished();
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0); // Initialise
    foot_delta_p = foot_velocity * Config::dt;
    Eigen::Matrix<float, 3, 3> foot_delta_R; // Initialise
    foot_delta_R = MyMath::eulerToMatrix(0, 0, -command.getGaitYawSpeed()*Config::dt);
     364:	vldr	s18, [pc, #212]	; 43c <project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)+0x10c>
    + new_foot_position: The x, y, z coordinates of the new foot position (wrt body) after a single tick.
    */
    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f current_foot_location_assuming_no_body_rpy;
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
     368:	.word	0xf0004628
     36c:	vmin.u<illegal width 64>	d20, d7, d17
     370:	.word	0x0388eb05
    Eigen::Vector3f foot_velocity(0.0, 0.0, 0.0); // Initialise
    foot_velocity = (
        Eigen::Vector3f()
        <<  -command.getBodyVelocity()(0),
     374:	mov	r0, r7
     376:	.short	0xedd3
     378:	add	r2, sp, #0
     37a:	.short	0xed93
     37c:	rev	r1, r0
     37e:	vldr	s16, [r3, #8]
     382:	bl	1a70 <project_namespace::Command::getBodyVelocity()>
            -command.getBodyVelocity()(1),
     386:	mov	r1, r6
     388:	add.w	r0, r7, #12
    Eigen::Vector3f current_foot_location_assuming_no_body_rpy;
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
    Eigen::Vector3f foot_velocity(0.0, 0.0, 0.0); // Initialise
    foot_velocity = (
        Eigen::Vector3f()
        <<  -command.getBodyVelocity()(0),
     38c:	vldr	s20, [r7]
            -command.getBodyVelocity()(1),
     390:	bl	1a70 <project_namespace::Command::getBodyVelocity()>
            0.0
    ).finished();
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0); // Initialise
    foot_delta_p = foot_velocity * Config::dt;
    Eigen::Matrix<float, 3, 3> foot_delta_R; // Initialise
    foot_delta_R = MyMath::eulerToMatrix(0, 0, -command.getGaitYawSpeed()*Config::dt);
     394:	.word	0xedd74630
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
    Eigen::Vector3f foot_velocity(0.0, 0.0, 0.0); // Initialise
    foot_velocity = (
        Eigen::Vector3f()
        <<  -command.getBodyVelocity()(0),
            -command.getBodyVelocity()(1),
     398:	ldr	r2, [sp, #16]
            0.0
    ).finished();
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0); // Initialise
    foot_delta_p = foot_velocity * Config::dt;
    Eigen::Matrix<float, 3, 3> foot_delta_R; // Initialise
    foot_delta_R = MyMath::eulerToMatrix(0, 0, -command.getGaitYawSpeed()*Config::dt);
     39a:	.short	0xf001
     39c:	usad8	r1, r1, r7
     3a0:	movs	r4, r1
     3a2:	vnmul.f32	s2, s0, s18
     3a6:	vmov.f32	s1, s17
     3aa:	vmov.f32	s0, s17
     3ae:	bl	7b0 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
     3b2:	.short	0xed97
     3b4:	ldrb	r1, [r1, #8]
     3b6:	.short	0xedd7
     3b8:	ldrb	r2, [r1, #8]
    Eigen::Vector3f current_foot_location_assuming_no_body_rpy;
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
    Eigen::Vector3f foot_velocity(0.0, 0.0, 0.0); // Initialise
    foot_velocity = (
        Eigen::Vector3f()
        <<  -command.getBodyVelocity()(0),
     3ba:	.short	0xeeb1
     3bc:	add	r2, sp, #296	; 0x128
  *
  */
template<typename DstScalar,typename SrcScalar> struct assign_op {

  EIGEN_EMPTY_STRUCT_CTOR(assign_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a = b; }
     3be:	vmul.f32	s14, s16, s14
     3c2:	.short	0xedd7
     3c4:	ldrh	r6, [r0, r0]
     3c6:	.short	0xee68
     3c8:	ldrb	r7, [r4, #8]
     3ca:	.short	0xed97
     3cc:	ldr	r7, [r0, #32]
     3ce:	.short	0xedd7
     3d0:	ldr	r3, [r1, #32]
            -command.getBodyVelocity()(1),
     3d2:	vneg.f32	s19, s19
     3d6:	vfma.f32	s14, s22, s11
     3da:	vldr	s10, [r7, #32]
     3de:	vfma.f32	s15, s22, s12
     3e2:	vldr	s11, [r7, #12]
     3e6:	vmul.f32	s16, s16, s13
     3ea:	vldr	s12, [r7, #16]
     3ee:	vldr	s13, [r7, #20]
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0); // Initialise
    foot_delta_p = foot_velocity * Config::dt;
    Eigen::Matrix<float, 3, 3> foot_delta_R; // Initialise
    foot_delta_R = MyMath::eulerToMatrix(0, 0, -command.getGaitYawSpeed()*Config::dt);
    new_foot_position = foot_delta_R*current_foot_location_assuming_no_body_rpy + foot_delta_p;
    new_foot_position(2) = -command.getStanceHeight();
     3f2:	.short	0x4630
     3f4:	vfma.f32	s16, s22, s10
     3f8:	.word	0x7aa5eeaa
     3fc:	vfma.f32	s15, s21, s12
     400:	.word	0x8aa6eeaa
     404:	vfma.f32	s14, s20, s18
     408:	vfma.f32	s15, s19, s18
     40c:	vadd.f32	s16, s16, s17
     410:	vstr	s14, [r4]
     414:	.word	0x7a01edc4
     418:	vstr	s16, [r4, #8]
     41c:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     420:	vneg.f32	s0, s0

    return new_foot_position;
     424:	mov	r0, r4
     426:	.short	0x3730
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0); // Initialise
    foot_delta_p = foot_velocity * Config::dt;
    Eigen::Matrix<float, 3, 3> foot_delta_R; // Initialise
    foot_delta_R = MyMath::eulerToMatrix(0, 0, -command.getGaitYawSpeed()*Config::dt);
    new_foot_position = foot_delta_R*current_foot_location_assuming_no_body_rpy + foot_delta_p;
    new_foot_position(2) = -command.getStanceHeight();
     428:	vstr	s0, [r4, #8]

    return new_foot_position;
     42c:	.word	0xecbd46bd
     430:	ldrh	r0, [r1, #24]
     432:	.short	0xe8bd
     434:	strh	r0, [r6, #14]
     436:	nop
     438:	movs	r0, r0
     43a:	movs	r0, r0
     43c:	bvc.n	454 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)+0x14>
     43e:	subs	r4, #35	; 0x23

00000440 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>:
#include <Arduino.h>

using namespace project_namespace;

// CONSTRUCTORS
Leg::Leg(
     440:	push	{r3, r4, r5, lr}
     442:	mov	r4, r0
    l_2(l_2_init),
    l_3(l_3_init),
    joint_servo_directions(joint_servo_directions_init),

    joint_angles(Eigen::Vector3f::Zero()),
    foot_position_wrt_body(Eigen::Vector3f::Zero())
     444:	vstr	s0, [r0]
     448:	vstr	s1, [r0, #4]
     44c:	movs	r3, #0
     44e:	vstr	s2, [r0, #8]
    }
    EIGEN_DEVICE_FUNC
    explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
      : m_data(internal::constructor_without_unaligned_array_assert()) {}
    EIGEN_DEVICE_FUNC 
    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {
     452:	add.w	r5, r0, #24
     456:	vstr	s3, [r0, #12]
     45a:	vstr	s4, [r0, #16]
     45e:	.short	0xedc0
     460:	cmp	r2, #5
     462:	.short	0xc907
     464:	stmia.w	r5, {r0, r1, r2}
     468:	.word	0xf1046263
     46c:	movs	r4, r7
     46e:	.short	0x62a3
     470:	str	r3, [r4, #44]	; 0x2c
     472:	.short	0x6323
     474:	str	r3, [r4, #52]	; 0x34
     476:	str	r3, [r4, #56]	; 0x38
     478:	bl	1e38 <PWMServo::PWMServo()>
     47c:	add.w	r0, r4, #64	; 0x40
     480:	bl	1e38 <PWMServo::PWMServo()>
     484:	add.w	r0, r4, #68	; 0x44
     488:	bl	1e38 <PWMServo::PWMServo()>
{}
     48c:	mov	r0, r4
     48e:	pop	{r3, r4, r5, pc}

00000490 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
void Leg::setFootPositionWrtBody(Eigen::Vector3f foot_position_wrt_body_arg) {
    foot_position_wrt_body = foot_position_wrt_body_arg;
}

// METHODS
Eigen::Vector3f Leg::calculateIKFoot(Eigen::Vector3f foot_pos) {
     490:	push	{r3, r4, r5, lr}
     492:	vpush	{d8-d13}
    float theta_2 = 0.0;
    float theta_3 = 0.0;

    float p_x = foot_pos(0);
    float p_y = foot_pos(1);
    float p_z = foot_pos(2);
     496:	vldr	s16, [r2, #8]
    // float p_yz = sqrt(pow(p_y, 2.0) + pow(p_z, 2.0));

    // Part 1: Finding theta_1
    float l_a = pow((pow((p_y - d_y), 2.0) + pow(p_z, 2.0)), 0.5);
     49a:	vmov.f64	d1, #96	; 0x3f000000  0.5
     49e:	vldr	s15, [r2, #4]
void Leg::setFootPositionWrtBody(Eigen::Vector3f foot_position_wrt_body_arg) {
    foot_position_wrt_body = foot_position_wrt_body_arg;
}

// METHODS
Eigen::Vector3f Leg::calculateIKFoot(Eigen::Vector3f foot_pos) {
     4a2:	mov	r4, r1
    float p_y = foot_pos(1);
    float p_z = foot_pos(2);
    // float p_yz = sqrt(pow(p_y, 2.0) + pow(p_z, 2.0));

    // Part 1: Finding theta_1
    float l_a = pow((pow((p_y - d_y), 2.0) + pow(p_z, 2.0)), 0.5);
     4a4:	.word	0x0ac8eeb7
     4a8:	vldr	s14, [r1, #4]
void Leg::setFootPositionWrtBody(Eigen::Vector3f foot_position_wrt_body_arg) {
    foot_position_wrt_body = foot_position_wrt_body_arg;
}

// METHODS
Eigen::Vector3f Leg::calculateIKFoot(Eigen::Vector3f foot_pos) {
     4ac:	mov	r5, r0

    float theta_1 = 0.0;
    float theta_2 = 0.0;
    float theta_3 = 0.0;

    float p_x = foot_pos(0);
     4ae:	vldr	s20, [r2]
    float p_y = foot_pos(1);
    float p_z = foot_pos(2);
    // float p_yz = sqrt(pow(p_y, 2.0) + pow(p_z, 2.0));

    // Part 1: Finding theta_1
    float l_a = pow((pow((p_y - d_y), 2.0) + pow(p_z, 2.0)), 0.5);
     4b2:	vsub.f32	s14, s15, s14
     4b6:	vmul.f64	d0, d0, d0
     4ba:	vcvt.f64.f32	d7, s14
     4be:	vfma.f64	d0, d7, d7
     4c2:	bl	52d8 <pow>
    float rho = asin(abs(p_z)/l_a);
     4c6:	vcmpe.f32	s16, #0.0
    float p_y = foot_pos(1);
    float p_z = foot_pos(2);
    // float p_yz = sqrt(pow(p_y, 2.0) + pow(p_z, 2.0));

    // Part 1: Finding theta_1
    float l_a = pow((pow((p_y - d_y), 2.0) + pow(p_z, 2.0)), 0.5);
     4ca:	vcvt.f32.f64	s18, d0
    float rho = asin(abs(p_z)/l_a);
     4ce:	vmrs	APSR_nzcv, fpscr
     4d2:	it	le
     4d4:	vnegle.f32	s16, s16
     4d8:	vdiv.f32	s0, s16, s18
     4dc:	.word	0x0ac0eeb7
     4e0:	bl	5228 <asin>
    float beta = acos(abs(d_j2_j1_by)/l_a);
     4e4:	vldr	s15, [r4, #12]
    float p_z = foot_pos(2);
    // float p_yz = sqrt(pow(p_y, 2.0) + pow(p_z, 2.0));

    // Part 1: Finding theta_1
    float l_a = pow((pow((p_y - d_y), 2.0) + pow(p_z, 2.0)), 0.5);
    float rho = asin(abs(p_z)/l_a);
     4e8:	vcvt.f32.f64	s21, d0
    float beta = acos(abs(d_j2_j1_by)/l_a);
     4ec:	.word	0x7ac0eef5
     4f0:	vmrs	APSR_nzcv, fpscr
     4f4:	it	le
     4f6:	vnegle.f32	s15, s15
     4fa:	.short	0xee87
     4fc:	lsrs	r1, r1, #10
     4fe:	.short	0xeeb7
     500:	lsrs	r0, r0, #11
     502:	bl	517c <acos>
     506:	vmov.f64	d8, d0
    theta_1 = beta - rho;
    
    // Part 2: theta_3
    float l_b = sqrt(pow(l_a, 2.0) - pow(d_j2_j1_by, 2.0));
     50a:	vldr	s0, [r4, #12]
     50e:	vcvt.f64.f32	d7, s18
     512:	vcvt.f64.f32	d0, s0
     516:	vnmul.f64	d0, d0, d0
     51a:	vfma.f64	d0, d7, d7
     51e:	vsqrt.f64	d11, d0
     522:	vcmp.f64	d11, d11
     526:	vmrs	APSR_nzcv, fpscr
     52a:	bne.w	630 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x1a0>
    float l_eff = sqrt(pow(l_b, 2.0) + pow((p_x - d_x - d_j2_j1_bx), 2.0));
     52e:	vldr	s15, [r4]
     532:	vcvt.f32.f64	s22, d11
     536:	vldr	s0, [r4, #8]
     53a:	vsub.f32	s15, s20, s15
     53e:	vcvt.f64.f32	d11, s22
     542:	vsub.f32	s0, s15, s0
     546:	vcvt.f64.f32	d0, s0
     54a:	vmul.f64	d0, d0, d0
     54e:	vfma.f64	d0, d11, d11
     552:	vsqrt.f64	d9, d0
     556:	vcmp.f64	d9, d9
     55a:	vmrs	APSR_nzcv, fpscr
     55e:	bne.n	63a <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x1aa>
    theta_3 = acos((pow(l_eff, 2.0) - pow(l_2, 2.0) - pow(l_3, 2.0))/(-2.0*l_2*l_3)) - EIGEN_PI/2.0;
     560:	vldr	s14, [r4, #16]
     564:	vcvt.f32.f64	s18, d9
     568:	vmov.f64	d13, #128	; 0xc0000000 -2.0
     56c:	vldr	s12, [r4, #20]
     570:	vcvt.f64.f32	d7, s14
     574:	vcvt.f64.f32	d9, s18
     578:	vcvt.f64.f32	d6, s12
     57c:	vnmul.f64	d0, d7, d7
     580:	vmul.f64	d7, d7, d13
     584:	vfma.f64	d0, d9, d9
     588:	vmul.f64	d7, d7, d6
     58c:	vfms.f64	d0, d6, d6
     590:	vdiv.f64	d0, d0, d7
     594:	bl	517c <acos>

    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
     598:	vldr	s14, [r4, #20]
     59c:	vldr	s12, [r4, #16]
     5a0:	vcvt.f64.f32	d7, s14
     5a4:	vcvt.f64.f32	d6, s12
    theta_1 = beta - rho;
    
    // Part 2: theta_3
    float l_b = sqrt(pow(l_a, 2.0) - pow(d_j2_j1_by, 2.0));
    float l_eff = sqrt(pow(l_b, 2.0) + pow((p_x - d_x - d_j2_j1_bx), 2.0));
    theta_3 = acos((pow(l_eff, 2.0) - pow(l_2, 2.0) - pow(l_3, 2.0))/(-2.0*l_2*l_3)) - EIGEN_PI/2.0;
     5a8:	vmov.f64	d12, d0

    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
     5ac:	vmul.f64	d7, d7, d7
     5b0:	vmul.f64	d0, d9, d13
     5b4:	vfms.f64	d7, d9, d9
     5b8:	vmul.f64	d0, d0, d6
     5bc:	vfms.f64	d7, d6, d6
     5c0:	vdiv.f64	d0, d7, d0
     5c4:	bl	517c <acos>
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;
     5c8:	vldr	s15, [r4, #8]
    float l_b = sqrt(pow(l_a, 2.0) - pow(d_j2_j1_by, 2.0));
    float l_eff = sqrt(pow(l_b, 2.0) + pow((p_x - d_x - d_j2_j1_bx), 2.0));
    theta_3 = acos((pow(l_eff, 2.0) - pow(l_2, 2.0) - pow(l_3, 2.0))/(-2.0*l_2*l_3)) - EIGEN_PI/2.0;

    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
     5cc:	vmov.f64	d9, d0
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;
     5d0:	vldr	s0, [r4]
     5d4:	vmov.f64	d1, d11
     5d8:	vsub.f32	s20, s20, s0
     5dc:	vsub.f32	s0, s20, s15
     5e0:	vcvt.f64.f32	d0, s0
     5e4:	bl	52d4 <atan2>

    joint_angles(0) = theta_1;
    joint_angles(1) = theta_2;
     5e8:	vcvt.f32.f64	s18, d9

    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;

    joint_angles(0) = theta_1;
     5ec:	vcvt.f32.f64	s16, d8
     5f0:	add.w	r3, r4, #36	; 0x24
    joint_angles(1) = theta_2;
     5f4:	vcvt.f64.f32	d9, s18

    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;

    joint_angles(0) = theta_1;
     5f8:	vsub.f32	s21, s16, s21
    joint_angles(1) = theta_2;
     5fc:	vldr	d7, [pc, #72]	; 648 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x1b8>
     600:	vsub.f64	d0, d0, d9

    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;

    joint_angles(0) = theta_1;
     604:	vstr	s21, [r4, #36]	; 0x24
    joint_angles(1) = theta_2;
    joint_angles(2) = theta_3;
     608:	vsub.f64	d12, d12, d7
    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;

    joint_angles(0) = theta_1;
    joint_angles(1) = theta_2;
     60c:	vadd.f64	d9, d0, d7
    joint_angles(2) = theta_3;
     610:	vcvt.f32.f64	s24, d12
    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;

    joint_angles(0) = theta_1;
    joint_angles(1) = theta_2;
     614:	vcvt.f32.f64	s18, d9
    joint_angles(2) = theta_3;
     618:	vstr	s24, [r4, #44]	; 0x2c
    // Part 3: theta_2
    float gamma = acos((pow(l_3, 2.0) - pow(l_eff, 2.0) - pow(l_2, 2.0))/(-2.0*l_eff*l_2));
    theta_2 = atan2(p_x - d_x - d_j2_j1_bx, l_b) - gamma + EIGEN_PI/2.0;

    joint_angles(0) = theta_1;
    joint_angles(1) = theta_2;
     61c:	vstr	s18, [r4, #40]	; 0x28
    joint_angles(2) = theta_3;

    return joint_angles;
}
     620:	vpop	{d8-d13}
     624:	ldmia.w	r3, {r0, r1, r2}
     628:	stmia.w	r5, {r0, r1, r2}
     62c:	mov	r0, r5
     62e:	pop	{r3, r4, r5, pc}
    float rho = asin(abs(p_z)/l_a);
    float beta = acos(abs(d_j2_j1_by)/l_a);
    theta_1 = beta - rho;
    
    // Part 2: theta_3
    float l_b = sqrt(pow(l_a, 2.0) - pow(d_j2_j1_by, 2.0));
     630:	bl	5558 <sqrt>
     634:	vmov.f64	d11, d0
     638:	b.n	52e <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x9e>
    float l_eff = sqrt(pow(l_b, 2.0) + pow((p_x - d_x - d_j2_j1_bx), 2.0));
     63a:	bl	5558 <sqrt>
     63e:	vmov.f64	d9, d0
     642:	b.n	560 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0xd0>
     644:	nop.w
     648:	.word	0x54442d18
     64c:	.word	0x3ff921fb

00000650 <project_namespace::Leg::moveLegToJointAngles(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
    joint_angles(2) = theta_3;

    return joint_angles;
}

void Leg::moveLegToJointAngles(Eigen::Vector3f joint_angles_cmd) {
     650:	vldr	s13, [r1]
     654:	push	{r4, lr}
    ARGUMENTS:
    + joint_angles_cmd: The commanded joint angles. {coxa: theta_1, femur: theta_2, tibia: theta_3}.
    */

    joint_angles = joint_angles_cmd; // Update attribute
    coxa_servo.write(degrees(joint_angles(0)));
     656:	vcvt.f64.f32	d7, s13
    joint_angles(2) = theta_3;

    return joint_angles;
}

void Leg::moveLegToJointAngles(Eigen::Vector3f joint_angles_cmd) {
     65a:	mov	r4, r0
    ARGUMENTS:
    + joint_angles_cmd: The commanded joint angles. {coxa: theta_1, femur: theta_2, tibia: theta_3}.
    */

    joint_angles = joint_angles_cmd; // Update attribute
    coxa_servo.write(degrees(joint_angles(0)));
     65c:	adds	r0, #60	; 0x3c
    joint_angles(2) = theta_3;

    return joint_angles;
}

void Leg::moveLegToJointAngles(Eigen::Vector3f joint_angles_cmd) {
     65e:	vpush	{d8}
    ARGUMENTS:
    + joint_angles_cmd: The commanded joint angles. {coxa: theta_1, femur: theta_2, tibia: theta_3}.
    */

    joint_angles = joint_angles_cmd; // Update attribute
    coxa_servo.write(degrees(joint_angles(0)));
     662:	vldr	d8, [pc, #100]	; 6c8 <project_namespace::Leg::moveLegToJointAngles(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x78>
     666:	vstr	s13, [r4, #36]	; 0x24
     66a:	ldr	r3, [r1, #4]
     66c:	vmul.f64	d7, d7, d8
     670:	str	r3, [r4, #40]	; 0x28
     672:	ldr	r3, [r1, #8]
     674:	str	r3, [r4, #44]	; 0x2c
     676:	vcvt.s32.f64	s15, d7
     67a:	vmov	r1, s15
     67e:	bl	1ec8 <PWMServo::write(int)>
    femur_servo.write(degrees(joint_angles(1)));
     682:	vldr	s12, [r4, #40]	; 0x28
     686:	add.w	r0, r4, #64	; 0x40
     68a:	vcvt.f64.f32	d6, s12
     68e:	vmul.f64	d6, d6, d8
     692:	vcvt.s32.f64	s15, d6
     696:	vmov	r1, s15
     69a:	bl	1ec8 <PWMServo::write(int)>
    tibia_servo.write(degrees(joint_angles(2)));
     69e:	vldr	s14, [r4, #44]	; 0x2c
     6a2:	add.w	r0, r4, #68	; 0x44
     6a6:	vcvt.f64.f32	d7, s14
     6aa:	vmul.f64	d7, d7, d8
}
     6ae:	vpop	{d8}
    */

    joint_angles = joint_angles_cmd; // Update attribute
    coxa_servo.write(degrees(joint_angles(0)));
    femur_servo.write(degrees(joint_angles(1)));
    tibia_servo.write(degrees(joint_angles(2)));
     6b2:	vcvt.s32.f64	s15, d7
}
     6b6:	ldmia.w	sp!, {r4, lr}
    */

    joint_angles = joint_angles_cmd; // Update attribute
    coxa_servo.write(degrees(joint_angles(0)));
    femur_servo.write(degrees(joint_angles(1)));
    tibia_servo.write(degrees(joint_angles(2)));
     6ba:	vmov	r1, s15
     6be:	b.w	1ec8 <PWMServo::write(int)>
     6c2:	nop
     6c4:	nop.w
     6c8:	.word	0x1a63c1f8
     6cc:	.word	0x404ca5dc

000006d0 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
}

void Leg::moveFoot(Eigen::Vector3f foot_pos) {
     6d0:	push	{r4, r5, r6, lr}
     6d2:	sub	sp, #32
     6d4:	mov	r5, r0
     6d6:	mov	r6, r1
     6d8:	add	r4, sp, #20
     6da:	ldmia	r1, {r0, r1, r2}
     6dc:	stmia.w	r4, {r0, r1, r2}

    ARGUMENTS:
    + foot_pos: The destination coordinates [x, y, z] of the foot.
    */

    calculateIKFoot(foot_pos);
     6e0:	mov	r2, r4
     6e2:	mov	r1, r5
     6e4:	mov	r0, sp
     6e6:	bl	490 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
     6ea:	ldr	r0, [r6, #0]
     6ec:	ldr	r1, [r6, #4]
     6ee:	add.w	r3, r5, #36	; 0x24
     6f2:	ldr	r2, [r6, #8]
     6f4:	str	r0, [r5, #48]	; 0x30
     6f6:	str	r1, [r5, #52]	; 0x34
     6f8:	str	r2, [r5, #56]	; 0x38
     6fa:	ldmia.w	r3, {r0, r1, r2}
     6fe:	stmia.w	r4, {r0, r1, r2}
    setFootPositionWrtBody(foot_pos);
    moveLegToJointAngles(joint_angles);
     702:	mov	r1, r4
     704:	mov	r0, r5
     706:	bl	650 <project_namespace::Leg::moveLegToJointAngles(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
     70a:	add	sp, #32
     70c:	pop	{r4, r5, r6, pc}
     70e:	nop

00000710 <Eigen::Matrix<float, 3, 3, 0, 3, 3>& Eigen::Matrix<float, 3, 3, 0, 3, 3>::operator=<Eigen::Quaternion<float, 0> >(Eigen::RotationBase<Eigen::Quaternion<float, 0>, 3> const&)>:
     710:	vldr	s14, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
     714:	vmov.f32	s10, #112	; 0x3f800000  1.0
     718:	vldr	s11, [r1, #8]
     71c:	vadd.f32	s6, s14, s14
     720:	vldr	s15, [r1]
     724:	vadd.f32	s9, s11, s11
     728:	vldr	s12, [r1, #12]
     72c:	vadd.f32	s7, s15, s15
     730:	vmul.f32	s13, s14, s6
     734:	vmul.f32	s11, s11, s9
     738:	vmul.f32	s8, s15, s6
     73c:	vmov.f32	s5, s13
     740:	vmov.f32	s4, s11
     744:	vmul.f32	s14, s14, s9
     748:	vfma.f32	s5, s15, s7
     74c:	vfma.f32	s4, s15, s7
     750:	vmov.f32	s3, s8
     754:	vmul.f32	s15, s15, s9
     758:	vfms.f32	s8, s9, s12
     75c:	vfma.f32	s3, s9, s12
     760:	vadd.f32	s13, s13, s11
     764:	vmov.f32	s9, s15
     768:	vmov.f32	s11, s14
     76c:	vfma.f32	s15, s6, s12
     770:	vfms.f32	s9, s6, s12
     774:	vstr	s8, [r0, #12]
     778:	vfma.f32	s11, s7, s12
     77c:	vstr	s3, [r0, #4]
     780:	vfms.f32	s14, s7, s12
     784:	vsub.f32	s13, s10, s13
     788:	vsub.f32	s12, s10, s5
     78c:	vsub.f32	s10, s10, s4
     790:	vstr	s15, [r0, #24]
     794:	vstr	s9, [r0, #8]
     798:	vstr	s12, [r0, #32]
     79c:	vstr	s13, [r0]
     7a0:	vstr	s10, [r0, #16]
     7a4:	vstr	s11, [r0, #20]
     7a8:	vstr	s14, [r0, #28]
     7ac:	bx	lr
     7ae:	nop

000007b0 <project_namespace::MyMath::eulerToMatrix(float, float, float)>:
     7b0:	vmov.f32	s15, #96	; 0x3f000000  0.5
     7b4:	push	{r4, r5, r7, lr}
     7b6:	vpush	{d8-d11}
     7ba:	vmul.f32	s17, s2, s15
     7be:	add	r7, sp, #0
     7c0:	vmul.f32	s16, s1, s15
     7c4:	sub	sp, #32
     7c6:	vmul.f32	s21, s0, s15
     7ca:	mov	r5, r0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     7cc:	vmov.f32	s0, s17
     7d0:	vldr	s18, [pc, #272]	; 8e4 <project_namespace::MyMath::eulerToMatrix(float, float, float)+0x134>
     7d4:	bl	5058 <cosf>
     7d8:	vmov.f32	s23, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     7dc:	vmov.f32	s0, s17
     7e0:	add.w	r4, sp, #15
     7e4:	bl	50e8 <sinf>
     7e8:	vmov.f32	s22, s0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     7ec:	vmov.f32	s0, s16
     7f0:	bic.w	r4, r4, #15
     7f4:	bl	5058 <cosf>
     7f8:	vmov.f32	s20, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     7fc:	vmov.f32	s0, s16
     800:	bl	50e8 <sinf>
     804:	vmov.f32	s12, s0
     808:	vmul.f32	s13, s22, s18
     80c:	vmul.f32	s17, s20, s22
     810:	vmul.f32	s15, s12, s18
     814:	vmul.f32	s16, s20, s13
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     818:	vmov.f32	s0, s21
     81c:	vmul.f32	s14, s15, s13
     820:	vmov.f32	s19, s16
     824:	vfma.f32	s17, s15, s23
     828:	vmov.f32	s11, s14
     82c:	vfma.f32	s19, s12, s23
     830:	vfma.f32	s16, s15, s23
     834:	vfnms.f32	s11, s20, s23
     838:	vfma.f32	s17, s12, s13
     83c:	vfma.f32	s19, s15, s22
     840:	vadd.f32	s16, s16, s14
     844:	vmov.f32	s20, s11
     848:	vneg.f32	s11, s12
     84c:	vsub.f32	s17, s17, s14
     850:	vfma.f32	s20, s11, s13
     854:	vfma.f32	s16, s11, s22
     858:	vsub.f32	s19, s19, s14
     85c:	vfms.f32	s20, s15, s22
     860:	bl	5058 <cosf>
     864:	vmov.f32	s22, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     868:	vmov.f32	s0, s21
     86c:	bl	50e8 <sinf>
     870:	vmul.f32	s15, s0, s18
     874:	vnmul.f32	s14, s16, s0
     878:	mov	r1, r4
     87a:	vmul.f32	s11, s22, s16
     87e:	mov	r0, r5
     880:	vmul.f32	s13, s22, s17
     884:	vfma.f32	s14, s22, s20
     888:	vfma.f32	s11, s0, s20
     88c:	vfma.f32	s13, s15, s20
     890:	vmul.f32	s12, s22, s19
     894:	vneg.f32	s10, s15
     898:	vfma.f32	s12, s15, s20
     89c:	vfma.f32	s11, s15, s19
     8a0:	vfma.f32	s13, s15, s16
     8a4:	vmov.f32	s15, s14
     8a8:	vfma.f32	s12, s0, s17
     8ac:	vfma.f32	s15, s10, s19
     8b0:	vmov.f32	s14, s13
     8b4:	vfma.f32	s11, s10, s17
     8b8:	vfms.f32	s14, s0, s19
     8bc:	vfma.f32	s12, s10, s16
     8c0:	vfma.f32	s15, s10, s17
     8c4:	vstr	s11, [r4]
     8c8:	vstr	s14, [r4, #8]
     8cc:	vstr	s12, [r4, #4]
     8d0:	vstr	s15, [r4, #12]
     8d4:	bl	710 <Eigen::Matrix<float, 3, 3, 0, 3, 3>& Eigen::Matrix<float, 3, 3, 0, 3, 3>::operator=<Eigen::Quaternion<float, 0> >(Eigen::RotationBase<Eigen::Quaternion<float, 0>, 3> const&)>
     8d8:	mov	r0, r5
     8da:	mov	sp, r7
     8dc:	vpop	{d8-d11}
     8e0:	pop	{r4, r5, r7, pc}
     8e2:	nop
     8e4:	.word	0x00000000

000008e8 <project_namespace::MasterController::MasterController(project_namespace::IMU&)>:
#include "MatrixPrinter.h"

using namespace project_namespace;

// CONSTRUCTORS
MasterController::MasterController(IMU& imu_init):
     8e8:	push	{r3, r4, r5, lr}
     8ea:	mov	r5, r1
     8ec:	mov	r4, r0
    imu(imu_init),
    gait_controller(GaitController(Gait::TROT, FootTrajectory::SEMICIRCULAR, imu)),
    ticks(0)
     8ee:	movs	r2, #1
     8f0:	movs	r1, #0
     8f2:	mov	r3, r5
     8f4:	str.w	r5, [r0], #16
     8f8:	bl	1ab0 <project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)>
     8fc:	movs	r3, #0
{ }
     8fe:	mov	r0, r4

// CONSTRUCTORS
MasterController::MasterController(IMU& imu_init):
    imu(imu_init),
    gait_controller(GaitController(Gait::TROT, FootTrajectory::SEMICIRCULAR, imu)),
    ticks(0)
     900:	str.w	r3, [r4, #176]	; 0xb0
{ }
     904:	pop	{r3, r4, r5, pc}
     906:	nop

00000908 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)>:

// METHODS
void MasterController::stepOnce(Robot& robot, Command& command) {
     908:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     90c:	vpush	{d8-d11}
     910:	sub	sp, #52	; 0x34
     912:	mov	r9, r0
    ARGUMENTS:
    + robot: The robot to control and command.
    + command: It contains the input commands into the robot.
    */

    if (command.getMode() == Mode::REST) {
     914:	mov	r0, r2
    gait_controller(GaitController(Gait::TROT, FootTrajectory::SEMICIRCULAR, imu)),
    ticks(0)
{ }

// METHODS
void MasterController::stepOnce(Robot& robot, Command& command) {
     916:	mov	r6, r2
     918:	add	r7, sp, #8
     91a:	sub	sp, #112	; 0x70
     91c:	mov	r8, r1
     91e:	add.w	r4, sp, #23
     922:	bic.w	r4, r4, #15
    ARGUMENTS:
    + robot: The robot to control and command.
    + command: It contains the input commands into the robot.
    */

    if (command.getMode() == Mode::REST) {
     926:	bl	1a90 <project_namespace::Command::getMode()>
     92a:	cbz	r0, 944 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x3c>
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
        robot.setBodyRoll(command.getBodyRoll());
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

    } else if (command.getMode() == Mode::TROT) {
     92c:	mov	r0, r6
     92e:	bl	1a90 <project_namespace::Command::getMode()>
     932:	cmp	r0, #1
     934:	beq.w	ba0 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x298>
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

        ticks += 1;
    }
     938:	adds	r7, #44	; 0x2c
     93a:	mov	sp, r7
     93c:	vpop	{d8-d11}
     940:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ticks = 0;
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     944:	vmov.f32	s22, #96	; 0x3f000000  0.5
    + robot: The robot to control and command.
    + command: It contains the input commands into the robot.
    */

    if (command.getMode() == Mode::REST) {
        ticks = 0;
     948:	str.w	r0, [r9, #176]	; 0xb0
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     94c:	mov	r0, r6
     94e:	vmov.f64	d10, #96	; 0x3f000000  0.5
     952:	bl	1a40 <project_namespace::Command::getStancePolygonLength()>
                command.getStancePolygonWidth()/2.0,
     956:	mov	r0, r6
        ticks = 0;
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     958:	vmul.f32	s18, s0, s22
                command.getStancePolygonWidth()/2.0,
     95c:	bl	1a48 <project_namespace::Command::getStancePolygonWidth()>
                -1.0*command.getStanceHeight()
     960:	mov	r0, r6
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
                command.getStancePolygonWidth()/2.0,
     962:	vmul.f32	s17, s0, s22
                -1.0*command.getStanceHeight()
     966:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     96a:	vneg.f32	s16, s0
        ).finished();
        new_foot_positions_wrt_body.col(1) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     96e:	mov	r0, r6
     970:	vstr	s18, [r4, #48]	; 0x30
     974:	vstr	s17, [r4, #52]	; 0x34
     978:	mov	r5, r4
     97a:	vstr	s16, [r4, #56]	; 0x38
     97e:	bl	1a40 <project_namespace::Command::getStancePolygonLength()>
                -1.0*command.getStancePolygonWidth()/2.0,
     982:	mov	r0, r6
                command.getStancePolygonWidth()/2.0,
                -1.0*command.getStanceHeight()
        ).finished();
        new_foot_positions_wrt_body.col(1) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     984:	vmov.f32	s23, s0
                -1.0*command.getStancePolygonWidth()/2.0,
     988:	bl	1a48 <project_namespace::Command::getStancePolygonWidth()>
     98c:	vmov.f32	s19, s0
                -1.0*command.getStanceHeight()
     990:	mov	r0, r6
     992:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     996:	vneg.f32	s0, s0
     99a:	vmul.f32	s23, s23, s22
        ).finished();
        new_foot_positions_wrt_body.col(2) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
     99e:	mov	r0, r6
     9a0:	vcvt.f64.f32	d7, s19
     9a4:	vstr	s0, [r4, #68]	; 0x44
     9a8:	vstr	s23, [r4, #60]	; 0x3c
     9ac:	vnmul.f64	d7, d7, d10
     9b0:	vcvt.f32.f64	s14, d7
     9b4:	vstr	s14, [r4, #64]	; 0x40
     9b8:	bl	1a40 <project_namespace::Command::getStancePolygonLength()>
     9bc:	vmov.f32	s19, s0
                command.getStancePolygonWidth()/2.0,
     9c0:	mov	r0, r6
     9c2:	bl	1a48 <project_namespace::Command::getStancePolygonWidth()>
                -1.0*command.getStanceHeight()
     9c6:	mov	r0, r6
                -1.0*command.getStanceHeight()
        ).finished();
        new_foot_positions_wrt_body.col(2) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
                command.getStancePolygonWidth()/2.0,
     9c8:	vmov.f32	s23, s0
                -1.0*command.getStanceHeight()
     9cc:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     9d0:	vcvt.f64.f32	d7, s19
        ).finished();
        new_foot_positions_wrt_body.col(3) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
     9d4:	mov	r0, r6
     9d6:	vneg.f32	s0, s0
     9da:	vmul.f32	s22, s23, s22
     9de:	vnmul.f64	d7, d7, d10
     9e2:	vstr	s0, [r4, #80]	; 0x50
     9e6:	vstr	s22, [r4, #76]	; 0x4c
     9ea:	vcvt.f32.f64	s14, d7
     9ee:	vstr	s14, [r4, #72]	; 0x48
     9f2:	bl	1a40 <project_namespace::Command::getStancePolygonLength()>
                -1.0*command.getStancePolygonWidth()/2.0,
     9f6:	mov	r0, r6
                command.getStancePolygonWidth()/2.0,
                -1.0*command.getStanceHeight()
        ).finished();
        new_foot_positions_wrt_body.col(3) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
     9f8:	vmov.f32	s22, s0
                -1.0*command.getStancePolygonWidth()/2.0,
     9fc:	bl	1a48 <project_namespace::Command::getStancePolygonWidth()>
     a00:	vmov.f32	s19, s0
                -1.0*command.getStanceHeight()
     a04:	mov	r0, r6
     a06:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     a0a:	vneg.f32	s0, s0
     a0e:	vcvt.f64.f32	d6, s22
     a12:	add.w	lr, r4, #48	; 0x30
     a16:	vcvt.f64.f32	d7, s19
     a1a:	vstr	s0, [r4, #92]	; 0x5c
     a1e:	vnmul.f64	d6, d6, d10
     a22:	vnmul.f64	d7, d7, d10
     a26:	vcvt.f32.f64	s12, d6
     a2a:	vcvt.f32.f64	s14, d7
     a2e:	vstr	s12, [r4, #84]	; 0x54
     a32:	vstr	s14, [r4, #88]	; 0x58
     a36:	ldmia.w	lr!, {r0, r1, r2, r3}
     a3a:	stmia	r5!, {r0, r1, r2, r3}
     a3c:	ldmia.w	lr!, {r0, r1, r2, r3}
     a40:	stmia	r5!, {r0, r1, r2, r3}
     a42:	ldmia.w	lr, {r0, r1, r2, r3}
     a46:	stmia.w	r5, {r0, r1, r2, r3}
        ).finished();
        // Track foot trajectory without body rpy
        robot.setFootPositionsWrtBodyAssumingNoBodyRPY(new_foot_positions_wrt_body);
     a4a:	mov	r1, r4
     a4c:	mov	r0, r8
     a4e:	bl	12b4 <project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Desired body orientation matrix
        Eigen::Matrix<float, 3, 3> body_rpy_matrix;
        body_rpy_matrix =
            MyMath::eulerToMatrix(
     a52:	mov	r0, r6
     a54:	bl	1a58 <project_namespace::Command::getBodyRoll()>
     a58:	mov	r0, r6
     a5a:	vmov.f32	s19, s0
     a5e:	bl	1a60 <project_namespace::Command::getBodyPitch()>
     a62:	vmov.f32	s20, s0
     a66:	mov	r0, r6
     a68:	add.w	r5, r4, #48	; 0x30
     a6c:	bl	1a68 <project_namespace::Command::getBodyYaw()>
     a70:	adds	r0, r7, #4
     a72:	vmov.f32	s2, s0
     a76:	vmov.f32	s1, s20
     a7a:	vmov.f32	s0, s19
     a7e:	bl	7b0 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     a82:	vldr	s5, [r7, #4]
     a86:	mov	r3, r4
     a88:	mov	r2, r5
     a8a:	vldr	s6, [r7, #8]
     a8e:	add.w	r1, r4, #84	; 0x54
     a92:	vldr	s7, [r7, #12]
     a96:	vldr	s8, [r7, #16]
     a9a:	vldr	s9, [r7, #20]
     a9e:	vldr	s10, [r7, #24]
     aa2:	vldr	s11, [r7, #28]
     aa6:	vldr	s12, [r7, #32]
     aaa:	vldr	s13, [r7, #36]	; 0x24
     aae:	vmul.f32	s14, s7, s16
  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
  {
    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;

    const Index outerSize = kernel.outerSize();
    for(Index outer = 0; outer < outerSize; ++outer)
     ab2:	cmp	r2, r1
     ab4:	vmul.f32	s15, s10, s16
     ab8:	add.w	r3, r3, #12
     abc:	vmul.f32	s16, s13, s16
     ac0:	vfma.f32	s14, s6, s17
     ac4:	vfma.f32	s15, s9, s17
     ac8:	vfma.f32	s16, s12, s17
     acc:	vfma.f32	s14, s5, s18
     ad0:	vfma.f32	s15, s8, s18
     ad4:	vfma.f32	s16, s11, s18
     ad8:	vstr	s14, [r3, #-12]
     adc:	vstr	s15, [r3, #-8]
     ae0:	vstr	s16, [r3, #-4]
     ae4:	beq.n	af6 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x1ee>
     ae6:	vldr	s18, [r2, #12]
     aea:	adds	r2, #12
     aec:	vldr	s17, [r2, #4]
     af0:	vldr	s16, [r2, #8]
     af4:	b.n	aae <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x1a6>
     af6:	ldr	r2, [r4, #0]
     af8:	mov	lr, r4
     afa:	ldr	r3, [r4, #4]
     afc:	ldr.w	ip, [r4, #8]
     b00:	ldr	r0, [r4, #12]
     b02:	ldr	r1, [r4, #16]
     b04:	str	r2, [r4, #48]	; 0x30
     b06:	str	r3, [r4, #52]	; 0x34
     b08:	ldr	r2, [r4, #20]
     b0a:	ldr	r3, [r4, #24]
     b0c:	str.w	ip, [r4, #56]	; 0x38
     b10:	str	r0, [r4, #60]	; 0x3c
     b12:	ldr.w	ip, [r4, #28]
     b16:	ldr	r0, [r4, #32]
     b18:	str	r1, [r4, #64]	; 0x40
     b1a:	str	r2, [r4, #68]	; 0x44
     b1c:	ldr	r1, [r4, #36]	; 0x24
     b1e:	ldr	r2, [r4, #40]	; 0x28
     b20:	str	r3, [r4, #72]	; 0x48
     b22:	ldr	r3, [r4, #44]	; 0x2c
     b24:	str.w	ip, [r4, #76]	; 0x4c
     b28:	str	r0, [r4, #80]	; 0x50
     b2a:	str	r1, [r4, #84]	; 0x54
     b2c:	str	r2, [r4, #88]	; 0x58
     b2e:	str	r3, [r4, #92]	; 0x5c
     b30:	ldmia	r5!, {r0, r1, r2, r3}
     b32:	stmia.w	lr!, {r0, r1, r2, r3}
     b36:	ldmia	r5!, {r0, r1, r2, r3}
     b38:	stmia.w	lr!, {r0, r1, r2, r3}
     b3c:	ldmia.w	r5, {r0, r1, r2, r3}
     b40:	stmia.w	lr, {r0, r1, r2, r3}
                command.getBodyYaw()
            );
        // Apply body rpy
        new_foot_positions_wrt_body = body_rpy_matrix.transpose()*new_foot_positions_wrt_body;
        // Move feet to calculated positions
        robot.moveAllFeet(new_foot_positions_wrt_body); // Foot positions, joint angles in Legs and Robot are internally updated.
     b44:	mov	r1, r4
     b46:	mov	r0, r8
     b48:	bl	1304 <project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Update robot attributes
        robot.setStancePolygonLength(command.getStancePolygonLength()); // Resting foot locations are updated internally
     b4c:	mov	r0, r6
     b4e:	bl	1a40 <project_namespace::Command::getStancePolygonLength()>
     b52:	mov	r0, r8
     b54:	bl	1404 <project_namespace::Robot::setStancePolygonLength(float)>
        robot.setStancePolygonWidth(command.getStancePolygonWidth()); // Resting foot locations are updated internally
     b58:	mov	r0, r6
     b5a:	bl	1a48 <project_namespace::Command::getStancePolygonWidth()>
     b5e:	mov	r0, r8
     b60:	bl	140c <project_namespace::Robot::setStancePolygonWidth(float)>
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
     b64:	mov	r0, r6
     b66:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     b6a:	mov	r0, r8
     b6c:	bl	1414 <project_namespace::Robot::setStanceHeight(float)>
        robot.setBodyRoll(command.getBodyRoll());
     b70:	mov	r0, r6
     b72:	bl	1a58 <project_namespace::Command::getBodyRoll()>
     b76:	mov	r0, r8
     b78:	bl	129c <project_namespace::Robot::setBodyRoll(float)>
        robot.setBodyPitch(command.getBodyPitch());
     b7c:	mov	r0, r6
     b7e:	bl	1a60 <project_namespace::Command::getBodyPitch()>
     b82:	mov	r0, r8
     b84:	bl	12a4 <project_namespace::Robot::setBodyPitch(float)>
        robot.setBodyYaw(command.getBodyYaw());
     b88:	mov	r0, r6
     b8a:	bl	1a68 <project_namespace::Command::getBodyYaw()>
     b8e:	mov	r0, r8
     b90:	bl	12ac <project_namespace::Robot::setBodyYaw(float)>
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

        ticks += 1;
    }
     b94:	adds	r7, #44	; 0x2c
     b96:	mov	sp, r7
     b98:	vpop	{d8-d11}
     b9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

    } else if (command.getMode() == Mode::TROT) {
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        new_foot_positions_wrt_body = gait_controller.calculateAllNewFootPositions(robot, command, ticks);
     ba0:	add.w	r5, r9, #16
     ba4:	ldr.w	r0, [r9, #176]	; 0xb0
     ba8:	mov	r3, r6
     baa:	mov	r2, r8
     bac:	mov	r1, r5
     bae:	str	r0, [sp, #0]
     bb0:	mov	r0, r4
     bb2:	bl	1ce8 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)>
        // Update robot contact pattern
        robot.setContactPattern(gait_controller.calculateContactPattern(ticks));
     bb6:	mov	r1, r5
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
     bb8:	ldr.w	ip, [r4, #12]
     bbc:	mov	r0, r4
     bbe:	ldr.w	lr, [r4, #16]
     bc2:	ldr	r5, [r4, #20]
     bc4:	ldr	r3, [r4, #24]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     bc6:	vldr	s17, [r4]
     bca:	vldr	s18, [r4, #4]
     bce:	vldr	s16, [r4, #8]
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
     bd2:	ldr	r2, [r4, #28]
     bd4:	str.w	ip, [r4, #60]	; 0x3c
     bd8:	str.w	lr, [r4, #64]	; 0x40
     bdc:	ldr.w	ip, [r4, #32]
     be0:	ldr.w	lr, [r4, #36]	; 0x24
     be4:	str	r5, [r4, #68]	; 0x44
     be6:	str	r3, [r4, #72]	; 0x48
     be8:	ldr	r5, [r4, #40]	; 0x28
     bea:	ldr	r3, [r4, #44]	; 0x2c
     bec:	str.w	ip, [r4, #80]	; 0x50
     bf0:	str.w	lr, [r4, #84]	; 0x54
     bf4:	str	r3, [r4, #92]	; 0x5c
     bf6:	str	r2, [r4, #76]	; 0x4c
     bf8:	str	r5, [r4, #88]	; 0x58
     bfa:	mov	r5, r4
     bfc:	ldr.w	r2, [r9, #176]	; 0xb0
     c00:	vstr	s17, [r4, #48]	; 0x30
     c04:	vstr	s18, [r4, #52]	; 0x34
     c08:	vstr	s16, [r4, #56]	; 0x38
     c0c:	bl	1c98 <project_namespace::GaitController::calculateContactPattern(int)>
     c10:	mov	r1, r4
     c12:	mov	r0, r8
     c14:	bl	12e8 <project_namespace::Robot::setContactPattern(Eigen::Matrix<int, 4, 1, 0, 4, 1>)>
     c18:	add.w	lr, r4, #48	; 0x30
     c1c:	ldmia.w	lr!, {r0, r1, r2, r3}
     c20:	stmia	r5!, {r0, r1, r2, r3}
     c22:	ldmia.w	lr!, {r0, r1, r2, r3}
     c26:	stmia	r5!, {r0, r1, r2, r3}
     c28:	ldmia.w	lr, {r0, r1, r2, r3}
     c2c:	stmia.w	r5, {r0, r1, r2, r3}
        // Track foot trajectory without body rpy
        robot.setFootPositionsWrtBodyAssumingNoBodyRPY(new_foot_positions_wrt_body);
     c30:	mov	r1, r4
     c32:	mov	r0, r8
     c34:	bl	12b4 <project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Desired body orientation matrix
        Eigen::Matrix<float, 3, 3> body_rpy_matrix;
        body_rpy_matrix =
            MyMath::eulerToMatrix(
     c38:	mov	r0, r6
     c3a:	bl	1a58 <project_namespace::Command::getBodyRoll()>
     c3e:	mov	r0, r6
     c40:	vmov.f32	s19, s0
     c44:	bl	1a60 <project_namespace::Command::getBodyPitch()>
     c48:	vmov.f32	s20, s0
     c4c:	mov	r0, r6
     c4e:	bl	1a68 <project_namespace::Command::getBodyYaw()>
     c52:	add.w	r5, r4, #48	; 0x30
     c56:	vmov.f32	s2, s0
     c5a:	adds	r0, r7, #4
     c5c:	vmov.f32	s1, s20
     c60:	vmov.f32	s0, s19
     c64:	bl	7b0 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
     c68:	vmov.f32	s15, s16
     c6c:	vmov.f32	s11, s18
     c70:	mov	r2, r5
     c72:	vmov.f32	s12, s17
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     c76:	vldr	s2, [r7, #4]
     c7a:	mov	r3, r4
     c7c:	vldr	s3, [r7, #8]
     c80:	add.w	r1, r4, #84	; 0x54
     c84:	vldr	s4, [r7, #12]
     c88:	vldr	s5, [r7, #16]
     c8c:	vldr	s6, [r7, #20]
     c90:	vldr	s7, [r7, #24]
     c94:	vldr	s8, [r7, #28]
     c98:	vldr	s9, [r7, #32]
     c9c:	vldr	s10, [r7, #36]	; 0x24
     ca0:	vmul.f32	s13, s4, s15
     ca4:	cmp	r1, r2
     ca6:	vmul.f32	s14, s7, s15
     caa:	add.w	r3, r3, #12
     cae:	vmul.f32	s15, s10, s15
     cb2:	vfma.f32	s13, s3, s11
     cb6:	vfma.f32	s14, s6, s11
     cba:	vfma.f32	s15, s9, s11
     cbe:	vfma.f32	s13, s2, s12
     cc2:	vfma.f32	s14, s5, s12
     cc6:	vfma.f32	s15, s8, s12
     cca:	vstr	s13, [r3, #-12]
     cce:	vstr	s14, [r3, #-8]
     cd2:	vstr	s15, [r3, #-4]
     cd6:	beq.n	ce8 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x3e0>
     cd8:	vldr	s12, [r2, #12]
     cdc:	adds	r2, #12
     cde:	vldr	s11, [r2, #4]
     ce2:	vldr	s15, [r2, #8]
     ce6:	b.n	ca0 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x398>
     ce8:	ldr	r2, [r4, #0]
     cea:	mov	lr, r4
     cec:	ldr	r3, [r4, #4]
     cee:	ldr.w	ip, [r4, #8]
     cf2:	ldr	r0, [r4, #12]
     cf4:	ldr	r1, [r4, #16]
     cf6:	str	r2, [r4, #48]	; 0x30
     cf8:	str	r3, [r4, #52]	; 0x34
     cfa:	ldr	r2, [r4, #20]
     cfc:	ldr	r3, [r4, #24]
     cfe:	str.w	ip, [r4, #56]	; 0x38
     d02:	str	r0, [r4, #60]	; 0x3c
     d04:	ldr.w	ip, [r4, #28]
     d08:	ldr	r0, [r4, #32]
     d0a:	str	r1, [r4, #64]	; 0x40
     d0c:	str	r2, [r4, #68]	; 0x44
     d0e:	ldr	r1, [r4, #36]	; 0x24
     d10:	ldr	r2, [r4, #40]	; 0x28
     d12:	str	r3, [r4, #72]	; 0x48
     d14:	ldr	r3, [r4, #44]	; 0x2c
     d16:	str.w	ip, [r4, #76]	; 0x4c
     d1a:	str	r0, [r4, #80]	; 0x50
     d1c:	str	r1, [r4, #84]	; 0x54
     d1e:	str	r2, [r4, #88]	; 0x58
     d20:	str	r3, [r4, #92]	; 0x5c
     d22:	ldmia	r5!, {r0, r1, r2, r3}
     d24:	stmia.w	lr!, {r0, r1, r2, r3}
     d28:	ldmia	r5!, {r0, r1, r2, r3}
     d2a:	stmia.w	lr!, {r0, r1, r2, r3}
     d2e:	ldmia.w	r5, {r0, r1, r2, r3}
     d32:	stmia.w	lr, {r0, r1, r2, r3}
                command.getBodyYaw()
            );
        // Apply body rpy
        new_foot_positions_wrt_body = body_rpy_matrix.transpose()*new_foot_positions_wrt_body;
        // Move feet to calculated positions
        robot.moveAllFeet(new_foot_positions_wrt_body); // Foot positions (true), joint angles in Legs and Robot are internally updated.
     d36:	mov	r1, r4
     d38:	mov	r0, r8
     d3a:	bl	1304 <project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Update robot attributes
        robot.setStancePolygonLength(command.getStancePolygonLength()); // Resting foot locations are updated internally
     d3e:	mov	r0, r6
     d40:	bl	1a40 <project_namespace::Command::getStancePolygonLength()>
     d44:	mov	r0, r8
     d46:	bl	1404 <project_namespace::Robot::setStancePolygonLength(float)>
        robot.setStancePolygonWidth(command.getStancePolygonWidth()); // Resting foot locations are updated internally
     d4a:	mov	r0, r6
     d4c:	bl	1a48 <project_namespace::Command::getStancePolygonWidth()>
     d50:	mov	r0, r8
     d52:	bl	140c <project_namespace::Robot::setStancePolygonWidth(float)>
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
     d56:	mov	r0, r6
     d58:	bl	1a50 <project_namespace::Command::getStanceHeight()>
     d5c:	mov	r0, r8
     d5e:	bl	1414 <project_namespace::Robot::setStanceHeight(float)>
        robot.setBodyRoll(command.getBodyRoll());
     d62:	mov	r0, r6
     d64:	bl	1a58 <project_namespace::Command::getBodyRoll()>
     d68:	mov	r0, r8
     d6a:	bl	129c <project_namespace::Robot::setBodyRoll(float)>
        robot.setBodyPitch(command.getBodyPitch());
     d6e:	mov	r0, r6
     d70:	bl	1a60 <project_namespace::Command::getBodyPitch()>
     d74:	mov	r0, r8
     d76:	bl	12a4 <project_namespace::Robot::setBodyPitch(float)>
        robot.setBodyYaw(command.getBodyYaw());
     d7a:	mov	r0, r6
     d7c:	bl	1a68 <project_namespace::Command::getBodyYaw()>
     d80:	mov	r0, r8
     d82:	bl	12ac <project_namespace::Robot::setBodyYaw(float)>

        ticks += 1;
     d86:	ldr.w	r3, [r9, #176]	; 0xb0
    }
     d8a:	adds	r7, #44	; 0x2c
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
        robot.setBodyRoll(command.getBodyRoll());
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

        ticks += 1;
     d8c:	adds	r3, #1
     d8e:	str.w	r3, [r9, #176]	; 0xb0
    }
     d92:	mov	sp, r7
     d94:	vpop	{d8-d11}
     d98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00000d9c <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)>:
     d9c:	movs	r3, #0
#include "GaitConfig.h"

using namespace project_namespace;

// CONSTRUCTORS
GaitConfig::GaitConfig(
     d9e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    gait_swing_duration_in_ticks(0),
    gait_cycle_duration_in_ticks(0),
    gait_phase_durations_in_ticks(Eigen::Vector4i::Zero()),
    leg_stance_duration_in_ticks(0),
    leg_swing_duration_in_ticks(0),
    swing_height(0.0)
     da2:	movs	r5, #0
#include "GaitConfig.h"

using namespace project_namespace;

// CONSTRUCTORS
GaitConfig::GaitConfig(
     da4:	add	r7, sp, #0
     da6:	str	r3, [r0, #16]
     da8:	sub	sp, #80	; 0x50
    gait_swing_duration_in_ticks(0),
    gait_cycle_duration_in_ticks(0),
    gait_phase_durations_in_ticks(Eigen::Vector4i::Zero()),
    leg_stance_duration_in_ticks(0),
    leg_swing_duration_in_ticks(0),
    swing_height(0.0)
     daa:	str	r5, [r0, #8]
     dac:	str	r5, [r0, #12]
     dae:	str	r5, [r0, #120]	; 0x78
     db0:	str	r3, [r0, #20]
     db2:	str	r3, [r0, #24]
     db4:	str	r3, [r0, #28]
     db6:	str	r3, [r0, #32]
     db8:	str	r3, [r0, #36]	; 0x24
     dba:	str	r3, [r0, #40]	; 0x28
     dbc:	str	r3, [r0, #44]	; 0x2c
     dbe:	str	r3, [r0, #48]	; 0x30
     dc0:	str	r3, [r0, #52]	; 0x34
     dc2:	str	r3, [r0, #56]	; 0x38
     dc4:	str	r3, [r0, #60]	; 0x3c
     dc6:	str	r3, [r0, #64]	; 0x40
     dc8:	str	r3, [r0, #68]	; 0x44
     dca:	str	r3, [r0, #72]	; 0x48
     dcc:	str	r3, [r0, #76]	; 0x4c
     dce:	str	r3, [r0, #80]	; 0x50
     dd0:	str	r3, [r0, #84]	; 0x54
     dd2:	str	r3, [r0, #88]	; 0x58
     dd4:	str	r3, [r0, #92]	; 0x5c
     dd6:	str	r3, [r0, #96]	; 0x60
     dd8:	str	r3, [r0, #100]	; 0x64
     dda:	str	r3, [r0, #104]	; 0x68
     ddc:	str	r3, [r0, #108]	; 0x6c
     dde:	str	r3, [r0, #112]	; 0x70
     de0:	str	r3, [r0, #116]	; 0x74
     de2:	stmia.w	r0, {r1, r2}
{
    if (gait == Gait::TROT) {
     de6:	cbz	r1, dee <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0x52>
        ).finished();
        leg_stance_duration_in_ticks = 2*gait_stance_duration_in_ticks + gait_swing_duration_in_ticks;
        leg_swing_duration_in_ticks = gait_swing_duration_in_ticks;
        swing_height = 0.0;
    }
}
     de8:	mov	sp, r7
     dea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     dee:	add.w	r4, sp, #15

  EIGEN_DEVICE_FUNC
  inline CommaInitializer(XprType& xpr, const Scalar& s)
    : m_xpr(xpr), m_row(0), m_col(1), m_currentBlockRows(1)
  {
    m_xpr.coeffRef(0,0) = s;
     df2:	movs	r3, #1
    leg_swing_duration_in_ticks(0),
    swing_height(0.0)
{
    if (gait == Gait::TROT) {
        gait_stance_duration = 0.02;
        gait_swing_duration = 0.5;
     df4:	mov.w	ip, #1056964608	; 0x3f000000
    leg_stance_duration_in_ticks(0),
    leg_swing_duration_in_ticks(0),
    swing_height(0.0)
{
    if (gait == Gait::TROT) {
        gait_stance_duration = 0.02;
     df8:	ldr.w	r8, [pc, #128]	; e7c <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xe0>
     dfc:	bic.w	r2, r4, #15
        gait_swing_duration = 0.5;
     e00:	mov	r5, r0
        && "Too many rows passed to comma initializer (operator<<)");
    }
    eigen_assert(m_col<m_xpr.cols()
      && "Too many coefficients passed to comma initializer (operator<<)");
    eigen_assert(m_currentBlockRows==1);
    m_xpr.coeffRef(m_row, m_col++) = s;
     e02:	mov	r4, r3
     e04:	add.w	lr, r0, #76	; 0x4c
     e08:	mov	r6, r2
    leg_stance_duration_in_ticks(0),
    leg_swing_duration_in_ticks(0),
    swing_height(0.0)
{
    if (gait == Gait::TROT) {
        gait_stance_duration = 0.02;
     e0a:	str.w	r8, [r0, #8]
     e0e:	str	r1, [r2, #48]	; 0x30
     e10:	str	r1, [r2, #20]
     e12:	str	r1, [r2, #24]
     e14:	str	r1, [r2, #60]	; 0x3c

  EIGEN_DEVICE_FUNC
  inline CommaInitializer(XprType& xpr, const Scalar& s)
    : m_xpr(xpr), m_row(0), m_col(1), m_currentBlockRows(1)
  {
    m_xpr.coeffRef(0,0) = s;
     e16:	str	r3, [r2, #0]
        && "Too many rows passed to comma initializer (operator<<)");
    }
    eigen_assert(m_col<m_xpr.cols()
      && "Too many coefficients passed to comma initializer (operator<<)");
    eigen_assert(m_currentBlockRows==1);
    m_xpr.coeffRef(m_row, m_col++) = s;
     e18:	str	r3, [r2, #16]
     e1a:	str	r3, [r2, #32]
     e1c:	str	r3, [r2, #4]
     e1e:	str	r3, [r2, #36]	; 0x24
     e20:	str	r3, [r2, #52]	; 0x34
     e22:	str	r3, [r2, #8]
     e24:	str	r3, [r2, #40]	; 0x28
     e26:	str	r3, [r2, #56]	; 0x38
     e28:	str	r3, [r2, #12]
     e2a:	str	r3, [r2, #28]
     e2c:	str	r3, [r2, #44]	; 0x2c
        gait_swing_duration = 0.5;
     e2e:	str.w	ip, [r5, #12]!
     e32:	mov	r1, r6
     e34:	mov	r2, r5
     e36:	movs	r3, #0
     e38:	b.n	e3e <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xa2>
     e3a:	ldr.w	r4, [r1, #4]!
struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>
{
  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)
  {
    for(Index outer = 0; outer < kernel.outerSize(); ++outer) {
      for(Index inner = 0; inner < kernel.innerSize(); ++inner) {
     e3e:	adds	r3, #1
     e40:	str.w	r4, [r2, #4]!
     e44:	cmp	r3, #4
     e46:	bne.n	e3a <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0x9e>
     e48:	adds	r5, #16
template<typename Kernel>
struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>
{
  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)
  {
    for(Index outer = 0; outer < kernel.outerSize(); ++outer) {
     e4a:	cmp	lr, r5
     e4c:	beq.n	e54 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xb8>
     e4e:	ldr.w	r4, [r6, #16]!
     e52:	b.n	e32 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0x96>
                1, 0, 1, 1,
                1, 1, 1, 0
        ).finished();
        gait_number_of_phases = 4;
        gait_stance_duration_in_ticks = int(gait_stance_duration/Config::dt);
        gait_swing_duration_in_ticks = int(gait_swing_duration/Config::dt);
     e54:	movs	r2, #50	; 0x32
                1, 0, 1, 1,
                1, 0, 1, 1,
                1, 1, 1, 0
        ).finished();
        gait_number_of_phases = 4;
        gait_stance_duration_in_ticks = int(gait_stance_duration/Config::dt);
     e56:	movs	r1, #2
        gait_swing_duration_in_ticks = int(gait_swing_duration/Config::dt);
        gait_cycle_duration_in_ticks = 2*gait_stance_duration_in_ticks + 2*gait_swing_duration_in_ticks;
     e58:	movs	r6, #104	; 0x68
            <<  gait_stance_duration_in_ticks,
                gait_swing_duration_in_ticks,
                gait_stance_duration_in_ticks,
                gait_swing_duration_in_ticks
        ).finished();
        leg_stance_duration_in_ticks = 2*gait_stance_duration_in_ticks + gait_swing_duration_in_ticks;
     e5a:	movs	r5, #54	; 0x36
        leg_swing_duration_in_ticks = gait_swing_duration_in_ticks;
        swing_height = 0.0;
     e5c:	movs	r4, #0
            <<  1, 1, 1, 0,
                1, 0, 1, 1,
                1, 0, 1, 1,
                1, 1, 1, 0
        ).finished();
        gait_number_of_phases = 4;
     e5e:	str	r3, [r0, #80]	; 0x50
        gait_stance_duration_in_ticks = int(gait_stance_duration/Config::dt);
     e60:	str	r1, [r0, #84]	; 0x54
     e62:	str	r1, [r0, #96]	; 0x60
     e64:	str	r1, [r0, #104]	; 0x68
        gait_swing_duration_in_ticks = int(gait_swing_duration/Config::dt);
     e66:	str	r2, [r0, #88]	; 0x58
     e68:	str	r2, [r0, #100]	; 0x64
     e6a:	str	r2, [r0, #108]	; 0x6c
                gait_swing_duration_in_ticks,
                gait_stance_duration_in_ticks,
                gait_swing_duration_in_ticks
        ).finished();
        leg_stance_duration_in_ticks = 2*gait_stance_duration_in_ticks + gait_swing_duration_in_ticks;
        leg_swing_duration_in_ticks = gait_swing_duration_in_ticks;
     e6c:	str	r2, [r0, #116]	; 0x74
                1, 1, 1, 0
        ).finished();
        gait_number_of_phases = 4;
        gait_stance_duration_in_ticks = int(gait_stance_duration/Config::dt);
        gait_swing_duration_in_ticks = int(gait_swing_duration/Config::dt);
        gait_cycle_duration_in_ticks = 2*gait_stance_duration_in_ticks + 2*gait_swing_duration_in_ticks;
     e6e:	str	r6, [r0, #92]	; 0x5c
            <<  gait_stance_duration_in_ticks,
                gait_swing_duration_in_ticks,
                gait_stance_duration_in_ticks,
                gait_swing_duration_in_ticks
        ).finished();
        leg_stance_duration_in_ticks = 2*gait_stance_duration_in_ticks + gait_swing_duration_in_ticks;
     e70:	str	r5, [r0, #112]	; 0x70
        leg_swing_duration_in_ticks = gait_swing_duration_in_ticks;
        swing_height = 0.0;
     e72:	str	r4, [r0, #120]	; 0x78
    }
}
     e74:	mov	sp, r7
     e76:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     e7a:	nop
     e7c:	.word	0x3ca3d70a

00000e80 <project_namespace::GaitConfig::getContactSchedule()>:

// GETTERS
Eigen::Matrix<int, 4, 4> GaitConfig::getContactSchedule() {
     e80:	push	{r4, r5, r6}
     e82:	add.w	r5, r1, #16
     e86:	mov	r6, r0
     e88:	mov	r4, r0
     e8a:	ldmia	r5!, {r0, r1, r2, r3}
     e8c:	stmia	r4!, {r0, r1, r2, r3}
     e8e:	ldmia	r5!, {r0, r1, r2, r3}
     e90:	stmia	r4!, {r0, r1, r2, r3}
     e92:	ldmia	r5!, {r0, r1, r2, r3}
     e94:	stmia	r4!, {r0, r1, r2, r3}
     e96:	ldmia.w	r5, {r0, r1, r2, r3}
     e9a:	stmia.w	r4, {r0, r1, r2, r3}
    return contact_schedule;
}
     e9e:	mov	r0, r6
     ea0:	pop	{r4, r5, r6}
     ea2:	bx	lr

00000ea4 <project_namespace::GaitConfig::getGaitNumberOfPhases()>:
int GaitConfig::getGaitNumberOfPhases() {
    return gait_number_of_phases;
}
     ea4:	ldr	r0, [r0, #80]	; 0x50
     ea6:	bx	lr

00000ea8 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>:
int GaitConfig::getGaitStanceDurationInTicks() {
    return gait_stance_duration_in_ticks;
}
     ea8:	ldr	r0, [r0, #84]	; 0x54
     eaa:	bx	lr

00000eac <project_namespace::GaitConfig::getGaitSwingDurationInTicks()>:
int GaitConfig::getGaitSwingDurationInTicks() {
    return gait_swing_duration_in_ticks;
}
     eac:	ldr	r0, [r0, #88]	; 0x58
     eae:	bx	lr

00000eb0 <project_namespace::GaitConfig::getGaitCycleDurationInTicks()>:
int GaitConfig::getGaitCycleDurationInTicks() {
    return gait_cycle_duration_in_ticks;
}
     eb0:	ldr	r0, [r0, #92]	; 0x5c
     eb2:	bx	lr

00000eb4 <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>:
     eb4:	adds	r1, #96	; 0x60
Eigen::Vector4i GaitConfig::getGaitPhaseDurationsInTicks() {
     eb6:	push	{r4}
     eb8:	mov	r4, r0
     eba:	ldmia	r1, {r0, r1, r2, r3}
     ebc:	stmia.w	r4, {r0, r1, r2, r3}
    return gait_phase_durations_in_ticks;
}
     ec0:	mov	r0, r4
     ec2:	ldr.w	r4, [sp], #4
     ec6:	bx	lr

00000ec8 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>:
int GaitConfig::getLegStanceDurationInTicks() {
    return leg_stance_duration_in_ticks;
}
     ec8:	ldr	r0, [r0, #112]	; 0x70
     eca:	bx	lr

00000ecc <project_namespace::GaitConfig::getLegSwingDurationInTicks()>:
int GaitConfig::getLegSwingDurationInTicks() {
    return leg_swing_duration_in_ticks;
}
     ecc:	ldr	r0, [r0, #116]	; 0x74
     ece:	bx	lr

00000ed0 <project_namespace::GaitConfig::getSwingHeight()>:
float GaitConfig::getSwingHeight() {
    return swing_height;
}
     ed0:	vldr	s0, [r0, #120]	; 0x78
     ed4:	bx	lr
     ed6:	nop

00000ed8 <project_namespace::GaitConfig::setSwingHeight(float)>:

// SETTERS
void GaitConfig::setSwingHeight(float swing_height_arg) {
    swing_height = swing_height_arg;
     ed8:	vstr	s0, [r0, #120]	; 0x78
     edc:	bx	lr
     ede:	nop

00000ee0 <project_namespace::IMU::IMU(BNO080&)>:
#include "IMU.h"

using namespace project_namespace;

IMU::IMU(BNO080& imu_hardware_init):
    imu_hardware(imu_hardware_init)
     ee0:	str	r1, [r0, #48]	; 0x30
{ }
     ee2:	bx	lr

00000ee4 <project_namespace::IMU::getGyro()>:
    }
    Eigen::Vector3f accel_vals(x, y, z);
    last_accel = accel_vals;
    return accel_vals;
}
Eigen::Vector3f IMU::getGyro() {
     ee4:	push	{r3, r4, r5, lr}
     ee6:	mov	r5, r0
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     ee8:	ldr	r0, [r1, #48]	; 0x30
    }
    Eigen::Vector3f accel_vals(x, y, z);
    last_accel = accel_vals;
    return accel_vals;
}
Eigen::Vector3f IMU::getGyro() {
     eea:	mov	r4, r1
     eec:	vpush	{d8}
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     ef0:	bl	2b0c <BNO080::dataAvailable()>
     ef4:	cbnz	r0, f22 <project_namespace::IMU::getGyro()+0x3e>
        x = imu_hardware.getGyroX();
        y = imu_hardware.getGyroY();
        z = imu_hardware.getGyroZ();
    } else {
        x = last_gyro(0);
     ef6:	vldr	s16, [r4, #12]
        y = last_gyro(1);
     efa:	vldr	s17, [r4, #16]
        z = last_gyro(2);
     efe:	vldr	s0, [r4, #20]
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
     f02:	vstr	s17, [r5, #4]
    }
    Eigen::Vector3f gyro_vals(x, y, z);
    last_gyro = gyro_vals;
    return gyro_vals;
}
     f06:	mov	r0, r5
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     f08:	vstr	s16, [r5]
      m_storage.data()[1] = y;
      m_storage.data()[2] = z;
     f0c:	vstr	s0, [r5, #8]
     f10:	vstr	s16, [r4, #12]
     f14:	ldr	r3, [r5, #4]
     f16:	vpop	{d8}
     f1a:	str	r3, [r4, #16]
     f1c:	ldr	r3, [r5, #8]
     f1e:	str	r3, [r4, #20]
     f20:	pop	{r3, r4, r5, pc}
Eigen::Vector3f IMU::getGyro() {
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        x = imu_hardware.getGyroX();
     f22:	ldr	r0, [r4, #48]	; 0x30
     f24:	bl	251c <BNO080::getGyroX()>
        y = imu_hardware.getGyroY();
     f28:	ldr	r0, [r4, #48]	; 0x30
Eigen::Vector3f IMU::getGyro() {
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        x = imu_hardware.getGyroX();
     f2a:	vmov.f32	s16, s0
        y = imu_hardware.getGyroY();
     f2e:	bl	2558 <BNO080::getGyroY()>
        z = imu_hardware.getGyroZ();
     f32:	ldr	r0, [r4, #48]	; 0x30
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        x = imu_hardware.getGyroX();
        y = imu_hardware.getGyroY();
     f34:	vmov.f32	s17, s0
        z = imu_hardware.getGyroZ();
     f38:	bl	2594 <BNO080::getGyroZ()>
     f3c:	b.n	f02 <project_namespace::IMU::getGyro()+0x1e>
     f3e:	nop

00000f40 <project_namespace::IMU::getHeadingQuaternion()>:
    }
    Eigen::Vector3f gyro_vals(x, y, z);
    last_gyro = gyro_vals;
    return gyro_vals;
}
Eigen::Quaternionf IMU::getHeadingQuaternion() {
     f40:	push	{r3, r4, r5, lr}
     f42:	mov	r5, r0
    float quat_x = 0.0;
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     f44:	ldr	r0, [r1, #48]	; 0x30
    }
    Eigen::Vector3f gyro_vals(x, y, z);
    last_gyro = gyro_vals;
    return gyro_vals;
}
Eigen::Quaternionf IMU::getHeadingQuaternion() {
     f46:	mov	r4, r1
     f48:	vpush	{d8-d9}
    float quat_x = 0.0;
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     f4c:	bl	2b0c <BNO080::dataAvailable()>
     f50:	cbnz	r0, f64 <project_namespace::IMU::getHeadingQuaternion()+0x24>
     f52:	adds	r4, #32
        last_quaternion = heading_quaternion;
        return heading_quaternion;
    } else {
        return last_quaternion;
    }
     f54:	vpop	{d8-d9}
     f58:	ldmia.w	r4, {r0, r1, r2, r3}
     f5c:	stmia.w	r5, {r0, r1, r2, r3}
     f60:	mov	r0, r5
     f62:	pop	{r3, r4, r5, pc}
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
     f64:	ldr	r0, [r4, #48]	; 0x30
     f66:	bl	24a4 <BNO080::getQuatReal()>
        quat_x = imu_hardware.getQuatI();
     f6a:	ldr	r0, [r4, #48]	; 0x30
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
     f6c:	vmov.f32	s16, s0
        quat_x = imu_hardware.getQuatI();
     f70:	bl	23f0 <BNO080::getQuatI()>
        quat_y = imu_hardware.getQuatJ();
     f74:	ldr	r0, [r4, #48]	; 0x30
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
        quat_x = imu_hardware.getQuatI();
     f76:	vmov.f32	s19, s0
        quat_y = imu_hardware.getQuatJ();
     f7a:	bl	242c <BNO080::getQuatJ()>
        quat_z = imu_hardware.getQuatK();
     f7e:	ldr	r0, [r4, #48]	; 0x30
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
        quat_x = imu_hardware.getQuatI();
        quat_y = imu_hardware.getQuatJ();
     f80:	vmov.f32	s18, s0
        quat_z = imu_hardware.getQuatK();
     f84:	bl	2468 <BNO080::getQuatK()>
     f88:	vmov.f32	s17, s0
        quat_accuracy = imu_hardware.getQuatRadianAccuracy();
     f8c:	ldr	r0, [r4, #48]	; 0x30
     f8e:	bl	24e0 <BNO080::getQuatRadianAccuracy()>
     f92:	vstr	s19, [r4, #32]
     f96:	vstr	s18, [r4, #36]	; 0x24
        last_quaternion = heading_quaternion;
        return heading_quaternion;
    } else {
        return last_quaternion;
    }
     f9a:	mov	r0, r5
     f9c:	vstr	s17, [r4, #40]	; 0x28
     fa0:	vstr	s16, [r4, #44]	; 0x2c
     fa4:	vstr	s19, [r5]
     fa8:	vstr	s18, [r5, #4]
     fac:	vstr	s17, [r5, #8]
     fb0:	vstr	s16, [r5, #12]
     fb4:	vpop	{d8-d9}
     fb8:	pop	{r3, r4, r5, pc}
     fba:	nop

00000fbc <project_namespace::Robot::Robot()>:
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     fbc:	movs	r3, #0
     fbe:	movs	r2, #0
     fc0:	ldr	r1, [pc, #588]	; (1210 <project_namespace::Robot::Robot()+0x254>)
using namespace project_namespace;

// TODO: Update dimensions according to CAD!!!

// CONSTRUCTORS
Robot::Robot():
     fc2:	push	{r4, r5, r6, lr}
     fc4:	mov	r4, r0
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     fc6:	ldr	r6, [pc, #588]	; (1214 <project_namespace::Robot::Robot()+0x258>)
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     fc8:	movs	r5, #1
     fca:	adds	r0, #240	; 0xf0
using namespace project_namespace;

// TODO: Update dimensions according to CAD!!!

// CONSTRUCTORS
Robot::Robot():
     fcc:	vpush	{d8-d12}
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     fd0:	vldr	s16, [pc, #580]	; 1218 <project_namespace::Robot::Robot()+0x25c>
using namespace project_namespace;

// TODO: Update dimensions according to CAD!!!

// CONSTRUCTORS
Robot::Robot():
     fd4:	sub	sp, #16
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     fd6:	vldr	s22, [pc, #580]	; 121c <project_namespace::Robot::Robot()+0x260>
     fda:	vldr	s24, [pc, #580]	; 1220 <project_namespace::Robot::Robot()+0x264>
     fde:	vmov.f32	s5, s16
     fe2:	vldr	s21, [pc, #576]	; 1224 <project_namespace::Robot::Robot()+0x268>
     fe6:	vmov.f32	s4, s16
     fea:	vldr	s23, [pc, #572]	; 1228 <project_namespace::Robot::Robot()+0x26c>
     fee:	vmov.f32	s3, s22
     ff2:	vldr	s20, [pc, #568]	; 122c <project_namespace::Robot::Robot()+0x270>
     ff6:	vmov.f32	s2, s24
     ffa:	vldr	s18, [pc, #564]	; 1230 <project_namespace::Robot::Robot()+0x274>
     ffe:	vmov.f32	s1, s21
    1002:	str	r1, [r4, #4]
    1004:	vmov.f32	s0, s23
    1008:	add	r1, sp, #4
    100a:	str	r3, [r4, #12]
    100c:	str	r3, [r4, #16]
    100e:	str	r3, [r4, #20]
    1010:	str	r3, [r4, #32]
    1012:	str	r3, [r4, #36]	; 0x24
    1014:	str	r3, [r4, #40]	; 0x28
    1016:	str	r3, [r4, #44]	; 0x2c
    1018:	str	r3, [r4, #48]	; 0x30
    101a:	str	r3, [r4, #52]	; 0x34
    101c:	str	r3, [r4, #56]	; 0x38
    101e:	str	r3, [r4, #60]	; 0x3c
    1020:	str	r3, [r4, #64]	; 0x40
    1022:	str	r3, [r4, #68]	; 0x44
    1024:	str	r3, [r4, #72]	; 0x48
    1026:	str	r3, [r4, #76]	; 0x4c
    1028:	str	r3, [r4, #80]	; 0x50
    102a:	str	r3, [r4, #84]	; 0x54
    102c:	str	r3, [r4, #88]	; 0x58
    102e:	str	r3, [r4, #92]	; 0x5c
    1030:	str	r3, [r4, #96]	; 0x60
    1032:	str	r3, [r4, #100]	; 0x64
    1034:	str	r3, [r4, #104]	; 0x68
    1036:	str	r3, [r4, #108]	; 0x6c
    1038:	str	r3, [r4, #112]	; 0x70
    103a:	str	r3, [r4, #116]	; 0x74
    103c:	str	r3, [r4, #120]	; 0x78
    103e:	str	r3, [r4, #124]	; 0x7c
    1040:	vldr	s19, [pc, #496]	; 1234 <project_namespace::Robot::Robot()+0x278>
    1044:	vldr	s17, [pc, #496]	; 1238 <project_namespace::Robot::Robot()+0x27c>
    1048:	str	r6, [r4, #0]
    104a:	str	r6, [r4, #8]
    104c:	str.w	r3, [r4, #128]	; 0x80
    1050:	str.w	r2, [r4, #224]	; 0xe0
    1054:	str.w	r2, [r4, #228]	; 0xe4
    1058:	str.w	r2, [r4, #232]	; 0xe8
    105c:	str.w	r2, [r4, #236]	; 0xec
    1060:	str.w	r3, [r4, #132]	; 0x84
    1064:	str.w	r3, [r4, #136]	; 0x88
    1068:	str.w	r3, [r4, #140]	; 0x8c
    106c:	str.w	r3, [r4, #144]	; 0x90
    1070:	str.w	r3, [r4, #148]	; 0x94
    1074:	str.w	r3, [r4, #152]	; 0x98
    1078:	str.w	r3, [r4, #156]	; 0x9c
    107c:	str.w	r3, [r4, #160]	; 0xa0
    1080:	str.w	r3, [r4, #164]	; 0xa4
    1084:	str.w	r3, [r4, #168]	; 0xa8
    1088:	str.w	r3, [r4, #172]	; 0xac
    108c:	str.w	r3, [r4, #176]	; 0xb0
    1090:	str.w	r3, [r4, #180]	; 0xb4
    1094:	str.w	r3, [r4, #184]	; 0xb8
    1098:	str.w	r3, [r4, #188]	; 0xbc
    109c:	str.w	r3, [r4, #192]	; 0xc0
    10a0:	str.w	r3, [r4, #196]	; 0xc4
    10a4:	str.w	r3, [r4, #200]	; 0xc8
    10a8:	str.w	r3, [r4, #204]	; 0xcc
    10ac:	str.w	r3, [r4, #208]	; 0xd0
    10b0:	str.w	r3, [r4, #212]	; 0xd4
    10b4:	str.w	r3, [r4, #216]	; 0xd8
    10b8:	str.w	r3, [r4, #220]	; 0xdc
    10bc:	str	r5, [sp, #4]
      m_storage.data()[1] = y;
    10be:	str	r5, [sp, #8]
      m_storage.data()[2] = z;
    10c0:	str	r5, [sp, #12]
    10c2:	bl	440 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
    10c6:	vmov.f32	s2, s24
    10ca:	add	r1, sp, #4
    10cc:	vmov.f32	s0, s23
    10d0:	add.w	r0, r4, #312	; 0x138
    10d4:	vmov.f32	s5, s16
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    10d8:	str	r5, [sp, #4]
    10da:	vmov.f32	s4, s16
      m_storage.data()[1] = y;
    10de:	str	r5, [sp, #8]
    10e0:	vmov.f32	s3, s20
      m_storage.data()[2] = z;
    10e4:	str	r5, [sp, #12]
    10e6:	vmov.f32	s1, s18
    10ea:	bl	440 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
    10ee:	vmov.f32	s3, s22
    10f2:	vmov.f32	s1, s21
    10f6:	add	r1, sp, #4
    10f8:	vmov.f32	s5, s16
    10fc:	add.w	r0, r4, #384	; 0x180
    1100:	vmov.f32	s4, s16
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    1104:	str	r5, [sp, #4]
    1106:	vmov.f32	s2, s19
      m_storage.data()[1] = y;
    110a:	str	r5, [sp, #8]
    110c:	vmov.f32	s0, s17
      m_storage.data()[2] = z;
    1110:	str	r5, [sp, #12]
    1112:	bl	440 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
    1116:	add	r1, sp, #4
    1118:	vmov.f32	s3, s20
    111c:	add.w	r0, r4, #456	; 0x1c8
    1120:	vmov.f32	s2, s19
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    1124:	str	r5, [sp, #4]
    1126:	vmov.f32	s1, s18
      m_storage.data()[1] = y;
    112a:	str	r5, [sp, #8]
    112c:	vmov.f32	s0, s17
      m_storage.data()[2] = z;
    1130:	str	r5, [sp, #12]
    1132:	vmov.f32	s5, s16
    1136:	vmov.f32	s4, s16
    113a:	bl	440 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    113e:	vldr	s9, [r4]
            stance_polygon_width/2.0,
    1142:	vldr	s14, [r4, #4]
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1146:	vmov.f64	d3, #96	; 0x3f000000  0.5
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    114a:	vcvt.f64.f32	d6, s9
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
    114e:	vldr	s15, [r4, #8]
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1152:	vcvt.f64.f32	d5, s14
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
}
    1156:	mov	r0, r4
    contact_pattern(Eigen::Vector4i::Zero())
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    1158:	vmov.f32	s8, #96	; 0x3f000000  0.5
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    115c:	vnmul.f64	d6, d6, d3
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1160:	vnmul.f64	d5, d5, d3
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
    1164:	vneg.f32	s15, s15
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    1168:	vcvt.f32.f64	s12, d6
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
    116c:	vmul.f32	s14, s14, s8
    contact_pattern(Eigen::Vector4i::Zero())
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    1170:	vmul.f32	s13, s9, s8
    1174:	vstr	s15, [r4, #40]	; 0x28
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1178:	vcvt.f32.f64	s10, d5
    117c:	vstr	s15, [r4, #52]	; 0x34
    1180:	vstr	s15, [r4, #64]	; 0x40
    1184:	vstr	s15, [r4, #76]	; 0x4c
    1188:	vstr	s15, [r4, #88]	; 0x58
    118c:	vstr	s15, [r4, #100]	; 0x64
    1190:	vstr	s15, [r4, #112]	; 0x70
    1194:	vstr	s12, [r4, #56]	; 0x38
    1198:	vstr	s12, [r4, #68]	; 0x44
    119c:	vstr	s12, [r4, #104]	; 0x68
    11a0:	vstr	s12, [r4, #116]	; 0x74
    11a4:	vstr	s10, [r4, #48]	; 0x30
    11a8:	vstr	s10, [r4, #72]	; 0x48
    11ac:	vstr	s10, [r4, #96]	; 0x60
    11b0:	vstr	s10, [r4, #120]	; 0x78
    11b4:	vstr	s10, [r4, #144]	; 0x90
    11b8:	vstr	s15, [r4, #124]	; 0x7c
    11bc:	vstr	s15, [r4, #136]	; 0x88
    11c0:	vstr	s13, [r4, #32]
    11c4:	vstr	s13, [r4, #44]	; 0x2c
    11c8:	vstr	s13, [r4, #80]	; 0x50
    11cc:	vstr	s13, [r4, #92]	; 0x5c
    11d0:	vstr	s13, [r4, #128]	; 0x80
    11d4:	vstr	s13, [r4, #140]	; 0x8c
    11d8:	vstr	s14, [r4, #36]	; 0x24
    11dc:	vstr	s14, [r4, #60]	; 0x3c
    11e0:	vstr	s14, [r4, #84]	; 0x54
    11e4:	vstr	s14, [r4, #108]	; 0x6c
    11e8:	vstr	s14, [r4, #132]	; 0x84
    11ec:	vstr	s15, [r4, #148]	; 0x94
    11f0:	vstr	s10, [r4, #168]	; 0xa8
    11f4:	vstr	s12, [r4, #152]	; 0x98
    11f8:	vstr	s12, [r4, #164]	; 0xa4
    11fc:	vstr	s14, [r4, #156]	; 0x9c
    1200:	vstr	s15, [r4, #160]	; 0xa0
    1204:	vstr	s15, [r4, #172]	; 0xac
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
}
    1208:	add	sp, #16
    120a:	vpop	{d8-d12}
    120e:	pop	{r4, r5, r6, pc}
    1210:	.word	0x3db851ec
    1214:	.word	0x3e4ccccd
    1218:	.word	0x3e23d70a
    121c:	.word	0x3d916873
    1220:	.word	0x3d1ba5e3
    1224:	.word	0x3d23d70a
    1228:	.word	0x3e1eb852
    122c:	.word	0xbd916873
    1230:	.word	0xbd23d70a
    1234:	.word	0xbd1ba5e3
    1238:	.word	0xbe1eb852

0000123c <project_namespace::Robot::getFootPositionsWrtBodyTrue()>:
    return body_pitch;
}
float Robot::getBodyYaw() {
    return body_yaw;
}
Eigen::Matrix<float, 3, 4> Robot::getFootPositionsWrtBodyTrue() {
    123c:	push	{r4, r5, r6}
    123e:	add.w	r5, r1, #32
    1242:	mov	r6, r0
    1244:	mov	r4, r0
    1246:	ldmia	r5!, {r0, r1, r2, r3}
    1248:	stmia	r4!, {r0, r1, r2, r3}
    124a:	ldmia	r5!, {r0, r1, r2, r3}
    124c:	stmia	r4!, {r0, r1, r2, r3}
    124e:	ldmia.w	r5, {r0, r1, r2, r3}
    1252:	stmia.w	r4, {r0, r1, r2, r3}
    return foot_positions_wrt_body_true;
}
    1256:	mov	r0, r6
    1258:	pop	{r4, r5, r6}
    125a:	bx	lr

0000125c <project_namespace::Robot::getFootPositionsWrtBodyAssumingNoBodyRPY()>:
Eigen::Matrix<float, 3, 4> Robot::getFootPositionsWrtBodyAssumingNoBodyRPY() {
    125c:	push	{r4, r5, r6}
    125e:	add.w	r5, r1, #80	; 0x50
    1262:	mov	r6, r0
    1264:	mov	r4, r0
    1266:	ldmia	r5!, {r0, r1, r2, r3}
    1268:	stmia	r4!, {r0, r1, r2, r3}
    126a:	ldmia	r5!, {r0, r1, r2, r3}
    126c:	stmia	r4!, {r0, r1, r2, r3}
    126e:	ldmia.w	r5, {r0, r1, r2, r3}
    1272:	stmia.w	r4, {r0, r1, r2, r3}
    return foot_positions_wrt_body_assuming_no_body_rpy;
}
    1276:	mov	r0, r6
    1278:	pop	{r4, r5, r6}
    127a:	bx	lr

0000127c <project_namespace::Robot::getFootPositionsWrtBodyAtRest()>:
Eigen::Matrix<float, 3, 4> Robot::getFootPositionsWrtBodyAtRest() {
    127c:	push	{r4, r5, r6}
    127e:	add.w	r5, r1, #128	; 0x80
    1282:	mov	r6, r0
    1284:	mov	r4, r0
    1286:	ldmia	r5!, {r0, r1, r2, r3}
    1288:	stmia	r4!, {r0, r1, r2, r3}
    128a:	ldmia	r5!, {r0, r1, r2, r3}
    128c:	stmia	r4!, {r0, r1, r2, r3}
    128e:	ldmia.w	r5, {r0, r1, r2, r3}
    1292:	stmia.w	r4, {r0, r1, r2, r3}
    return foot_positions_wrt_body_at_rest;
}
    1296:	mov	r0, r6
    1298:	pop	{r4, r5, r6}
    129a:	bx	lr

0000129c <project_namespace::Robot::setBodyRoll(float)>:
void Robot::setStanceHeight(float stance_height_arg) {
    stance_height = stance_height_arg;
    updateStancePolygon();
}
void Robot::setBodyRoll(float body_roll_arg) {
    body_roll = body_roll_arg;
    129c:	vstr	s0, [r0, #12]
    12a0:	bx	lr
    12a2:	nop

000012a4 <project_namespace::Robot::setBodyPitch(float)>:
}
void Robot::setBodyPitch(float body_pitch_arg) {
    body_pitch = body_pitch_arg;
    12a4:	vstr	s0, [r0, #16]
    12a8:	bx	lr
    12aa:	nop

000012ac <project_namespace::Robot::setBodyYaw(float)>:
}
void Robot::setBodyYaw(float body_yaw_arg) {
    body_yaw = body_yaw_arg;
    12ac:	vstr	s0, [r0, #20]
    12b0:	bx	lr
    12b2:	nop

000012b4 <project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>:
}
void Robot::setFootPositionsWrtBodyTrue(Eigen::Matrix<float, 3, 4> foot_positions_wrt_body_true_arg) {
    foot_positions_wrt_body_true = foot_positions_wrt_body_true_arg;
}
void Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4> foot_positions_wrt_body_assuming_no_body_rpy_arg) {
    12b4:	ldr	r3, [r1, #0]
    12b6:	str	r3, [r0, #80]	; 0x50
    12b8:	ldr	r3, [r1, #4]
    12ba:	str	r3, [r0, #84]	; 0x54
    12bc:	ldr	r3, [r1, #8]
    12be:	str	r3, [r0, #88]	; 0x58
    12c0:	ldr	r3, [r1, #12]
    12c2:	str	r3, [r0, #92]	; 0x5c
    12c4:	ldr	r3, [r1, #16]
    12c6:	str	r3, [r0, #96]	; 0x60
    12c8:	ldr	r3, [r1, #20]
    12ca:	str	r3, [r0, #100]	; 0x64
    12cc:	ldr	r3, [r1, #24]
    12ce:	str	r3, [r0, #104]	; 0x68
    12d0:	ldr	r3, [r1, #28]
    12d2:	str	r3, [r0, #108]	; 0x6c
    12d4:	ldr	r3, [r1, #32]
    12d6:	str	r3, [r0, #112]	; 0x70
    12d8:	ldr	r3, [r1, #36]	; 0x24
    12da:	str	r3, [r0, #116]	; 0x74
    12dc:	ldr	r3, [r1, #40]	; 0x28
    12de:	str	r3, [r0, #120]	; 0x78
    12e0:	ldr	r3, [r1, #44]	; 0x2c
    12e2:	str	r3, [r0, #124]	; 0x7c
    12e4:	bx	lr
    12e6:	nop

000012e8 <project_namespace::Robot::setContactPattern(Eigen::Matrix<int, 4, 1, 0, 4, 1>)>:
    foot_positions_wrt_body_at_rest = foot_positions_wrt_body_at_rest_arg;
}
void Robot::setJointAngles(Eigen::Matrix<float, 3, 4> joint_angles_arg) {
    joint_angles = joint_angles_arg;
}
void Robot::setContactPattern(Eigen::Vector4i contact_pattern_arg) {
    12e8:	ldr	r3, [r1, #0]
    12ea:	str.w	r3, [r0, #224]	; 0xe0
    12ee:	ldr	r3, [r1, #4]
    12f0:	str.w	r3, [r0, #228]	; 0xe4
    12f4:	ldr	r3, [r1, #8]
    12f6:	str.w	r3, [r0, #232]	; 0xe8
    12fa:	ldr	r3, [r1, #12]
    12fc:	str.w	r3, [r0, #236]	; 0xec
    1300:	bx	lr
    1302:	nop

00001304 <project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>:
    contact_pattern = contact_pattern_arg;
}

// METHODS
void Robot::moveAllFeet(Eigen::Matrix<float, 3, 4> foot_positions_wrt_body_cmd) {
    1304:	push	{r4, r5, r6, lr}
    1306:	mov	r4, r1
    1308:	sub	sp, #16
    130a:	ldr	r6, [r1, #0]
    130c:	mov	r5, r0
    130e:	ldr	r2, [r1, #4]
    ARUGMENTS:
    + foot_positions_wrt_body_cmd: The commanded foot positions.
    of the foot, [FL, FR, BL, BR].
    */

    front_left_leg.moveFoot(foot_positions_wrt_body_cmd.col(0));
    1310:	adds	r0, #240	; 0xf0
    1312:	ldr	r3, [r4, #8]
    1314:	add	r1, sp, #4
    1316:	str	r6, [sp, #4]
    1318:	str	r2, [sp, #8]
    131a:	str	r3, [sp, #12]
    131c:	bl	6d0 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    1320:	ldr	r6, [r4, #12]
    front_right_leg.moveFoot(foot_positions_wrt_body_cmd.col(1));
    1322:	add	r1, sp, #4
    1324:	ldr	r2, [r4, #16]
    1326:	add.w	r0, r5, #312	; 0x138
    132a:	ldr	r3, [r4, #20]
    132c:	str	r6, [sp, #4]
    132e:	str	r2, [sp, #8]
    1330:	str	r3, [sp, #12]
    1332:	bl	6d0 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    1336:	ldr	r6, [r4, #24]
    back_left_leg.moveFoot(foot_positions_wrt_body_cmd.col(2));
    1338:	add	r1, sp, #4
    133a:	ldr	r2, [r4, #28]
    133c:	add.w	r0, r5, #384	; 0x180
    1340:	ldr	r3, [r4, #32]
    1342:	str	r6, [sp, #4]
    1344:	str	r2, [sp, #8]
    1346:	str	r3, [sp, #12]
    1348:	bl	6d0 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    134c:	ldr	r3, [r4, #44]	; 0x2c
    back_right_leg.moveFoot(foot_positions_wrt_body_cmd.col(3));
    134e:	add	r1, sp, #4
    1350:	ldr	r6, [r4, #36]	; 0x24
    1352:	add.w	r0, r5, #456	; 0x1c8
    1356:	ldr	r2, [r4, #40]	; 0x28
    1358:	str	r3, [sp, #12]
    135a:	str	r6, [sp, #4]
    135c:	str	r2, [sp, #8]
    135e:	bl	6d0 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    1362:	ldr	r3, [r4, #0]
    1364:	str	r3, [r5, #32]
    1366:	ldr	r3, [r4, #4]
    1368:	str	r3, [r5, #36]	; 0x24
    136a:	ldr	r3, [r4, #8]
    136c:	str	r3, [r5, #40]	; 0x28
    136e:	ldr	r3, [r4, #12]
    1370:	str	r3, [r5, #44]	; 0x2c
    1372:	ldr	r3, [r4, #16]
    1374:	str	r3, [r5, #48]	; 0x30
    1376:	ldr	r3, [r4, #20]
    1378:	str	r3, [r5, #52]	; 0x34
    137a:	ldr	r3, [r4, #24]
    137c:	str	r3, [r5, #56]	; 0x38
    137e:	ldr	r3, [r4, #28]
    1380:	str	r3, [r5, #60]	; 0x3c
    1382:	ldr	r3, [r4, #32]
    1384:	str	r3, [r5, #64]	; 0x40
    1386:	ldr	r3, [r4, #36]	; 0x24
    1388:	str	r3, [r5, #68]	; 0x44
    138a:	ldr	r3, [r4, #40]	; 0x28
    138c:	str	r3, [r5, #72]	; 0x48
    138e:	ldr	r3, [r4, #44]	; 0x2c
    1390:	str	r3, [r5, #76]	; 0x4c
    foot_positions_wrt_body_true = foot_positions_wrt_body_cmd;
}
    1392:	add	sp, #16
    1394:	pop	{r4, r5, r6, pc}
    1396:	nop

00001398 <project_namespace::Robot::updateStancePolygon()>:
    stance polygon length or width, or stance height.
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    1398:	vldr	s9, [r0]
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    139c:	vmov.f64	d3, #96	; 0x3f000000  0.5
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
    13a0:	vldr	s14, [r0, #4]
    stance polygon length or width, or stance height.
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    13a4:	vmov.f32	s8, #96	; 0x3f000000  0.5
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    13a8:	vcvt.f64.f32	d5, s9
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
    13ac:	vldr	s15, [r0, #8]
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    13b0:	vcvt.f64.f32	d6, s14
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
    13b4:	vneg.f32	s15, s15
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    13b8:	vnmul.f64	d5, d5, d3
    13bc:	vstr	s15, [r0, #136]	; 0x88
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    13c0:	vnmul.f64	d6, d6, d3
    13c4:	vstr	s15, [r0, #148]	; 0x94
    13c8:	vstr	s15, [r0, #160]	; 0xa0
    13cc:	vstr	s15, [r0, #172]	; 0xac
    stance polygon length or width, or stance height.
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    13d0:	vmul.f32	s9, s9, s8
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    13d4:	vcvt.f32.f64	s10, d5
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
    13d8:	vmul.f32	s14, s14, s8
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    13dc:	vcvt.f32.f64	s12, d6
    13e0:	vstr	s9, [r0, #128]	; 0x80
    13e4:	vstr	s9, [r0, #140]	; 0x8c
    13e8:	vstr	s10, [r0, #152]	; 0x98
    13ec:	vstr	s10, [r0, #164]	; 0xa4
    13f0:	vstr	s14, [r0, #132]	; 0x84
    13f4:	vstr	s12, [r0, #144]	; 0x90
    13f8:	vstr	s12, [r0, #168]	; 0xa8
    13fc:	vstr	s14, [r0, #156]	; 0x9c
    1400:	bx	lr
    1402:	nop

00001404 <project_namespace::Robot::setStancePolygonLength(float)>:
    return contact_pattern;
}

// SETTERS
void Robot::setStancePolygonLength(float stance_polygon_length_arg) {
    stance_polygon_length = stance_polygon_length_arg;
    1404:	vstr	s0, [r0]
    updateStancePolygon();
    1408:	b.w	1398 <project_namespace::Robot::updateStancePolygon()>

0000140c <project_namespace::Robot::setStancePolygonWidth(float)>:
}
void Robot::setStancePolygonWidth(float stance_polygon_width_arg) {
    stance_polygon_width = stance_polygon_width_arg;
    140c:	vstr	s0, [r0, #4]
    updateStancePolygon();
    1410:	b.w	1398 <project_namespace::Robot::updateStancePolygon()>

00001414 <project_namespace::Robot::setStanceHeight(float)>:
}
void Robot::setStanceHeight(float stance_height_arg) {
    stance_height = stance_height_arg;
    1414:	vstr	s0, [r0, #8]
    updateStancePolygon();
    1418:	b.w	1398 <project_namespace::Robot::updateStancePolygon()>

0000141c <project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)>:

// CONSTRUCTORS

LegSwingController::LegSwingController(GaitConfig& gait_config_init, IMU& imu_init):
    gait_config(gait_config_init),
    imu(imu_init)
    141c:	stmia.w	r0, {r1, r2}
{ }
    1420:	bx	lr
    1422:	nop

00001424 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)>:

// METHODS

Eigen::Vector3f LegSwingController::calculateRaibertTouchdownLocation(Robot& robot, Command& command, int leg_index) {
    1424:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1428:	vpush	{d8-d14}
    142c:	sub	sp, #40	; 0x28
    142e:	mov	r5, r0
    1430:	mov	r8, r3
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    1432:	movs	r0, #0
    1434:	add	r7, sp, #0
    1436:	sub	sp, #64	; 0x40
    1438:	str	r0, [r5, #0]
      m_storage.data()[1] = y;
    143a:	str	r0, [r5, #4]
    143c:	mov	r9, r1
    143e:	add.w	r3, sp, #15
      m_storage.data()[2] = z;
    1442:	str	r0, [r5, #8]
    float alpha = 0.0; // For gait translation.
    float beta = 0.0; // For gait yaw.

    // If gait translation involves both antero-posterior and lateral movement,
    // alpha will be a vector sum of respective alphas in both directions, clipped within 0 and 1.
    if (command.getBodyVelocity()(0) > 0) { // If moving forwards
    1444:	mov	r1, r8
    1446:	adds	r0, r7, #4
    imu(imu_init)
{ }

// METHODS

Eigen::Vector3f LegSwingController::calculateRaibertTouchdownLocation(Robot& robot, Command& command, int leg_index) {
    1448:	mov	sl, r2
    144a:	bic.w	r4, r3, #15
    144e:	ldr.w	r6, [r7, #128]	; 0x80
    float alpha = 0.0; // For gait translation.
    float beta = 0.0; // For gait yaw.

    // If gait translation involves both antero-posterior and lateral movement,
    // alpha will be a vector sum of respective alphas in both directions, clipped within 0 and 1.
    if (command.getBodyVelocity()(0) > 0) { // If moving forwards
    1452:	bl	1a70 <project_namespace::Command::getBodyVelocity()>
    1456:	vldr	s15, [r7, #4]
    145a:	vcmpe.f32	s15, #0.0
    145e:	vmrs	APSR_nzcv, fpscr
    1462:	ble.n	1552 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x12e>
        alpha = constrain(sqrt(pow(Parameters::lateral_alpha, 2.0) + pow(Parameters::forwards_alpha, 2.0)), 0.0, 1.0);
    1464:	vldr	s19, [pc, #264]	; 1570 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x14c>
    }
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
    1468:	ldr.w	r0, [r9]
    146c:	add.w	r6, r6, r6, lsl #1
    1470:	bl	ec8 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
        *Config::dt
    1474:	vmov	s15, r0
        *command.getBodyVelocity()
    1478:	mov	r1, r8
    147a:	adds	r0, r7, #4
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
    147c:	vcvt.f32.s32	s15, s15
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
        *command.getGaitYawSpeed()
    ;
    Eigen::Matrix<float, 3, 3> projected_total_gait_yaw_rotation_matrix;
    projected_total_gait_yaw_rotation_matrix = MyMath::eulerToMatrix(0, 0, projected_total_gait_yaw_during_stance_phase);
    1480:	vldr	s20, [pc, #240]	; 1574 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x150>
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
    1484:	vldr	s17, [pc, #240]	; 1578 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x154>
    1488:	vmul.f32	s19, s15, s19
        *command.getBodyVelocity()
    148c:	bl	1a70 <project_namespace::Command::getBodyVelocity()>
    ;
    touchdown_displacement_from_neutral_location(2) = 0; // z-coordinate not important for touchdown location
    // Calculate touchdown location displacement due to gait yaw
    float projected_total_gait_yaw_during_stance_phase =
        beta
        *gait_config.getLegStanceDurationInTicks()
    1490:	ldr.w	r0, [r9]
    1494:	vldr	s22, [r7, #4]
    1498:	vldr	s21, [r7, #8]
    149c:	bl	ec8 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
    14a0:	vmov	s16, r0
        *Config::dt
        *command.getGaitYawSpeed()
    14a4:	mov	r0, r8
    14a6:	bl	1a80 <project_namespace::Command::getGaitYawSpeed()>
    ;
    Eigen::Matrix<float, 3, 3> projected_total_gait_yaw_rotation_matrix;
    projected_total_gait_yaw_rotation_matrix = MyMath::eulerToMatrix(0, 0, projected_total_gait_yaw_during_stance_phase);
    14aa:	vmov.f32	s1, s20
    14ae:	vcvt.f32.s32	s16, s16
    14b2:	adds	r0, r7, #4
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
    14b4:	vmul.f32	s19, s19, s17
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
        *command.getGaitYawSpeed()
    ;
    Eigen::Matrix<float, 3, 3> projected_total_gait_yaw_rotation_matrix;
    projected_total_gait_yaw_rotation_matrix = MyMath::eulerToMatrix(0, 0, projected_total_gait_yaw_during_stance_phase);
    14b8:	vmul.f32	s16, s16, s20
    14bc:	vmul.f32	s2, s16, s17
    14c0:	vmul.f32	s2, s2, s0
    14c4:	vmov.f32	s0, s20
    14c8:	bl	7b0 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
    
    // Linear combination of effects of both linear and yaw movement
    touchdown_location =
        projected_total_gait_yaw_rotation_matrix*robot.getFootPositionsWrtBodyAtRest().col(leg_index)
    14cc:	mov	r0, r4
    14ce:	mov	r1, sl
    14d0:	vldr	s25, [r7, #4]
    14d4:	vldr	s24, [r7, #8]
    14d8:	vldr	s23, [r7, #12]
    14dc:	vldr	s28, [r7, #16]
    14e0:	vldr	s27, [r7, #20]
    14e4:	vldr	s26, [r7, #24]
    14e8:	vldr	s17, [r7, #28]
    14ec:	vldr	s16, [r7, #32]
    14f0:	vldr	s18, [r7, #36]	; 0x24
    14f4:	bl	127c <project_namespace::Robot::getFootPositionsWrtBodyAtRest()>
    14f8:	add.w	r3, r4, r6, lsl #2
        + touchdown_displacement_from_neutral_location
    ;

    return touchdown_location;
}
    14fc:	mov	r0, r5
    14fe:	adds	r7, #40	; 0x28
  }

  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  CoeffReturnType coeff(Index row, Index col) const
  {
    return m_data[col * colStride() + row * rowStride()];
    1500:	vldr	s1, [r3, #8]
    1504:	vldr	s12, [r3, #4]
    1508:	vmul.f32	s14, s17, s1
    150c:	vldr	s13, [r3]
    1510:	vmul.f32	s15, s16, s1
    1514:	vmul.f32	s1, s18, s1
    1518:	vfma.f32	s14, s28, s12
    151c:	vfma.f32	s15, s27, s12
    1520:	vfma.f32	s1, s26, s12
    1524:	vfma.f32	s14, s25, s13
    1528:	vfma.f32	s15, s24, s13
    152c:	vfma.f32	s1, s23, s13
    1530:	vfma.f32	s14, s19, s22
    1534:	vfma.f32	s15, s19, s21
    1538:	vadd.f32	s1, s1, s20
    153c:	vstr	s1, [r5, #8]
    1540:	vstr	s14, [r5]
    1544:	vstr	s15, [r5, #4]
    1548:	mov	sp, r7
    154a:	vpop	{d8-d14}
    154e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    // If gait translation involves both antero-posterior and lateral movement,
    // alpha will be a vector sum of respective alphas in both directions, clipped within 0 and 1.
    if (command.getBodyVelocity()(0) > 0) { // If moving forwards
        alpha = constrain(sqrt(pow(Parameters::lateral_alpha, 2.0) + pow(Parameters::forwards_alpha, 2.0)), 0.0, 1.0);
    } else if (command.getBodyVelocity()(0) < 0) {
    1552:	mov	r1, r8
    1554:	adds	r0, r7, #4
    1556:	bl	1a70 <project_namespace::Command::getBodyVelocity()>
    155a:	vldr	s15, [r7, #4]
    155e:	vcmpe.f32	s15, #0.0
    1562:	vmrs	APSR_nzcv, fpscr
    1566:	bpl.w	1464 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x40>
        alpha = constrain(sqrt(pow(Parameters::lateral_alpha, 2.0) + pow(Parameters::backwards_alpha, 2.0)), 0.0, 1.0);
    156a:	vmov.f32	s19, #112	; 0x3f800000  1.0
    156e:	b.n	1468 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x44>
    1570:	.word	0x3eb851ec
    1574:	.word	0x00000000
    1578:	.word	0x3c23d70a

0000157c <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)>:
    ;

    return touchdown_location;
}

Eigen::Vector3f LegSwingController::calculateRollPitchCapturePoint(Command& command) {
    157c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1580:	vpush	{d8-d11}
    1584:	add	r7, sp, #0
    1586:	sub	sp, #48	; 0x30
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    1588:	movs	r3, #0
    */

    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f rpy_angles;
    rpy_angles = imu.getHeadingQuaternion().normalized().toRotationMatrix().eulerAngles(0, 1, 2);
    158a:	ldr	r1, [r1, #4]
    ;

    return touchdown_location;
}

Eigen::Vector3f LegSwingController::calculateRollPitchCapturePoint(Command& command) {
    158c:	add.w	r4, sp, #15
    1590:	mov	r5, r0
    1592:	str	r3, [r0, #0]
    1594:	mov	r8, r2
    1596:	bic.w	r4, r4, #15
      m_storage.data()[1] = y;
    159a:	str	r3, [r0, #4]
      m_storage.data()[2] = z;
    159c:	str	r3, [r0, #8]
    */

    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f rpy_angles;
    rpy_angles = imu.getHeadingQuaternion().normalized().toRotationMatrix().eulerAngles(0, 1, 2);
    159e:	add.w	r6, r4, #16
    15a2:	mov	r0, r6
    15a4:	bl	f40 <project_namespace::IMU::getHeadingQuaternion()>
    15a8:	vldr	s10, [r4, #20]
    15ac:	vldr	s11, [r4, #28]
#else
  scalar_sum_op() {
    EIGEN_SCALAR_BINARY_OP_PLUGIN
  }
#endif
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a + b; }
    15b0:	vmul.f32	s14, s10, s10
    15b4:	vldr	s13, [r4, #16]
    15b8:	vmul.f32	s15, s11, s11
    15bc:	vldr	s12, [r4, #24]
    15c0:	vfma.f32	s14, s13, s13
    15c4:	vfma.f32	s15, s12, s12
    15c8:	vadd.f32	s15, s14, s15
{
  typedef typename internal::nested_eval<Derived,2>::type _Nested;
  _Nested n(derived());
  RealScalar z = n.squaredNorm();
  // NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent x86 CPU
  if(z>RealScalar(0))
    15cc:	vcmpe.f32	s15, #0.0
    15d0:	vmrs	APSR_nzcv, fpscr
    15d4:	bgt.w	1710 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x194>
    15d8:	ldmia.w	r6, {r0, r1, r2, r3}
    15dc:	stmia.w	r4, {r0, r1, r2, r3}
    15e0:	vldr	s15, [r4]
    15e4:	vldr	s13, [r4, #4]
    15e8:	vldr	s18, [r4, #8]
    15ec:	vldr	s12, [r4, #12]
  // however, not inlining this function is an order of magnitude slower, so
  // it has to be inlined, and so the return by value is not an issue
  Matrix3 res;

  const Scalar tx  = Scalar(2)*this->x();
  const Scalar ty  = Scalar(2)*this->y();
    15f0:	vadd.f32	s10, s13, s13
  const Scalar tz  = Scalar(2)*this->z();
    15f4:	vadd.f32	s11, s18, s18
  // if not inlined then the cost of the return by value is huge ~ +35%,
  // however, not inlining this function is an order of magnitude slower, so
  // it has to be inlined, and so the return by value is not an issue
  Matrix3 res;

  const Scalar tx  = Scalar(2)*this->x();
    15f8:	vadd.f32	s9, s15, s15
  const Scalar twy = ty*this->w();
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
  const Scalar txz = tz*this->x();
  const Scalar tyy = ty*this->y();
    15fc:	vmul.f32	s14, s13, s10
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();
    1600:	vmul.f32	s18, s11, s18
  const Scalar tz  = Scalar(2)*this->z();
  const Scalar twx = tx*this->w();
  const Scalar twy = ty*this->w();
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
    1604:	vmul.f32	s7, s15, s10
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    1608:	vmov.f32	s1, s14

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
    160c:	vmov.f32	s21, s18
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
  const Scalar txz = tz*this->x();
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
    1610:	vmul.f32	s13, s13, s11
    1614:	vfma.f32	s1, s15, s9

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
    1618:	vfma.f32	s21, s15, s9
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
    161c:	vmov.f32	s20, s7
  const Scalar twx = tx*this->w();
  const Scalar twy = ty*this->w();
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
  const Scalar txz = tz*this->x();
    1620:	vmul.f32	s15, s15, s11
    1624:	vmov.f32	s0, s13
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
    1628:	vfms.f32	s20, s11, s12
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
  res.coeffRef(2,1) = tyz+twx;
    162c:	vfma.f32	s13, s9, s12
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
    1630:	vfma.f32	s7, s11, s12
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
    1634:	vmov.f32	s23, s15
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
    1638:	vfms.f32	s15, s10, s12
  const Scalar txz = tz*this->x();
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
    163c:	vmov.f32	s8, #112	; 0x3f800000  1.0
    1640:	vadd.f32	s18, s14, s18
    1644:	vfms.f32	s0, s9, s12
    1648:	vsub.f32	s1, s8, s1
    164c:	vsub.f32	s18, s8, s18
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
    1650:	vsub.f32	s21, s8, s21
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
  res.coeffRef(2,1) = tyz+twx;
    1654:	vmov.f32	s19, s13
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
    1658:	vmov.f32	s22, s7
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
    165c:	vfma.f32	s23, s10, s12
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
    1660:	vmov.f32	s17, s15
    1664:	bl	5600 <atan2f>
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    1668:	vmul.f32	s20, s20, s20
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    166c:	vmov.f32	s16, s0
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    1670:	vmov.f32	s0, s20
    1674:	vfma.f32	s0, s18, s18
    1678:	vsqrt.f32	s1, s0
    167c:	vcmp.f32	s1, s1
    1680:	vmrs	APSR_nzcv, fpscr
    1684:	bne.n	173e <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1c2>
  } 
  else
  {
    res[0] = atan2(coeff(j,k), coeff(k,k));
    Scalar c2 = Vector2(coeff(i,i), coeff(i,j)).norm();
    if((odd && res[0]<Scalar(0)) || ((!odd) && res[0]>Scalar(0))) {
    1686:	vcmpe.f32	s16, #0.0
    168a:	vmrs	APSR_nzcv, fpscr
    168e:	ble.n	1730 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1b4>
      if(res[0] > Scalar(0)) {
        res[0] -= Scalar(EIGEN_PI);
    1690:	vldr	s15, [pc, #208]	; 1764 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1e8>
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    1694:	vneg.f32	s1, s1
    1698:	vneg.f32	s0, s23
    169c:	vsub.f32	s16, s16, s15
    16a0:	bl	5600 <atan2f>
    16a4:	vmov.f32	s18, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
    16a8:	vmov.f32	s0, s16
    16ac:	bl	50e8 <sinf>
    16b0:	vmov.f32	s20, s0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
    16b4:	vmov.f32	s0, s16
    16b8:	bl	5058 <cosf>
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    16bc:	vnmul.f32	s7, s22, s0
    16c0:	vnmul.f32	s1, s19, s20
    16c4:	vfma.f32	s7, s20, s17
    16c8:	vfma.f32	s1, s0, s21
    16cc:	vmov.f32	s0, s7
    16d0:	bl	5600 <atan2f>
    float roll_error =  command.getBodyRoll() - rpy_angles(0);
    16d4:	mov	r0, r8
    16d6:	bl	1a58 <project_namespace::Command::getBodyRoll()>
    float pitch_error =  command.getBodyPitch() - rpy_angles(1);
    16da:	mov	r0, r8

    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f rpy_angles;
    rpy_angles = imu.getHeadingQuaternion().normalized().toRotationMatrix().eulerAngles(0, 1, 2);
    float roll_error =  command.getBodyRoll() - rpy_angles(0);
    16dc:	vadd.f32	s16, s0, s16
    float pitch_error =  command.getBodyPitch() - rpy_angles(1);
    16e0:	bl	1a60 <project_namespace::Command::getBodyPitch()>
    16e4:	vadd.f32	s0, s0, s18
    16e8:	vldr	s15, [pc, #124]	; 1768 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1ec>
    16ec:	vldr	s18, [pc, #124]	; 176c <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1f0>
            Parameters::roll_gain*roll_error,
            0.0
    ).finished();

    return rp_capture_point;
}
    16f0:	mov	r0, r5
    16f2:	vmul.f32	s16, s16, s15
    16f6:	vstr	s15, [r5, #8]
    16fa:	vmul.f32	s0, s0, s18
    16fe:	vstr	s16, [r5, #4]
    1702:	vstr	s0, [r5]
    1706:	mov	sp, r7
    1708:	vpop	{d8-d11}
    170c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    1710:	vsqrt.f32	s0, s15
    1714:	vcmp.f32	s0, s0
    1718:	vmrs	APSR_nzcv, fpscr
    171c:	bne.n	1748 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1cc>
#else
  scalar_quotient_op() {
    EIGEN_SCALAR_BINARY_OP_PLUGIN
  }
#endif
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a / b; }
    171e:	vdiv.f32	s15, s13, s0
    1722:	vdiv.f32	s18, s12, s0
    1726:	vdiv.f32	s13, s10, s0
    172a:	vdiv.f32	s12, s11, s0
    172e:	b.n	15f0 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x74>
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    1730:	vneg.f32	s0, s23
    1734:	bl	5600 <atan2f>
    1738:	vmov.f32	s18, s0
    173c:	b.n	16a8 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x12c>
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    173e:	bl	5608 <sqrtf>
    1742:	vmov.f32	s1, s0
    1746:	b.n	1686 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x10a>
    1748:	vmov.f32	s0, s15
    174c:	bl	5608 <sqrtf>
    1750:	vldr	s13, [r4, #16]
    1754:	vldr	s10, [r4, #20]
    1758:	vldr	s12, [r4, #24]
    175c:	vldr	s11, [r4, #28]
    1760:	b.n	171e <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1a2>
    1762:	nop
    1764:	.word	0x40490fdb
    1768:	.word	0x00000000
    176c:	.word	0x80000000

00001770 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>:

Eigen::Vector3f LegSwingController::calculateRollPitchRateCapturePoint() {
    1770:	push	{r4, lr}
    1772:	mov	r4, r0
    + rp_rate_capture_point: The offsets from the touchdown location dependent on
    the roll and pitch angle rates of the robot body.
    */
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0); // Initialise
    Eigen::Vector3f gyro_vals(0.0, 0.0, 0.0);
    gyro_vals = imu.getGyro();
    1774:	ldr	r1, [r1, #4]
    ).finished();

    return rp_capture_point;
}

Eigen::Vector3f LegSwingController::calculateRollPitchRateCapturePoint() {
    1776:	vpush	{d8}
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    177a:	vldr	s16, [pc, #64]	; 17bc <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()+0x4c>
    177e:	sub	sp, #16
    1780:	vstr	s16, [r4]
    + rp_rate_capture_point: The offsets from the touchdown location dependent on
    the roll and pitch angle rates of the robot body.
    */
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0); // Initialise
    Eigen::Vector3f gyro_vals(0.0, 0.0, 0.0);
    gyro_vals = imu.getGyro();
    1784:	add	r0, sp, #4
      m_storage.data()[1] = y;
    1786:	vstr	s16, [r4, #4]
      m_storage.data()[2] = z;
    178a:	vstr	s16, [r4, #8]
    178e:	bl	ee4 <project_namespace::IMU::getGyro()>
    1792:	vldr	s14, [sp, #8]
    1796:	vldr	s15, [sp, #4]
            -1.0*Parameters::roll_rate_gain*roll_rate,
            0.0
    ).finished();

    return rp_rate_capture_point;
}
    179a:	mov	r0, r4
    179c:	vldr	s13, [pc, #32]	; 17c0 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()+0x50>
    17a0:	vmul.f32	s14, s14, s16
    17a4:	vstr	s16, [r4, #8]
    17a8:	vmul.f32	s15, s15, s13
    17ac:	vstr	s14, [r4]
    17b0:	vstr	s15, [r4, #4]
    17b4:	add	sp, #16
    17b6:	vpop	{d8}
    17ba:	pop	{r4, pc}
    17bc:	.word	0x00000000
    17c0:	.word	0x80000000
    17c4:	.word	0x00000000

000017c8 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)>:
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    17c8:	vcmpe.f32	s0, #0.0
    Robot& robot,
    Command& command,
    int leg_index,
    float swing_proportion_completed,
    FootTrajectory trajectory_shape
) {
    17cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    17d0:	vpush	{d8-d13}
    17d4:	sub	sp, #28
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    17d6:	vmrs	APSR_nzcv, fpscr
    Robot& robot,
    Command& command,
    int leg_index,
    float swing_proportion_completed,
    FootTrajectory trajectory_shape
) {
    17da:	mov	r4, r0
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    17dc:	mov.w	r0, #0
    17e0:	add	r7, sp, #8
    17e2:	str	r0, [r4, #0]
    17e4:	sub	sp, #64	; 0x40
      m_storage.data()[1] = y;
    17e6:	str	r0, [r4, #4]
      m_storage.data()[2] = z;
    17e8:	str	r0, [r4, #8]
    17ea:	ldr.w	r8, [r7, #104]	; 0x68
    17ee:	ldr.w	sl, [r7, #108]	; 0x6c
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    17f2:	blt.w	19e4 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x21c>
    17f6:	vmov.f32	s15, #112	; 0x3f800000  1.0
    17fa:	vmov.f32	s16, s0
    17fe:	vcmpe.f32	s0, s15
    1802:	vmrs	APSR_nzcv, fpscr
    1806:	bhi.w	19e4 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x21c>
    180a:	add.w	r5, sp, #23
    180e:	mov	r6, r1
    Eigen::Vector3f current_foot_location_assuming_no_body_rpy(0.0, 0.0, 0.0);
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
    1810:	mov	r1, r2
    1812:	mov	r9, r3
    1814:	bic.w	r5, r5, #15
    1818:	mov	fp, r2
    181a:	mov	r0, r5
    181c:	bl	125c <project_namespace::Robot::getFootPositionsWrtBodyAssumingNoBodyRPY()>
    Eigen::Vector3f raibert_touchdown_location(0.0, 0.0, 0.0);
    raibert_touchdown_location = calculateRaibertTouchdownLocation(robot, command, leg_index);
    1820:	mov	r2, fp
    1822:	add.w	r1, r8, r8, lsl #1
    1826:	adds	r0, r7, #4
    1828:	mov	r3, r9
    182a:	add.w	r5, r5, r1, lsl #2
    182e:	mov	r1, r6
    1830:	vldr	s19, [r5]
    1834:	vldr	s20, [r5, #4]
    1838:	vldr	s21, [r5, #8]
    183c:	str.w	r8, [sp]
    1840:	bl	1424 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)>
    Eigen::Vector3f touchdown_location(0.0, 0.0, 0.0);
    touchdown_location = raibert_touchdown_location;

    // Applying rp_capture_point
    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0);
    rp_capture_point = calculateRollPitchCapturePoint(command);
    1844:	adds	r0, r7, #4
    1846:	mov	r2, r9
    1848:	mov	r1, r6
    184a:	vldr	s18, [r7, #4]
    184e:	vldr	s17, [r7, #8]
    1852:	bl	157c <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)>
    1856:	vldr	s15, [r7, #8]
    185a:	vldr	s13, [r7, #4]
    touchdown_location(0) = touchdown_location(0) + rp_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
    185e:	vcmpe.f32	s15, #0.0
    touchdown_location = raibert_touchdown_location;

    // Applying rp_capture_point
    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0);
    rp_capture_point = calculateRollPitchCapturePoint(command);
    touchdown_location(0) = touchdown_location(0) + rp_capture_point(0); // Apply x-offset to all legs
    1862:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
    1866:	vmrs	APSR_nzcv, fpscr
    186a:	ble.n	193e <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x176>
    186c:	bics.w	r3, r8, #2
    1870:	bne.n	193e <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x176>
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    1872:	adds	r0, r7, #4
    1874:	mov	r1, r6
    touchdown_location(0) = touchdown_location(0) + rp_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    1876:	vadd.f32	s17, s17, s15
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    187a:	bl	1770 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>
    187e:	vldr	s15, [r7, #8]
    1882:	vldr	s13, [r7, #4]
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    1886:	vcmpe.f32	s15, #0.0
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    188a:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    188e:	vmrs	APSR_nzcv, fpscr
    1892:	ble.n	1898 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    1894:	vadd.f32	s17, s17, s15
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    1898:	ldr	r0, [r6, #0]
    189a:	bl	ecc <project_namespace::GaitConfig::getLegSwingDurationInTicks()>
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    189e:	vmov	s15, r0
    18a2:	vldr	s12, [pc, #340]	; 19f8 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x230>
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    18a6:	vcvt.f64.f32	d11, s16
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    18aa:	vcvt.f32.s32	s14, s15
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
    18ae:	cmp.w	sl, #1
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    18b2:	vmov.f64	d0, #112	; 0x3f800000  1.0
    18b6:	vsub.f32	s13, s18, s19
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    18ba:	vmul.f32	s14, s14, s12
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    18be:	vsub.f64	d12, d0, d11
    18c2:	vsub.f32	s17, s17, s20
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    18c6:	vcvt.f64.f32	d7, s14
    18ca:	vmul.f64	d7, d7, d12
    18ce:	vcvt.f32.f64	s14, d7
    18d2:	vdiv.f32	s15, s14, s12
    18d6:	vdiv.f32	s26, s13, s15
    18da:	vdiv.f32	s18, s17, s15
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
    18de:	beq.n	19c0 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1f8>
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    } else if (trajectory_shape == FootTrajectory::TRIANGULAR) {
    18e0:	cmp.w	sl, #0
    18e4:	bne.n	1982 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1ba>
        if (swing_proportion_completed <= 0.5) {
            z_from_ground = gait_config.getSwingHeight()*swing_proportion_completed;
    18e6:	ldr	r0, [r6, #0]
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    } else if (trajectory_shape == FootTrajectory::TRIANGULAR) {
        if (swing_proportion_completed <= 0.5) {
    18e8:	vmov.f32	s15, #96	; 0x3f000000  0.5
    18ec:	vcmpe.f32	s16, s15
    18f0:	vmrs	APSR_nzcv, fpscr
    18f4:	bls.n	1988 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1c0>
            z_from_ground = gait_config.getSwingHeight()*swing_proportion_completed;
        } else {
            z_from_ground = gait_config.getSwingHeight()*(1.0 - swing_proportion_completed);
    18f6:	bl	ed0 <project_namespace::GaitConfig::getSwingHeight()>
    18fa:	vcvt.f64.f32	d0, s0
    18fe:	vmul.f64	d0, d0, d12
    1902:	vcvt.f32.f64	s16, d0
    1906:	vldr	s15, [pc, #244]	; 19fc <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x234>
    190a:	vadd.f32	s19, s19, s26
    190e:	vadd.f32	s20, s20, s18
        }
    }
    new_foot_position = current_foot_location_assuming_no_body_rpy + foot_delta_p;
    new_foot_position(2) = -command.getStanceHeight() + z_from_ground;
    1912:	mov	r0, r9
    1914:	vadd.f32	s21, s21, s15
    1918:	vstr	s19, [r4]
    191c:	vstr	s20, [r4, #4]
    1920:	vstr	s21, [r4, #8]
    1924:	bl	1a50 <project_namespace::Command::getStanceHeight()>
    1928:	vsub.f32	s0, s16, s0

    return new_foot_position;
    192c:	mov	r0, r4
    192e:	adds	r7, #20
        } else {
            z_from_ground = gait_config.getSwingHeight()*(1.0 - swing_proportion_completed);
        }
    }
    new_foot_position = current_foot_location_assuming_no_body_rpy + foot_delta_p;
    new_foot_position(2) = -command.getStanceHeight() + z_from_ground;
    1930:	vstr	s0, [r4, #8]

    return new_foot_position;
    1934:	mov	sp, r7
    1936:	vpop	{d8-d13}
    193a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    } else if ((rp_capture_point(1) < 0) and (leg_index == 1 or leg_index == 3)) {
    193e:	vcmpe.f32	s15, #0.0
    1942:	vmrs	APSR_nzcv, fpscr
    1946:	bmi.n	1992 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1ca>
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    1948:	adds	r0, r7, #4
    194a:	mov	r1, r6
    194c:	bl	1770 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>
    1950:	vldr	s15, [r7, #8]
    1954:	vldr	s13, [r7, #4]
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    1958:	vcmpe.f32	s15, #0.0
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    195c:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    1960:	vmrs	APSR_nzcv, fpscr
    1964:	ble.n	196c <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1a4>
    1966:	bics.w	r3, r8, #2
    196a:	beq.n	1894 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xcc>
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
    196c:	vcmpe.f32	s15, #0.0
    1970:	vmrs	APSR_nzcv, fpscr
    1974:	bpl.n	1898 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>
    1976:	bic.w	r8, r8, #2
    197a:	cmp.w	r8, #1
    197e:	beq.n	1894 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xcc>
    1980:	b.n	1898 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    1982:	vldr	s16, [pc, #120]	; 19fc <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x234>
    1986:	b.n	1906 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x13e>
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    } else if (trajectory_shape == FootTrajectory::TRIANGULAR) {
        if (swing_proportion_completed <= 0.5) {
            z_from_ground = gait_config.getSwingHeight()*swing_proportion_completed;
    1988:	bl	ed0 <project_namespace::GaitConfig::getSwingHeight()>
    198c:	vmul.f32	s16, s16, s0
    1990:	b.n	1906 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x13e>
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    } else if ((rp_capture_point(1) < 0) and (leg_index == 1 or leg_index == 3)) {
    1992:	bic.w	r3, r8, #2
    1996:	cmp	r3, #1
    1998:	bne.n	1948 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x180>
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    199a:	adds	r0, r7, #4
    199c:	mov	r1, r6
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    } else if ((rp_capture_point(1) < 0) and (leg_index == 1 or leg_index == 3)) {
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    199e:	vadd.f32	s17, s17, s15
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    19a2:	bl	1770 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>
    19a6:	vldr	s15, [r7, #8]
    19aa:	vldr	s13, [r7, #4]
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
    19ae:	vcmpe.f32	s15, #0.0
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    19b2:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
    19b6:	vmrs	APSR_nzcv, fpscr
    19ba:	bpl.w	1898 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>
    19be:	b.n	1976 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1ae>
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    19c0:	ldr	r0, [r6, #0]
    19c2:	bl	ed0 <project_namespace::GaitConfig::getSwingHeight()>
    19c6:	vmov.f32	s16, s0
    19ca:	vldr	d0, [pc, #36]	; 19f0 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x228>
    19ce:	vcvt.f64.f32	d8, s16
    19d2:	vmul.f64	d0, d11, d0
    19d6:	bl	4fb8 <sin>
    19da:	vmul.f64	d0, d8, d0
    19de:	vcvt.f32.f64	s16, d0
    19e2:	b.n	1906 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x13e>
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    19e4:	ldr	r3, [pc, #24]	; (1a00 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x238>)
    19e6:	movs	r1, #166	; 0xa6
    19e8:	ldr	r2, [pc, #24]	; (1a04 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x23c>)
    19ea:	ldr	r0, [pc, #28]	; (1a08 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x240>)
    19ec:	bl	8718 <__assert_func>
    19f0:	.word	0x54442d18
    19f4:	.word	0x400921fb
    19f8:	.word	0x3c23d70a
    19fc:	.word	0x00000000
    1a00:	.word	0x20000100
    1a04:	.word	0x20000048
    1a08:	.word	0x20000144

00001a0c <project_namespace::Command::Command()>:
    1a0c:	movs	r2, #0
    1a0e:	ldr	r1, [pc, #36]	; (1a34 <project_namespace::Command::Command()+0x28>)
    1a10:	push	{r4, r5, r6}
    1a12:	ldr	r6, [pc, #36]	; (1a38 <project_namespace::Command::Command()+0x2c>)
    1a14:	movs	r4, #0
    1a16:	ldr	r5, [pc, #36]	; (1a3c <project_namespace::Command::Command()+0x30>)
    1a18:	str	r6, [r0, #4]
    1a1a:	str	r5, [r0, #40]	; 0x28
    1a1c:	str	r4, [r0, #44]	; 0x2c
    1a1e:	str	r1, [r0, #0]
    1a20:	str	r1, [r0, #8]
    1a22:	str	r2, [r0, #12]
    1a24:	str	r2, [r0, #16]
    1a26:	str	r2, [r0, #20]
    1a28:	str	r2, [r0, #24]
    1a2a:	str	r2, [r0, #28]
    1a2c:	str	r2, [r0, #32]
    1a2e:	str	r2, [r0, #36]	; 0x24
    1a30:	pop	{r4, r5, r6}
    1a32:	bx	lr
    1a34:	.word	0x3e4ccccd
    1a38:	.word	0x3db851ec
    1a3c:	.word	0x3dcccccd

00001a40 <project_namespace::Command::getStancePolygonLength()>:
    1a40:	vldr	s0, [r0]
    1a44:	bx	lr
    1a46:	nop

00001a48 <project_namespace::Command::getStancePolygonWidth()>:
    1a48:	vldr	s0, [r0, #4]
    1a4c:	bx	lr
    1a4e:	nop

00001a50 <project_namespace::Command::getStanceHeight()>:
    1a50:	vldr	s0, [r0, #8]
    1a54:	bx	lr
    1a56:	nop

00001a58 <project_namespace::Command::getBodyRoll()>:
    1a58:	vldr	s0, [r0, #12]
    1a5c:	bx	lr
    1a5e:	nop

00001a60 <project_namespace::Command::getBodyPitch()>:
    1a60:	vldr	s0, [r0, #16]
    1a64:	bx	lr
    1a66:	nop

00001a68 <project_namespace::Command::getBodyYaw()>:
    1a68:	vldr	s0, [r0, #20]
    1a6c:	bx	lr
    1a6e:	nop

00001a70 <project_namespace::Command::getBodyVelocity()>:
    1a70:	adds	r1, #24
    1a72:	mov	r3, r0
    1a74:	ldmia	r1, {r0, r1, r2}
    1a76:	stmia.w	r3, {r0, r1, r2}
    1a7a:	mov	r0, r3
    1a7c:	bx	lr
    1a7e:	nop

00001a80 <project_namespace::Command::getGaitYawSpeed()>:
    1a80:	vldr	s0, [r0, #36]	; 0x24
    1a84:	bx	lr
    1a86:	nop

00001a88 <project_namespace::Command::getSwingHeight()>:
    1a88:	vldr	s0, [r0, #40]	; 0x28
    1a8c:	bx	lr
    1a8e:	nop

00001a90 <project_namespace::Command::getMode()>:
    1a90:	ldr	r0, [r0, #44]	; 0x2c
    1a92:	bx	lr

00001a94 <project_namespace::Command::setBodyVelocity(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
    1a94:	ldr	r3, [r1, #0]
    1a96:	str	r3, [r0, #24]
    1a98:	ldr	r3, [r1, #4]
    1a9a:	str	r3, [r0, #28]
    1a9c:	ldr	r3, [r1, #8]
    1a9e:	str	r3, [r0, #32]
    1aa0:	bx	lr
    1aa2:	nop

00001aa4 <project_namespace::Command::setSwingHeight(float)>:
    1aa4:	vstr	s0, [r0, #40]	; 0x28
    1aa8:	bx	lr
    1aaa:	nop

00001aac <project_namespace::Command::setMode(project_namespace::Mode)>:
    1aac:	str	r1, [r0, #44]	; 0x2c
    1aae:	bx	lr

00001ab0 <project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)>:
#include "MatrixPrinter.h"

using namespace project_namespace;

// CONSTRUCTORS
GaitController::GaitController(Gait gait_init, FootTrajectory trajectory_shape_init, IMU& imu_init):
    1ab0:	push	{r3, r4, r5, lr}
    gait(gait_init),
    trajectory_shape(trajectory_shape_init),
    imu(imu_init),
    gait_config(GaitConfig(gait, trajectory_shape)),
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
    1ab2:	add.w	r5, r0, #16
#include "MatrixPrinter.h"

using namespace project_namespace;

// CONSTRUCTORS
GaitController::GaitController(Gait gait_init, FootTrajectory trajectory_shape_init, IMU& imu_init):
    1ab6:	mov	r4, r0
    gait(gait_init),
    trajectory_shape(trajectory_shape_init),
    imu(imu_init),
    gait_config(GaitConfig(gait, trajectory_shape)),
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
    1ab8:	stmia.w	r0, {r1, r2, r3}
    1abc:	mov	r0, r5
    1abe:	bl	d9c <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)>
    1ac2:	mov	r1, r5
    1ac4:	add.w	r0, r4, #144	; 0x90
    1ac8:	bl	32c <project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)>
    1acc:	mov	r1, r5
    1ace:	ldr	r2, [r4, #8]
    1ad0:	add.w	r0, r4, #148	; 0x94
    1ad4:	bl	141c <project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)>
{ }
    1ad8:	mov	r0, r4
    1ada:	pop	{r3, r4, r5, pc}

00001adc <project_namespace::GaitController::calculateGaitPhaseIndex(int)>:

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    1adc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1ae0:	add.w	r6, r0, #16
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
{ }

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    1ae4:	mov	sl, r1
    1ae6:	add	r7, sp, #0
    1ae8:	sub	sp, #32
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1aea:	mov	r0, r6
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1aec:	movs	r4, #0
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1aee:	bl	eb0 <project_namespace::GaitConfig::getGaitCycleDurationInTicks()>
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
{ }

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    1af2:	add.w	r9, sp, #15
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    1af6:	mov	r5, r4
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
{ }

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    1af8:	bic.w	r9, r9, #15
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1afc:	sdiv	r3, sl, r0
    1b00:	mov	r8, r9
    1b02:	mls	sl, r3, r0, sl
    1b06:	b.n	1b1c <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x40>
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
    1b08:	mov	r1, r6
    1b0a:	mov	r0, r9
    1b0c:	bl	eb4 <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>
    1b10:	ldr.w	r3, [r8], #4
    1b14:	add	r5, r3
        if (ticks_into_current_gait_cycle < tick_sum) {
    1b16:	cmp	sl, r5
    1b18:	blt.n	1b3a <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x5e>
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1b1a:	adds	r4, #1
    1b1c:	mov	r0, r6
    1b1e:	bl	ea4 <project_namespace::GaitConfig::getGaitNumberOfPhases()>
    1b22:	cmp	r4, r0
    1b24:	blt.n	1b08 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x2c>
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    1b26:	movs	r4, #99	; 0x63
        if (ticks_into_current_gait_cycle < tick_sum) {
            gait_phase_index = i;
            break;
        }
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    1b28:	mov	r0, r6
    1b2a:	bl	ea4 <project_namespace::GaitConfig::getGaitNumberOfPhases()>
    1b2e:	cmp	r0, r4
    1b30:	blt.n	1b3e <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x62>
    return gait_phase_index;
}
    1b32:	mov	r0, r4
    1b34:	mov	sp, r7
    1b36:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (ticks_into_current_gait_cycle < tick_sum) {
            gait_phase_index = i;
            break;
        }
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    1b3a:	cmp	r4, #0
    1b3c:	bge.n	1b28 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x4c>
    1b3e:	ldr	r3, [pc, #12]	; (1b4c <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x70>)
    1b40:	movs	r1, #41	; 0x29
    1b42:	ldr	r2, [pc, #12]	; (1b50 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x74>)
    1b44:	ldr	r0, [pc, #12]	; (1b54 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x78>)
    1b46:	bl	8718 <__assert_func>
    1b4a:	nop
    1b4c:	.word	0x200001f4
    1b50:	.word	0x200001b0
    1b54:	.word	0x2000024c

00001b58 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)>:
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    1b58:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1b5c:	add.w	r6, r0, #16
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    1b60:	mov	r9, r1
    1b62:	add	r7, sp, #0
    1b64:	sub	sp, #32
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1b66:	mov	r0, r6
    int tick_sum = 0;
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1b68:	movs	r4, #0
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1b6a:	bl	eb0 <project_namespace::GaitConfig::getGaitCycleDurationInTicks()>
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    1b6e:	add.w	sl, sp, #15
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    1b72:	mov	r5, r4
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    1b74:	bic.w	sl, sl, #15
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1b78:	sdiv	r1, r9, r0
    1b7c:	mov	r8, sl
    1b7e:	mls	r9, r1, r0, r9
    1b82:	b.n	1b9c <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x44>
    int tick_sum = 0;
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
    1b84:	mov	r1, r6
    1b86:	mov	r0, sl
    1b88:	bl	eb4 <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>
    1b8c:	ldr.w	r3, [r8], #4
    1b90:	mov.w	fp, r4, lsl #2
    1b94:	add	r5, r3
        if (tick_sum > ticks_into_current_gait_cycle) {
    1b96:	cmp	r9, r5
    1b98:	blt.n	1bbc <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x64>
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1b9a:	adds	r4, #1
    1b9c:	mov	r0, r6
    1b9e:	bl	ea4 <project_namespace::GaitConfig::getGaitNumberOfPhases()>
    1ba2:	cmp	r4, r0
    1ba4:	blt.n	1b84 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x2c>

    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    1ba6:	movw	r5, #999	; 0x3e7
                + gait_config.getGaitPhaseDurationsInTicks()(i)
            ;
            break;
        }
    }
    assert (
    1baa:	mov	r0, r6
    1bac:	bl	ea8 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>
    1bb0:	cmp	r0, r5
    1bb2:	blt.n	1bdc <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x84>
            (ticks_into_current_phase <= gait_config.getGaitStanceDurationInTicks())
            || (ticks_into_current_phase <= gait_config.getGaitSwingDurationInTicks())
        )
    );
    return ticks_into_current_phase;
}
    1bb4:	mov	r0, r5
    1bb6:	mov	sp, r7
    1bb8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
        if (tick_sum > ticks_into_current_gait_cycle) {
            ticks_into_current_phase =
                ticks_into_current_gait_cycle
                - tick_sum
                + gait_config.getGaitPhaseDurationsInTicks()(i)
    1bbc:	mov	r1, r6
    1bbe:	mov	r0, sl
    1bc0:	bl	eb4 <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
        if (tick_sum > ticks_into_current_gait_cycle) {
            ticks_into_current_phase =
                ticks_into_current_gait_cycle
                - tick_sum
    1bc4:	rsb	r5, r5, r9
                + gait_config.getGaitPhaseDurationsInTicks()(i)
            ;
    1bc8:	ldr.w	r3, [sl, fp]
        (ticks_into_current_phase >= 0)
        && (
            (ticks_into_current_phase <= gait_config.getGaitStanceDurationInTicks())
            || (ticks_into_current_phase <= gait_config.getGaitSwingDurationInTicks())
        )
    );
    1bcc:	adds	r5, r5, r3
    1bce:	bpl.n	1baa <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x52>
                + gait_config.getGaitPhaseDurationsInTicks()(i)
            ;
            break;
        }
    }
    assert (
    1bd0:	ldr	r3, [pc, #28]	; (1bf0 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x98>)
    1bd2:	movs	r1, #78	; 0x4e
    1bd4:	ldr	r2, [pc, #28]	; (1bf4 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x9c>)
    1bd6:	ldr	r0, [pc, #32]	; (1bf8 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0xa0>)
    1bd8:	bl	8718 <__assert_func>
    1bdc:	mov	r0, r6
    1bde:	bl	eac <project_namespace::GaitConfig::getGaitSwingDurationInTicks()>
    1be2:	cmp	r0, r5
    1be4:	blt.n	1bd0 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x78>
            (ticks_into_current_phase <= gait_config.getGaitStanceDurationInTicks())
            || (ticks_into_current_phase <= gait_config.getGaitSwingDurationInTicks())
        )
    );
    return ticks_into_current_phase;
}
    1be6:	mov	r0, r5
    1be8:	mov	sp, r7
    1bea:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1bee:	nop
    1bf0:	.word	0x20000264
    1bf4:	.word	0x20000160
    1bf8:	.word	0x2000024c

00001bfc <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)>:

int GaitController::calculateTicksIntoCurrentLegPhase(int ticks, int leg_index) {
    1bfc:	push	{r3, r4, r5, r6, r7, lr}
    1bfe:	mov	r5, r0
    1c00:	mov	r4, r1
    1c02:	mov	r6, r2
    RETURNS:
    + ticks_into_current_leg_phase: The number of ticks into the leg's own phase (NOT GAIT PHASE!!!).
    */
    int ticks_into_current_leg_phase = 999; // Initialise with impossible value, caught by assert later

    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1c04:	bl	1adc <project_namespace::GaitController::calculateGaitPhaseIndex(int)>
    int ticks_into_current_gait_phase = calculateTicksIntoCurrentGaitPhase(ticks);
    1c08:	mov	r1, r4
    RETURNS:
    + ticks_into_current_leg_phase: The number of ticks into the leg's own phase (NOT GAIT PHASE!!!).
    */
    int ticks_into_current_leg_phase = 999; // Initialise with impossible value, caught by assert later

    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1c0a:	mov	r7, r0
    int ticks_into_current_gait_phase = calculateTicksIntoCurrentGaitPhase(ticks);
    1c0c:	mov	r0, r5
    1c0e:	bl	1b58 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)>
    if (gait == Gait::TROT) {
    1c12:	ldr	r3, [r5, #0]
    1c14:	cbz	r3, 1c2a <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x2e>
    1c16:	movw	r4, #999	; 0x3e7
                // BR is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            }
        }
    }
    assert(
    1c1a:	add.w	r0, r5, #16
    1c1e:	bl	ec8 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
    1c22:	cmp	r0, r4
    1c24:	blt.n	1c40 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x44>
        (ticks_into_current_leg_phase >= 0)
        && (ticks_into_current_leg_phase <= gait_config.getLegStanceDurationInTicks())
    ); // leg stance duration is always longer than swing stance duration

    return ticks_into_current_leg_phase;
}
    1c26:	mov	r0, r4
    1c28:	pop	{r3, r4, r5, r6, r7, pc}
    1c2a:	mov	r4, r0
    int ticks_into_current_leg_phase = 999; // Initialise with impossible value, caught by assert later

    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    int ticks_into_current_gait_phase = calculateTicksIntoCurrentGaitPhase(ticks);
    if (gait == Gait::TROT) {
        if (leg_index == 0) {
    1c2c:	cbnz	r6, 1c4c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x50>
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 3) {
            // Back-right leg
            if (current_gait_phase_index == 0) {
    1c2e:	cbz	r7, 1c3c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
                // BR is just starting its leg stance phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 1) {
    1c30:	cmp	r7, #1
    1c32:	beq.n	1c66 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x6a>
                // BR is in the middle of its leg stance phase
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            } else if (current_gait_phase_index == 2) {
    1c34:	cmp	r7, #2
    1c36:	beq.n	1c72 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x76>
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + gait_config.getGaitSwingDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            } else if (current_gait_phase_index == 3) {
    1c38:	cmp	r7, #3
    1c3a:	bne.n	1c16 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1a>
        }
    }
    assert(
        (ticks_into_current_leg_phase >= 0)
        && (ticks_into_current_leg_phase <= gait_config.getLegStanceDurationInTicks())
    ); // leg stance duration is always longer than swing stance duration
    1c3c:	cmp	r4, #0
    1c3e:	bge.n	1c1a <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1e>
                // BR is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            }
        }
    }
    assert(
    1c40:	ldr	r3, [pc, #72]	; (1c8c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x90>)
    1c42:	movs	r1, #193	; 0xc1
    1c44:	ldr	r2, [pc, #72]	; (1c90 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x94>)
    1c46:	ldr	r0, [pc, #76]	; (1c94 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x98>)
    1c48:	bl	8718 <__assert_func>
                ;
            } else if (current_gait_phase_index == 3) {
                // FL is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            }
        } else if (leg_index == 1) {
    1c4c:	cmp	r6, #1
    1c4e:	beq.n	1c5a <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x5e>
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 2) {
    1c50:	cmp	r6, #2
    1c52:	beq.n	1c5a <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x5e>
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 3) {
    1c54:	cmp	r6, #3
    1c56:	bne.n	1c16 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1a>
    1c58:	b.n	1c2e <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x32>
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 2) {
            // Back-left leg
            if (current_gait_phase_index == 0) {
    1c5a:	cbz	r7, 1c72 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x76>
                    + ticks_into_current_gait_phase
                ;
            } else if (current_gait_phase_index == 1) {
                // BL is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 2) {
    1c5c:	subs	r3, r7, #1
    1c5e:	cmp	r3, #1
    1c60:	bls.n	1c3c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
                // BL is just starting its leg stance phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 3) {
    1c62:	cmp	r7, #3
    1c64:	bne.n	1c16 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1a>
                // BR is just starting its leg stance phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 1) {
                // BR is in the middle of its leg stance phase
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
    1c66:	add.w	r0, r5, #16
    1c6a:	bl	ea8 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>
                    + ticks_into_current_gait_phase
                ;
    1c6e:	add	r4, r0
    1c70:	b.n	1c3c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
            } else if (current_gait_phase_index == 2) {
                // BR is approaching end of its leg stance phase
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
    1c72:	add.w	r7, r5, #16
    1c76:	mov	r0, r7
    1c78:	bl	ea8 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>
    1c7c:	mov	r6, r0
                    + gait_config.getGaitSwingDurationInTicks()
    1c7e:	mov	r0, r7
    1c80:	bl	eac <project_namespace::GaitConfig::getGaitSwingDurationInTicks()>
                    + ticks_into_current_gait_phase
                ;
    1c84:	add	r0, r6
    1c86:	add	r4, r0
    1c88:	b.n	1c3c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
    1c8a:	nop
    1c8c:	.word	0x20000320
    1c90:	.word	0x20000394
    1c94:	.word	0x2000024c

00001c98 <project_namespace::GaitController::calculateContactPattern(int)>:
    ); // leg stance duration is always longer than swing stance duration

    return ticks_into_current_leg_phase;
}

Eigen::Vector4i GaitController::calculateContactPattern(int ticks) {
    1c98:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1c9c:	add	r7, sp, #0
    1c9e:	sub	sp, #80	; 0x50
    1ca0:	mov	r8, r1
    1ca2:	mov	r4, r0
    1ca4:	add.w	r5, sp, #15
    RETURNS:
    + contact_pattern: The contact pattern of the legs at the time given in ticks.
    0 = swing, 1 = stance, [FL, FR, BL, BR].
    */
    
    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1ca8:	mov	r1, r2
    1caa:	mov	r0, r8
    1cac:	bl	1adc <project_namespace::GaitController::calculateGaitPhaseIndex(int)>
    ); // leg stance duration is always longer than swing stance duration

    return ticks_into_current_leg_phase;
}

Eigen::Vector4i GaitController::calculateContactPattern(int ticks) {
    1cb0:	bic.w	r5, r5, #15
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
      m_storage.data()[0] = x;
    1cb4:	movs	r3, #0
    RETURNS:
    + contact_pattern: The contact pattern of the legs at the time given in ticks.
    0 = swing, 1 = stance, [FL, FR, BL, BR].
    */
    
    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1cb6:	mov	r6, r0
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);
    1cb8:	add.w	r1, r8, #16
    1cbc:	mov	r0, r5
    1cbe:	str	r3, [r4, #0]
      m_storage.data()[1] = y;
    1cc0:	str	r3, [r4, #4]
      m_storage.data()[2] = z;
    1cc2:	str	r3, [r4, #8]
      m_storage.data()[3] = w;
    1cc4:	str	r3, [r4, #12]
    1cc6:	bl	e80 <project_namespace::GaitConfig::getContactSchedule()>

    return contact_pattern;
}
    1cca:	mov	r0, r4
    1ccc:	lsls	r3, r6, #4
    1cce:	adds	r2, r5, r3
    1cd0:	ldr	r6, [r5, r3]
    1cd2:	ldr	r1, [r2, #8]
    1cd4:	ldr	r5, [r2, #4]
    1cd6:	ldr	r3, [r2, #12]
    1cd8:	str	r6, [r4, #0]
    1cda:	str	r5, [r4, #4]
    1cdc:	str	r1, [r4, #8]
    1cde:	str	r3, [r4, #12]
    1ce0:	mov	sp, r7
    1ce2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1ce6:	nop

00001ce8 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)>:

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1ce8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1cec:	vpush	{d8}
    1cf0:	sub	sp, #52	; 0x34
    1cf2:	mov	r8, r1
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1cf4:	adds	r1, #16
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);

    return contact_pattern;
}

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1cf6:	mov	sl, r3
    1cf8:	add	r7, sp, #8
    1cfa:	sub	sp, #48	; 0x30
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1cfc:	mov	r4, r1
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);

    return contact_pattern;
}

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1cfe:	str	r0, [r7, #12]
    1d00:	mov	r5, r0
    1d02:	add.w	r3, sp, #23
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1d06:	mov	r0, sl
    1d08:	str	r1, [r7, #20]
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);

    return contact_pattern;
}

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1d0a:	bic.w	fp, r3, #15
    1d0e:	str	r2, [r7, #8]
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1d10:	bl	1a88 <project_namespace::Command::getSwingHeight()>
    1d14:	mov	r0, r4
    1d16:	bl	ed8 <project_namespace::GaitConfig::setSwingHeight(float)>
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);
    1d1a:	mov	r0, fp
    1d1c:	ldr	r2, [r7, #88]	; 0x58
    1d1e:	mov	r1, r8
    1d20:	bl	1c98 <project_namespace::GaitController::calculateContactPattern(int)>
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
    1d24:	ldr.w	r2, [fp, #12]
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1d28:	add.w	r3, r8, #144	; 0x90
    1d2c:	ldr.w	r0, [fp, #4]
    1d30:	ldr.w	r1, [fp, #8]
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1d34:	add.w	r4, r8, #148	; 0x94
    1d38:	str.w	r2, [fp, #28]
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
      m_storage.data()[0] = x;
    1d3c:	movs	r2, #0
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1d3e:	str	r3, [r7, #4]
    1d40:	add.w	r9, fp, #16
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
    1d44:	ldr.w	r3, [fp]
    1d48:	mov	r6, fp
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1d4a:	str	r4, [r7, #16]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1d4c:	movs	r4, #0
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
    1d4e:	str.w	r0, [fp, #20]
    1d52:	str.w	r1, [fp, #24]
    1d56:	str.w	r3, [fp, #16]
    1d5a:	str.w	r2, [fp]
      m_storage.data()[1] = y;
    1d5e:	str.w	r2, [fp, #4]
      m_storage.data()[2] = z;
    1d62:	str.w	r2, [fp, #8]
      m_storage.data()[3] = w;
    1d66:	str.w	r2, [fp, #12]
    1d6a:	ldr.w	fp, [r7, #8]
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
    1d6e:	cbz	r3, 1d86 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x9e>
                    leg_swing_proportion_completed,
                    trajectory_shape
                )
            ;
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
    1d70:	cmp	r3, #1
    1d72:	beq.n	1df2 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x10a>
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1d74:	adds	r4, #1
    1d76:	adds	r5, #12
    1d78:	adds	r6, #4
    1d7a:	cmp	r4, #4
    1d7c:	beq.n	1de4 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0xfc>
    1d7e:	ldr.w	r3, [r9, #4]!
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
    1d82:	cmp	r3, #0
    1d84:	bne.n	1d70 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x88>
            // Leg is in swing phase
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
    1d86:	mov	r2, r4
    1d88:	ldr	r1, [r7, #88]	; 0x58
    1d8a:	mov	r0, r8
    1d8c:	adds	r5, #12
    1d8e:	bl	1bfc <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)>
    1d92:	vmov	s16, r0
                / float(gait_config.getLegSwingDurationInTicks())
    1d96:	ldr	r0, [r7, #20]
    1d98:	adds	r6, #4
    1d9a:	bl	ecc <project_namespace::GaitConfig::getLegSwingDurationInTicks()>
    1d9e:	vmov	s15, r0
    1da2:	vcvt.f32.s32	s16, s16
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1da6:	ldr.w	r2, [r8, #4]
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
            // Leg is in swing phase
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
    1daa:	vcvt.f32.s32	s15, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1dae:	str	r4, [sp, #0]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1db0:	adds	r4, #1
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1db2:	mov	r3, sl
    1db4:	str	r2, [sp, #4]
    1db6:	add.w	r0, r7, #28
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
            // Leg is in swing phase
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
    1dba:	vdiv.f32	s17, s16, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1dbe:	mov	r2, fp
    1dc0:	ldr	r1, [r7, #16]
    1dc2:	vmov.f32	s0, s17
    1dc6:	bl	17c8 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)>
    1dca:	ldr	r1, [r7, #28]
    1dcc:	ldr	r2, [r7, #32]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1dce:	cmp	r4, #4
    1dd0:	ldr	r3, [r7, #36]	; 0x24
                    leg_index,
                    leg_swing_proportion_completed,
                    trajectory_shape
                )
            ;
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
    1dd2:	vstr	s17, [r6, #-4]
    1dd6:	str.w	r1, [r5, #-12]
    1dda:	str.w	r2, [r5, #-8]
    1dde:	str.w	r3, [r5, #-4]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1de2:	bne.n	1d7e <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x96>
            foot_phase_proportions_completed(leg_index) = leg_stance_proportion_completed;
        }
    }

    return new_foot_positions_wrt_body;
    1de4:	ldr	r0, [r7, #12]
    1de6:	adds	r7, #44	; 0x2c
    1de8:	mov	sp, r7
    1dea:	vpop	{d8}
    1dee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ;
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
            // Leg is in stance phase
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
    1df2:	mov	r2, r4
    1df4:	ldr	r1, [r7, #88]	; 0x58
    1df6:	mov	r0, r8
    1df8:	bl	1bfc <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)>
    1dfc:	vmov	s16, r0
                / float(gait_config.getLegStanceDurationInTicks())
    1e00:	ldr	r0, [r7, #20]
    1e02:	bl	ec8 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
    1e06:	vmov	s15, r0
    1e0a:	vcvt.f32.s32	s16, s16
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1e0e:	mov	r3, sl
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
            // Leg is in stance phase
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
    1e10:	vcvt.f32.s32	s15, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1e14:	mov	r2, fp
    1e16:	ldr	r1, [r7, #4]
    1e18:	add.w	r0, r7, #28
    1e1c:	str	r4, [sp, #0]
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
            // Leg is in stance phase
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
    1e1e:	vdiv.f32	s17, s16, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1e22:	bl	330 <project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)>
    1e26:	ldr	r1, [r7, #28]
    1e28:	ldr	r2, [r7, #32]
    1e2a:	ldr	r3, [r7, #36]	; 0x24
    1e2c:	str	r1, [r5, #0]
    1e2e:	str	r2, [r5, #4]
    1e30:	str	r3, [r5, #8]
            ;
            foot_phase_proportions_completed(leg_index) = leg_stance_proportion_completed;
    1e32:	vstr	s17, [r6]
    1e36:	b.n	1d74 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x8c>

00001e38 <PWMServo::PWMServo()>:
    1e38:	movs	r2, #255	; 0xff
    1e3a:	strb	r2, [r0, #0]
    1e3c:	strb	r2, [r0, #1]
    1e3e:	bx	lr

00001e40 <PWMServo::attach(int, int, int)>:
    1e40:	cmp	r1, #39	; 0x27
    1e42:	bhi.n	1eba <PWMServo::attach(int, int, int)+0x7a>
    1e44:	cmp	r1, #15
    1e46:	push	{r4, r5, r6, lr}
    1e48:	sub.w	r5, r1, #18
    1e4c:	ite	le
    1e4e:	movle	r6, #0
    1e50:	movgt	r6, #1
    1e52:	cmp	r5, #15
    1e54:	bhi.n	1eb6 <PWMServo::attach(int, int, int)+0x76>
    1e56:	movw	r4, #48371	; 0xbcf3
    1e5a:	lsrs	r4, r5
    1e5c:	and.w	r4, r4, #1
    1e60:	eor.w	r4, r4, #1
    1e64:	cbz	r6, 1e6c <PWMServo::attach(int, int, int)+0x2c>
    1e66:	cbz	r4, 1e6c <PWMServo::attach(int, int, int)+0x2c>
    1e68:	movs	r0, #0
    1e6a:	pop	{r4, r5, r6, pc}
    1e6c:	mov	r4, r0
    1e6e:	uxtb	r0, r1
    1e70:	mov	r5, r3
    1e72:	mov	r6, r2
    1e74:	vldr	s0, [pc, #72]	; 1ec0 <PWMServo::attach(int, int, int)+0x80>
    1e78:	strb	r0, [r4, #0]
    1e7a:	bl	4738 <analogWriteFrequency>
    1e7e:	movs	r0, #255	; 0xff
    1e80:	asrs	r2, r6, #4
    1e82:	movs	r1, #0
    1e84:	asrs	r3, r5, #4
    1e86:	strb	r0, [r4, #1]
    1e88:	strb	r2, [r4, #2]
    1e8a:	strb	r3, [r4, #3]
    1e8c:	ldrb	r0, [r4, #0]
    1e8e:	bl	4ab8 <digitalWrite>
    1e92:	ldrb	r0, [r4, #0]
    1e94:	movs	r1, #1
    1e96:	bl	4ad0 <pinMode>
    1e9a:	ldrb	r2, [r4, #0]
    1e9c:	ldr	r1, [pc, #36]	; (1ec4 <PWMServo::attach(int, int, int)+0x84>)
    1e9e:	movs	r3, #1
    1ea0:	asrs	r4, r2, #5
    1ea2:	and.w	r2, r2, #31
    1ea6:	mov	r0, r3
    1ea8:	lsls	r3, r2
    1eaa:	ldr.w	r2, [r1, r4, lsl #2]
    1eae:	orrs	r3, r2
    1eb0:	str.w	r3, [r1, r4, lsl #2]
    1eb4:	pop	{r4, r5, r6, pc}
    1eb6:	movs	r4, #1
    1eb8:	b.n	1e64 <PWMServo::attach(int, int, int)+0x24>
    1eba:	movs	r0, #0
    1ebc:	bx	lr
    1ebe:	nop
    1ec0:	.word	0x42480000
    1ec4:	.word	0x200021e0

00001ec8 <PWMServo::write(int)>:
    1ec8:	ldrb	r3, [r0, #0]
    1eca:	cmp	r3, #39	; 0x27
    1ecc:	bhi.n	1f1e <PWMServo::write(int)+0x56>
    1ece:	cmp	r1, #0
    1ed0:	push	{r4, r5, r6, lr}
    1ed2:	mov	r4, r0
    1ed4:	blt.n	1f20 <PWMServo::write(int)+0x58>
    1ed6:	cmp	r1, #180	; 0xb4
    1ed8:	ble.n	1f26 <PWMServo::write(int)+0x5e>
    1eda:	movs	r5, #180	; 0xb4
    1edc:	mov	r1, r5
    1ede:	ldrb	r6, [r4, #2]
    1ee0:	movw	r0, #46603	; 0xb60b
    1ee4:	ldrb	r2, [r4, #3]
    1ee6:	movw	r3, #3355	; 0xd1b
    1eea:	strb	r5, [r4, #1]
    1eec:	lsls	r5, r6, #12
    1eee:	subs	r2, r2, r6
    1ef0:	mul.w	r2, r0, r2
    1ef4:	mul.w	r1, r1, r2
    1ef8:	add.w	r1, r5, r1, asr #11
    1efc:	mul.w	r5, r3, r1
    1f00:	lsrs	r5, r5, #22
    1f02:	cpsid	i

void pinMode(uint8_t pin, uint8_t mode);
void init_pins(void);
void analogWrite(uint8_t pin, int val);
uint32_t analogWriteRes(uint32_t bits);
static inline uint32_t analogWriteResolution(uint32_t bits) { return analogWriteRes(bits); }
    1f04:	movs	r0, #12
    1f06:	bl	4a58 <analogWriteRes>
    1f0a:	mov	r6, r0
    1f0c:	mov	r1, r5
    1f0e:	ldrb	r0, [r4, #0]
    1f10:	bl	4670 <analogWrite>
    1f14:	mov	r0, r6
    1f16:	bl	4a58 <analogWriteRes>
    1f1a:	cpsie	i
    1f1c:	pop	{r4, r5, r6, pc}
    1f1e:	bx	lr
    1f20:	movs	r5, #0
    1f22:	mov	r1, r5
    1f24:	b.n	1ede <PWMServo::write(int)+0x16>
    1f26:	uxtb	r5, r1
    1f28:	b.n	1ede <PWMServo::write(int)+0x16>
    1f2a:	nop

00001f2c <TwoWire::available()>:
    1f2c:	ldrb.w	r2, [r0, #59]	; 0x3b
    1f30:	ldrb.w	r0, [r0, #58]	; 0x3a
    1f34:	subs	r0, r2, r0
    1f36:	bx	lr

00001f38 <TwoWire::read()>:
    1f38:	ldrb.w	r3, [r0, #58]	; 0x3a
    1f3c:	ldrb.w	r2, [r0, #59]	; 0x3b
    1f40:	cmp	r2, r3
    1f42:	bls.n	1f50 <TwoWire::read()+0x18>
    1f44:	adds	r2, r3, #1
    1f46:	add	r3, r0
    1f48:	strb.w	r2, [r0, #58]	; 0x3a
    1f4c:	ldrb	r0, [r3, #26]
    1f4e:	bx	lr
    1f50:	mov.w	r0, #4294967295
    1f54:	bx	lr
    1f56:	nop

00001f58 <BNO080::printHeader() [clone .part.7]>:
    1f58:	push	{r4, r5, r6, lr}
    1f5a:	mov	r4, r0
    1f5c:	ldr.w	r0, [r0, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1f60:	movs	r2, #7
    1f62:	ldr	r1, [pc, #80]	; (1fb4 <BNO080::printHeader() [clone .part.7]+0x5c>)
    1f64:	ldr	r3, [r0, #0]
    1f66:	subs	r5, r4, #1
    1f68:	adds	r6, r4, #3
    1f6a:	ldr	r3, [r3, #4]
    1f6c:	blx	r3
    1f6e:	ldr.w	r0, [r4, #184]	; 0xb8
    1f72:	movs	r2, #1
    1f74:	ldr	r1, [pc, #64]	; (1fb8 <BNO080::printHeader() [clone .part.7]+0x60>)
    1f76:	ldr	r3, [r0, #0]
    1f78:	ldr	r3, [r3, #4]
    1f7a:	blx	r3
    1f7c:	ldrb.w	r1, [r5, #1]!
    1f80:	cmp	r1, #15
    1f82:	bls.n	1fa0 <BNO080::printHeader() [clone .part.7]+0x48>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1f84:	movs	r3, #0
    1f86:	movs	r2, #16
    1f88:	ldr.w	r0, [r4, #184]	; 0xb8
    1f8c:	bl	4ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f90:	cmp	r5, r6
    1f92:	bne.n	1f6e <BNO080::printHeader() [clone .part.7]+0x16>
    1f94:	ldr.w	r0, [r4, #184]	; 0xb8
    1f98:	ldmia.w	sp!, {r4, r5, r6, lr}
    1f9c:	b.w	4e74 <Print::println()>
    1fa0:	ldr.w	r0, [r4, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1fa4:	movs	r2, #1
    1fa6:	ldr	r1, [pc, #20]	; (1fbc <BNO080::printHeader() [clone .part.7]+0x64>)
    1fa8:	ldr	r3, [r0, #0]
    1faa:	ldr	r3, [r3, #4]
    1fac:	blx	r3
    1fae:	ldrb	r1, [r5, #0]
    1fb0:	b.n	1f84 <BNO080::printHeader() [clone .part.7]+0x2c>
    1fb2:	nop
    1fb4:	.word	0x200003f8
    1fb8:	.word	0x20000400
    1fbc:	.word	0x20000404

00001fc0 <BNO080::printPacket() [clone .part.6]>:
    1fc0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1fc4:	ldrb	r3, [r0, #0]
    1fc6:	mov	r5, r0
    1fc8:	ldrb	r7, [r0, #1]
    1fca:	subs	r6, r0, #1
    1fcc:	ldr.w	r0, [r0, #184]	; 0xb8
    1fd0:	movs	r2, #7
    1fd2:	orr.w	r7, r3, r7, lsl #8
    1fd6:	ldr	r1, [pc, #408]	; (2170 <BNO080::printPacket() [clone .part.6]+0x1b0>)
    1fd8:	ldr	r3, [r0, #0]
    1fda:	adds	r4, r5, #3
    1fdc:	sxth	r7, r7
    1fde:	ldr	r3, [r3, #4]
    1fe0:	uxth.w	r8, r7
    1fe4:	blx	r3
    1fe6:	ldr.w	r0, [r5, #184]	; 0xb8
    1fea:	movs	r2, #1
    1fec:	ldr	r1, [pc, #388]	; (2174 <BNO080::printPacket() [clone .part.6]+0x1b4>)
    1fee:	ldr	r3, [r0, #0]
    1ff0:	ldr	r3, [r3, #4]
    1ff2:	blx	r3
    1ff4:	ldrb.w	r1, [r6, #1]!
    1ff8:	cmp	r1, #15
    1ffa:	bls.n	2068 <BNO080::printPacket() [clone .part.6]+0xa8>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1ffc:	movs	r3, #0
    1ffe:	movs	r2, #16
    2000:	ldr.w	r0, [r5, #184]	; 0xb8
    2004:	bl	4ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2008:	cmp	r4, r6
    200a:	bne.n	1fe6 <BNO080::printPacket() [clone .part.6]+0x26>
    200c:	subs	r6, r7, #4
    200e:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2012:	movs	r2, #6
    2014:	ldr	r1, [pc, #352]	; (2178 <BNO080::printPacket() [clone .part.6]+0x1b8>)
    2016:	uxtb	r6, r6
    2018:	ldr	r3, [r0, #0]
    201a:	cmp	r6, #40	; 0x28
    201c:	ldr	r3, [r3, #4]
    201e:	it	cs
    2020:	movcs	r6, #40	; 0x28
    2022:	blx	r3
    2024:	cbz	r6, 207a <BNO080::printPacket() [clone .part.6]+0xba>
    2026:	subs	r6, #1
    2028:	uxtb	r6, r6
    202a:	adds	r6, #4
    202c:	add	r6, r5
    202e:	b.n	2040 <BNO080::printPacket() [clone .part.6]+0x80>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    2030:	movs	r3, #0
    2032:	movs	r2, #16
    2034:	ldr.w	r0, [r5, #184]	; 0xb8
    2038:	bl	4ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    203c:	cmp	r6, r4
    203e:	beq.n	207a <BNO080::printPacket() [clone .part.6]+0xba>
    2040:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2044:	movs	r2, #1
    2046:	ldr	r1, [pc, #300]	; (2174 <BNO080::printPacket() [clone .part.6]+0x1b4>)
    2048:	ldr	r3, [r0, #0]
    204a:	ldr	r3, [r3, #4]
    204c:	blx	r3
    204e:	ldrb.w	r1, [r4, #1]!
    2052:	cmp	r1, #15
    2054:	bhi.n	2030 <BNO080::printPacket() [clone .part.6]+0x70>
    2056:	ldr.w	r0, [r5, #184]	; 0xb8
    205a:	movs	r2, #1
    205c:	ldr	r1, [pc, #284]	; (217c <BNO080::printPacket() [clone .part.6]+0x1bc>)
    205e:	ldr	r3, [r0, #0]
    2060:	ldr	r3, [r3, #4]
    2062:	blx	r3
    2064:	ldrb	r1, [r4, #0]
    2066:	b.n	2030 <BNO080::printPacket() [clone .part.6]+0x70>
    2068:	ldr.w	r0, [r5, #184]	; 0xb8
    206c:	movs	r2, #1
    206e:	ldr	r1, [pc, #268]	; (217c <BNO080::printPacket() [clone .part.6]+0x1bc>)
    2070:	ldr	r3, [r0, #0]
    2072:	ldr	r3, [r3, #4]
    2074:	blx	r3
    2076:	ldrb	r1, [r6, #0]
    2078:	b.n	1ffc <BNO080::printPacket() [clone .part.6]+0x3c>
    207a:	cmp	r7, #0
    207c:	blt.n	20fe <BNO080::printPacket() [clone .part.6]+0x13e>
    207e:	ldr.w	r0, [r5, #184]	; 0xb8
    2082:	movs	r2, #8
    2084:	ldr	r1, [pc, #248]	; (2180 <BNO080::printPacket() [clone .part.6]+0x1c0>)
    2086:	ldr	r3, [r0, #0]
    2088:	ldr	r3, [r3, #4]
    208a:	blx	r3
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    208c:	mov	r1, r8
    208e:	ldr.w	r0, [r5, #184]	; 0xb8
    2092:	bl	4f24 <Print::print(long)>
    2096:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    209a:	ldr	r1, [pc, #232]	; (2184 <BNO080::printPacket() [clone .part.6]+0x1c4>)
    209c:	movs	r2, #9
    209e:	ldr	r3, [r0, #0]
    20a0:	ldr	r3, [r3, #4]
    20a2:	blx	r3
    20a4:	ldrb	r1, [r5, #2]
    20a6:	cbz	r1, 20d4 <BNO080::printPacket() [clone .part.6]+0x114>
    20a8:	cmp	r1, #1
    20aa:	beq.n	2134 <BNO080::printPacket() [clone .part.6]+0x174>
    20ac:	cmp	r1, #2
    20ae:	beq.n	214e <BNO080::printPacket() [clone .part.6]+0x18e>
    20b0:	cmp	r1, #3
    20b2:	beq.n	20ee <BNO080::printPacket() [clone .part.6]+0x12e>
    20b4:	cmp	r1, #4
    20b6:	beq.n	215e <BNO080::printPacket() [clone .part.6]+0x19e>
    20b8:	cmp	r1, #5
    20ba:	beq.n	211a <BNO080::printPacket() [clone .part.6]+0x15a>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20bc:	movs	r3, #0
    20be:	movs	r2, #10
    20c0:	ldr.w	r0, [r5, #184]	; 0xb8
    20c4:	bl	4ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    20c8:	ldr.w	r0, [r5, #184]	; 0xb8
    20cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    20d0:	b.w	4e74 <Print::println()>
    20d4:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    20d8:	movs	r2, #7
    20da:	ldr	r1, [pc, #172]	; (2188 <BNO080::printPacket() [clone .part.6]+0x1c8>)
    20dc:	ldr	r3, [r0, #0]
    20de:	ldr	r3, [r3, #4]
    20e0:	blx	r3
    20e2:	ldr.w	r0, [r5, #184]	; 0xb8
    20e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    20ea:	b.w	4e74 <Print::println()>
    20ee:	ldr.w	r0, [r5, #184]	; 0xb8
    20f2:	movs	r2, #13
    20f4:	ldr	r1, [pc, #148]	; (218c <BNO080::printPacket() [clone .part.6]+0x1cc>)
    20f6:	ldr	r3, [r0, #0]
    20f8:	ldr	r3, [r3, #4]
    20fa:	blx	r3
    20fc:	b.n	20c8 <BNO080::printPacket() [clone .part.6]+0x108>
    20fe:	ldr.w	r4, [r5, #184]	; 0xb8
    2102:	movs	r2, #20
    2104:	ldr	r1, [pc, #136]	; (2190 <BNO080::printPacket() [clone .part.6]+0x1d0>)
    2106:	ubfx	r8, r8, #0, #15
    210a:	ldr	r3, [r4, #0]
    210c:	mov	r0, r4
    210e:	ldr	r3, [r3, #4]
    2110:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    2112:	mov	r0, r4
    2114:	bl	4e74 <Print::println()>
    2118:	b.n	207e <BNO080::printPacket() [clone .part.6]+0xbe>
    211a:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    211e:	movs	r2, #11
    2120:	ldr	r1, [pc, #112]	; (2194 <BNO080::printPacket() [clone .part.6]+0x1d4>)
    2122:	ldr	r3, [r0, #0]
    2124:	ldr	r3, [r3, #4]
    2126:	blx	r3
    2128:	ldr.w	r0, [r5, #184]	; 0xb8
    212c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    2130:	b.w	4e74 <Print::println()>
    2134:	ldr.w	r0, [r5, #184]	; 0xb8
    2138:	movs	r2, #10
    213a:	ldr	r1, [pc, #92]	; (2198 <BNO080::printPacket() [clone .part.6]+0x1d8>)
    213c:	ldr	r3, [r0, #0]
    213e:	ldr	r3, [r3, #4]
    2140:	blx	r3
    2142:	ldr.w	r0, [r5, #184]	; 0xb8
    2146:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    214a:	b.w	4e74 <Print::println()>
    214e:	ldr.w	r0, [r5, #184]	; 0xb8
    2152:	movs	r2, #7
    2154:	ldr	r1, [pc, #68]	; (219c <BNO080::printPacket() [clone .part.6]+0x1dc>)
    2156:	ldr	r3, [r0, #0]
    2158:	ldr	r3, [r3, #4]
    215a:	blx	r3
    215c:	b.n	20c8 <BNO080::printPacket() [clone .part.6]+0x108>
    215e:	ldr.w	r0, [r5, #184]	; 0xb8
    2162:	movs	r2, #11
    2164:	ldr	r1, [pc, #56]	; (21a0 <BNO080::printPacket() [clone .part.6]+0x1e0>)
    2166:	ldr	r3, [r0, #0]
    2168:	ldr	r3, [r3, #4]
    216a:	blx	r3
    216c:	b.n	20c8 <BNO080::printPacket() [clone .part.6]+0x108>
    216e:	nop
    2170:	.word	0x200003f8
    2174:	.word	0x20000400
    2178:	.word	0x20000408
    217c:	.word	0x20000404
    2180:	.word	0x20000428
    2184:	.word	0x20000434
    2188:	.word	0x20000440
    218c:	.word	0x2000045c
    2190:	.word	0x20000410
    2194:	.word	0x20000478
    2198:	.word	0x20000448
    219c:	.word	0x20000454
    21a0:	.word	0x2000046c

000021a4 <BNO080::parseInputReport()>:
    21a4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    21a8:	ldrb	r2, [r0, #1]
    21aa:	ldrb	r3, [r0, #0]
    21ac:	ldr.w	r1, [r0, #5]
    21b0:	orr.w	r3, r3, r2, lsl #8
    21b4:	ldrb	r2, [r0, #2]
    21b6:	str.w	r1, [r0, #256]	; 0x100
    21ba:	cmp	r2, #5
    21bc:	ubfx	r3, r3, #0, #15
    21c0:	ldrb	r1, [r0, #8]
    21c2:	ldrb	r6, [r0, #7]
    21c4:	ldrb	r5, [r0, #6]
    21c6:	ldrb	r4, [r0, #5]
    21c8:	beq.n	2296 <BNO080::parseInputReport()+0xf2>
    21ca:	subs	r3, #4
    21cc:	ldrb.w	lr, [r0, #11]
    21d0:	ldrb	r6, [r0, #14]
    21d2:	sxth	r3, r3
    21d4:	ldrb	r7, [r0, #13]
    21d6:	ldrb	r5, [r0, #15]
    21d8:	and.w	r8, lr, #3
    21dc:	ldrb	r4, [r0, #16]
    21de:	cmp	r3, #14
    21e0:	ldrb.w	r9, [r0, #18]
    21e4:	orr.w	ip, r7, r6, lsl #8
    21e8:	ldrb	r2, [r0, #17]
    21ea:	orr.w	r4, r5, r4, lsl #8
    21ee:	orr.w	r9, r2, r9, lsl #8
    21f2:	bgt.n	224a <BNO080::parseInputReport()+0xa6>
    21f4:	movs	r2, #0
    21f6:	mov	r1, r2
    21f8:	ldrb	r3, [r0, #9]
    21fa:	cmp	r3, #1
    21fc:	beq.n	2266 <BNO080::parseInputReport()+0xc2>
    21fe:	cmp	r3, #4
    2200:	beq.n	22ea <BNO080::parseInputReport()+0x146>
    2202:	cmp	r3, #2
    2204:	beq.n	22fe <BNO080::parseInputReport()+0x15a>
    2206:	cmp	r3, #3
    2208:	beq.w	2312 <BNO080::parseInputReport()+0x16e>
    220c:	cmp	r3, #8
    220e:	it	ne
    2210:	cmpne	r3, #5
    2212:	beq.n	227a <BNO080::parseInputReport()+0xd6>
    2214:	sub.w	sl, r3, #40	; 0x28
    2218:	cmp.w	sl, #1
    221c:	bls.n	227a <BNO080::parseInputReport()+0xd6>
    221e:	cmp	r3, #17
    2220:	beq.w	2326 <BNO080::parseInputReport()+0x182>
    2224:	cmp	r3, #19
    2226:	beq.w	2364 <BNO080::parseInputReport()+0x1c0>
    222a:	cmp	r3, #30
    222c:	beq.w	233e <BNO080::parseInputReport()+0x19a>
    2230:	cmp	r3, #20
    2232:	beq.w	236c <BNO080::parseInputReport()+0x1c8>
    2236:	cmp	r3, #21
    2238:	beq.w	2394 <BNO080::parseInputReport()+0x1f0>
    223c:	cmp	r3, #22
    223e:	beq.n	232e <BNO080::parseInputReport()+0x18a>
    2240:	cmp	r3, #241	; 0xf1
    2242:	beq.w	237c <BNO080::parseInputReport()+0x1d8>
    2246:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    224a:	ldrb	r1, [r0, #20]
    224c:	cmp	r3, #16
    224e:	ldrb	r2, [r0, #19]
    2250:	orr.w	r2, r2, r1, lsl #8
    2254:	ble.w	23e2 <BNO080::parseInputReport()+0x23e>
    2258:	ldrb	r3, [r0, #21]
    225a:	ldrb	r1, [r0, #22]
    225c:	orr.w	r1, r3, r1, lsl #8
    2260:	ldrb	r3, [r0, #9]
    2262:	cmp	r3, #1
    2264:	bne.n	21fe <BNO080::parseInputReport()+0x5a>
    2266:	strh.w	r8, [r0, #210]	; 0xd2
    226a:	strh.w	ip, [r0, #204]	; 0xcc
    226e:	strh.w	r4, [r0, #206]	; 0xce
    2272:	strh.w	r9, [r0, #208]	; 0xd0
    2276:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    227a:	strh.w	r8, [r0, #246]	; 0xf6
    227e:	strh.w	ip, [r0, #236]	; 0xec
    2282:	strh.w	r4, [r0, #238]	; 0xee
    2286:	strh.w	r9, [r0, #240]	; 0xf0
    228a:	strh.w	r2, [r0, #242]	; 0xf2
    228e:	strh.w	r1, [r0, #244]	; 0xf4
    2292:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2296:	ldrb	r2, [r0, #4]
    2298:	orr.w	r5, r5, r6, lsl #8
    229c:	ldrb	r3, [r0, #9]
    229e:	orr.w	r4, r2, r4, lsl #8
    22a2:	ldrb	r7, [r0, #11]
    22a4:	ldrb	r2, [r0, #10]
    22a6:	orr.w	r1, r1, r3, lsl #8
    22aa:	ldrb	r6, [r0, #13]
    22ac:	ldrb	r3, [r0, #12]
    22ae:	orr.w	r7, r2, r7, lsl #8
    22b2:	ldrb.w	ip, [r0, #15]
    22b6:	orr.w	r6, r3, r6, lsl #8
    22ba:	ldrb	r2, [r0, #14]
    22bc:	ldrb.w	lr, [r0, #17]
    22c0:	ldrb	r3, [r0, #16]
    22c2:	orr.w	r2, r2, ip, lsl #8
    22c6:	strh.w	r5, [r0, #238]	; 0xee
    22ca:	orr.w	r3, r3, lr, lsl #8
    22ce:	strh.w	r4, [r0, #236]	; 0xec
    22d2:	strh.w	r1, [r0, #240]	; 0xf0
    22d6:	strh.w	r7, [r0, #242]	; 0xf2
    22da:	strh.w	r6, [r0, #248]	; 0xf8
    22de:	strh.w	r2, [r0, #250]	; 0xfa
    22e2:	strh.w	r3, [r0, #252]	; 0xfc
    22e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    22ea:	strh.w	r8, [r0, #218]	; 0xda
    22ee:	strh.w	ip, [r0, #212]	; 0xd4
    22f2:	strh.w	r4, [r0, #214]	; 0xd6
    22f6:	strh.w	r9, [r0, #216]	; 0xd8
    22fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    22fe:	strh.w	r8, [r0, #226]	; 0xe2
    2302:	strh.w	ip, [r0, #220]	; 0xdc
    2306:	strh.w	r4, [r0, #222]	; 0xde
    230a:	strh.w	r9, [r0, #224]	; 0xe0
    230e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2312:	strh.w	r8, [r0, #234]	; 0xea
    2316:	strh.w	ip, [r0, #228]	; 0xe4
    231a:	strh.w	r4, [r0, #230]	; 0xe6
    231e:	strh.w	r9, [r0, #232]	; 0xe8
    2322:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2326:	strh.w	r9, [r0, #254]	; 0xfe
    232a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    232e:	strh.w	ip, [r0, #282]	; 0x11a
    2332:	strh.w	r4, [r0, #284]	; 0x11c
    2336:	strh.w	r9, [r0, #286]	; 0x11e
    233a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    233e:	mvn.w	r1, #14
    2342:	add.w	r2, r0, #15
    2346:	add.w	r4, r0, #23
    234a:	strb.w	r6, [r0, #261]	; 0x105
    234e:	subs	r1, r1, r0
    2350:	b.n	2356 <BNO080::parseInputReport()+0x1b2>
    2352:	ldrb.w	r5, [r2, #1]!
    2356:	ldr.w	r3, [r0, #264]	; 0x108
    235a:	cmp	r2, r4
    235c:	add	r3, r2
    235e:	strb	r5, [r3, r1]
    2360:	bne.n	2352 <BNO080::parseInputReport()+0x1ae>
    2362:	b.n	2246 <BNO080::parseInputReport()+0xa2>
    2364:	strb.w	r7, [r0, #260]	; 0x104
    2368:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    236c:	strh.w	ip, [r0, #270]	; 0x10e
    2370:	strh.w	r4, [r0, #272]	; 0x110
    2374:	strh.w	r9, [r0, #274]	; 0x112
    2378:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    237c:	ldrb.w	r3, [r0, #188]	; 0xbc
    2380:	mov	r4, r0
    2382:	cbnz	r3, 23a4 <BNO080::parseInputReport()+0x200>
    2384:	cmp.w	lr, #7
    2388:	bne.w	2246 <BNO080::parseInputReport()+0xa2>
    238c:	strb.w	r6, [r4, #268]	; 0x10c
    2390:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2394:	strh.w	ip, [r0, #276]	; 0x114
    2398:	strh.w	r4, [r0, #278]	; 0x116
    239c:	strh.w	r9, [r0, #280]	; 0x118
    23a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    23a4:	ldr.w	r5, [r0, #184]	; 0xb8
    23a8:	movs	r2, #1
    23aa:	ldr	r1, [pc, #60]	; (23e8 <BNO080::parseInputReport()+0x244>)
    23ac:	ldr	r3, [r5, #0]
    23ae:	mov	r0, r5
    23b0:	ldr	r3, [r3, #4]
    23b2:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    23b4:	mov	r0, r5
    23b6:	bl	4e74 <Print::println()>
    23ba:	ldrb	r3, [r4, #11]
    23bc:	cmp	r3, #7
    23be:	bne.w	2246 <BNO080::parseInputReport()+0xa2>
    23c2:	ldrb.w	r3, [r4, #188]	; 0xbc
    23c6:	cbz	r3, 23de <BNO080::parseInputReport()+0x23a>
    23c8:	ldr.w	r5, [r4, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    23cc:	movs	r2, #20
    23ce:	ldr	r1, [pc, #28]	; (23ec <BNO080::parseInputReport()+0x248>)
    23d0:	ldr	r3, [r5, #0]
    23d2:	mov	r0, r5
    23d4:	ldr	r3, [r3, #4]
    23d6:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    23d8:	mov	r0, r5
    23da:	bl	4e74 <Print::println()>
    23de:	ldrb	r6, [r4, #14]
    23e0:	b.n	238c <BNO080::parseInputReport()+0x1e8>
    23e2:	movs	r1, #0
    23e4:	b.n	21f8 <BNO080::parseInputReport()+0x54>
    23e6:	nop
    23e8:	.word	0x20000484
    23ec:	.word	0x20000488

000023f0 <BNO080::getQuatI()>:
    23f0:	push	{r3, lr}
    23f2:	ldrsh.w	r2, [r0, #236]	; 0xec
    23f6:	vmov.f64	d0, #0	; 0x40000000  2.0
    23fa:	ldrb.w	r3, [r0, #288]	; 0x120
    23fe:	vmov	s14, r2
    2402:	negs	r3, r3
    2404:	vpush	{d8}
    2408:	vmov	s2, r3
    240c:	vcvt.f32.s32	s16, s14
    2410:	vcvt.f64.s32	d1, s2
    2414:	bl	52d8 <pow>
    2418:	vcvt.f64.f32	d7, s16
    241c:	vpop	{d8}
    2420:	vmul.f64	d0, d7, d0
    2424:	vcvt.f32.f64	s0, d0
    2428:	pop	{r3, pc}
    242a:	nop

0000242c <BNO080::getQuatJ()>:
    242c:	push	{r3, lr}
    242e:	ldrsh.w	r2, [r0, #238]	; 0xee
    2432:	vmov.f64	d0, #0	; 0x40000000  2.0
    2436:	ldrb.w	r3, [r0, #288]	; 0x120
    243a:	vmov	s14, r2
    243e:	negs	r3, r3
    2440:	vpush	{d8}
    2444:	vmov	s2, r3
    2448:	vcvt.f32.s32	s16, s14
    244c:	vcvt.f64.s32	d1, s2
    2450:	bl	52d8 <pow>
    2454:	vcvt.f64.f32	d7, s16
    2458:	vpop	{d8}
    245c:	vmul.f64	d0, d7, d0
    2460:	vcvt.f32.f64	s0, d0
    2464:	pop	{r3, pc}
    2466:	nop

00002468 <BNO080::getQuatK()>:
    2468:	push	{r3, lr}
    246a:	ldrsh.w	r2, [r0, #240]	; 0xf0
    246e:	vmov.f64	d0, #0	; 0x40000000  2.0
    2472:	ldrb.w	r3, [r0, #288]	; 0x120
    2476:	vmov	s14, r2
    247a:	negs	r3, r3
    247c:	vpush	{d8}
    2480:	vmov	s2, r3
    2484:	vcvt.f32.s32	s16, s14
    2488:	vcvt.f64.s32	d1, s2
    248c:	bl	52d8 <pow>
    2490:	vcvt.f64.f32	d7, s16
    2494:	vpop	{d8}
    2498:	vmul.f64	d0, d7, d0
    249c:	vcvt.f32.f64	s0, d0
    24a0:	pop	{r3, pc}
    24a2:	nop

000024a4 <BNO080::getQuatReal()>:
    24a4:	push	{r3, lr}
    24a6:	ldrsh.w	r2, [r0, #242]	; 0xf2
    24aa:	vmov.f64	d0, #0	; 0x40000000  2.0
    24ae:	ldrb.w	r3, [r0, #288]	; 0x120
    24b2:	vmov	s14, r2
    24b6:	negs	r3, r3
    24b8:	vpush	{d8}
    24bc:	vmov	s2, r3
    24c0:	vcvt.f32.s32	s16, s14
    24c4:	vcvt.f64.s32	d1, s2
    24c8:	bl	52d8 <pow>
    24cc:	vcvt.f64.f32	d7, s16
    24d0:	vpop	{d8}
    24d4:	vmul.f64	d0, d7, d0
    24d8:	vcvt.f32.f64	s0, d0
    24dc:	pop	{r3, pc}
    24de:	nop

000024e0 <BNO080::getQuatRadianAccuracy()>:
    24e0:	push	{r3, lr}
    24e2:	ldrsh.w	r2, [r0, #244]	; 0xf4
    24e6:	vmov.f64	d0, #0	; 0x40000000  2.0
    24ea:	ldrb.w	r3, [r0, #290]	; 0x122
    24ee:	vmov	s14, r2
    24f2:	negs	r3, r3
    24f4:	vpush	{d8}
    24f8:	vmov	s2, r3
    24fc:	vcvt.f32.s32	s16, s14
    2500:	vcvt.f64.s32	d1, s2
    2504:	bl	52d8 <pow>
    2508:	vcvt.f64.f32	d7, s16
    250c:	vpop	{d8}
    2510:	vmul.f64	d0, d7, d0
    2514:	vcvt.f32.f64	s0, d0
    2518:	pop	{r3, pc}
    251a:	nop

0000251c <BNO080::getGyroX()>:
    251c:	push	{r3, lr}
    251e:	ldrsh.w	r2, [r0, #220]	; 0xdc
    2522:	vmov.f64	d0, #0	; 0x40000000  2.0
    2526:	ldrb.w	r3, [r0, #296]	; 0x128
    252a:	vmov	s14, r2
    252e:	negs	r3, r3
    2530:	vpush	{d8}
    2534:	vmov	s2, r3
    2538:	vcvt.f32.s32	s16, s14
    253c:	vcvt.f64.s32	d1, s2
    2540:	bl	52d8 <pow>
    2544:	vcvt.f64.f32	d7, s16
    2548:	vpop	{d8}
    254c:	vmul.f64	d0, d7, d0
    2550:	vcvt.f32.f64	s0, d0
    2554:	pop	{r3, pc}
    2556:	nop

00002558 <BNO080::getGyroY()>:
    2558:	push	{r3, lr}
    255a:	ldrsh.w	r2, [r0, #222]	; 0xde
    255e:	vmov.f64	d0, #0	; 0x40000000  2.0
    2562:	ldrb.w	r3, [r0, #296]	; 0x128
    2566:	vmov	s14, r2
    256a:	negs	r3, r3
    256c:	vpush	{d8}
    2570:	vmov	s2, r3
    2574:	vcvt.f32.s32	s16, s14
    2578:	vcvt.f64.s32	d1, s2
    257c:	bl	52d8 <pow>
    2580:	vcvt.f64.f32	d7, s16
    2584:	vpop	{d8}
    2588:	vmul.f64	d0, d7, d0
    258c:	vcvt.f32.f64	s0, d0
    2590:	pop	{r3, pc}
    2592:	nop

00002594 <BNO080::getGyroZ()>:
    2594:	push	{r3, lr}
    2596:	ldrsh.w	r2, [r0, #224]	; 0xe0
    259a:	vmov.f64	d0, #0	; 0x40000000  2.0
    259e:	ldrb.w	r3, [r0, #296]	; 0x128
    25a2:	vmov	s14, r2
    25a6:	negs	r3, r3
    25a8:	vpush	{d8}
    25ac:	vmov	s2, r3
    25b0:	vcvt.f32.s32	s16, s14
    25b4:	vcvt.f64.s32	d1, s2
    25b8:	bl	52d8 <pow>
    25bc:	vcvt.f64.f32	d7, s16
    25c0:	vpop	{d8}
    25c4:	vmul.f64	d0, d7, d0
    25c8:	vcvt.f32.f64	s0, d0
    25cc:	pop	{r3, pc}
    25ce:	nop

000025d0 <BNO080::waitForI2C()>:
    25d0:	push	{r4, r5, r6, lr}
    25d2:	mov	r5, r0
    25d4:	movs	r4, #100	; 0x64
    25d6:	ldr	r6, [pc, #92]	; (2634 <BNO080::waitForI2C()+0x64>)
    25d8:	b.n	25f6 <BNO080::waitForI2C()+0x26>
    25da:	ldrb.w	r3, [r0, #59]	; 0x3b
    25de:	ldrb.w	r2, [r0, #58]	; 0x3a
    25e2:	movs	r0, #1
    25e4:	subs	r3, r3, r2
    25e6:	cmp	r3, #0
    25e8:	bgt.n	260c <BNO080::waitForI2C()+0x3c>
    25ea:	bl	4348 <delay>
    25ee:	subs	r3, r4, #1
    25f0:	ands.w	r4, r3, #255	; 0xff
    25f4:	beq.n	2610 <BNO080::waitForI2C()+0x40>
    25f6:	ldr.w	r0, [r5, #176]	; 0xb0
    25fa:	ldr	r3, [r0, #0]
    25fc:	ldr	r3, [r3, #16]
    25fe:	cmp	r3, r6
    2600:	beq.n	25da <BNO080::waitForI2C()+0xa>
    2602:	blx	r3
    2604:	mov	r3, r0
    2606:	movs	r0, #1
    2608:	cmp	r3, #0
    260a:	ble.n	25ea <BNO080::waitForI2C()+0x1a>
    260c:	movs	r0, #1
    260e:	pop	{r4, r5, r6, pc}
    2610:	ldrb.w	r0, [r5, #188]	; 0xbc
    2614:	cmp	r0, #0
    2616:	beq.n	260e <BNO080::waitForI2C()+0x3e>
    2618:	ldr.w	r5, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    261c:	movs	r2, #11
    261e:	ldr	r1, [pc, #24]	; (2638 <BNO080::waitForI2C()+0x68>)
    2620:	ldr	r3, [r5, #0]
    2622:	mov	r0, r5
    2624:	ldr	r3, [r3, #4]
    2626:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    2628:	mov	r0, r5
    262a:	bl	4e74 <Print::println()>
    262e:	mov	r0, r4
    2630:	pop	{r4, r5, r6, pc}
    2632:	nop
    2634:	.word	0x00001f2d
    2638:	.word	0x200004a0

0000263c <BNO080::getData(unsigned short)>:
    263c:	cmp	r1, #0
    263e:	beq.w	2782 <BNO080::getData(unsigned short)+0x146>
    2642:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2646:	mov	r6, r0
    2648:	mov	r9, r1
    264a:	movs	r5, #0
    264c:	ldr	r7, [pc, #312]	; (2788 <BNO080::getData(unsigned short)+0x14c>)
    264e:	cmp.w	r9, #28
    2652:	mov	r8, r9
    2654:	mov.w	r3, #1
    2658:	ldrb.w	r1, [r6, #180]	; 0xb4
    265c:	it	cs
    265e:	movcs.w	r8, #28
    2662:	ldr.w	r0, [r6, #176]	; 0xb0
    2666:	add.w	r2, r8, #4
    266a:	uxtb	r2, r2
    266c:	bl	2cb4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
    2670:	mov	r0, r6
    2672:	bl	25d0 <BNO080::waitForI2C()>
    2676:	cmp	r0, #0
    2678:	beq.w	277e <BNO080::getData(unsigned short)+0x142>
    267c:	ldr.w	r0, [r6, #176]	; 0xb0
    2680:	ldr	r3, [r0, #0]
    2682:	ldr	r3, [r3, #20]
    2684:	cmp	r3, r7
    2686:	bne.n	2772 <BNO080::getData(unsigned short)+0x136>
    2688:	ldrb.w	r2, [r0, #58]	; 0x3a
    268c:	ldrb.w	r1, [r0, #59]	; 0x3b
    2690:	cmp	r1, r2
    2692:	bls.n	26a2 <BNO080::getData(unsigned short)+0x66>
    2694:	adds	r2, #1
    2696:	strb.w	r2, [r0, #58]	; 0x3a
    269a:	ldr.w	r0, [r6, #176]	; 0xb0
    269e:	ldr	r3, [r0, #0]
    26a0:	ldr	r3, [r3, #20]
    26a2:	cmp	r3, r7
    26a4:	bne.n	2766 <BNO080::getData(unsigned short)+0x12a>
    26a6:	ldrb.w	r2, [r0, #58]	; 0x3a
    26aa:	ldrb.w	r1, [r0, #59]	; 0x3b
    26ae:	cmp	r1, r2
    26b0:	bls.n	2756 <BNO080::getData(unsigned short)+0x11a>
    26b2:	adds	r2, #1
    26b4:	strb.w	r2, [r0, #58]	; 0x3a
    26b8:	ldr.w	r0, [r6, #176]	; 0xb0
    26bc:	ldr	r3, [r0, #0]
    26be:	ldr	r3, [r3, #20]
    26c0:	cmp	r3, r7
    26c2:	bne.n	2762 <BNO080::getData(unsigned short)+0x126>
    26c4:	ldrb.w	r2, [r0, #58]	; 0x3a
    26c8:	ldrb.w	r1, [r0, #59]	; 0x3b
    26cc:	cmp	r1, r2
    26ce:	bls.n	2756 <BNO080::getData(unsigned short)+0x11a>
    26d0:	adds	r2, #1
    26d2:	strb.w	r2, [r0, #58]	; 0x3a
    26d6:	ldr.w	r0, [r6, #176]	; 0xb0
    26da:	ldr	r3, [r0, #0]
    26dc:	ldr	r3, [r3, #20]
    26de:	cmp	r3, r7
    26e0:	bne.n	275a <BNO080::getData(unsigned short)+0x11e>
    26e2:	ldrb.w	r3, [r0, #58]	; 0x3a
    26e6:	ldrb.w	r2, [r0, #59]	; 0x3b
    26ea:	cmp	r2, r3
    26ec:	bls.n	26f8 <BNO080::getData(unsigned short)+0xbc>
    26ee:	adds	r3, #1
    26f0:	strb.w	r3, [r0, #58]	; 0x3a
    26f4:	ldr.w	r0, [r6, #176]	; 0xb0
    26f8:	movs	r4, #0
    26fa:	b.n	2730 <BNO080::getData(unsigned short)+0xf4>
    26fc:	ldrb.w	r3, [r0, #58]	; 0x3a
    2700:	ldrb.w	r2, [r0, #59]	; 0x3b
    2704:	add.w	lr, r3, #1
    2708:	adds	r1, r0, r3
    270a:	cmp	r2, r3
    270c:	bls.n	2752 <BNO080::getData(unsigned short)+0x116>
    270e:	strb.w	lr, [r0, #58]	; 0x3a
    2712:	ldrb	r0, [r1, #26]
    2714:	adds	r4, #1
    2716:	cmp	r5, #127	; 0x7f
    2718:	add.w	r2, r5, #1
    271c:	add.w	r3, r6, r5
    2720:	uxtb	r4, r4
    2722:	bhi.n	2728 <BNO080::getData(unsigned short)+0xec>
    2724:	uxth	r5, r2
    2726:	strb	r0, [r3, #4]
    2728:	cmp	r4, r8
    272a:	bcs.n	273e <BNO080::getData(unsigned short)+0x102>
    272c:	ldr.w	r0, [r6, #176]	; 0xb0
    2730:	ldr	r3, [r0, #0]
    2732:	ldr	r3, [r3, #20]
    2734:	cmp	r3, r7
    2736:	beq.n	26fc <BNO080::getData(unsigned short)+0xc0>
    2738:	blx	r3
    273a:	uxtb	r0, r0
    273c:	b.n	2714 <BNO080::getData(unsigned short)+0xd8>
    273e:	rsb	r9, r8, r9
    2742:	uxth.w	r9, r9
    2746:	cmp.w	r9, #0
    274a:	bne.n	264e <BNO080::getData(unsigned short)+0x12>
    274c:	movs	r0, #1
    274e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2752:	movs	r0, #255	; 0xff
    2754:	b.n	2714 <BNO080::getData(unsigned short)+0xd8>
    2756:	cmp	r3, r7
    2758:	beq.n	26f8 <BNO080::getData(unsigned short)+0xbc>
    275a:	blx	r3
    275c:	ldr.w	r0, [r6, #176]	; 0xb0
    2760:	b.n	26f8 <BNO080::getData(unsigned short)+0xbc>
    2762:	blx	r3
    2764:	b.n	26d6 <BNO080::getData(unsigned short)+0x9a>
    2766:	blx	r3
    2768:	ldr.w	r0, [r6, #176]	; 0xb0
    276c:	ldr	r3, [r0, #0]
    276e:	ldr	r3, [r3, #20]
    2770:	b.n	26c0 <BNO080::getData(unsigned short)+0x84>
    2772:	blx	r3
    2774:	ldr.w	r0, [r6, #176]	; 0xb0
    2778:	ldr	r3, [r0, #0]
    277a:	ldr	r3, [r3, #20]
    277c:	b.n	26a2 <BNO080::getData(unsigned short)+0x66>
    277e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2782:	movs	r0, #1
    2784:	bx	lr
    2786:	nop
    2788:	.word	0x00001f39

0000278c <BNO080::receivePacket()>:
    278c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2790:	mov	r4, r0
    2792:	ldr.w	r0, [r0, #176]	; 0xb0
    2796:	cmp	r0, #0
    2798:	beq.n	288e <BNO080::receivePacket()+0x102>
    279a:	movs	r3, #1
    279c:	movs	r2, #4
    279e:	ldrb.w	r1, [r4, #180]	; 0xb4
    27a2:	bl	2cb4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
    27a6:	mov	r0, r4
    27a8:	bl	25d0 <BNO080::waitForI2C()>
    27ac:	mov	r5, r0
    27ae:	cbnz	r0, 27b8 <BNO080::receivePacket()+0x2c>
    27b0:	movs	r5, #0
    27b2:	mov	r0, r5
    27b4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    27b8:	ldr.w	r3, [r4, #176]	; 0xb0
    27bc:	ldr	r7, [pc, #592]	; (2a10 <BNO080::receivePacket()+0x284>)
    27be:	ldr	r2, [r3, #0]
    27c0:	ldr	r2, [r2, #20]
    27c2:	cmp	r2, r7
    27c4:	bne.w	29ce <BNO080::receivePacket()+0x242>
    27c8:	ldrb.w	r1, [r3, #58]	; 0x3a
    27cc:	ldrb.w	r0, [r3, #59]	; 0x3b
    27d0:	cmp	r0, r1
    27d2:	bls.w	2ac6 <BNO080::receivePacket()+0x33a>
    27d6:	adds	r2, r1, #1
    27d8:	add	r1, r3
    27da:	strb.w	r2, [r3, #58]	; 0x3a
    27de:	ldr.w	r3, [r4, #176]	; 0xb0
    27e2:	ldrb.w	r9, [r1, #26]
    27e6:	ldr	r2, [r3, #0]
    27e8:	sxth.w	sl, r9
    27ec:	ldr	r2, [r2, #20]
    27ee:	cmp	r2, r7
    27f0:	bne.w	29e4 <BNO080::receivePacket()+0x258>
    27f4:	ldrb.w	r0, [r3, #58]	; 0x3a
    27f8:	ldrb.w	r1, [r3, #59]	; 0x3b
    27fc:	cmp	r1, r0
    27fe:	bls.w	2ace <BNO080::receivePacket()+0x342>
    2802:	adds	r2, r0, #1
    2804:	add	r0, r3
    2806:	strb.w	r2, [r3, #58]	; 0x3a
    280a:	ldrb.w	fp, [r0, #26]
    280e:	ldr.w	r3, [r4, #176]	; 0xb0
    2812:	mov.w	r1, fp, lsl #8
    2816:	ldr	r2, [r3, #0]
    2818:	sxth	r6, r1
    281a:	ldr	r2, [r2, #20]
    281c:	cmp	r2, r7
    281e:	bne.w	2a06 <BNO080::receivePacket()+0x27a>
    2822:	ldrb.w	r1, [r3, #58]	; 0x3a
    2826:	ldrb.w	r0, [r3, #59]	; 0x3b
    282a:	cmp	r0, r1
    282c:	bls.w	2ad6 <BNO080::receivePacket()+0x34a>
    2830:	adds	r2, r1, #1
    2832:	add	r1, r3
    2834:	strb.w	r2, [r3, #58]	; 0x3a
    2838:	ldrb	r0, [r1, #26]
    283a:	ldr.w	r3, [r4, #176]	; 0xb0
    283e:	uxtb.w	r8, r0
    2842:	ldr	r2, [r3, #0]
    2844:	ldr	r2, [r2, #20]
    2846:	cmp	r2, r7
    2848:	bne.w	29fe <BNO080::receivePacket()+0x272>
    284c:	ldrb.w	r2, [r3, #58]	; 0x3a
    2850:	ldrb.w	r1, [r3, #59]	; 0x3b
    2854:	cmp	r1, r2
    2856:	bls.w	2ae0 <BNO080::receivePacket()+0x354>
    285a:	adds	r1, r2, #1
    285c:	add	r2, r3
    285e:	strb.w	r1, [r3, #58]	; 0x3a
    2862:	ldrb	r0, [r2, #26]
    2864:	orr.w	r1, r6, sl
    2868:	strb.w	r9, [r4]
    286c:	strb.w	fp, [r4, #1]
    2870:	ubfx	r1, r1, #0, #15
    2874:	strb.w	r8, [r4, #2]
    2878:	strb	r0, [r4, #3]
    287a:	cmp	r1, #0
    287c:	beq.n	27b0 <BNO080::receivePacket()+0x24>
    287e:	subs	r1, #4
    2880:	mov	r0, r4
    2882:	uxth	r1, r1
    2884:	bl	263c <BNO080::getData(unsigned short)>
    2888:	mov	r0, r5
    288a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    288e:	ldrb.w	r0, [r4, #202]	; 0xca
    2892:	bl	4ac4 <digitalRead>
    2896:	cmp	r0, #1
    2898:	beq.n	27b0 <BNO080::receivePacket()+0x24>
    289a:	ldr.w	r3, [r4, #192]	; 0xc0
    289e:	ldr.w	r0, [r4, #196]	; 0xc4
    28a2:	ldrb	r2, [r3, #19]
    28a4:	cmp	r2, #0
    28a6:	beq.n	2906 <BNO080::receivePacket()+0x17a>
    28a8:	cpsid	i
    28aa:	ldrb	r2, [r3, #19]
    28ac:	lsls	r7, r2, #31
    28ae:	bpl.n	28be <BNO080::receivePacket()+0x132>
    28b0:	ldr	r1, [pc, #352]	; (2a14 <BNO080::receivePacket()+0x288>)
    28b2:	ldr	r2, [r3, #20]
    28b4:	ldr	r5, [r1, #0]
    28b6:	ands	r2, r5
    28b8:	str	r2, [r3, #40]	; 0x28
    28ba:	str	r2, [r1, #0]
    28bc:	ldrb	r2, [r3, #19]
    28be:	lsls	r6, r2, #30
    28c0:	bpl.n	28d0 <BNO080::receivePacket()+0x144>
    28c2:	ldr	r1, [pc, #340]	; (2a18 <BNO080::receivePacket()+0x28c>)
    28c4:	ldr	r2, [r3, #24]
    28c6:	ldr	r5, [r1, #0]
    28c8:	ands	r2, r5
    28ca:	str	r2, [r3, #44]	; 0x2c
    28cc:	str	r2, [r1, #0]
    28ce:	ldrb	r2, [r3, #19]
    28d0:	lsls	r5, r2, #29
    28d2:	bpl.n	28e2 <BNO080::receivePacket()+0x156>
    28d4:	ldr	r1, [pc, #324]	; (2a1c <BNO080::receivePacket()+0x290>)
    28d6:	ldr	r2, [r3, #28]
    28d8:	ldr	r5, [r1, #0]
    28da:	ands	r2, r5
    28dc:	str	r2, [r3, #48]	; 0x30
    28de:	str	r2, [r1, #0]
    28e0:	ldrb	r2, [r3, #19]
    28e2:	lsls	r1, r2, #28
    28e4:	bpl.n	28f4 <BNO080::receivePacket()+0x168>
    28e6:	ldr	r1, [pc, #312]	; (2a20 <BNO080::receivePacket()+0x294>)
    28e8:	ldr	r2, [r3, #32]
    28ea:	ldr	r5, [r1, #0]
    28ec:	ands	r2, r5
    28ee:	str	r2, [r3, #52]	; 0x34
    28f0:	str	r2, [r1, #0]
    28f2:	ldrb	r2, [r3, #19]
    28f4:	lsls	r7, r2, #27
    28f6:	bpl.n	2904 <BNO080::receivePacket()+0x178>
    28f8:	ldr	r1, [pc, #296]	; (2a24 <BNO080::receivePacket()+0x298>)
    28fa:	ldr	r2, [r3, #36]	; 0x24
    28fc:	ldr	r5, [r1, #0]
    28fe:	ands	r2, r5
    2900:	str	r2, [r3, #56]	; 0x38
    2902:	str	r2, [r1, #0]
    2904:	cpsie	i
    2906:	ldr	r2, [r3, #8]
    2908:	cmp	r0, r2
    290a:	beq.w	2aba <BNO080::receivePacket()+0x32e>
    290e:	ldr	r2, [pc, #280]	; (2a28 <BNO080::receivePacket()+0x29c>)
    2910:	str	r0, [r3, #8]
    2912:	ldr	r2, [r2, #24]
    2914:	ldr	r1, [pc, #276]	; (2a2c <BNO080::receivePacket()+0x2a0>)
    2916:	ubfx	r5, r2, #4, #2
    291a:	ubfx	r2, r2, #26, #3
    291e:	ldr.w	r1, [r1, r5, lsl #2]
    2922:	adds	r2, #1
    2924:	udiv	r1, r1, r2
    2928:	cmp	r0, #0
    292a:	beq.n	2a0c <BNO080::receivePacket()+0x280>
    292c:	udiv	r2, r1, r0
    2930:	cbz	r2, 2948 <BNO080::receivePacket()+0x1bc>
    2932:	udiv	r1, r1, r2
    2936:	cmp	r0, r1
    2938:	it	cc
    293a:	addcc	r2, #1
    293c:	cmp.w	r2, #258	; 0x102
    2940:	bcc.w	2ae4 <BNO080::receivePacket()+0x358>
    2944:	movw	r2, #32767	; 0x7fff
    2948:	str	r2, [r3, #12]
    294a:	ldr	r3, [r3, #0]
    294c:	movs	r5, #0
    294e:	movs	r1, #3
    2950:	ldr	r6, [pc, #220]	; (2a30 <BNO080::receivePacket()+0x2a4>)
    2952:	movs	r0, #1
    2954:	str	r5, [r3, #16]
    2956:	str	r1, [r3, #36]	; 0x24
    2958:	mov	r1, r5
    295a:	str	r2, [r3, #64]	; 0x40
    295c:	str	r6, [r3, #96]	; 0x60
    295e:	str	r0, [r3, #16]
    2960:	ldrb.w	r0, [r4, #200]	; 0xc8
    2964:	bl	4ab8 <digitalWrite>
    2968:	ldr.w	r6, [r4, #192]	; 0xc0
    296c:	ldr	r3, [r6, #0]
    296e:	str	r5, [r3, #100]	; 0x64
    2970:	ldr	r2, [r3, #92]	; 0x5c
    2972:	tst.w	r2, #2031616	; 0x1f0000
    2976:	beq.n	2970 <BNO080::receivePacket()+0x1e4>
    2978:	ldr	r1, [r3, #116]	; 0x74
    297a:	movs	r2, #0
    297c:	uxtb	r1, r1
    297e:	str	r2, [r3, #100]	; 0x64
    2980:	ldr	r2, [r3, #92]	; 0x5c
    2982:	tst.w	r2, #2031616	; 0x1f0000
    2986:	beq.n	2980 <BNO080::receivePacket()+0x1f4>
    2988:	ldr	r5, [r3, #116]	; 0x74
    298a:	movs	r2, #0
    298c:	uxtb	r7, r5
    298e:	str	r2, [r3, #100]	; 0x64
    2990:	ldr	r2, [r3, #92]	; 0x5c
    2992:	tst.w	r2, #2031616	; 0x1f0000
    2996:	beq.n	2990 <BNO080::receivePacket()+0x204>
    2998:	ldr	r0, [r3, #116]	; 0x74
    299a:	movs	r2, #0
    299c:	uxtb	r0, r0
    299e:	str	r2, [r3, #100]	; 0x64
    29a0:	ldr	r2, [r3, #92]	; 0x5c
    29a2:	tst.w	r2, #2031616	; 0x1f0000
    29a6:	beq.n	29a0 <BNO080::receivePacket()+0x214>
    29a8:	lsls	r5, r5, #8
    29aa:	ldr	r3, [r3, #116]	; 0x74
    29ac:	strb	r1, [r4, #0]
    29ae:	and.w	r5, r5, #32512	; 0x7f00
    29b2:	strb	r3, [r4, #3]
    29b4:	strb	r7, [r4, #1]
    29b6:	orrs	r5, r1
    29b8:	strb	r0, [r4, #2]
    29ba:	bne.n	2a34 <BNO080::receivePacket()+0x2a8>
    29bc:	ldrb.w	r3, [r4, #188]	; 0xbc
    29c0:	cmp	r3, #0
    29c2:	beq.w	27b0 <BNO080::receivePacket()+0x24>
    29c6:	mov	r0, r4
    29c8:	bl	1f58 <BNO080::printHeader() [clone .part.7]>
    29cc:	b.n	27b2 <BNO080::receivePacket()+0x26>
    29ce:	mov	r0, r3
    29d0:	blx	r2
    29d2:	ldr.w	r3, [r4, #176]	; 0xb0
    29d6:	uxtb.w	r9, r0
    29da:	ldr	r2, [r3, #0]
    29dc:	sxth.w	sl, r9
    29e0:	ldr	r2, [r2, #20]
    29e2:	b.n	27ee <BNO080::receivePacket()+0x62>
    29e4:	mov	r0, r3
    29e6:	blx	r2
    29e8:	ldr.w	r3, [r4, #176]	; 0xb0
    29ec:	lsls	r1, r0, #8
    29ee:	ldr	r2, [r3, #0]
    29f0:	uxtb.w	fp, r0
    29f4:	sxth	r6, r1
    29f6:	ldr	r2, [r2, #20]
    29f8:	b.n	281c <BNO080::receivePacket()+0x90>
    29fa:	mov.w	r8, #255	; 0xff
    29fe:	mov	r0, r3
    2a00:	blx	r2
    2a02:	uxtb	r0, r0
    2a04:	b.n	2864 <BNO080::receivePacket()+0xd8>
    2a06:	mov	r0, r3
    2a08:	blx	r2
    2a0a:	b.n	283a <BNO080::receivePacket()+0xae>
    2a0c:	mov	r2, r1
    2a0e:	b.n	2930 <BNO080::receivePacket()+0x1a4>
    2a10:	.word	0x00001f39
    2a14:	.word	0xe000e180
    2a18:	.word	0xe000e184
    2a1c:	.word	0xe000e188
    2a20:	.word	0xe000e18c
    2a24:	.word	0xe000e190
    2a28:	.word	0x400fc000
    2a2c:	.word	0x200003e8
    2a30:	.word	0xc0000007
    2a34:	subs	r5, #4
    2a36:	uxth	r0, r5
    2a38:	cbz	r0, 2a64 <BNO080::receivePacket()+0x2d8>
    2a3a:	adds	r5, r4, #4
    2a3c:	movs	r1, #0
    2a3e:	movs	r7, #255	; 0xff
    2a40:	ldr	r2, [r6, #0]
    2a42:	str	r7, [r2, #100]	; 0x64
    2a44:	ldr	r3, [r2, #92]	; 0x5c
    2a46:	tst.w	r3, #2031616	; 0x1f0000
    2a4a:	beq.n	2a44 <BNO080::receivePacket()+0x2b8>
    2a4c:	cmp	r1, #127	; 0x7f
    2a4e:	ldr	r3, [r2, #116]	; 0x74
    2a50:	add.w	r1, r1, #1
    2a54:	add.w	r5, r5, #1
    2a58:	it	ls
    2a5a:	strbls.w	r3, [r5, #-1]
    2a5e:	uxth	r3, r1
    2a60:	cmp	r0, r3
    2a62:	bhi.n	2a40 <BNO080::receivePacket()+0x2b4>
    2a64:	movs	r1, #1
    2a66:	ldrb.w	r0, [r4, #200]	; 0xc8
    2a6a:	bl	4ab8 <digitalWrite>
    2a6e:	ldr.w	r2, [r4, #192]	; 0xc0
    2a72:	ldrb	r3, [r2, #19]
    2a74:	cbz	r3, 2ab0 <BNO080::receivePacket()+0x324>
    2a76:	lsls	r6, r3, #31
    2a78:	bpl.n	2a82 <BNO080::receivePacket()+0x2f6>
    2a7a:	ldr	r3, [pc, #124]	; (2af8 <BNO080::receivePacket()+0x36c>)
    2a7c:	ldr	r1, [r2, #40]	; 0x28
    2a7e:	str	r1, [r3, #0]
    2a80:	ldrb	r3, [r2, #19]
    2a82:	lsls	r5, r3, #30
    2a84:	bpl.n	2a8e <BNO080::receivePacket()+0x302>
    2a86:	ldr	r3, [pc, #116]	; (2afc <BNO080::receivePacket()+0x370>)
    2a88:	ldr	r1, [r2, #44]	; 0x2c
    2a8a:	str	r1, [r3, #0]
    2a8c:	ldrb	r3, [r2, #19]
    2a8e:	lsls	r0, r3, #29
    2a90:	bpl.n	2a9a <BNO080::receivePacket()+0x30e>
    2a92:	ldr	r3, [pc, #108]	; (2b00 <BNO080::receivePacket()+0x374>)
    2a94:	ldr	r1, [r2, #48]	; 0x30
    2a96:	str	r1, [r3, #0]
    2a98:	ldrb	r3, [r2, #19]
    2a9a:	lsls	r1, r3, #28
    2a9c:	bpl.n	2aa6 <BNO080::receivePacket()+0x31a>
    2a9e:	ldr	r3, [pc, #100]	; (2b04 <BNO080::receivePacket()+0x378>)
    2aa0:	ldr	r1, [r2, #52]	; 0x34
    2aa2:	str	r1, [r3, #0]
    2aa4:	ldrb	r3, [r2, #19]
    2aa6:	lsls	r3, r3, #27
    2aa8:	bpl.n	2ab0 <BNO080::receivePacket()+0x324>
    2aaa:	ldr	r2, [r2, #56]	; 0x38
    2aac:	ldr	r3, [pc, #88]	; (2b08 <BNO080::receivePacket()+0x37c>)
    2aae:	str	r2, [r3, #0]
    2ab0:	ldrb.w	r5, [r4, #188]	; 0xbc
    2ab4:	cbnz	r5, 2abe <BNO080::receivePacket()+0x332>
    2ab6:	movs	r5, #1
    2ab8:	b.n	27b2 <BNO080::receivePacket()+0x26>
    2aba:	ldr	r2, [r3, #12]
    2abc:	b.n	294a <BNO080::receivePacket()+0x1be>
    2abe:	mov	r0, r4
    2ac0:	bl	1fc0 <BNO080::printPacket() [clone .part.6]>
    2ac4:	b.n	27b2 <BNO080::receivePacket()+0x26>
    2ac6:	mov.w	sl, #255	; 0xff
    2aca:	mov	r9, sl
    2acc:	b.n	27ee <BNO080::receivePacket()+0x62>
    2ace:	mvn.w	r6, #255	; 0xff
    2ad2:	mov.w	fp, #255	; 0xff
    2ad6:	cmp	r2, r7
    2ad8:	bne.n	29fa <BNO080::receivePacket()+0x26e>
    2ada:	movs	r0, #255	; 0xff
    2adc:	mov	r8, r0
    2ade:	b.n	2864 <BNO080::receivePacket()+0xd8>
    2ae0:	movs	r0, #255	; 0xff
    2ae2:	b.n	2864 <BNO080::receivePacket()+0xd8>
    2ae4:	cmp	r2, #2
    2ae6:	bls.n	2af2 <BNO080::receivePacket()+0x366>
    2ae8:	subs	r2, #2
    2aea:	lsrs	r1, r2, #1
    2aec:	orr.w	r2, r2, r1, lsl #8
    2af0:	b.n	2948 <BNO080::receivePacket()+0x1bc>
    2af2:	movs	r2, #0
    2af4:	b.n	2948 <BNO080::receivePacket()+0x1bc>
    2af6:	nop
    2af8:	.word	0xe000e100
    2afc:	.word	0xe000e104
    2b00:	.word	0xe000e108
    2b04:	.word	0xe000e10c
    2b08:	.word	0xe000e110

00002b0c <BNO080::dataAvailable()>:
    2b0c:	push	{r3, r4, r5, lr}
    2b0e:	mov	r4, r0
    2b10:	ldrb.w	r0, [r0, #202]	; 0xca
    2b14:	cmp	r0, #255	; 0xff
    2b16:	beq.n	2b20 <BNO080::dataAvailable()+0x14>
    2b18:	bl	4ac4 <digitalRead>
    2b1c:	cmp	r0, #1
    2b1e:	beq.n	2b38 <BNO080::dataAvailable()+0x2c>
    2b20:	mov	r0, r4
    2b22:	bl	278c <BNO080::receivePacket()>
    2b26:	mov	r5, r0
    2b28:	cbz	r0, 2b38 <BNO080::dataAvailable()+0x2c>
    2b2a:	ldrb	r3, [r4, #2]
    2b2c:	cmp	r3, #3
    2b2e:	beq.n	2b3e <BNO080::dataAvailable()+0x32>
    2b30:	cmp	r3, #2
    2b32:	beq.n	2b4c <BNO080::dataAvailable()+0x40>
    2b34:	cmp	r3, #5
    2b36:	beq.n	2b44 <BNO080::dataAvailable()+0x38>
    2b38:	movs	r5, #0
    2b3a:	mov	r0, r5
    2b3c:	pop	{r3, r4, r5, pc}
    2b3e:	ldrb	r3, [r4, #4]
    2b40:	cmp	r3, #251	; 0xfb
    2b42:	bne.n	2b38 <BNO080::dataAvailable()+0x2c>
    2b44:	mov	r0, r4
    2b46:	bl	21a4 <BNO080::parseInputReport()>
    2b4a:	b.n	2b3a <BNO080::dataAvailable()+0x2e>
    2b4c:	ldrb	r3, [r4, #4]
    2b4e:	cmp	r3, #241	; 0xf1
    2b50:	bne.n	2b3a <BNO080::dataAvailable()+0x2e>
    2b52:	ldrb	r3, [r4, #6]
    2b54:	cmp	r3, #7
    2b56:	bne.n	2b3a <BNO080::dataAvailable()+0x2e>
    2b58:	ldrb	r3, [r4, #9]
    2b5a:	strb.w	r3, [r4, #268]	; 0x10c
    2b5e:	b.n	2b3a <BNO080::dataAvailable()+0x2e>

00002b60 <TwoWire::force_clock()>:
    2b60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2b64:	mov	fp, r0
    2b66:	ldr	r0, [pc, #256]	; (2c68 <TwoWire::force_clock()+0x108>)
    2b68:	sub	sp, #12
    2b6a:	movs	r5, #21
    2b6c:	ldr.w	sl, [fp, #20]
    2b70:	ldrb.w	r6, [fp, #24]
    2b74:	ldrb.w	r3, [fp, #25]
    2b78:	add.w	r6, sl, r6, lsl #4
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2b7c:	ldr	r1, [pc, #236]	; (2c6c <TwoWire::force_clock()+0x10c>)
    2b7e:	add.w	r3, sl, r3, lsl #4
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2b82:	ldr.w	lr, [pc, #236]	; 2c70 <TwoWire::force_clock()+0x110>
    2b86:	ldrb	r6, [r6, #8]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2b88:	mov	r4, r1
    2b8a:	ldrb.w	r3, [r3, #40]	; 0x28
    2b8e:	lsls	r6, r6, #4

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2b90:	ldr.w	r9, [pc, #224]	; 2c74 <TwoWire::force_clock()+0x114>
    2b94:	lsls	r3, r3, #4
    2b96:	adds	r7, r0, r6
    2b98:	ldr.w	r8, [r0, r6]
    2b9c:	add.w	ip, r0, r3
    2ba0:	ldr	r6, [r0, r3]
    2ba2:	ldr	r0, [r7, #12]
    2ba4:	ldr	r3, [r7, #4]
    2ba6:	ldr.w	r7, [ip, #12]
    2baa:	str	r3, [sp, #0]
    2bac:	str	r5, [r3, #0]
    2bae:	str.w	r0, [r8, #132]	; 0x84
    2bb2:	ldr.w	r3, [r8, #4]
    2bb6:	ldr.w	r2, [ip, #4]
    2bba:	orrs	r3, r0
    2bbc:	str	r2, [sp, #4]
    2bbe:	str.w	r3, [r8, #4]
    2bc2:	str	r5, [r2, #0]
    2bc4:	str.w	r7, [r6, #132]	; 0x84
    2bc8:	ldr	r3, [r6, #4]
    2bca:	orrs	r3, r7
    2bcc:	str	r3, [r6, #4]
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2bce:	ldr	r1, [r1, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2bd0:	ldr.w	r3, [lr]
    2bd4:	umull	r3, r2, r9, r3
    2bd8:	lsrs	r2, r2, #18
    2bda:	add.w	r2, r2, r2, lsl #2
    2bde:	lsls	r2, r2, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2be0:	ldr	r3, [r4, #0]
    2be2:	subs	r3, r3, r1
    2be4:	cmp	r2, r3
    2be6:	bhi.n	2be0 <TwoWire::force_clock()+0x80>
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2be8:	ldr	r2, [pc, #128]	; (2c6c <TwoWire::force_clock()+0x10c>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2bea:	movs	r5, #9

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2bec:	ldr.w	ip, [pc, #132]	; 2c74 <TwoWire::force_clock()+0x114>
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2bf0:	mov	r9, r2
    2bf2:	ldr.w	r3, [r8, #8]
    2bf6:	tst	r0, r3
    2bf8:	beq.n	2c00 <TwoWire::force_clock()+0xa0>
    2bfa:	ldr	r3, [r6, #8]
    2bfc:	tst	r7, r3
    2bfe:	bne.n	2c64 <TwoWire::force_clock()+0x104>
    2c00:	str.w	r7, [r6, #136]	; 0x88
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2c04:	ldr	r4, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2c06:	ldr.w	r1, [lr]
    2c0a:	umull	r3, r1, ip, r1
    2c0e:	lsrs	r1, r1, #18
    2c10:	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2c14:	ldr	r3, [r2, #0]
    2c16:	subs	r3, r3, r4
    2c18:	cmp	r1, r3
    2c1a:	bhi.n	2c14 <TwoWire::force_clock()+0xb4>
    2c1c:	str.w	r7, [r6, #132]	; 0x84
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2c20:	ldr.w	r4, [r9]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2c24:	ldr.w	r1, [lr]
    2c28:	umull	r3, r1, ip, r1
    2c2c:	lsrs	r1, r1, #18
    2c2e:	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2c32:	ldr	r3, [r2, #0]
    2c34:	subs	r3, r3, r4
    2c36:	cmp	r1, r3
    2c38:	bhi.n	2c32 <TwoWire::force_clock()+0xd2>
    2c3a:	subs	r5, #1
    2c3c:	bne.n	2bf2 <TwoWire::force_clock()+0x92>
    2c3e:	mov	r0, r5
    2c40:	ldrb.w	r3, [fp, #24]
    2c44:	ldr	r2, [sp, #0]
    2c46:	add.w	r3, sl, r3, lsl #4
    2c4a:	ldr	r3, [r3, #12]
    2c4c:	str	r3, [r2, #0]
    2c4e:	ldrb.w	r3, [fp, #25]
    2c52:	ldr	r2, [sp, #4]
    2c54:	add.w	sl, sl, r3, lsl #4
    2c58:	ldr.w	r3, [sl, #44]	; 0x2c
    2c5c:	str	r3, [r2, #0]
    2c5e:	add	sp, #12
    2c60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2c64:	movs	r0, #1
    2c66:	b.n	2c40 <TwoWire::force_clock()+0xe0>
    2c68:	.word	0x20000618
    2c6c:	.word	0xe0001004
    2c70:	.word	0x2000125c
    2c74:	.word	0x431bde83

00002c78 <TwoWire::wait_idle()>:
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
    2c78:	ldr	r1, [pc, #52]	; (2cb0 <TwoWire::wait_idle()+0x38>)
    2c7a:	ldr	r2, [r0, #16]
    2c7c:	push	{r4, lr}
    2c7e:	ldr	r4, [r1, #0]
    2c80:	b.n	2c8e <TwoWire::wait_idle()+0x16>
    2c82:	lsls	r3, r3, #7
    2c84:	bmi.n	2c96 <TwoWire::wait_idle()+0x1e>
    2c86:	ldr	r3, [r1, #0]
    2c88:	subs	r3, r3, r4
    2c8a:	cmp	r3, #16
    2c8c:	bhi.n	2ca0 <TwoWire::wait_idle()+0x28>
    2c8e:	ldr	r3, [r2, #20]
    2c90:	tst.w	r3, #33554432	; 0x2000000
    2c94:	bne.n	2c82 <TwoWire::wait_idle()+0xa>
    2c96:	mov.w	r3, #32512	; 0x7f00
    2c9a:	movs	r0, #1
    2c9c:	str	r3, [r2, #20]
    2c9e:	pop	{r4, pc}
    2ca0:	mov	r4, r0
    2ca2:	bl	2b60 <TwoWire::force_clock()>
    2ca6:	cmp	r0, #0
    2ca8:	beq.n	2c9e <TwoWire::wait_idle()+0x26>
    2caa:	ldr	r2, [r4, #16]
    2cac:	b.n	2c96 <TwoWire::wait_idle()+0x1e>
    2cae:	nop
    2cb0:	.word	0x20002404

00002cb4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
    2cb4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2cb8:	mov	r4, r1
    2cba:	mov	r5, r2
    2cbc:	mov	r8, r3
    2cbe:	mov	r9, r0
    2cc0:	bl	2c78 <TwoWire::wait_idle()>
    2cc4:	cbnz	r0, 2ccc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18>
    2cc6:	movs	r0, #4
    2cc8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2ccc:	movs	r2, #0
    2cce:	lsls	r3, r4, #1
    2cd0:	cmp	r5, #0
    2cd2:	movw	sl, #1025	; 0x401
    2cd6:	mov	r4, r2
    2cd8:	uxtb	r3, r3
    2cda:	ldr	r6, [pc, #244]	; (2dd0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>)
    2cdc:	it	eq
    2cde:	moveq	r5, #1
    2ce0:	cmp	r4, #2
    2ce2:	orr.w	sl, r3, sl
    2ce6:	ldr.w	fp, [r6]
    2cea:	strb.w	r2, [r9, #58]	; 0x3a
    2cee:	strb.w	r2, [r9, #59]	; 0x3b
    2cf2:	bls.n	2d86 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
    2cf4:	ldr.w	r3, [r9, #16]
    2cf8:	ldrb.w	r2, [r9, #59]	; 0x3b
    2cfc:	cmp	r2, #31
    2cfe:	bhi.n	2d26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    2d00:	ldr	r1, [r3, #92]	; 0x5c
    2d02:	ubfx	r1, r1, #16, #3
    2d06:	cbnz	r1, 2d0e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x5a>
    2d08:	b.n	2d26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    2d0a:	cmp	r2, #32
    2d0c:	beq.n	2d26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    2d0e:	add.w	lr, r2, #1
    2d12:	add.w	r0, r9, r2
    2d16:	subs	r1, #1
    2d18:	uxtb.w	r2, lr
    2d1c:	strb.w	r2, [r9, #59]	; 0x3b
    2d20:	ldr	r7, [r3, #112]	; 0x70
    2d22:	strb	r7, [r0, #26]
    2d24:	bne.n	2d0a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x56>
    2d26:	ldr	r2, [r3, #20]
    2d28:	lsls	r0, r2, #20
    2d2a:	bmi.n	2dc6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x112>
    2d2c:	tst.w	r2, #9216	; 0x2400
    2d30:	bne.n	2d3c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x88>
    2d32:	ldr	r1, [r6, #0]
    2d34:	rsb	r1, fp, r1
    2d38:	cmp	r1, #50	; 0x32
    2d3a:	bls.n	2d62 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xae>
    2d3c:	ldr	r2, [r3, #16]
    2d3e:	mov.w	r1, #512	; 0x200
    2d42:	orr.w	r2, r2, #768	; 0x300
    2d46:	str	r2, [r3, #16]
    2d48:	str	r1, [r3, #96]	; 0x60
    2d4a:	ldr	r2, [r3, #92]	; 0x5c
    2d4c:	tst.w	r2, #458752	; 0x70000
    2d50:	beq.n	2d5a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
    2d52:	ldr	r2, [r3, #16]
    2d54:	orr.w	r2, r2, #512	; 0x200
    2d58:	str	r2, [r3, #16]
    2d5a:	ldrb.w	r0, [r9, #59]	; 0x3b
    2d5e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2d62:	ldrb.w	r1, [r9, #59]	; 0x3b
    2d66:	cmp	r1, r5
    2d68:	bcc.n	2d7e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    2d6a:	cmp	r4, #2
    2d6c:	bls.n	2d7e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    2d6e:	ldr	r1, [r3, #92]	; 0x5c
    2d70:	lsls	r1, r1, #29
    2d72:	bne.n	2d7e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    2d74:	lsls	r2, r2, #22
    2d76:	bmi.n	2d4a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    2d78:	cmp.w	r8, #0
    2d7c:	beq.n	2d4a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    2d7e:	bl	4bb8 <yield>
    2d82:	cmp	r4, #2
    2d84:	bhi.n	2cf4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x40>
    2d86:	ldr.w	r2, [r9, #16]
    2d8a:	ldr	r3, [r2, #92]	; 0x5c
    2d8c:	and.w	r3, r3, #7
    2d90:	cmp	r3, #3
    2d92:	bhi.n	2db0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    2d94:	subs	r1, r5, #1
    2d96:	mov.w	r0, #512	; 0x200
    2d9a:	orr.w	r1, r1, #256	; 0x100
    2d9e:	cbnz	r4, 2db4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x100>
    2da0:	str.w	sl, [r2, #96]	; 0x60
    2da4:	subs	r3, #1
    2da6:	adds	r4, #1
    2da8:	cmp	r3, #3
    2daa:	bhi.n	2db0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    2dac:	cmp	r4, #2
    2dae:	bls.n	2d9e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
    2db0:	mov	r3, r2
    2db2:	b.n	2cf8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
    2db4:	cmp	r4, #1
    2db6:	beq.n	2dc2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10e>
    2db8:	cmp.w	r8, #0
    2dbc:	beq.n	2da4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    2dbe:	str	r0, [r2, #96]	; 0x60
    2dc0:	b.n	2da4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    2dc2:	str	r1, [r2, #96]	; 0x60
    2dc4:	b.n	2da4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    2dc6:	ldr	r2, [r3, #16]
    2dc8:	orr.w	r2, r2, #768	; 0x300
    2dcc:	str	r2, [r3, #16]
    2dce:	b.n	2d4a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    2dd0:	.word	0x20002404

00002dd4 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    2dd4:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    2dd6:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    2dd8:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    2dda:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    2ddc:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    2dde:	beq.n	2de8 <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    2de0:	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    2de4:	b.w	4c58 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    2de8:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    2dea:	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    2dee:	bx	r3

00002df0 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    2df0:	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    2df2:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    2df6:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    2dfa:	bne.n	2ed8 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    2dfc:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    2dfe:	bcc.n	2e84 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    2e00:	ldr.w	r3, [r1], #4
    2e04:	str.w	r3, [r0], #4
    2e08:	ldr.w	r3, [r1], #4
    2e0c:	str.w	r3, [r0], #4
    2e10:	ldr.w	r3, [r1], #4
    2e14:	str.w	r3, [r0], #4
    2e18:	ldr.w	r3, [r1], #4
    2e1c:	str.w	r3, [r0], #4
    2e20:	ldr.w	r3, [r1], #4
    2e24:	str.w	r3, [r0], #4
    2e28:	ldr.w	r3, [r1], #4
    2e2c:	str.w	r3, [r0], #4
    2e30:	ldr.w	r3, [r1], #4
    2e34:	str.w	r3, [r0], #4
    2e38:	ldr.w	r3, [r1], #4
    2e3c:	str.w	r3, [r0], #4
    2e40:	ldr.w	r3, [r1], #4
    2e44:	str.w	r3, [r0], #4
    2e48:	ldr.w	r3, [r1], #4
    2e4c:	str.w	r3, [r0], #4
    2e50:	ldr.w	r3, [r1], #4
    2e54:	str.w	r3, [r0], #4
    2e58:	ldr.w	r3, [r1], #4
    2e5c:	str.w	r3, [r0], #4
    2e60:	ldr.w	r3, [r1], #4
    2e64:	str.w	r3, [r0], #4
    2e68:	ldr.w	r3, [r1], #4
    2e6c:	str.w	r3, [r0], #4
    2e70:	ldr.w	r3, [r1], #4
    2e74:	str.w	r3, [r0], #4
    2e78:	ldr.w	r3, [r1], #4
    2e7c:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    2e80:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    2e82:	bcs.n	2e00 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    2e84:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    2e86:	bcc.n	2eac <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    2e88:	ldr.w	r3, [r1], #4
    2e8c:	str.w	r3, [r0], #4
    2e90:	ldr.w	r3, [r1], #4
    2e94:	str.w	r3, [r0], #4
    2e98:	ldr.w	r3, [r1], #4
    2e9c:	str.w	r3, [r0], #4
    2ea0:	ldr.w	r3, [r1], #4
    2ea4:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    2ea8:	subs	r2, #16
	bhs	.Lmid_block_loop
    2eaa:	bcs.n	2e88 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    2eac:	adds	r2, #12
	blo	.Lcopy_less_than_4
    2eae:	bcc.n	2ebc <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    2eb0:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    2eb4:	str.w	r3, [r0], #4
	subs	r2, #4
    2eb8:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    2eba:	bcs.n	2eb0 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    2ebc:	adds	r2, #4
	beq	.Ldone
    2ebe:	beq.n	2ed2 <memcpy+0xe2>

	lsls	r2, r2, #31
    2ec0:	lsls	r2, r2, #31
	itt ne
    2ec2:	itt	ne
	ldrbne  r3, [r1], #1
    2ec4:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    2ec8:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    2ecc:	bcc.n	2ed2 <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    2ece:	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    2ed0:	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    2ed2:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    2ed4:	bx	lr
    2ed6:	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    2ed8:	cmp	r2, #8
	blo	.Lbyte_copy
    2eda:	bcc.n	2f04 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    2edc:	lsls	r3, r1, #30
	beq	.Ldst_aligned
    2ede:	beq.n	2dfc <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    2ee0:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    2ee4:	beq.n	2dfc <memcpy+0xc>

	rsb	r3, #4
    2ee6:	rsb	r3, r3, #4
	subs	r2, r3
    2eea:	subs	r2, r2, r3

	lsls    r3, r3, #31
    2eec:	lsls	r3, r3, #31
	itt ne
    2eee:	itt	ne
	ldrbne  r3, [r1], #1
    2ef0:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    2ef4:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    2ef8:	bcc.n	2dfc <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    2efa:	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    2efe:	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    2f02:	b.n	2dfc <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    2f04:	subs	r2, #4
	blo	.Lcopy_less_than_4
    2f06:	bcc.n	2ebc <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    2f08:	subs	r2, #1
	ldrb    r3, [r1], #1
    2f0a:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    2f0e:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    2f12:	bcs.n	2f08 <memcpy+0x118>

	ldrb	r3, [r1]
    2f14:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    2f16:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    2f18:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    2f1a:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    2f1c:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    2f1e:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    2f20:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    2f22:	bx	lr

00002f24 <unused_interrupt_vector>:
//  R0
// Code from :: https://community.nxp.com/thread/389002
__attribute__((naked))
void unused_interrupt_vector(void)
{
  __asm( ".syntax unified\n"
    2f24:	movs	r0, #4
    2f26:	mov	r1, lr
    2f28:	tst	r0, r1
    2f2a:	beq.n	2f34 <_MSP>
    2f2c:	mrs	r0, PSP
    2f30:	b.w	2f44 <HardFault_HandlerC>

00002f34 <_MSP>:
    2f34:	mrs	r0, MSP
    2f38:	b.w	2f44 <HardFault_HandlerC>

00002f3c <startup_default_early_hook>:
         "B HardFault_HandlerC \n"
         "_MSP: \n"
         "MRS R0, MSP \n"
         "B HardFault_HandlerC \n"
         ".syntax divided\n") ;
}
    2f3c:	bx	lr
    2f3e:	nop

00002f40 <startup_default_late_hook>:


extern int main (void);
void startup_default_early_hook(void) {}
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
    2f40:	bx	lr
    2f42:	nop

00002f44 <HardFault_HandlerC>:
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2f44:	ldr	r3, [pc, #108]	; (2fb4 <HardFault_HandlerC+0x70>)
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    2f46:	movs	r1, #5
    2f48:	ldr	r2, [pc, #108]	; (2fb8 <HardFault_HandlerC+0x74>)
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    2f4a:	movs	r0, #56	; 0x38
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    2f4c:	push	{r4, r5, lr}
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    2f4e:	str.w	r1, [r2, #328]	; 0x148
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
  GPIO2_DR_SET = (1 << 3);
    2f52:	movs	r1, #8
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    2f54:	str.w	r0, [r2, #824]	; 0x338
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    2f58:	sub	sp, #12
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2f5a:	ldr	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
    2f5c:	ldr	r4, [pc, #92]	; (2fbc <HardFault_HandlerC+0x78>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2f5e:	orrs	r2, r1
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
    2f60:	ldr	r0, [pc, #92]	; (2fc0 <HardFault_HandlerC+0x7c>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2f62:	str	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
    2f64:	str.w	r1, [r3, #132]	; 0x84
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    2f68:	str.w	r1, [r3, #136]	; 0x88

  if ( F_CPU_ACTUAL >= 600000000 )
    2f6c:	ldr	r3, [r4, #0]
    2f6e:	cmp	r3, r0
    2f70:	bls.n	2f78 <HardFault_HandlerC+0x34>
    set_arm_clock(300000000);
    2f72:	ldr	r0, [pc, #80]	; (2fc4 <HardFault_HandlerC+0x80>)
    2f74:	bl	3768 <set_arm_clock>

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    2f78:	ldr	r5, [pc, #56]	; (2fb4 <HardFault_HandlerC+0x70>)
    2f7a:	movs	r4, #8
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    2f7c:	movs	r0, #0
    2f7e:	ldr	r2, [pc, #72]	; (2fc8 <HardFault_HandlerC+0x84>)
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    2f80:	ldr	r1, [pc, #72]	; (2fcc <HardFault_HandlerC+0x88>)
  if ( F_CPU_ACTUAL >= 600000000 )
    set_arm_clock(300000000);

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    2f82:	str.w	r4, [r5, #132]	; 0x84
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    2f86:	str	r0, [sp, #4]
    2f88:	ldr	r3, [sp, #4]
    2f8a:	cmp	r3, r2
    2f8c:	bhi.n	2f9a <HardFault_HandlerC+0x56>
    2f8e:	ldr	r3, [sp, #4]
    2f90:	adds	r3, #1
    2f92:	str	r3, [sp, #4]
    2f94:	ldr	r3, [sp, #4]
    2f96:	cmp	r3, r2
    2f98:	bls.n	2f8e <HardFault_HandlerC+0x4a>
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    2f9a:	str.w	r4, [r5, #136]	; 0x88
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    2f9e:	str	r0, [sp, #4]
    2fa0:	ldr	r3, [sp, #4]
    2fa2:	cmp	r3, r1
    2fa4:	bhi.n	2f82 <HardFault_HandlerC+0x3e>
    2fa6:	ldr	r3, [sp, #4]
    2fa8:	adds	r3, #1
    2faa:	str	r3, [sp, #4]
    2fac:	ldr	r3, [sp, #4]
    2fae:	cmp	r3, r1
    2fb0:	bls.n	2fa6 <HardFault_HandlerC+0x62>
    2fb2:	b.n	2f82 <HardFault_HandlerC+0x3e>
    2fb4:	.word	0x401bc000
    2fb8:	.word	0x401f8000
    2fbc:	.word	0x2000125c
    2fc0:	.word	0x23c345ff
    2fc4:	.word	0x11e1a300
    2fc8:	.word	0x000f423f
    2fcc:	.word	0x0089543f

00002fd0 <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    2fd0:	ldr	r2, [pc, #36]	; (2ff8 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    2fd2:	push	{r3, lr}
        char *prev = __brkval;
    2fd4:	ldr	r3, [r2, #0]
        if (incr != 0) {
    2fd6:	cbz	r0, 2fe2 <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    2fd8:	add	r0, r3
    2fda:	ldr	r1, [pc, #32]	; (2ffc <_sbrk+0x2c>)
    2fdc:	cmp	r0, r1
    2fde:	bhi.n	2fe6 <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    2fe0:	str	r0, [r2, #0]
        }
        return prev;
}
    2fe2:	mov	r0, r3
    2fe4:	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    2fe6:	bl	8754 <__errno>
    2fea:	movs	r2, #12
                        return (void *)-1;
    2fec:	mov.w	r3, #4294967295
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    2ff0:	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    2ff2:	mov	r0, r3
    2ff4:	pop	{r3, pc}
    2ff6:	nop
    2ff8:	.word	0x20001254
    2ffc:	.word	0x20280000

00003000 <_read>:

__attribute__((weak))
int _read(int file, char *ptr, int len)
{
	return 0;
}
    3000:	movs	r0, #0
    3002:	bx	lr

00003004 <_close>:

__attribute__((weak))
int _close(int fd)
{
	return -1;
}
    3004:	mov.w	r0, #4294967295
    3008:	bx	lr
    300a:	nop

0000300c <_fstat>:
#include <sys/stat.h>

__attribute__((weak))
int _fstat(int fd, struct stat *st)
{
	st->st_mode = S_IFCHR;
    300c:	mov.w	r3, #8192	; 0x2000
	return 0;
}
    3010:	movs	r0, #0
#include <sys/stat.h>

__attribute__((weak))
int _fstat(int fd, struct stat *st)
{
	st->st_mode = S_IFCHR;
    3012:	str	r3, [r1, #4]
	return 0;
}
    3014:	bx	lr
    3016:	nop

00003018 <_isatty>:

__attribute__((weak))
int _isatty(int fd)
{
	return 1;
}
    3018:	movs	r0, #1
    301a:	bx	lr

0000301c <_lseek>:

__attribute__((weak))
int _lseek(int fd, long long offset, int whence)
{
	return -1;
}
    301c:	mov.w	r0, #4294967295
    3020:	bx	lr
    3022:	nop

00003024 <abort>:
}

__attribute__((weak))
void abort(void)
{
	while (1) asm ("WFI");
    3024:	wfi
    3026:	b.n	3024 <abort>

00003028 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    3028:	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    302a:	ldr	r1, [pc, #80]	; (307c <rx_queue_transfer+0x54>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    302c:	mov.w	r7, #131072	; 0x20000
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    3030:	ldr	r5, [pc, #76]	; (3080 <rx_queue_transfer+0x58>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    3032:	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    3034:	add.w	r4, r1, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    3038:	ldr	r6, [pc, #72]	; (3084 <rx_queue_transfer+0x5c>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    303a:	ldr	r2, [pc, #76]	; (3088 <rx_queue_transfer+0x60>)
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    303c:	add.w	r5, r5, r0, lsl #5
    3040:	mov	r1, r4
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    3042:	str	r7, [r2, #0]
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    3044:	mov	r0, r5
    3046:	ldrh	r2, [r6, #0]
    3048:	bl	42c8 <usb_prepare_transfer>
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    304c:	ldrh	r1, [r6, #0]
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    304e:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    3052:	add	r1, r4
	asm("dsb");
    3054:	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    3058:	ldr	r2, [pc, #48]	; (308c <rx_queue_transfer+0x64>)
    305a:	str	r3, [r2, #0]
		location += 32;
    305c:	adds	r3, #32
	} while (location < end_addr);
    305e:	cmp	r1, r3
    3060:	bhi.n	305a <rx_queue_transfer+0x32>
	asm("dsb");
    3062:	dsb	sy
	asm("isb");
    3066:	isb	sy
	arm_dcache_delete(buffer, rx_packet_size);
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    306a:	movs	r0, #3
    306c:	mov	r1, r5
    306e:	bl	4320 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    3072:	ldr	r3, [pc, #28]	; (3090 <rx_queue_transfer+0x68>)
    3074:	mov.w	r2, #131072	; 0x20000
    3078:	str	r2, [r3, #0]
    307a:	pop	{r3, r4, r5, r6, r7, pc}
    307c:	.word	0x20200000
    3080:	.word	0x20002200
    3084:	.word	0x2000230e
    3088:	.word	0xe000e18c
    308c:	.word	0xe000ef5c
    3090:	.word	0xe000e10c

00003094 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    3094:	ldr	r2, [pc, #144]	; (3128 <rx_event+0x94>)
    3096:	ldr	r3, [r0, #4]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    3098:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    309c:	ubfx	r3, r3, #16, #15
    30a0:	ldrh	r4, [r2, #0]
	int i = t->callback_param;
    30a2:	ldr	r5, [r0, #28]
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    30a4:	subs	r4, r4, r3
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    30a6:	cmp	r4, #0
    30a8:	ble.n	311c <rx_event+0x88>
		// received a packet with data
		uint32_t head = rx_head;
    30aa:	ldr	r1, [pc, #128]	; (312c <rx_event+0x98>)
		if (head != rx_tail) {
    30ac:	ldr	r2, [pc, #128]	; (3130 <rx_event+0x9c>)
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
    30ae:	ldrb	r3, [r1, #0]
		if (head != rx_tail) {
    30b0:	ldrb	r2, [r2, #0]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
    30b2:	uxtb	r3, r3
		if (head != rx_tail) {
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    30b4:	ldr	r0, [pc, #124]	; (3134 <rx_event+0xa0>)
			uint32_t count = rx_count[ii];
    30b6:	ldr	r6, [pc, #128]	; (3138 <rx_event+0xa4>)
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
		if (head != rx_tail) {
    30b8:	cmp	r3, r2
    30ba:	beq.n	30cc <rx_event+0x38>
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    30bc:	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    30c0:	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    30c4:	rsb	r2, r7, #512	; 0x200
    30c8:	cmp	r4, r2
    30ca:	bls.n	30f2 <rx_event+0x5e>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    30cc:	adds	r3, #1
				return;
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
    30ce:	movs	r2, #0
    30d0:	ldr	r7, [pc, #104]	; (313c <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    30d2:	cmp	r3, #8
				// TODO: trigger serialEvent
				return;
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
    30d4:	strh.w	r4, [r6, r5, lsl #1]
		rx_index[i] = 0;
    30d8:	strh.w	r2, [r7, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    30dc:	ldr	r6, [pc, #96]	; (3140 <rx_event+0xac>)
    30de:	ite	ls
    30e0:	uxtbls	r2, r3
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    30e2:	movhi	r3, r2
		rx_list[head] = i;
		rx_head = head;
    30e4:	strb	r2, [r1, #0]
		rx_available += len;
    30e6:	ldr	r2, [r6, #0]
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    30e8:	strb	r5, [r0, r3]
		rx_head = head;
		rx_available += len;
    30ea:	add	r4, r2
    30ec:	str	r4, [r6, #0]
    30ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    30f2:	ldr	r3, [pc, #80]	; (3144 <rx_event+0xb0>)
    30f4:	add.w	r0, r7, r8, lsl #9
    30f8:	mov	r2, r4
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    30fa:	add	r7, r4
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    30fc:	add.w	r1, r3, r5, lsl #9
    3100:	add	r0, r3
    3102:	bl	2df0 <memcpy>
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
				rx_available += len;
    3106:	ldr	r2, [pc, #56]	; (3140 <rx_event+0xac>)
				rx_queue_transfer(i);
    3108:	mov	r0, r5
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    310a:	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    310e:	ldr	r3, [r2, #0]
    3110:	add	r4, r3
    3112:	str	r4, [r2, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    3114:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
				rx_available += len;
				rx_queue_transfer(i);
    3118:	b.w	3028 <rx_queue_transfer>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    311c:	mov	r0, r5
	}
}
    311e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    3122:	b.w	3028 <rx_queue_transfer>
    3126:	nop
    3128:	.word	0x2000230e
    312c:	.word	0x20002324
    3130:	.word	0x20002300
    3134:	.word	0x20002304
    3138:	.word	0x20002310
    313c:	.word	0x200021e8
    3140:	.word	0x20002320
    3144:	.word	0x20200000

00003148 <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    3148:	ldr	r3, [pc, #120]	; (31c4 <usb_serial_flush_callback+0x7c>)
    314a:	ldrb	r2, [r3, #0]
    314c:	cbnz	r2, 3166 <usb_serial_flush_callback+0x1e>
    314e:	and.w	r3, r2, #255	; 0xff
	if (!usb_configuration) return;
    3152:	ldr	r2, [pc, #116]	; (31c8 <usb_serial_flush_callback+0x80>)
    3154:	ldrb	r2, [r2, #0]
    3156:	cbz	r2, 3166 <usb_serial_flush_callback+0x1e>
	tx_available = 0;
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
    3158:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
    315c:	ldr	r5, [pc, #108]	; (31cc <usb_serial_flush_callback+0x84>)
    315e:	ldrh	r2, [r5, #0]
    3160:	cbnz	r2, 3168 <usb_serial_flush_callback+0x20>
    3162:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3166:	bx	lr
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    3168:	ldr	r6, [pc, #100]	; (31d0 <usb_serial_flush_callback+0x88>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    316a:	rsb	r8, r2, #2048	; 0x800
{
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    316e:	ldr	r7, [pc, #100]	; (31d4 <usb_serial_flush_callback+0x8c>)
    3170:	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    3172:	mov	r2, r8
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    3174:	ldr	r4, [pc, #96]	; (31d8 <usb_serial_flush_callback+0x90>)
{
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    3176:	add.w	r7, r7, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    317a:	add.w	r4, r4, r1, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    317e:	mov	r0, r7
    3180:	mov	r1, r4
    3182:	bl	42c8 <usb_prepare_transfer>
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    3186:	add.w	r2, r8, r4
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    318a:	bic.w	r1, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
	asm("dsb");
    318e:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    3192:	ldr	r3, [pc, #72]	; (31dc <usb_serial_flush_callback+0x94>)
    3194:	str	r1, [r3, #0]
		location += 32;
    3196:	adds	r1, #32
	} while (location < end_addr);
    3198:	cmp	r2, r1
    319a:	bhi.n	3194 <usb_serial_flush_callback+0x4c>
	asm("dsb");
    319c:	dsb	sy
	asm("isb");
    31a0:	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    31a4:	movs	r0, #4
    31a6:	mov	r1, r7
    31a8:	bl	42f8 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    31ac:	ldrb	r3, [r6, #0]
    31ae:	ldr	r2, [pc, #32]	; (31d0 <usb_serial_flush_callback+0x88>)
    31b0:	adds	r3, #1
    31b2:	uxtb	r3, r3
    31b4:	cmp	r3, #3
    31b6:	it	hi
    31b8:	movhi	r3, #0
    31ba:	strb	r3, [r2, #0]
	tx_available = 0;
    31bc:	movs	r3, #0
    31be:	strh	r3, [r5, #0]
    31c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    31c4:	.word	0x200021fa
    31c8:	.word	0x200023f8
    31cc:	.word	0x20002326
    31d0:	.word	0x200021fb
    31d4:	.word	0x20002340
    31d8:	.word	0x20201000
    31dc:	.word	0xe000ef70

000031e0 <usb_serial_write.part.1>:
{
	USB1_GPTIMER0CTRL = 0;
}


int usb_serial_write(const void *buffer, uint32_t size)
    31e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    31e4:	sub	sp, #20
    31e6:	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    31e8:	str	r1, [sp, #4]
    31ea:	cmp	r1, #0
    31ec:	beq.w	3334 <usb_serial_write.part.1+0x154>
    31f0:	movs	r3, #0
    31f2:	ldr.w	r8, [pc, #348]	; 3350 <usb_serial_write.part.1+0x170>
    31f6:	ldr.w	r9, [pc, #332]	; 3344 <usb_serial_write.part.1+0x164>
    31fa:	str	r3, [sp, #0]
				tx_available = TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    31fc:	ldr	r6, [pc, #312]	; (3338 <usb_serial_write.part.1+0x158>)
    31fe:	ldrh.w	r3, [r8]
				//printf("tx head=%d\n", tx_head);
				//printf("TXFILLTUNING=%08lX\n", USB1_TXFILLTUNING);
				//usb_print_transfer_log();
				//while (1) ;
			}
			if (!usb_configuration) return sent;
    3202:	ldr.w	sl, [pc, #336]	; 3354 <usb_serial_write.part.1+0x174>
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm("dsb");
	do {
		SCB_CACHE_DCCIMVAC = location;
    3206:	ldr.w	fp, [pc, #336]	; 3358 <usb_serial_write.part.1+0x178>
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
    320a:	ldr	r2, [pc, #304]	; (333c <usb_serial_write.part.1+0x15c>)
    320c:	ldrb	r4, [r2, #0]
    320e:	ldr	r2, [pc, #304]	; (3340 <usb_serial_write.part.1+0x160>)
    3210:	add.w	r7, r2, r4, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    3214:	cmp	r3, #0
    3216:	bne.n	32f6 <usb_serial_write.part.1+0x116>
    3218:	mov	r5, r3
    321a:	mov	r4, r3
    321c:	b.n	3248 <usb_serial_write.part.1+0x68>
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    321e:	ldrb.w	r3, [r9]
				}
				tx_available = TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			if (!waiting) {
    3222:	cbnz	r4, 3226 <usb_serial_write.part.1+0x46>
				wait_begin_at = systick_millis_count;
    3224:	ldr	r5, [r6, #0]
    3226:	movs	r4, #1
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    3228:	cmp	r3, #0
    322a:	bne.n	32ea <usb_serial_write.part.1+0x10a>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    322c:	ldr	r3, [r6, #0]
    322e:	subs	r3, r3, r5
    3230:	cmp	r3, #120	; 0x78
    3232:	bhi.n	3328 <usb_serial_write.part.1+0x148>
				//printf("tx head=%d\n", tx_head);
				//printf("TXFILLTUNING=%08lX\n", USB1_TXFILLTUNING);
				//usb_print_transfer_log();
				//while (1) ;
			}
			if (!usb_configuration) return sent;
    3234:	ldrb.w	r3, [sl]
    3238:	cmp	r3, #0
    323a:	beq.n	32ea <usb_serial_write.part.1+0x10a>
			yield();
    323c:	bl	4bb8 <yield>
	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    3240:	ldrh.w	r3, [r8]
    3244:	cmp	r3, #0
    3246:	bne.n	32f2 <usb_serial_write.part.1+0x112>
			//digitalWriteFast(3, HIGH);
			uint32_t status = usb_transfer_status(xfer);
    3248:	mov	r0, r7
    324a:	bl	4344 <usb_transfer_status>
			if (!(status & 0x80)) {
    324e:	ands.w	r0, r0, #128	; 0x80
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    3252:	ldr	r2, [pc, #240]	; (3344 <usb_serial_write.part.1+0x164>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			//digitalWriteFast(3, HIGH);
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    3254:	bne.n	321e <usb_serial_write.part.1+0x3e>
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = TX_SIZE;
    3256:	mov.w	r3, #2048	; 0x800
    325a:	ldr	r2, [pc, #224]	; (333c <usb_serial_write.part.1+0x15c>)
				transmit_previous_timeout = 0;
    325c:	strb.w	r0, [r9]
    3260:	ldrb	r4, [r2, #0]
    3262:	mov	r2, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = TX_SIZE;
    3264:	strh.w	r3, [r8]
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    3268:	lsls	r4, r4, #11
		if (size >= tx_available) {
    326a:	ldr	r5, [sp, #4]
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    326c:	ldr	r1, [pc, #216]	; (3348 <usb_serial_write.part.1+0x168>)
    326e:	add	r0, r4
		if (size >= tx_available) {
    3270:	cmp	r5, r2
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    3272:	add	r0, r1
		if (size >= tx_available) {
    3274:	bcc.n	32fe <usb_serial_write.part.1+0x11e>
			memcpy(txdata, data, tx_available);
			//*(txbuffer + (tx_head * TX_SIZE)) = 'A' + tx_head; // to see which buffer
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    3276:	add	r4, r1
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    3278:	ldr	r1, [sp, #8]
    327a:	bl	2df0 <memcpy>
			//*(txbuffer + (tx_head * TX_SIZE)) = 'A' + tx_head; // to see which buffer
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    327e:	movs	r3, #0
    3280:	mov	r1, r4
    3282:	mov.w	r2, #2048	; 0x800
    3286:	mov	r0, r7
    3288:	bl	42c8 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    328c:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    3290:	add.w	r4, r4, #2048	; 0x800
	asm("dsb");
    3294:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    3298:	str.w	r3, [fp]
		location += 32;
    329c:	adds	r3, #32
	} while (location < end_addr);
    329e:	cmp	r4, r3
    32a0:	bhi.n	3298 <usb_serial_write.part.1+0xb8>
	asm("dsb");
    32a2:	dsb	sy
	asm("isb");
    32a6:	isb	sy
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    32aa:	movs	r0, #4
    32ac:	mov	r1, r7
    32ae:	bl	42f8 <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    32b2:	ldr	r3, [pc, #136]	; (333c <usb_serial_write.part.1+0x15c>)
    32b4:	ldr	r2, [pc, #132]	; (333c <usb_serial_write.part.1+0x15c>)
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    32b6:	movs	r1, #0
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
			if (++tx_head >= TX_NUM) tx_head = 0;
    32b8:	ldrb	r3, [r3, #0]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    32ba:	ldr	r0, [pc, #144]	; (334c <usb_serial_write.part.1+0x16c>)
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
			if (++tx_head >= TX_NUM) tx_head = 0;
    32bc:	adds	r3, #1
    32be:	uxtb	r3, r3
    32c0:	cmp	r3, #3
    32c2:	it	hi
    32c4:	movhi	r3, #0
    32c6:	strb	r3, [r2, #0]
			size -= tx_available;
    32c8:	ldrh.w	r2, [r8]
			sent += tx_available;
    32cc:	ldr	r3, [sp, #0]
			data += tx_available;
			tx_available = 0;
    32ce:	strh.w	r1, [r8]
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
			if (++tx_head >= TX_NUM) tx_head = 0;
			size -= tx_available;
			sent += tx_available;
    32d2:	add	r3, r2
    32d4:	str	r3, [sp, #0]
			data += tx_available;
    32d6:	ldr	r3, [sp, #8]
    32d8:	add	r3, r2
    32da:	str	r3, [sp, #8]
    32dc:	mov	r3, r1
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    32de:	str.w	r1, [r0, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    32e2:	ldr	r1, [sp, #4]
    32e4:	subs	r2, r1, r2
    32e6:	str	r2, [sp, #4]
    32e8:	bne.n	320a <usb_serial_write.part.1+0x2a>
    32ea:	ldr	r0, [sp, #0]
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    32ec:	add	sp, #20
    32ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    32f2:	ldr	r2, [pc, #72]	; (333c <usb_serial_write.part.1+0x15c>)
    32f4:	ldrb	r4, [r2, #0]
    32f6:	mov	r2, r3
    32f8:	rsb	r0, r3, #2048	; 0x800
    32fc:	b.n	3268 <usb_serial_write.part.1+0x88>
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    32fe:	ldr	r4, [sp, #4]
    3300:	ldr	r1, [sp, #8]
    3302:	mov	r2, r4
    3304:	str	r3, [sp, #12]
    3306:	bl	2df0 <memcpy>
			tx_available -= size;
    330a:	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    330c:	ldr	r2, [pc, #60]	; (334c <usb_serial_write.part.1+0x16c>)
    330e:	mov.w	r1, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    3312:	subs	r3, r3, r4
    3314:	strh.w	r3, [r8]
    3318:	ldr	r3, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    331a:	str.w	r1, [r2, #132]	; 0x84
    331e:	mov	r0, r3
    3320:	add	r0, r4
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    3322:	add	sp, #20
    3324:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    3328:	movs	r3, #1
				return sent;
    332a:	ldr	r0, [sp, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    332c:	strb	r3, [r2, #0]
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    332e:	add	sp, #20
    3330:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    3334:	ldr	r0, [sp, #4]
    3336:	b.n	32ec <usb_serial_write.part.1+0x10c>
    3338:	.word	0x20002404
    333c:	.word	0x200021fb
    3340:	.word	0x20002340
    3344:	.word	0x20002325
    3348:	.word	0x20201000
    334c:	.word	0x402e0000
    3350:	.word	0x20002326
    3354:	.word	0x200023f8
    3358:	.word	0xe000ef70

0000335c <usb_serial_reset>:
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_serial_reset(void)
{
    335c:	bx	lr
    335e:	nop

00003360 <usb_serial_configure>:
void usb_serial_configure(void)
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    3360:	ldr	r3, [pc, #196]	; (3428 <usb_serial_configure+0xc8>)
	printf("usb_serial_reset\n");
	// deallocate all transfer descriptors
}

void usb_serial_configure(void)
{
    3362:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    3366:	ldrb	r3, [r3, #0]
		tx_packet_size = CDC_TX_SIZE_480;
    3368:	ldr	r7, [pc, #192]	; (342c <usb_serial_configure+0xcc>)
void usb_serial_configure(void)
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    336a:	cmp	r3, #0
    336c:	beq.n	3418 <usb_serial_configure+0xb8>
		tx_packet_size = CDC_TX_SIZE_480;
    336e:	mov.w	r3, #512	; 0x200
		rx_packet_size = CDC_RX_SIZE_480;
    3372:	ldr.w	r8, [pc, #236]	; 3460 <usb_serial_configure+0x100>
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
    3376:	strh	r3, [r7, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    3378:	strh.w	r3, [r8]
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    337c:	movs	r1, #0
    337e:	movs	r2, #128	; 0x80
    3380:	ldr	r0, [pc, #172]	; (3430 <usb_serial_configure+0xd0>)
	tx_head = 0;
    3382:	mov	r5, r1
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    3384:	ldr	r6, [pc, #172]	; (3434 <usb_serial_configure+0xd4>)
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    3386:	bl	8e58 <memset>
	tx_head = 0;
    338a:	ldr	r4, [pc, #172]	; (3438 <usb_serial_configure+0xd8>)
	tx_available = 0;
    338c:	ldr	r3, [pc, #172]	; (343c <usb_serial_configure+0xdc>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    338e:	mov	r1, r5
    3390:	mov.w	r2, #256	; 0x100
    3394:	ldr	r0, [pc, #168]	; (3440 <usb_serial_configure+0xe0>)
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    3396:	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    3398:	mov	r4, r5
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    339a:	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    339c:	bl	8e58 <memset>
	memset(rx_count, 0, sizeof(rx_count));
    33a0:	str	r5, [r6, #0]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    33a2:	mov	r3, r5
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    33a4:	str	r5, [r6, #4]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    33a6:	mov	r2, r5
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    33a8:	str	r5, [r6, #8]
    33aa:	str	r5, [r6, #12]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    33ac:	ldr	r1, [pc, #148]	; (3444 <usb_serial_configure+0xe4>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
    33ae:	ldr	r6, [pc, #152]	; (3448 <usb_serial_configure+0xe8>)
	rx_head = 0;
	rx_tail = 0;
    33b0:	ldr	r0, [pc, #152]	; (344c <usb_serial_configure+0xec>)
	rx_available = 0;
    33b2:	ldr.w	lr, [pc, #176]	; 3464 <usb_serial_configure+0x104>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    33b6:	strb	r5, [r1, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    33b8:	movs	r1, #16
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    33ba:	strb	r5, [r0, #0]
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    33bc:	movs	r0, #2
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
    33be:	str	r5, [r6, #0]
    33c0:	str	r5, [r6, #4]
    33c2:	str	r5, [r6, #8]
    33c4:	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    33c6:	str.w	r5, [lr]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    33ca:	bl	4260 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    33ce:	ldrh.w	r1, [r8]
    33d2:	mov	r2, r5
    33d4:	ldr	r3, [pc, #120]	; (3450 <usb_serial_configure+0xf0>)
    33d6:	movs	r0, #3
    33d8:	bl	41fc <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    33dc:	mov	r3, r5
    33de:	ldrh	r1, [r7, #0]
    33e0:	movs	r2, #1
    33e2:	movs	r0, #4
    33e4:	bl	4260 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    33e8:	mov	r0, r4
    33ea:	adds	r4, #1
    33ec:	bl	3028 <rx_queue_transfer>
    33f0:	cmp	r4, #8
    33f2:	bne.n	33e8 <usb_serial_configure+0x88>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    33f4:	ldr	r3, [pc, #92]	; (3454 <usb_serial_configure+0xf4>)
	USB1_GPTIMER0LD = microseconds - 1;
    33f6:	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    33f8:	ldr	r0, [pc, #92]	; (3458 <usb_serial_configure+0xf8>)
	USB1_GPTIMER0CTRL = 0;
    33fa:	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    33fc:	ldr	r4, [pc, #92]	; (345c <usb_serial_configure+0xfc>)
    33fe:	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    3400:	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    3404:	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    3408:	ldr.w	r2, [r3, #328]	; 0x148
    340c:	orr.w	r2, r2, #16777216	; 0x1000000
    3410:	str.w	r2, [r3, #328]	; 0x148
    3414:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    3418:	movs	r3, #64	; 0x40
		rx_packet_size = CDC_RX_SIZE_12;
    341a:	ldr.w	r8, [pc, #68]	; 3460 <usb_serial_configure+0x100>
	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    341e:	strh	r3, [r7, #0]
		rx_packet_size = CDC_RX_SIZE_12;
    3420:	strh.w	r3, [r8]
    3424:	b.n	337c <usb_serial_configure+0x1c>
    3426:	nop
    3428:	.word	0x200023d0
    342c:	.word	0x200021f8
    3430:	.word	0x20002340
    3434:	.word	0x20002310
    3438:	.word	0x200021fb
    343c:	.word	0x20002326
    3440:	.word	0x20002200
    3444:	.word	0x20002324
    3448:	.word	0x200021e8
    344c:	.word	0x20002300
    3450:	.word	0x00003095
    3454:	.word	0x402e0000
    3458:	.word	0x200023c0
    345c:	.word	0x00003149
    3460:	.word	0x2000230e
    3464:	.word	0x20002320

00003468 <usb_serial_read>:
int usb_serial_read(void *buffer, uint32_t size)
{
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
    3468:	ldr	r3, [pc, #196]	; (3530 <usb_serial_read+0xc8>)
    346a:	mov.w	r2, #131072	; 0x20000

//static int maxtimes=0;

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
    346e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
    3472:	str	r2, [r3, #0]

//static int maxtimes=0;

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
    3474:	sub	sp, #12
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
    3476:	ldr	r3, [pc, #188]	; (3534 <usb_serial_read+0xcc>)
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    3478:	mov	r9, r1
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
    347a:	ldrb	r4, [r3, #0]
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    347c:	cmp	r1, #0
    347e:	beq.n	3528 <usb_serial_read+0xc0>
    3480:	ldr	r3, [pc, #180]	; (3538 <usb_serial_read+0xd0>)
    3482:	uxtb	r4, r4
    3484:	ldrb	r3, [r3, #0]
    3486:	cmp	r4, r3
    3488:	beq.n	352c <usb_serial_read+0xc4>
    348a:	mov	sl, r0
    348c:	movs	r7, #0
    348e:	ldr.w	fp, [pc, #192]	; 3550 <usb_serial_read+0xe8>
		if (++tail > RX_NUM) tail = 0;
    3492:	adds	r4, #1
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    3494:	ldr	r3, [pc, #164]	; (353c <usb_serial_read+0xd4>)
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
    3496:	rsb	r8, r7, r9
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    349a:	mov	r0, sl
	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
    349c:	cmp	r4, #9
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    349e:	str	r3, [sp, #4]
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
    34a0:	ldr	r3, [pc, #156]	; (3540 <usb_serial_read+0xd8>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
    34a2:	it	cs
    34a4:	movcs	r4, #0
		uint32_t i = rx_list[tail];
    34a6:	ldrb	r5, [r3, r4]
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    34a8:	ldr	r3, [pc, #144]	; (353c <usb_serial_read+0xd4>)
    34aa:	ldrh.w	lr, [r3, r5, lsl #1]
    34ae:	ldr	r3, [pc, #148]	; (3544 <usb_serial_read+0xdc>)
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    34b0:	add.w	r1, lr, r5, lsl #9
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    34b4:	ldrh.w	r6, [r3, r5, lsl #1]
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    34b8:	ldr	r3, [pc, #140]	; (3548 <usb_serial_read+0xe0>)
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    34ba:	rsb	r6, lr, r6
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    34be:	add	r1, r3
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
    34c0:	cmp	r8, r6
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    34c2:	mov	r2, r6
			p += avail;
			rx_available -= avail;
			count += avail;
    34c4:	add	r7, r6
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
    34c6:	bcs.n	34fc <usb_serial_read+0x94>
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    34c8:	add.w	r1, lr, r5, lsl #9
    34cc:	mov	r2, r8
    34ce:	add	r1, r3
    34d0:	bl	2df0 <memcpy>
			rx_available -= len;
			rx_index[i] += len;
    34d4:	ldr	r3, [sp, #4]
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
			rx_available -= len;
    34d6:	ldr.w	r1, [fp]
    34da:	mov	r0, r9
			rx_index[i] += len;
    34dc:	ldrh.w	r2, [r3, r5, lsl #1]
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
			rx_available -= len;
    34e0:	rsb	r1, r8, r1
			rx_index[i] += len;
    34e4:	add	r8, r2
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
			rx_available -= len;
    34e6:	str.w	r1, [fp]
			rx_index[i] += len;
    34ea:	strh.w	r8, [r3, r5, lsl #1]
			count += avail;
			rx_tail = tail;
			rx_queue_transfer(i);
		}
	}
	NVIC_ENABLE_IRQ(IRQ_USB1);
    34ee:	ldr	r3, [pc, #92]	; (354c <usb_serial_read+0xe4>)
    34f0:	mov.w	r2, #131072	; 0x20000
    34f4:	str	r2, [r3, #0]
	return count;
}
    34f6:	add	sp, #12
    34f8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    34fc:	bl	2df0 <memcpy>
			p += avail;
			rx_available -= avail;
    3500:	ldr.w	r2, [fp]
			count += avail;
			rx_tail = tail;
    3504:	uxtb	r3, r4
			rx_queue_transfer(i);
    3506:	mov	r0, r5
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
			p += avail;
			rx_available -= avail;
    3508:	subs	r2, r2, r6
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
			p += avail;
    350a:	add	sl, r6
			rx_available -= avail;
    350c:	str.w	r2, [fp]
			count += avail;
			rx_tail = tail;
    3510:	ldr	r2, [pc, #32]	; (3534 <usb_serial_read+0xcc>)
    3512:	strb	r3, [r2, #0]
			rx_queue_transfer(i);
    3514:	bl	3028 <rx_queue_transfer>

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    3518:	cmp	r9, r7
    351a:	bls.n	3524 <usb_serial_read+0xbc>
    351c:	ldr	r3, [pc, #24]	; (3538 <usb_serial_read+0xd0>)
    351e:	ldrb	r3, [r3, #0]
    3520:	cmp	r4, r3
    3522:	bne.n	3492 <usb_serial_read+0x2a>
    3524:	mov	r0, r7
    3526:	b.n	34ee <usb_serial_read+0x86>
    3528:	mov	r0, r1
    352a:	b.n	34ee <usb_serial_read+0x86>
    352c:	movs	r0, #0
    352e:	b.n	34ee <usb_serial_read+0x86>
    3530:	.word	0xe000e18c
    3534:	.word	0x20002300
    3538:	.word	0x20002324
    353c:	.word	0x200021e8
    3540:	.word	0x20002304
    3544:	.word	0x20002310
    3548:	.word	0x20200000
    354c:	.word	0xe000e10c
    3550:	.word	0x20002320

00003554 <usb_serial_peekchar>:
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    3554:	ldr	r3, [pc, #44]	; (3584 <usb_serial_peekchar+0x30>)
	if (tail == rx_head) return -1;
    3556:	ldr	r2, [pc, #48]	; (3588 <usb_serial_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    3558:	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    355a:	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    355c:	uxtb	r3, r3
	if (tail == rx_head) return -1;
    355e:	cmp	r3, r2
    3560:	beq.n	357e <usb_serial_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    3562:	adds	r3, #1
	uint32_t i = rx_list[tail];
    3564:	ldr	r0, [pc, #36]	; (358c <usb_serial_peekchar+0x38>)
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    3566:	ldr	r2, [pc, #40]	; (3590 <usb_serial_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    3568:	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    356a:	ldr	r1, [pc, #40]	; (3594 <usb_serial_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    356c:	it	cs
    356e:	movcs	r3, #0
	uint32_t i = rx_list[tail];
    3570:	ldrb	r3, [r0, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    3572:	ldrh.w	r1, [r1, r3, lsl #1]
    3576:	add.w	r3, r2, r3, lsl #9
    357a:	ldrb	r0, [r3, r1]
    357c:	bx	lr

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    357e:	mov.w	r0, #4294967295
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
}
    3582:	bx	lr
    3584:	.word	0x20002300
    3588:	.word	0x20002324
    358c:	.word	0x20002304
    3590:	.word	0x20200000
    3594:	.word	0x200021e8

00003598 <usb_serial_available>:

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	return rx_available;
    3598:	ldr	r3, [pc, #4]	; (35a0 <usb_serial_available+0x8>)
    359a:	ldr	r0, [r3, #0]
}
    359c:	bx	lr
    359e:	nop
    35a0:	.word	0x20002320

000035a4 <usb_serial_flush_input>:

// discard any buffered input
void usb_serial_flush_input(void)
{
    35a4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t tail = rx_tail;
    35a8:	ldr	r6, [pc, #84]	; (3600 <usb_serial_flush_input+0x5c>)
	while (tail != rx_head) {
    35aa:	ldr	r5, [pc, #88]	; (3604 <usb_serial_flush_input+0x60>)
}

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
    35ac:	ldrb	r4, [r6, #0]
	while (tail != rx_head) {
    35ae:	ldrb	r3, [r5, #0]
}

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
    35b0:	uxtb	r4, r4
	while (tail != rx_head) {
    35b2:	cmp	r4, r3
    35b4:	beq.n	35fa <usb_serial_flush_input+0x56>
    35b6:	ldr.w	r9, [pc, #84]	; 360c <usb_serial_flush_input+0x68>
    35ba:	ldr.w	fp, [pc, #84]	; 3610 <usb_serial_flush_input+0x6c>
    35be:	ldr.w	r8, [pc, #84]	; 3614 <usb_serial_flush_input+0x70>
    35c2:	ldr	r7, [pc, #68]	; (3608 <usb_serial_flush_input+0x64>)
		if (++tail > RX_NUM) tail = 0;
    35c4:	adds	r4, #1
    35c6:	cmp	r4, #8
    35c8:	uxtb.w	sl, r4
    35cc:	bls.n	35d2 <usb_serial_flush_input+0x2e>
    35ce:	movs	r4, #0
    35d0:	mov	sl, r4
		uint32_t i = rx_list[tail];
    35d2:	ldrb.w	r1, [r9, r4]
		rx_available -= rx_count[i] - rx_index[i];
    35d6:	ldr.w	r2, [fp]
    35da:	ldrh.w	r3, [r8, r1, lsl #1]
		rx_queue_transfer(i);
    35de:	mov	r0, r1
{
	uint32_t tail = rx_tail;
	while (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		rx_available -= rx_count[i] - rx_index[i];
    35e0:	ldrh.w	r1, [r7, r1, lsl #1]
    35e4:	subs	r3, r3, r1
    35e6:	subs	r3, r2, r3
    35e8:	str.w	r3, [fp]
		rx_queue_transfer(i);
    35ec:	bl	3028 <rx_queue_transfer>
		rx_tail = tail;
    35f0:	strb.w	sl, [r6]

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
	while (tail != rx_head) {
    35f4:	ldrb	r3, [r5, #0]
    35f6:	cmp	r4, r3
    35f8:	bne.n	35c4 <usb_serial_flush_input+0x20>
    35fa:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    35fe:	nop
    3600:	.word	0x20002300
    3604:	.word	0x20002324
    3608:	.word	0x200021e8
    360c:	.word	0x20002304
    3610:	.word	0x20002320
    3614:	.word	0x20002310

00003618 <usb_serial_getchar>:
}


// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    3618:	push	{lr}
    361a:	sub	sp, #12
	uint8_t c;
	if (usb_serial_read(&c, 1)) return c;
    361c:	movs	r1, #1
    361e:	add.w	r0, sp, #7
    3622:	bl	3468 <usb_serial_read>
    3626:	cbz	r0, 3632 <usb_serial_getchar+0x1a>
    3628:	ldrb.w	r0, [sp, #7]
	return -1;
}
    362c:	add	sp, #12
    362e:	ldr.w	pc, [sp], #4
// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
	uint8_t c;
	if (usb_serial_read(&c, 1)) return c;
	return -1;
    3632:	mov.w	r0, #4294967295
    3636:	b.n	362c <usb_serial_getchar+0x14>

00003638 <usb_serial_putchar>:
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    3638:	ldr	r3, [pc, #36]	; (3660 <usb_serial_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    363a:	push	{lr}
    363c:	sub	sp, #12
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    363e:	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    3640:	strb.w	r0, [sp, #7]
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    3644:	cbnz	r3, 3650 <usb_serial_putchar+0x18>
    3646:	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
	return usb_serial_write(&c, 1);
}
    364a:	add	sp, #12
    364c:	ldr.w	pc, [sp], #4
    3650:	movs	r1, #1
    3652:	add.w	r0, sp, #7
    3656:	bl	31e0 <usb_serial_write.part.1>
    365a:	add	sp, #12
    365c:	ldr.w	pc, [sp], #4
    3660:	.word	0x200023f8

00003664 <usb_serial_write>:
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    3664:	ldr	r3, [pc, #16]	; (3678 <usb_serial_write+0x14>)
    3666:	ldrb	r3, [r3, #0]
    3668:	and.w	r2, r3, #255	; 0xff
    366c:	cbz	r3, 3672 <usb_serial_write+0xe>
    366e:	b.w	31e0 <usb_serial_write.part.1>
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    3672:	mov	r0, r2
    3674:	bx	lr
    3676:	nop
    3678:	.word	0x200023f8

0000367c <usb_serial_write_buffer_free>:

int usb_serial_write_buffer_free(void)
{
    367c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    3680:	movs	r4, #0
}

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
    3682:	ldr.w	r8, [pc, #64]	; 36c4 <usb_serial_write_buffer_free+0x48>
    3686:	movs	r3, #1
    3688:	ldr	r5, [pc, #48]	; (36bc <usb_serial_write_buffer_free+0x40>)
	return sent;
}

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
    368a:	mov	r7, r4
    368c:	ldr	r6, [pc, #48]	; (36c0 <usb_serial_write_buffer_free+0x44>)
	tx_noautoflush = 1;
    368e:	strb.w	r3, [r8]
	for (uint32_t i=0; i < TX_NUM; i++) {
		if (i == tx_head) continue;
    3692:	ldrb	r3, [r6, #0]
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    3694:	mov	r0, r5
    3696:	adds	r5, #32
int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
		if (i == tx_head) continue;
    3698:	cmp	r3, r4

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    369a:	add.w	r4, r4, #1
		if (i == tx_head) continue;
    369e:	beq.n	36ac <usb_serial_write_buffer_free+0x30>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    36a0:	bl	4344 <usb_transfer_status>
    36a4:	lsls	r3, r0, #24
    36a6:	it	pl
    36a8:	addpl.w	r7, r7, #2048	; 0x800

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    36ac:	cmp	r4, #4
    36ae:	bne.n	3692 <usb_serial_write_buffer_free+0x16>
		if (i == tx_head) continue;
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
	}
	tx_noautoflush = 0;
    36b0:	movs	r3, #0
	return sum;
}
    36b2:	mov	r0, r7
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
		if (i == tx_head) continue;
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
	}
	tx_noautoflush = 0;
    36b4:	strb.w	r3, [r8]
	return sum;
}
    36b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    36bc:	.word	0x20002340
    36c0:	.word	0x200021fb
    36c4:	.word	0x200021fa

000036c8 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    36c8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	if (!usb_configuration) return;
    36cc:	ldr	r3, [pc, #124]	; (374c <usb_serial_flush_output+0x84>)
    36ce:	ldrb	r3, [r3, #0]
    36d0:	cbz	r3, 36d8 <usb_serial_flush_output+0x10>
	if (tx_available == 0) return;
    36d2:	ldr	r5, [pc, #124]	; (3750 <usb_serial_flush_output+0x88>)
    36d4:	ldrh	r2, [r5, #0]
    36d6:	cbnz	r2, 36dc <usb_serial_flush_output+0x14>
    36d8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
    36dc:	ldr.w	r8, [pc, #132]	; 3764 <usb_serial_flush_output+0x9c>
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    36e0:	rsb	r9, r2, #2048	; 0x800
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
    36e4:	ldr	r6, [pc, #108]	; (3754 <usb_serial_flush_output+0x8c>)
void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    36e6:	mov.w	lr, #1
	transfer_t *xfer = tx_transfer + tx_head;
    36ea:	ldrb.w	r1, [r8]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    36ee:	mov	r2, r9

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    36f0:	ldr	r4, [pc, #100]	; (3758 <usb_serial_flush_output+0x90>)
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    36f2:	movs	r3, #0
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
    36f4:	add.w	r6, r6, r1, lsl #5
void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    36f8:	ldr	r7, [pc, #96]	; (375c <usb_serial_flush_output+0x94>)
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    36fa:	add.w	r4, r4, r1, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    36fe:	mov	r0, r6
void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    3700:	strb.w	lr, [r7]
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    3704:	mov	r1, r4
    3706:	bl	42c8 <usb_prepare_transfer>
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    370a:	add.w	r2, r9, r4
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    370e:	bic.w	r1, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
	asm("dsb");
    3712:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    3716:	ldr	r3, [pc, #72]	; (3760 <usb_serial_flush_output+0x98>)
    3718:	str	r1, [r3, #0]
		location += 32;
    371a:	adds	r1, #32
	} while (location < end_addr);
    371c:	cmp	r2, r1
    371e:	bhi.n	3718 <usb_serial_flush_output+0x50>
	asm("dsb");
    3720:	dsb	sy
	asm("isb");
    3724:	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    3728:	movs	r0, #4
    372a:	mov	r1, r6
    372c:	bl	42f8 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    3730:	ldrb.w	r3, [r8]
    3734:	ldr	r2, [pc, #44]	; (3764 <usb_serial_flush_output+0x9c>)
    3736:	adds	r3, #1
    3738:	uxtb	r3, r3
    373a:	cmp	r3, #3
    373c:	it	hi
    373e:	movhi	r3, #0
    3740:	strb	r3, [r2, #0]
	tx_available = 0;
    3742:	movs	r3, #0
    3744:	strh	r3, [r5, #0]
	tx_noautoflush = 0;
    3746:	strb	r3, [r7, #0]
    3748:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    374c:	.word	0x200023f8
    3750:	.word	0x20002326
    3754:	.word	0x20002340
    3758:	.word	0x20201000
    375c:	.word	0x200021fa
    3760:	.word	0xe000ef70
    3764:	.word	0x200021fb

00003768 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    3768:	ldr	r2, [pc, #600]	; (39c4 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    376a:	ldr	r3, [pc, #604]	; (39c8 <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    376c:	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
    376e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
    3772:	ldr	r4, [pc, #600]	; (39cc <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    3774:	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    3778:	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    377a:	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    377c:	bls.n	37b8 <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    377e:	ldr	r3, [pc, #592]	; (39d0 <set_arm_clock+0x268>)
    3780:	cmp	r0, r3
    3782:	bls.w	39b0 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    3786:	ldr	r3, [pc, #588]	; (39d4 <set_arm_clock+0x26c>)
    3788:	movw	r5, #1575	; 0x627
    378c:	ldr	r7, [pc, #584]	; (39d8 <set_arm_clock+0x270>)
    378e:	add	r3, r0
    3790:	ldr	r4, [pc, #584]	; (39dc <set_arm_clock+0x274>)
    3792:	lsrs	r2, r3, #8
    3794:	umull	r3, r2, r7, r2
    3798:	lsrs	r3, r2, #7
    379a:	add.w	r3, r3, r3, lsl #2
    379e:	add.w	r2, r3, r3, lsl #2
    37a2:	addw	r3, r2, #1250	; 0x4e2
    37a6:	cmp	r3, r5
    37a8:	it	cs
    37aa:	movcs	r3, r5
    37ac:	sub.w	r3, r3, #800	; 0x320
    37b0:	umull	r3, r5, r4, r3
    37b4:	lsrs	r5, r5, #3
    37b6:	b.n	37c2 <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
    37b8:	ldr	r5, [pc, #548]	; (39e0 <set_arm_clock+0x278>)
    37ba:	cmp	r0, r5
    37bc:	ite	ls
    37be:	movls	r5, #6
    37c0:	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    37c2:	ldr	r2, [pc, #516]	; (39c8 <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    37c4:	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    37c8:	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    37cc:	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    37ce:	orr.w	r3, r3, #192	; 0xc0
    37d2:	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    37d6:	bcs.n	37ee <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    37d8:	ldr	r3, [pc, #496]	; (39cc <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    37da:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    37de:	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    37e0:	orrs	r6, r5
		DCDC_REG3 = dcdc;
    37e2:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    37e4:	ldr	r3, [r2, #0]
    37e6:	cmp	r3, #0
    37e8:	bge.n	37e4 <set_arm_clock+0x7c>
    37ea:	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    37ee:	ands.w	r3, lr, #33554432	; 0x2000000
    37f2:	bne.n	3858 <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    37f4:	ldr	r4, [pc, #492]	; (39e4 <set_arm_clock+0x27c>)
    37f6:	ldr	r2, [pc, #496]	; (39e8 <set_arm_clock+0x280>)
    37f8:	ldr.w	ip, [r4, #16]
    37fc:	mov	r4, r2
    37fe:	and.w	r2, ip, r2
    3802:	cmp	r2, r4
    3804:	itet	eq
    3806:	moveq.w	r3, #402653184	; 0x18000000
    380a:	movne.w	r2, #4096	; 0x1000
    380e:	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    3810:	eor.w	r4, lr, r3
    3814:	tst.w	r4, #939524096	; 0x38000000
    3818:	beq.n	382c <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    381a:	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    381e:	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
    3822:	ldr	r4, [pc, #420]	; (39c8 <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    3824:	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
    3828:	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    382c:	eor.w	r3, r1, r2
    3830:	tst.w	r3, #12288	; 0x3000
    3834:	beq.n	3848 <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    3836:	ldr	r3, [pc, #400]	; (39c8 <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    3838:	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    383c:	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    383e:	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    3840:	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    3842:	ldr	r3, [r2, #72]	; 0x48
    3844:	lsls	r4, r3, #28
    3846:	bmi.n	3842 <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    3848:	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    384c:	ldr	r2, [pc, #376]	; (39c8 <set_arm_clock+0x260>)
    384e:	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    3852:	ldr	r3, [r2, #72]	; 0x48
    3854:	lsls	r1, r3, #26
    3856:	bmi.n	3852 <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    3858:	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    385a:	ldr	r4, [pc, #400]	; (39ec <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    385c:	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    385e:	mul.w	r3, r1, r2
    3862:	mul.w	r3, r0, r3
    3866:	cmp	r3, r4
    3868:	bhi.n	387e <set_arm_clock+0x116>
		if (div_arm < 8) {
    386a:	cmp	r2, #7
    386c:	bhi.w	399a <set_arm_clock+0x232>
			div_arm = div_arm + 1;
    3870:	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    3872:	mul.w	r3, r1, r2
    3876:	mul.w	r3, r0, r3
    387a:	cmp	r3, r4
    387c:	bls.n	386a <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    387e:	ldr	r0, [pc, #368]	; (39f0 <set_arm_clock+0x288>)
    3880:	ldr	r4, [pc, #368]	; (39f4 <set_arm_clock+0x28c>)
    3882:	add	r0, r3
    3884:	umull	r0, r3, r4, r0
    3888:	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    388a:	cmp	r3, #108	; 0x6c
    388c:	bhi.w	39a6 <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
    3890:	cmp	r3, #53	; 0x35
    3892:	bhi.w	39b4 <set_arm_clock+0x24c>
    3896:	ldr.w	r8, [pc, #392]	; 3a20 <set_arm_clock+0x2b8>
    389a:	movs	r3, #54	; 0x36
    389c:	ldr	r0, [pc, #344]	; (39f8 <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    389e:	ldr.w	ip, [pc, #324]	; 39e4 <set_arm_clock+0x27c>
    38a2:	ldr	r4, [pc, #344]	; (39fc <set_arm_clock+0x294>)
    38a4:	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    38a8:	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    38ac:	and.w	r4, r9, r4
    38b0:	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    38b2:	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    38b6:	beq.n	38d0 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    38b8:	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    38bc:	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    38c0:	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    38c2:	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    38c6:	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    38ca:	ldr	r3, [r4, #0]
    38cc:	cmp	r3, #0
    38ce:	bge.n	38ca <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    38d0:	ldr.w	ip, [pc, #244]	; 39c8 <set_arm_clock+0x260>
    38d4:	subs	r2, #1
    38d6:	ldr.w	r3, [ip, #16]
    38da:	and.w	r3, r3, #7
    38de:	cmp	r3, r2
    38e0:	beq.n	38f2 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    38e2:	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    38e6:	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    38e8:	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    38ec:	ldr	r3, [r4, #72]	; 0x48
    38ee:	lsls	r3, r3, #15
    38f0:	bmi.n	38ec <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    38f2:	subs	r1, #1
    38f4:	lsls	r1, r1, #10
    38f6:	eor.w	r3, lr, r1
    38fa:	tst.w	r3, #7168	; 0x1c00
    38fe:	beq.n	391a <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    3900:	ldr	r3, [pc, #196]	; (39c8 <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    3902:	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    3906:	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    390a:	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    390c:	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    3910:	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    3914:	ldr	r3, [r2, #72]	; 0x48
    3916:	lsls	r1, r3, #30
    3918:	bmi.n	3914 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    391a:	ldr	r3, [pc, #228]	; (3a00 <set_arm_clock+0x298>)
    391c:	ldr	r1, [pc, #228]	; (3a04 <set_arm_clock+0x29c>)
    391e:	add	r3, r0
    3920:	lsrs	r3, r3, #7
    3922:	umull	r3, r1, r1, r3
    3926:	lsrs	r1, r1, #12
    3928:	cmp	r1, #4
    392a:	it	cs
    392c:	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    392e:	subs	r3, r1, #1
    3930:	lsls	r3, r3, #8
    3932:	eor.w	r2, lr, r3
    3936:	tst.w	r2, #768	; 0x300
    393a:	beq.n	394c <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    393c:	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    3940:	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    3944:	ldr	r2, [pc, #128]	; (39c8 <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    3946:	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    394a:	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    394c:	ldr	r3, [pc, #120]	; (39c8 <set_arm_clock+0x260>)
    394e:	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    3950:	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    3952:	bic.w	r4, r4, #33554432	; 0x2000000
    3956:	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    3958:	ldr	r3, [r2, #72]	; 0x48
    395a:	lsls	r3, r3, #26
    395c:	bmi.n	3958 <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    395e:	ldr	r3, [pc, #168]	; (3a08 <set_arm_clock+0x2a0>)
    3960:	mov.w	r2, #4294967295
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    3964:	ldr	r4, [pc, #164]	; (3a0c <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    3966:	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    3968:	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    396c:	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    396e:	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    3972:	ldr	r4, [pc, #156]	; (3a10 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    3974:	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    3978:	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    397c:	ldr	r2, [pc, #148]	; (3a14 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    397e:	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    3980:	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    3982:	bcs.n	3996 <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    3984:	ldr	r3, [pc, #68]	; (39cc <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    3986:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    398a:	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    398c:	orrs	r6, r5
		DCDC_REG3 = dcdc;
    398e:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    3990:	ldr	r3, [r2, #0]
    3992:	cmp	r3, #0
    3994:	bge.n	3990 <set_arm_clock+0x228>
	}

	return frequency;
}
    3996:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    399a:	cmp	r1, #4
    399c:	bhi.w	387e <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    39a0:	adds	r1, #1
				div_arm = 1;
    39a2:	movs	r2, #1
    39a4:	b.n	385e <set_arm_clock+0xf6>
    39a6:	ldr.w	r8, [pc, #124]	; 3a24 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    39aa:	movs	r3, #108	; 0x6c
    39ac:	ldr	r0, [pc, #104]	; (3a18 <set_arm_clock+0x2b0>)
    39ae:	b.n	389e <set_arm_clock+0x136>
    39b0:	movs	r5, #18
    39b2:	b.n	37c2 <set_arm_clock+0x5a>
    39b4:	ldr	r0, [pc, #100]	; (3a1c <set_arm_clock+0x2b4>)
    39b6:	ldr.w	r8, [pc, #112]	; 3a28 <set_arm_clock+0x2c0>
    39ba:	mul.w	r0, r0, r3
    39be:	orr.w	r8, r3, r8
    39c2:	b.n	389e <set_arm_clock+0x136>
    39c4:	.word	0x1f78a400
    39c8:	.word	0x400fc000
    39cc:	.word	0x40080000
    39d0:	.word	0x23c34600
    39d4:	.word	0xdc3cba00
    39d8:	.word	0x004cb223
    39dc:	.word	0x51eb851f
    39e0:	.word	0x016e3600
    39e4:	.word	0x400d8000
    39e8:	.word	0x80003040
    39ec:	.word	0x269fb1ff
    39f0:	.word	0x005b8d80
    39f4:	.word	0x165e9f81
    39f8:	.word	0x269fb200
    39fc:	.word	0x8001307f
    3a00:	.word	0x08f0d17f
    3a04:	.word	0x00e5109f
    3a08:	.word	0x431bde83
    3a0c:	.word	0x2000125c
    3a10:	.word	0x20001258
    3a14:	.word	0x20002400
    3a18:	.word	0x4d3f6400
    3a1c:	.word	0x00b71b00
    3a20:	.word	0x80002036
    3a24:	.word	0x8000206c
    3a28:	.word	0x80002000

00003a2c <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    3a2c:	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    3a2e:	push	{r4, r5}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    3a30:	cbz	r3, 3a3a <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    3a32:	ldr	r3, [r2, #4]
    3a34:	orr.w	r3, r3, #32768	; 0x8000
    3a38:	str	r3, [r2, #4]
	}
	__disable_irq();
    3a3a:	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    3a3c:	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    3a3e:	cbz	r4, 3a68 <schedule_transfer+0x3c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    3a40:	ldr	r3, [pc, #64]	; (3a84 <schedule_transfer+0x58>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    3a42:	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    3a44:	ldr.w	r4, [r3, #432]	; 0x1b0
    3a48:	tst	r4, r1
    3a4a:	bne.n	3a7c <schedule_transfer+0x50>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    3a4c:	ldr.w	r4, [r3, #320]	; 0x140
    3a50:	orr.w	r4, r4, #16384	; 0x4000
    3a54:	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    3a58:	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW));
    3a5c:	ldr.w	r4, [r3, #320]	; 0x140
    3a60:	lsls	r4, r4, #17
    3a62:	bpl.n	3a4c <schedule_transfer+0x20>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    3a64:	tst	r1, r5
    3a66:	bne.n	3a7c <schedule_transfer+0x50>
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
    3a68:	movs	r3, #0
	USB1_ENDPTPRIME |= epmask;
    3a6a:	ldr	r4, [pc, #24]	; (3a84 <schedule_transfer+0x58>)
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    3a6c:	str	r2, [r0, #8]
	endpoint->status = 0;
    3a6e:	str	r3, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    3a70:	ldr.w	r3, [r4, #432]	; 0x1b0
    3a74:	orrs	r1, r3
    3a76:	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    3a7a:	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    3a7c:	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    3a7e:	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    3a80:	pop	{r4, r5}
    3a82:	bx	lr
    3a84:	.word	0x402e0000

00003a88 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    3a88:	push	{r4, r5, r6, lr}
    3a8a:	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    3a8c:	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    3a8e:	cbz	r0, 3ab6 <run_callbacks+0x2e>
    3a90:	mov	r2, r0
    3a92:	movs	r4, #0
    3a94:	b.n	3a9e <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    3a96:	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    3a98:	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    3a9a:	cmp	r2, #1
    3a9c:	beq.n	3ab8 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    3a9e:	ldr	r3, [r2, #4]
    3aa0:	ands.w	r3, r3, #128	; 0x80
    3aa4:	beq.n	3a96 <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    3aa6:	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    3aa8:	cbz	r4, 3ab6 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    3aaa:	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    3aac:	ldr	r5, [r0, #0]
		ep->callback_function(first);
    3aae:	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    3ab0:	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    3ab2:	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    3ab4:	bne.n	3aaa <run_callbacks+0x22>
    3ab6:	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    3ab8:	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    3aba:	str	r3, [r6, #52]	; 0x34
			break;
    3abc:	b.n	3aa8 <run_callbacks+0x20>
    3abe:	nop

00003ac0 <endpoint0_transmit.constprop.1>:
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    3ac0:	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    3ac2:	cbnz	r1, 3b02 <endpoint0_transmit.constprop.1+0x42>
    3ac4:	ldr	r4, [pc, #136]	; (3b50 <endpoint0_transmit.constprop.1+0x90>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3ac6:	ldr	r1, [pc, #140]	; (3b54 <endpoint0_transmit.constprop.1+0x94>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3ac8:	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3aca:	ldr	r3, [pc, #140]	; (3b58 <endpoint0_transmit.constprop.1+0x98>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3acc:	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3ace:	movs	r5, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    3ad0:	str	r1, [r4, #8]
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3ad2:	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    3ad4:	mov	r2, r3
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3ad6:	str	r5, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    3ad8:	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3ada:	ldr.w	r4, [r3, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3ade:	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3ae0:	orr.w	r4, r4, #65537	; 0x10001
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    3ae4:	ldr	r5, [pc, #116]	; (3b5c <endpoint0_transmit.constprop.1+0x9c>)
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3ae6:	str.w	r4, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    3aea:	ldr.w	r1, [r3, #432]	; 0x1b0
    3aee:	orr.w	r1, r1, #1
    3af2:	str.w	r1, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    3af6:	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    3af8:	ldr.w	r3, [r2, #432]	; 0x1b0
    3afc:	cmp	r3, #0
    3afe:	bne.n	3af8 <endpoint0_transmit.constprop.1+0x38>
}
    3b00:	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3b02:	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3b04:	ldr	r3, [pc, #88]	; (3b60 <endpoint0_transmit.constprop.1+0xa0>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    3b06:	ldr	r5, [pc, #80]	; (3b58 <endpoint0_transmit.constprop.1+0x98>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3b08:	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    3b0a:	ldr	r4, [pc, #68]	; (3b50 <endpoint0_transmit.constprop.1+0x90>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3b0c:	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    3b10:	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3b12:	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3b14:	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    3b16:	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    3b1a:	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    3b1c:	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    3b20:	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    3b22:	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    3b26:	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    3b2a:	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    3b2e:	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    3b30:	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    3b32:	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    3b36:	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    3b3a:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    3b3e:	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    3b40:	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    3b42:	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    3b46:	ldr.w	r3, [r2, #432]	; 0x1b0
    3b4a:	cmp	r3, #0
    3b4c:	bne.n	3b46 <endpoint0_transmit.constprop.1+0x86>
    3b4e:	b.n	3ac6 <endpoint0_transmit.constprop.1+0x6>
    3b50:	.word	0x20004000
    3b54:	.word	0x20003020
    3b58:	.word	0x402e0000
    3b5c:	.word	0x200023d4
    3b60:	.word	0x20003000

00003b64 <isr>:
	//transfer_log_count = 0;
}


static void isr(void)
{
    3b64:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    3b68:	ldr	r4, [pc, #752]	; (3e5c <isr+0x2f8>)
	//transfer_log_count = 0;
}


static void isr(void)
{
    3b6a:	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    3b6c:	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    3b70:	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    3b74:	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    3b78:	beq.n	3c38 <isr+0xd4>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    3b7a:	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3b7e:	cmp	r3, #0
    3b80:	beq.n	3c2e <isr+0xca>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    3b82:	mov.w	fp, #65537	; 0x10001
    3b86:	ldr.w	r9, [pc, #764]	; 3e84 <isr+0x320>
    3b8a:	ldr	r6, [pc, #724]	; (3e60 <isr+0x2fc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    3b8c:	mov	r5, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    3b8e:	mov	sl, fp
    3b90:	ldr	r0, [r6, #40]	; 0x28
    3b92:	ldr	r2, [r6, #44]	; 0x2c
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    3b94:	str.w	r3, [r4, #428]	; 0x1ac
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    3b98:	ldr.w	r3, [r4, #320]	; 0x140
    3b9c:	orr.w	r3, r3, #8192	; 0x2000
    3ba0:	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    3ba4:	ldr.w	r3, [r4, #320]	; 0x140
    3ba8:	lsls	r7, r3, #18
    3baa:	bpl.n	3b98 <isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    3bac:	ldr.w	r3, [r5, #320]	; 0x140
    3bb0:	bic.w	r3, r3, #8192	; 0x2000
    3bb4:	str.w	r3, [r5, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    3bb8:	str.w	sl, [r5, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    3bbc:	ldr.w	r3, [r4, #436]	; 0x1b4
    3bc0:	ands.w	r3, r3, #65537	; 0x10001
    3bc4:	bne.n	3bbc <isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3bc6:	uxth	r1, r0
    3bc8:	movw	r7, #1665	; 0x681
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    3bcc:	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3bd0:	cmp	r1, r7
    3bd2:	bhi.w	3d20 <isr+0x1bc>
    3bd6:	cmp.w	r1, #1664	; 0x680
    3bda:	bcs.w	3fb4 <isr+0x450>
    3bde:	cmp.w	r1, #258	; 0x102
    3be2:	beq.w	3eba <isr+0x356>
    3be6:	bhi.w	3db2 <isr+0x24e>
    3bea:	cmp	r1, #128	; 0x80
    3bec:	beq.w	3ea0 <isr+0x33c>
    3bf0:	cmp	r1, #130	; 0x82
    3bf2:	bne.w	3da2 <isr+0x23e>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    3bf6:	uxth	r2, r2
    3bf8:	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    3bfc:	cmp	r1, #7
    3bfe:	bhi.w	3da2 <isr+0x23e>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    3c02:	lsls	r1, r1, #2
    3c04:	ldr	r0, [pc, #604]	; (3e64 <isr+0x300>)
		reply_buffer[0] = 0;
    3c06:	ldr	r7, [pc, #608]	; (3e68 <isr+0x304>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    3c08:	add	r0, r1
    3c0a:	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    3c0c:	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    3c0e:	strb	r3, [r7, #0]
		reply_buffer[1] = 0;
    3c10:	strb	r3, [r7, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    3c12:	bpl.w	4032 <isr+0x4ce>
    3c16:	lsls	r2, r1, #15
    3c18:	bpl.n	3c1e <isr+0xba>
			reply_buffer[0] = 1;
    3c1a:	movs	r3, #1
    3c1c:	strb	r3, [r7, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    3c1e:	movs	r1, #2
    3c20:	ldr	r0, [pc, #580]	; (3e68 <isr+0x304>)
    3c22:	bl	3ac0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3c26:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3c2a:	cmp	r3, #0
    3c2c:	bne.n	3b90 <isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    3c2e:	ldr	r2, [pc, #556]	; (3e5c <isr+0x2f8>)
    3c30:	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    3c34:	cmp	r3, #0
    3c36:	bne.n	3cda <isr+0x176>
					}
				}
			}
		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    3c38:	tst.w	r8, #64	; 0x40
    3c3c:	beq.n	3c70 <isr+0x10c>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    3c3e:	ldr	r3, [pc, #540]	; (3e5c <isr+0x2f8>)
    3c40:	ldr.w	r1, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    3c44:	mov	r2, r3
				}
			}
		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    3c46:	str.w	r1, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    3c4a:	ldr.w	r1, [r3, #444]	; 0x1bc
    3c4e:	str.w	r1, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    3c52:	ldr.w	r4, [r2, #432]	; 0x1b0
    3c56:	ldr	r3, [pc, #516]	; (3e5c <isr+0x2f8>)
    3c58:	cmp	r4, #0
    3c5a:	bne.n	3c52 <isr+0xee>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    3c5c:	mov.w	r2, #4294967295
    3c60:	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    3c64:	ldr.w	r3, [r3, #388]	; 0x184
			// we took too long to respond :(
			// TODO; is this ever really a problem?
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
    3c68:	bl	335c <usb_serial_reset>
		#endif
		endpointN_notify_mask = 0;
    3c6c:	ldr	r3, [pc, #508]	; (3e6c <isr+0x308>)
    3c6e:	str	r4, [r3, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    3c70:	tst.w	r8, #16777216	; 0x1000000
    3c74:	beq.n	3c7e <isr+0x11a>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    3c76:	ldr	r3, [pc, #504]	; (3e70 <isr+0x30c>)
    3c78:	ldr	r3, [r3, #0]
    3c7a:	cbz	r3, 3c7e <isr+0x11a>
    3c7c:	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    3c7e:	tst.w	r8, #33554432	; 0x2000000
    3c82:	beq.n	3c8c <isr+0x128>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    3c84:	ldr	r3, [pc, #492]	; (3e74 <isr+0x310>)
    3c86:	ldr	r3, [r3, #0]
    3c88:	cbz	r3, 3c8c <isr+0x128>
    3c8a:	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    3c8c:	tst.w	r8, #4
    3c90:	beq.n	3ca4 <isr+0x140>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    3c92:	ldr	r3, [pc, #456]	; (3e5c <isr+0x2f8>)
    3c94:	ldr.w	r3, [r3, #388]	; 0x184
    3c98:	ands.w	r3, r3, #512	; 0x200
    3c9c:	beq.n	3d1a <isr+0x1b6>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    3c9e:	ldr	r3, [pc, #472]	; (3e78 <isr+0x314>)
    3ca0:	movs	r2, #1
    3ca2:	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    3ca4:	ldr	r3, [pc, #436]	; (3e5c <isr+0x2f8>)
    3ca6:	ldr.w	r2, [r3, #328]	; 0x148
    3caa:	lsls	r2, r2, #24
    3cac:	bpl.n	3cd4 <isr+0x170>
    3cae:	tst.w	r8, #128	; 0x80
    3cb2:	beq.n	3cd4 <isr+0x170>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    3cb4:	ldr	r1, [pc, #452]	; (3e7c <isr+0x318>)
    3cb6:	ldrb	r2, [r1, #0]
    3cb8:	cbz	r2, 3cd4 <isr+0x170>
			if (--usb_reboot_timer == 0) {
    3cba:	subs	r2, #1
    3cbc:	uxtb	r2, r2
    3cbe:	strb	r2, [r1, #0]
    3cc0:	cbnz	r2, 3cd4 <isr+0x170>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    3cc2:	ldr	r1, [pc, #444]	; (3e80 <isr+0x31c>)
    3cc4:	ldrb	r2, [r1, #0]
    3cc6:	and.w	r2, r2, #251	; 0xfb
    3cca:	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    3ccc:	cmp	r2, #0
    3cce:	beq.w	4136 <isr+0x5d2>
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				asm("bkpt #251"); // run bootloader
    3cd2:	bkpt	0x00fb
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    3cd4:	add	sp, #12
    3cd6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    3cda:	ldr	r1, [pc, #424]	; (3e84 <isr+0x320>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    3cdc:	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    3ce0:	ldr	r0, [r1, #0]
    3ce2:	tst	r3, r0
    3ce4:	bne.w	40be <isr+0x55a>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    3ce8:	ldr	r2, [pc, #384]	; (3e6c <isr+0x308>)
    3cea:	ldr	r4, [r2, #0]
			if (completestatus) {
    3cec:	ands	r4, r3
    3cee:	beq.n	3c38 <isr+0xd4>
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
    3cf0:	lsls	r3, r4, #29
    3cf2:	bmi.w	4154 <isr+0x5f0>
						run_callbacks(endpoint_queue_head + i * 2);
					}
					if (completestatus & (1 << (i + 16))) { // transmit
    3cf6:	lsls	r7, r4, #13
    3cf8:	bmi.w	414c <isr+0x5e8>
			}
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
    3cfc:	lsls	r6, r4, #28
    3cfe:	bmi.w	4164 <isr+0x600>
						run_callbacks(endpoint_queue_head + i * 2);
					}
					if (completestatus & (1 << (i + 16))) { // transmit
    3d02:	lsls	r5, r4, #12
    3d04:	bmi.w	415c <isr+0x5f8>
			}
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
    3d08:	lsls	r0, r4, #27
    3d0a:	bmi.w	4144 <isr+0x5e0>
						run_callbacks(endpoint_queue_head + i * 2);
					}
					if (completestatus & (1 << (i + 16))) { // transmit
    3d0e:	lsls	r1, r4, #11
    3d10:	bpl.n	3c38 <isr+0xd4>
						run_callbacks(endpoint_queue_head + i * 2 + 1);
    3d12:	ldr	r0, [pc, #372]	; (3e88 <isr+0x324>)
    3d14:	bl	3a88 <run_callbacks>
    3d18:	b.n	3c38 <isr+0xd4>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    3d1a:	ldr	r2, [pc, #348]	; (3e78 <isr+0x314>)
    3d1c:	strb	r3, [r2, #0]
    3d1e:	b.n	3ca4 <isr+0x140>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3d20:	movw	r7, #8225	; 0x2021
    3d24:	cmp	r1, r7
    3d26:	beq.n	3d9a <isr+0x236>
    3d28:	bhi.n	3e0a <isr+0x2a6>
    3d2a:	cmp.w	r1, #2176	; 0x880
    3d2e:	beq.w	3f98 <isr+0x434>
    3d32:	cmp.w	r1, #2304	; 0x900
    3d36:	bne.n	3da2 <isr+0x23e>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    3d38:	ubfx	r0, r0, #16, #8
    3d3c:	ldr	r2, [pc, #332]	; (3e8c <isr+0x328>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    3d3e:	ldr	r1, [pc, #336]	; (3e90 <isr+0x32c>)
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    3d40:	strb	r0, [r2, #0]
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    3d42:	ldr	r7, [pc, #336]	; (3e94 <isr+0x330>)
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    3d44:	ldr	r2, [pc, #336]	; (3e98 <isr+0x334>)
    3d46:	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    3d48:	str.w	r7, [r5, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    3d4c:	str.w	r1, [r5, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    3d50:	str.w	r2, [r5, #464]	; 0x1d0
		#endif
		#if defined(ENDPOINT7_CONFIG)
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
    3d54:	bl	3360 <usb_serial_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3d58:	ldr	r2, [pc, #320]	; (3e9c <isr+0x338>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3d5a:	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3d5c:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3d5e:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3d60:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3d62:	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3d64:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3d66:	ldr.w	r1, [r5, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3d6a:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3d6c:	orr.w	r1, r1, #65537	; 0x10001
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3d70:	str	r2, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3d72:	str.w	r1, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3d76:	ldr.w	r2, [r5, #432]	; 0x1b0
    3d7a:	orr.w	r2, r2, #65536	; 0x10000
    3d7e:	str.w	r2, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    3d82:	ldr	r2, [pc, #256]	; (3e84 <isr+0x320>)
    3d84:	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    3d86:	ldr.w	r3, [r4, #432]	; 0x1b0
    3d8a:	cmp	r3, #0
    3d8c:	bne.n	3d86 <isr+0x222>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3d8e:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3d92:	cmp	r3, #0
    3d94:	bne.w	3b90 <isr+0x2c>
    3d98:	b.n	3c2e <isr+0xca>
		usb_cdc_line_rtsdtr = setup.wValue;
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
    3d9a:	lsrs	r1, r2, #16
    3d9c:	cmp	r1, #7
    3d9e:	beq.w	403a <isr+0x4d6>
			return;
		}
		break;
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    3da2:	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3da6:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3daa:	cmp	r3, #0
    3dac:	bne.w	3b90 <isr+0x2c>
    3db0:	b.n	3c2e <isr+0xca>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3db2:	movw	r7, #770	; 0x302
    3db6:	cmp	r1, r7
    3db8:	beq.w	3f32 <isr+0x3ce>
    3dbc:	cmp.w	r1, #1280	; 0x500
    3dc0:	bne.n	3da2 <isr+0x23e>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3dc2:	ldr	r2, [pc, #216]	; (3e9c <isr+0x338>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3dc4:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3dc6:	movs	r7, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3dc8:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3dca:	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3dcc:	str	r7, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3dce:	ldr.w	r1, [r5, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3dd2:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3dd4:	orr.w	r3, r1, #65537	; 0x10001
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3dd8:	str	r2, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3dda:	str.w	r3, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3dde:	ldr.w	r3, [r5, #432]	; 0x1b0
    3de2:	orr.w	r3, r3, #65536	; 0x10000
    3de6:	str.w	r3, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    3dea:	ldr.w	r3, [r4, #432]	; 0x1b0
    3dee:	cmp	r3, #0
    3df0:	bne.n	3dea <isr+0x286>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    3df2:	lsrs	r3, r0, #16
    3df4:	lsls	r3, r3, #25
    3df6:	orr.w	r3, r3, #16777216	; 0x1000000
    3dfa:	str.w	r3, [r5, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3dfe:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3e02:	cmp	r3, #0
    3e04:	bne.w	3b90 <isr+0x2c>
    3e08:	b.n	3c2e <isr+0xca>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3e0a:	movw	r3, #8737	; 0x2221
    3e0e:	cmp	r1, r3
    3e10:	beq.w	3f20 <isr+0x3bc>
    3e14:	movw	r3, #8993	; 0x2321
    3e18:	cmp	r1, r3
    3e1a:	bne.n	3da2 <isr+0x23e>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3e1c:	ldr	r3, [pc, #124]	; (3e9c <isr+0x338>)
    3e1e:	movs	r1, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3e20:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3e22:	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3e24:	movs	r1, #0
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3e26:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3e28:	ldr.w	r2, [r4, #444]	; 0x1bc
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3e2c:	str	r3, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3e2e:	orr.w	r2, r2, #65537	; 0x10001
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3e32:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3e34:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3e36:	str.w	r2, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3e3a:	ldr.w	r3, [r4, #432]	; 0x1b0
    3e3e:	orr.w	r3, r3, #65536	; 0x10000
    3e42:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    3e46:	ldr.w	r3, [r4, #432]	; 0x1b0
    3e4a:	cmp	r3, #0
    3e4c:	bne.n	3e46 <isr+0x2e2>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3e4e:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3e52:	cmp	r3, #0
    3e54:	bne.w	3b90 <isr+0x2c>
    3e58:	b.n	3c2e <isr+0xca>
    3e5a:	nop
    3e5c:	.word	0x402e0000
    3e60:	.word	0x20004000
    3e64:	.word	0x402e01c0
    3e68:	.word	0x200023e8
    3e6c:	.word	0x200023c4
    3e70:	.word	0x200023c0
    3e74:	.word	0x200023cc
    3e78:	.word	0x200023d0
    3e7c:	.word	0x200023d8
    3e80:	.word	0x200023c8
    3e84:	.word	0x200023d4
    3e88:	.word	0x20004240
    3e8c:	.word	0x200023f8
    3e90:	.word	0x000200c8
    3e94:	.word	0x00cc0002
    3e98:	.word	0x00c80002
    3e9c:	.word	0x20003020
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    3ea0:	ldr	r2, [pc, #744]	; (418c <isr+0x628>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    3ea2:	movs	r1, #2
    3ea4:	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    3ea6:	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    3ea8:	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    3eaa:	bl	3ac0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3eae:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3eb2:	cmp	r3, #0
    3eb4:	bne.w	3b90 <isr+0x2c>
    3eb8:	b.n	3c2e <isr+0xca>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    3eba:	uxth	r2, r2
    3ebc:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    3ec0:	cmp	r3, #7
    3ec2:	bhi.w	3da2 <isr+0x23e>
		dir = setup.wIndex & 0x80;
		if (dir) {
    3ec6:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    3eca:	mov.w	r3, r3, lsl #2
    3ece:	ldr	r2, [pc, #704]	; (4190 <isr+0x62c>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3ed0:	mov.w	r1, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    3ed4:	add	r2, r3
    3ed6:	ldr	r3, [r2, #0]
    3ed8:	ite	ne
    3eda:	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    3ede:	biceq.w	r3, r3, #1
    3ee2:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3ee4:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3ee6:	ldr	r3, [pc, #684]	; (4194 <isr+0x630>)
    3ee8:	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3eea:	movs	r1, #0
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3eec:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3eee:	ldr.w	r2, [r4, #444]	; 0x1bc
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3ef2:	str	r3, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3ef4:	orr.w	r2, r2, #65537	; 0x10001
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3ef8:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3efa:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3efc:	str.w	r2, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3f00:	ldr.w	r3, [r4, #432]	; 0x1b0
    3f04:	orr.w	r3, r3, #65536	; 0x10000
    3f08:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    3f0c:	ldr.w	r3, [r4, #432]	; 0x1b0
    3f10:	cmp	r3, #0
    3f12:	bne.n	3f0c <isr+0x3a8>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3f14:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3f18:	cmp	r3, #0
    3f1a:	bne.w	3b90 <isr+0x2c>
    3f1e:	b.n	3c2e <isr+0xca>
			}
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    3f20:	ldr	r3, [pc, #628]	; (4198 <isr+0x634>)
		usb_cdc_line_rtsdtr = setup.wValue;
    3f22:	ubfx	r0, r0, #16, #8
			}
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    3f26:	ldr	r2, [pc, #628]	; (419c <isr+0x638>)
    3f28:	ldr	r1, [r3, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    3f2a:	ldr	r3, [pc, #628]	; (41a0 <isr+0x63c>)
			}
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    3f2c:	str	r1, [r2, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    3f2e:	strb	r0, [r3, #0]
    3f30:	b.n	3e1c <isr+0x2b8>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    3f32:	uxth	r2, r2
    3f34:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    3f38:	cmp	r3, #7
    3f3a:	bhi.w	3da2 <isr+0x23e>
		dir = setup.wIndex & 0x80;
		if (dir) {
    3f3e:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    3f42:	mov.w	r3, r3, lsl #2
    3f46:	ldr	r2, [pc, #584]	; (4190 <isr+0x62c>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3f48:	mov.w	r1, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    3f4c:	add	r2, r3
    3f4e:	ldr	r3, [r2, #0]
    3f50:	ite	ne
    3f52:	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    3f56:	orreq.w	r3, r3, #1
    3f5a:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3f5c:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3f5e:	ldr	r3, [pc, #564]	; (4194 <isr+0x630>)
    3f60:	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3f62:	movs	r1, #0
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3f64:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3f66:	ldr.w	r2, [r4, #444]	; 0x1bc
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3f6a:	str	r3, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3f6c:	orr.w	r2, r2, #65537	; 0x10001
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3f70:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3f72:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3f74:	str.w	r2, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3f78:	ldr.w	r3, [r4, #432]	; 0x1b0
    3f7c:	orr.w	r3, r3, #65536	; 0x10000
    3f80:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    3f84:	ldr.w	r3, [r4, #432]	; 0x1b0
    3f88:	cmp	r3, #0
    3f8a:	bne.n	3f84 <isr+0x420>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3f8c:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3f90:	cmp	r3, #0
    3f92:	bne.w	3b90 <isr+0x2c>
    3f96:	b.n	3c2e <isr+0xca>
		usb_midi_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    3f98:	ldr	r2, [pc, #520]	; (41a4 <isr+0x640>)
		endpoint0_transmit(reply_buffer, 1, 0);
    3f9a:	movs	r1, #1
		usb_midi_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    3f9c:	ldr	r3, [pc, #492]	; (418c <isr+0x628>)
    3f9e:	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    3fa0:	mov	r0, r3
		usb_midi_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    3fa2:	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    3fa4:	bl	3ac0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3fa8:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3fac:	cmp	r3, #0
    3fae:	bne.w	3b90 <isr+0x2c>
    3fb2:	b.n	3c2e <isr+0xca>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    3fb4:	ldr	r3, [pc, #496]	; (41a8 <isr+0x644>)
    3fb6:	ldr	r1, [r3, #4]
    3fb8:	cmp	r1, #0
    3fba:	beq.w	3da2 <isr+0x23e>
    3fbe:	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    3fc0:	uxth.w	lr, r2
    3fc4:	b.n	3fd0 <isr+0x46c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    3fc6:	adds	r3, #12
    3fc8:	ldr	r1, [r3, #4]
    3fca:	cmp	r1, #0
    3fcc:	beq.w	3da2 <isr+0x23e>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    3fd0:	ldrh	r7, [r3, #0]
    3fd2:	cmp	r7, r0
    3fd4:	bne.n	3fc6 <isr+0x462>
    3fd6:	ldrh	r7, [r3, #2]
    3fd8:	cmp	r7, lr
    3fda:	bne.n	3fc6 <isr+0x462>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    3fdc:	lsrs	r7, r0, #8
    3fde:	cmp	r7, #3
    3fe0:	beq.w	41f0 <isr+0x68c>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    3fe4:	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    3fe6:	lsrs	r2, r2, #16
    3fe8:	cmp	r3, r2
    3fea:	it	cs
    3fec:	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    3fee:	cmp.w	r0, #512	; 0x200
    3ff2:	beq.w	416c <isr+0x608>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    3ff6:	cmp.w	r0, #1792	; 0x700
    3ffa:	beq.w	4110 <isr+0x5ac>
    3ffe:	ldr	r7, [pc, #428]	; (41ac <isr+0x648>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    4000:	mov	r2, r3
    4002:	str	r3, [sp, #4]
    4004:	mov	r0, r7
    4006:	bl	2df0 <memcpy>
    400a:	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    400c:	bic.w	r2, r7, #31
	uint32_t end_addr = (uint32_t)addr + size;
    4010:	add	r7, r3
	asm("dsb");
    4012:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    4016:	ldr	r1, [pc, #408]	; (41b0 <isr+0x64c>)
    4018:	str	r2, [r1, #0]
		location += 32;
    401a:	adds	r2, #32
	} while (location < end_addr);
    401c:	cmp	r7, r2
    401e:	bhi.n	4016 <isr+0x4b2>
	asm("dsb");
    4020:	dsb	sy
	asm("isb");
    4024:	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    4028:	ldr	r0, [pc, #384]	; (41ac <isr+0x648>)
    402a:	mov	r1, r3
    402c:	bl	3ac0 <endpoint0_transmit.constprop.1>
    4030:	b.n	3c26 <isr+0xc2>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    4032:	lsls	r3, r1, #31
    4034:	bpl.w	3c1e <isr+0xba>
    4038:	b.n	3c1a <isr+0xb6>
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    403a:	ldr	r7, [pc, #376]	; (41b4 <isr+0x650>)
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    403c:	mov.w	lr, #1
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    4040:	str	r3, [r6, #12]
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    4042:	ldr	r1, [pc, #372]	; (41b8 <isr+0x654>)
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    4044:	ldr	r3, [pc, #372]	; (41bc <isr+0x658>)
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    4046:	str	r0, [r7, #0]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    4048:	str.w	lr, [r3]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    404c:	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    404e:	ldr.w	r0, [r5, #432]	; 0x1b0
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
    4052:	ldr	r1, [pc, #364]	; (41c0 <isr+0x65c>)
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    4054:	str	r2, [r7, #4]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    4056:	orr.w	r2, r0, lr
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    405a:	add.w	r7, r1, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
    405e:	add.w	lr, r1, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    4062:	str	r3, [r6, #8]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    4064:	add.w	r0, r1, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    4068:	str.w	r2, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    406c:	add.w	r2, r1, #16384	; 0x4000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    4070:	str	r1, [r3, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    4072:	str	r7, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    4074:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    4078:	str	r0, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    407a:	str	r2, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
    407c:	ldr.w	r3, [r4, #432]	; 0x1b0
    4080:	cmp	r3, #0
    4082:	bne.n	407c <isr+0x518>
	}
	endpoint0_transfer_ack.next = 1;
    4084:	ldr	r2, [pc, #268]	; (4194 <isr+0x630>)
    4086:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    4088:	movw	r1, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    408c:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    408e:	str	r0, [r2, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    4090:	mov.w	r0, #65536	; 0x10000
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    4094:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    4096:	ldr.w	r1, [r5, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    409a:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    409c:	orr.w	r3, r1, #65537	; 0x10001
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    40a0:	str	r2, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    40a2:	str.w	r3, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    40a6:	ldr.w	r3, [r5, #432]	; 0x1b0
    40aa:	orrs	r3, r0
    40ac:	str.w	r3, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    40b0:	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    40b4:	ldr.w	r3, [r4, #432]	; 0x1b0
    40b8:	cmp	r3, #0
    40ba:	bne.n	40b4 <isr+0x550>
    40bc:	b.n	3c26 <isr+0xc2>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    40be:	ldr	r4, [pc, #244]	; (41b4 <isr+0x650>)
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    40c0:	movw	r0, #8225	; 0x2021
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    40c4:	movs	r5, #0
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    40c6:	ldrh	r4, [r4, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    40c8:	str	r5, [r1, #0]
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    40ca:	cmp	r4, r0
    40cc:	bne.w	3ce8 <isr+0x184>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    40d0:	ldr	r1, [pc, #236]	; (41c0 <isr+0x65c>)
    40d2:	ldr	r4, [pc, #240]	; (41c4 <isr+0x660>)
    40d4:	ldmia	r1, {r0, r1}
    40d6:	lsrs	r5, r1, #16
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    40d8:	cmp	r0, #134	; 0x86

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    40da:	str	r0, [r4, #0]
    40dc:	strh	r1, [r4, #4]
    40de:	strb	r5, [r4, #6]
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    40e0:	bne.w	3ce8 <isr+0x184>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    40e4:	cpsid	i
	sof_usage |= (1 << interface);
    40e6:	ldr	r0, [pc, #224]	; (41c8 <isr+0x664>)
    40e8:	ldrb	r1, [r0, #0]
    40ea:	orr.w	r1, r1, #4
    40ee:	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    40f0:	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    40f4:	lsls	r0, r1, #24
    40f6:	bmi.n	4106 <isr+0x5a2>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    40f8:	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    40fc:	movs	r0, #128	; 0x80
    40fe:	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    4102:	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    4106:	cpsie	i
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    4108:	ldr	r2, [pc, #192]	; (41cc <isr+0x668>)
    410a:	movs	r1, #80	; 0x50
    410c:	strb	r1, [r2, #0]
    410e:	b.n	3ce8 <isr+0x184>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    4110:	ldr	r0, [pc, #188]	; (41d0 <isr+0x66c>)
					memcpy(usb_descriptor_buffer, src, datalen);
    4112:	mov	r2, r3
    4114:	ldr	r7, [pc, #148]	; (41ac <isr+0x648>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    4116:	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    411a:	ldr	r1, [pc, #184]	; (41d4 <isr+0x670>)
    411c:	ldr	r0, [pc, #184]	; (41d8 <isr+0x674>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    411e:	str	r3, [sp, #4]
    4120:	cmp.w	lr, #0
    4124:	it	eq
    4126:	moveq	r1, r0
    4128:	mov	r0, r7
    412a:	bl	2df0 <memcpy>
					usb_descriptor_buffer[1] = 7;
    412e:	movs	r2, #7
    4130:	ldr	r3, [sp, #4]
    4132:	strb	r2, [r7, #1]
    4134:	b.n	400c <isr+0x4a8>

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
	if (sof_usage == 0) {
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    4136:	ldr.w	r2, [r3, #328]	; 0x148
    413a:	bic.w	r2, r2, #128	; 0x80
    413e:	str.w	r2, [r3, #328]	; 0x148
    4142:	b.n	3cd2 <isr+0x16e>
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
						run_callbacks(endpoint_queue_head + i * 2);
    4144:	ldr	r0, [pc, #148]	; (41dc <isr+0x678>)
    4146:	bl	3a88 <run_callbacks>
    414a:	b.n	3d0e <isr+0x1aa>
					}
					if (completestatus & (1 << (i + 16))) { // transmit
						run_callbacks(endpoint_queue_head + i * 2 + 1);
    414c:	ldr	r0, [pc, #144]	; (41e0 <isr+0x67c>)
    414e:	bl	3a88 <run_callbacks>
    4152:	b.n	3cfc <isr+0x198>
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
						run_callbacks(endpoint_queue_head + i * 2);
    4154:	ldr	r0, [pc, #140]	; (41e4 <isr+0x680>)
    4156:	bl	3a88 <run_callbacks>
    415a:	b.n	3cf6 <isr+0x192>
					}
					if (completestatus & (1 << (i + 16))) { // transmit
						run_callbacks(endpoint_queue_head + i * 2 + 1);
    415c:	ldr	r0, [pc, #136]	; (41e8 <isr+0x684>)
    415e:	bl	3a88 <run_callbacks>
    4162:	b.n	3d08 <isr+0x1a4>
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
						run_callbacks(endpoint_queue_head + i * 2);
    4164:	ldr	r0, [pc, #132]	; (41ec <isr+0x688>)
    4166:	bl	3a88 <run_callbacks>
    416a:	b.n	3d02 <isr+0x19e>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    416c:	ldr	r0, [pc, #96]	; (41d0 <isr+0x66c>)
					memcpy(usb_descriptor_buffer, src, datalen);
    416e:	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    4170:	ldr	r1, [pc, #100]	; (41d8 <isr+0x674>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    4172:	ldrb	r7, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    4174:	ldr	r0, [pc, #92]	; (41d4 <isr+0x670>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    4176:	str	r3, [sp, #4]
    4178:	cmp	r7, #0
    417a:	it	eq
    417c:	moveq	r1, r0
    417e:	ldr	r0, [pc, #44]	; (41ac <isr+0x648>)
    4180:	bl	2df0 <memcpy>
    4184:	ldr	r7, [pc, #36]	; (41ac <isr+0x648>)
    4186:	ldr	r3, [sp, #4]
    4188:	b.n	400c <isr+0x4a8>
    418a:	nop
    418c:	.word	0x200023e8
    4190:	.word	0x402e01c0
    4194:	.word	0x20003020
    4198:	.word	0x20002404
    419c:	.word	0x20002ac8
    41a0:	.word	0x20002328
    41a4:	.word	0x200023f8
    41a8:	.word	0x20000898
    41ac:	.word	0x20203000
    41b0:	.word	0xe000ef70
    41b4:	.word	0x200023e0
    41b8:	.word	0x00070080
    41bc:	.word	0x20003000
    41c0:	.word	0x200023f0
    41c4:	.word	0x20002ac0
    41c8:	.word	0x200023c8
    41cc:	.word	0x200023d8
    41d0:	.word	0x200023d0
    41d4:	.word	0x60001654
    41d8:	.word	0x60001698
    41dc:	.word	0x20004200
    41e0:	.word	0x20004140
    41e4:	.word	0x20004100
    41e8:	.word	0x200041c0
    41ec:	.word	0x20004180
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    41f0:	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    41f2:	ldrb	r3, [r1, #0]
    41f4:	cmp	r3, r2
    41f6:	it	cs
    41f8:	movcs	r3, r2
    41fa:	b.n	3ff6 <isr+0x492>

000041fc <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    41fc:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    41fe:	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    4202:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    4206:	ite	ne
    4208:	movne	r7, #0
    420a:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    420e:	cmp	r2, #2
    4210:	bls.n	4216 <usb_config_rx+0x1a>
    4212:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    4216:	mov.w	sl, r0, lsl #7
    421a:	ldr.w	r9, [pc, #64]	; 425c <usb_config_rx+0x60>
    421e:	mov	r5, r1
    4220:	mov	r4, r0
    4222:	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    4226:	movs	r1, #0
    4228:	movs	r2, #64	; 0x40
    422a:	mov	r8, r3
    422c:	mov	r0, r6
    422e:	bl	8e58 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    4232:	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    4234:	orr.w	r1, r7, r5, lsl #16
    4238:	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    423c:	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    4240:	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    4242:	cmp.w	r8, #0
    4246:	beq.n	4212 <usb_config_rx+0x16>
    4248:	ldr	r3, [pc, #12]	; (4258 <usb_config_rx+0x5c>)
    424a:	lsls	r0, r4
    424c:	ldr	r4, [r3, #0]
    424e:	orrs	r0, r4
    4250:	str	r0, [r3, #0]
    4252:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4256:	nop
    4258:	.word	0x200023c4
    425c:	.word	0x20004000

00004260 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    4260:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    4262:	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    4266:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    426a:	ite	ne
    426c:	movne	r7, #0
    426e:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    4272:	cmp	r2, #2
    4274:	bls.n	427a <usb_config_tx+0x1a>
    4276:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    427a:	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    427c:	lsls	r5, r0, #7
    427e:	ldr.w	r9, [pc, #68]	; 42c4 <usb_config_tx+0x64>
    4282:	mov	r8, r1
    4284:	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    4286:	movs	r1, #0
    4288:	mov	r4, r0
    428a:	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    428c:	add.w	sl, r5, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    4290:	mov	r0, sl
    4292:	bl	8e58 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    4296:	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    4298:	orr.w	r1, r7, r8, lsl #16
    429c:	str.w	r1, [r5, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    42a0:	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    42a4:	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    42a8:	cmp	r6, #0
    42aa:	beq.n	4276 <usb_config_tx+0x16>
    42ac:	add.w	r0, r4, #16
    42b0:	ldr	r3, [pc, #12]	; (42c0 <usb_config_tx+0x60>)
    42b2:	lsls	r2, r0
    42b4:	ldr	r0, [r3, #0]
    42b6:	orrs	r2, r0
    42b8:	str	r2, [r3, #0]
    42ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    42be:	nop
    42c0:	.word	0x200023c4
    42c4:	.word	0x20004000

000042c8 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    42c8:	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    42ca:	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    42cc:	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    42ce:	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    42d2:	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    42d4:	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    42d6:	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    42d8:	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    42dc:	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    42e0:	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    42e4:	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    42e8:	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    42ea:	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    42ec:	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    42ee:	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    42f0:	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    42f2:	pop	{r4, r5, r6, r7}
    42f4:	bx	lr
    42f6:	nop

000042f8 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    42f8:	subs	r3, r0, #2
    42fa:	cmp	r3, #2
    42fc:	bls.n	4300 <usb_transmit+0x8>
    42fe:	bx	lr
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    4300:	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    4302:	ldr	r3, [pc, #24]	; (431c <usb_transmit+0x24>)
    4304:	add.w	r4, r0, #16
    4308:	movs	r5, #1
    430a:	mov	r2, r1
    430c:	add.w	r0, r3, r0, lsl #7
    4310:	lsl.w	r1, r5, r4
}
    4314:	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    4316:	b.w	3a2c <schedule_transfer>
    431a:	nop
    431c:	.word	0x20004040

00004320 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    4320:	subs	r3, r0, #2
    4322:	cmp	r3, #2
    4324:	bls.n	4328 <usb_receive+0x8>
    4326:	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    4328:	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    432a:	ldr	r3, [pc, #20]	; (4340 <usb_receive+0x20>)
    432c:	movs	r4, #1
    432e:	mov	r2, r1
    4330:	lsl.w	r1, r4, r0
    4334:	add.w	r0, r3, r0, lsl #7
}
    4338:	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    433c:	b.w	3a2c <schedule_transfer>
    4340:	.word	0x20004000

00004344 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    4344:	ldr	r0, [r0, #4]
#endif
}
    4346:	bx	lr

00004348 <delay>:

void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    4348:	cmp	r0, #0
    434a:	beq.n	43fc <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    434c:	movs	r2, #1
{

}*/

void delay(uint32_t msec)
{
    434e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4352:	sub	sp, #20
    4354:	mov	fp, r0
    4356:	ldr	r4, [pc, #168]	; (4400 <delay+0xb8>)
    4358:	ldr	r5, [pc, #168]	; (4404 <delay+0xbc>)
    435a:	ldr	r6, [pc, #172]	; (4408 <delay+0xc0>)
    435c:	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    4360:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    4364:	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    4366:	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    4368:	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    436c:	cmp	r1, #0
    436e:	bne.n	4360 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    4370:	ldr	r7, [pc, #152]	; (440c <delay+0xc4>)
    4372:	strd	r8, r9, [sp, #8]
    4376:	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    4378:	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    437a:	ldr	r2, [pc, #148]	; (4410 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    437c:	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    4380:	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    4382:	ldr	r2, [r2, #0]
    4384:	movs	r7, #1
    4386:	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    438a:	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    438e:	mov	r8, r3
	if (frac > 1000) frac = 1000;
    4390:	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    4392:	cmp	r3, r1
    4394:	it	eq
    4396:	cmpeq	r2, r8
    4398:	ite	cs
    439a:	movcs	sl, r8
    439c:	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    439e:	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    43a2:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    43a6:	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    43a8:	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    43aa:	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    43ae:	cmp	r3, #0
    43b0:	bne.n	43a2 <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    43b2:	ldr	r0, [sp, #4]
    43b4:	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    43b6:	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    43b8:	ldr	r0, [pc, #84]	; (4410 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    43ba:	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    43be:	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    43c0:	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    43c4:	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    43c8:	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    43cc:	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    43d0:	mov	r8, r1
	if (frac > 1000) frac = 1000;
    43d2:	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    43d4:	cmp	r1, r3
    43d6:	it	eq
    43d8:	cmpeq	r0, r8
    43da:	ite	cs
    43dc:	movcs	r3, r8
    43de:	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    43e0:	add	r2, r3
    43e2:	cmp	r2, lr
    43e4:	bcc.n	43f6 <delay+0xae>
			if (--msec == 0) return;
    43e6:	subs.w	fp, fp, #1
			start += 1000;
    43ea:	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    43ee:	bne.n	43a2 <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    43f0:	add	sp, #20
    43f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    43f6:	bl	4bb8 <yield>
	}
    43fa:	b.n	43a2 <delay+0x5a>
    43fc:	bx	lr
    43fe:	nop
    4400:	.word	0x20004280
    4404:	.word	0x20002404
    4408:	.word	0x200023fc
    440c:	.word	0xe0001004
    4410:	.word	0x20002400

00004414 <Panic_Temp_isr>:

static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
    4414:	cpsid	i
  IOMUXC_GPR_GPR16 = 0x00000007;
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    4416:	ldr	r2, [pc, #24]	; (4430 <Panic_Temp_isr+0x1c>)
static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
  IOMUXC_GPR_GPR16 = 0x00000007;
    4418:	movs	r1, #7
    441a:	ldr	r3, [pc, #24]	; (4434 <Panic_Temp_isr+0x20>)
    441c:	str	r1, [r3, #64]	; 0x40
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    441e:	ldr	r3, [r2, #56]	; 0x38
    4420:	orr.w	r3, r3, #64	; 0x40
    4424:	str	r3, [r2, #56]	; 0x38
  asm volatile ("dsb":::"memory");
    4426:	dsb	sy
  while (1) asm ("wfi");
    442a:	wfi
    442c:	b.n	442a <Panic_Temp_isr+0x16>
    442e:	nop
    4430:	.word	0x400d4000
    4434:	.word	0x400ac000

00004438 <flexpwmWrite>:
};

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
    4438:	push	{r4, r5, r6, r7, lr}
	uint16_t mask = 1 << submodule;
	uint32_t modulo = p->SM[submodule].VAL1;
    443a:	add.w	r6, r1, r1, lsl #1
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    443e:	ldr	r4, [pc, #164]	; (44e4 <flexpwmWrite+0xac>)

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    4440:	movs	r5, #1
	uint32_t modulo = p->SM[submodule].VAL1;
    4442:	add.w	r6, r0, r6, lsl #5
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    4446:	ldrb.w	ip, [r4]

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    444a:	lsl.w	r1, r5, r1
	uint32_t modulo = p->SM[submodule].VAL1;
    444e:	ldrh	r4, [r6, #14]

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    4450:	uxth.w	lr, r1
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    4454:	ldrh.w	r5, [r0, #392]	; 0x188
#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
	uint32_t modulo = p->SM[submodule].VAL1;
    4458:	uxth	r4, r4
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    445a:	mov.w	r7, lr, lsl #4

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
	uint32_t modulo = p->SM[submodule].VAL1;
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    445e:	mla	r3, r4, r3, r3
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    4462:	uxth	r5, r5
    4464:	and.w	r7, r7, #240	; 0xf0

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
	uint32_t modulo = p->SM[submodule].VAL1;
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    4468:	lsr.w	r3, r3, ip
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    446c:	orrs	r5, r7
    446e:	cmp	r3, r4
    4470:	strh.w	r5, [r0, #392]	; 0x188
    4474:	it	cs
    4476:	movcs	r3, r4
	switch (channel) {
    4478:	cmp	r2, #1
    447a:	beq.n	44c2 <flexpwmWrite+0x8a>
    447c:	bcc.n	44aa <flexpwmWrite+0x72>
    447e:	cmp	r2, #2
    4480:	beq.n	4494 <flexpwmWrite+0x5c>
    4482:	and.w	r1, r1, #15
	  case 2: // B
		p->SM[submodule].VAL5 = cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
		//printf(" write channel B\n");
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    4486:	ldrh.w	r3, [r0, #392]	; 0x188
    448a:	uxth	r3, r3
    448c:	orrs	r1, r3
    448e:	strh.w	r1, [r0, #392]	; 0x188
    4492:	pop	{r4, r5, r6, r7, pc}
		p->SM[submodule].VAL3 = cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
		//printf(" write channel A\n");
		break;
	  case 2: // B
		p->SM[submodule].VAL5 = cval;
    4494:	uxth	r3, r3
    4496:	and.w	r1, r1, #15
    449a:	strh	r3, [r6, #30]
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
    449c:	ldrh.w	r3, [r0, #384]	; 0x180
    44a0:	uxth	r3, r3
    44a2:	orrs	r7, r3
    44a4:	strh.w	r7, [r0, #384]	; 0x180
    44a8:	b.n	4486 <flexpwmWrite+0x4e>
	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
	switch (channel) {
	  case 0: // X
		p->SM[submodule].VAL0 = modulo - cval;
    44aa:	subs	r3, r4, r3
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
    44ac:	and.w	r1, r1, #15
	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
	switch (channel) {
	  case 0: // X
		p->SM[submodule].VAL0 = modulo - cval;
    44b0:	uxth	r3, r3
    44b2:	strh	r3, [r6, #10]
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
    44b4:	ldrh.w	r3, [r0, #384]	; 0x180
    44b8:	uxth	r3, r3
    44ba:	orrs	r3, r1
    44bc:	strh.w	r3, [r0, #384]	; 0x180
		//printf(" write channel X\n");
		break;
    44c0:	b.n	4486 <flexpwmWrite+0x4e>
	  case 1: // A
		p->SM[submodule].VAL3 = cval;
    44c2:	uxth	r3, r3
    44c4:	and.w	r1, r1, #15
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    44c8:	mov.w	lr, lr, lsl #8
		p->SM[submodule].VAL0 = modulo - cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
		//printf(" write channel X\n");
		break;
	  case 1: // A
		p->SM[submodule].VAL3 = cval;
    44cc:	strh	r3, [r6, #22]
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    44ce:	ldrh.w	r3, [r0, #384]	; 0x180
    44d2:	and.w	lr, lr, #3840	; 0xf00
    44d6:	uxth	r3, r3
    44d8:	orr.w	lr, lr, r3
    44dc:	strh.w	lr, [r0, #384]	; 0x180
		//printf(" write channel A\n");
		break;
    44e0:	b.n	4486 <flexpwmWrite+0x4e>
    44e2:	nop
    44e4:	.word	0x20001260

000044e8 <flexpwmFrequency>:
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
}

void flexpwmFrequency(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, float frequency)
{
    44e8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint16_t mask = 1 << submodule;
	uint32_t olddiv = p->SM[submodule].VAL1;
    44ec:	mov.w	lr, r1, lsl #1
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
    44f0:	ldr	r2, [pc, #228]	; (45d8 <flexpwmFrequency+0xf0>)
    44f2:	vmov.f64	d6, #96	; 0x3f000000  0.5
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
}

void flexpwmFrequency(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, float frequency)
{
	uint16_t mask = 1 << submodule;
    44f6:	mov.w	ip, #1
	uint32_t olddiv = p->SM[submodule].VAL1;
    44fa:	add.w	r3, lr, r1
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
}

void flexpwmFrequency(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, float frequency)
{
	uint16_t mask = 1 << submodule;
    44fe:	lsl.w	r7, ip, r1
	uint32_t olddiv = p->SM[submodule].VAL1;
    4502:	add.w	r3, r0, r3, lsl #5
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
}

void flexpwmFrequency(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, float frequency)
{
	uint16_t mask = 1 << submodule;
    4506:	uxth	r6, r7
	uint32_t olddiv = p->SM[submodule].VAL1;
    4508:	ldrh	r3, [r3, #14]
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
    450a:	vldr	s15, [r2]
}

void flexpwmFrequency(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, float frequency)
{
	uint16_t mask = 1 << submodule;
	uint32_t olddiv = p->SM[submodule].VAL1;
    450e:	uxth	r5, r3
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
    4510:	vcvt.f32.u32	s15, s15
    4514:	vdiv.f32	s0, s15, s0
    4518:	vcvt.f64.f32	d0, s0
    451c:	vadd.f64	d0, d0, d6
    4520:	vcvt.u32.f64	s15, d0
    4524:	vmov	r3, s15
	uint32_t prescale = 0;
	//printf(" div=%lu\n", newdiv);
	while (newdiv > 65535 && prescale < 7) {
    4528:	cmp.w	r3, #65536	; 0x10000
    452c:	bcc.n	45cc <flexpwmFrequency+0xe4>
    452e:	movs	r2, #0
    4530:	movw	r4, #65535	; 0xffff
    4534:	b.n	453a <flexpwmFrequency+0x52>
    4536:	cmp	r2, #6
    4538:	bhi.n	4542 <flexpwmFrequency+0x5a>
		newdiv = newdiv >> 1;
    453a:	lsrs	r3, r3, #1
		prescale = prescale + 1;
    453c:	adds	r2, #1
	uint16_t mask = 1 << submodule;
	uint32_t olddiv = p->SM[submodule].VAL1;
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
	uint32_t prescale = 0;
	//printf(" div=%lu\n", newdiv);
	while (newdiv > 65535 && prescale < 7) {
    453e:	cmp	r3, r4
    4540:	bhi.n	4536 <flexpwmFrequency+0x4e>
		newdiv = newdiv >> 1;
		prescale = prescale + 1;
	}
	if (newdiv > 65535) {
    4542:	cmp.w	r3, #65536	; 0x10000
    4546:	mov.w	r2, r2, lsl #4
    454a:	bcs.n	45bc <flexpwmFrequency+0xd4>
    454c:	orr.w	r2, r2, #1024	; 0x400
    4550:	uxth	r2, r2
    4552:	add.w	ip, r3, #4294967295
    4556:	uxth.w	ip, ip
		newdiv = 65535;
	} else if (newdiv < 2) {
		newdiv = 2;
	}
	//printf(" div=%lu, scale=%lu\n", newdiv, prescale);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    455a:	ldrh.w	r8, [r0, #392]	; 0x188
    455e:	lsls	r6, r6, #4
	p->SM[submodule].CTRL = FLEXPWM_SMCTRL_FULL | FLEXPWM_SMCTRL_PRSC(prescale);
	p->SM[submodule].VAL1 = newdiv - 1;
	p->SM[submodule].VAL0 = (p->SM[submodule].VAL0 * newdiv) / olddiv;
	p->SM[submodule].VAL3 = (p->SM[submodule].VAL3 * newdiv) / olddiv;
	p->SM[submodule].VAL5 = (p->SM[submodule].VAL5 * newdiv) / olddiv;
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    4560:	and.w	r4, r7, #15
	} else if (newdiv < 2) {
		newdiv = 2;
	}
	//printf(" div=%lu, scale=%lu\n", newdiv, prescale);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
	p->SM[submodule].CTRL = FLEXPWM_SMCTRL_FULL | FLEXPWM_SMCTRL_PRSC(prescale);
    4564:	add	r1, lr
		newdiv = 65535;
	} else if (newdiv < 2) {
		newdiv = 2;
	}
	//printf(" div=%lu, scale=%lu\n", newdiv, prescale);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    4566:	uxtb	r6, r6
    4568:	uxth.w	r7, r8
	p->SM[submodule].CTRL = FLEXPWM_SMCTRL_FULL | FLEXPWM_SMCTRL_PRSC(prescale);
    456c:	add.w	r1, r0, r1, lsl #5
		newdiv = 65535;
	} else if (newdiv < 2) {
		newdiv = 2;
	}
	//printf(" div=%lu, scale=%lu\n", newdiv, prescale);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    4570:	orrs	r6, r7
    4572:	strh.w	r6, [r0, #392]	; 0x188
	p->SM[submodule].CTRL = FLEXPWM_SMCTRL_FULL | FLEXPWM_SMCTRL_PRSC(prescale);
    4576:	strh	r2, [r1, #6]
	p->SM[submodule].VAL1 = newdiv - 1;
    4578:	strh.w	ip, [r1, #14]
	p->SM[submodule].VAL0 = (p->SM[submodule].VAL0 * newdiv) / olddiv;
    457c:	ldrh	r2, [r1, #10]
    457e:	uxth	r2, r2
    4580:	mul.w	r2, r3, r2
    4584:	udiv	r2, r2, r5
    4588:	uxth	r2, r2
    458a:	strh	r2, [r1, #10]
	p->SM[submodule].VAL3 = (p->SM[submodule].VAL3 * newdiv) / olddiv;
    458c:	ldrh	r2, [r1, #22]
    458e:	uxth	r2, r2
    4590:	mul.w	r2, r3, r2
    4594:	udiv	r2, r2, r5
    4598:	uxth	r2, r2
    459a:	strh	r2, [r1, #22]
	p->SM[submodule].VAL5 = (p->SM[submodule].VAL5 * newdiv) / olddiv;
    459c:	ldrh	r2, [r1, #30]
    459e:	uxth	r2, r2
    45a0:	mul.w	r3, r3, r2
    45a4:	udiv	r3, r3, r5
    45a8:	uxth	r3, r3
    45aa:	strh	r3, [r1, #30]
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    45ac:	ldrh.w	r3, [r0, #392]	; 0x188
    45b0:	uxth	r3, r3
    45b2:	orrs	r4, r3
    45b4:	strh.w	r4, [r0, #392]	; 0x188
    45b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    45bc:	orr.w	r2, r2, #1024	; 0x400
	//printf(" div=%lu\n", newdiv);
	while (newdiv > 65535 && prescale < 7) {
		newdiv = newdiv >> 1;
		prescale = prescale + 1;
	}
	if (newdiv > 65535) {
    45c0:	movw	ip, #65534	; 0xfffe
		newdiv = 65535;
    45c4:	movw	r3, #65535	; 0xffff
    45c8:	uxth	r2, r2
    45ca:	b.n	455a <flexpwmFrequency+0x72>
	} else if (newdiv < 2) {
    45cc:	cmp	r3, #1
    45ce:	mov.w	r2, #1024	; 0x400
    45d2:	bhi.n	4552 <flexpwmFrequency+0x6a>
		newdiv = 2;
    45d4:	movs	r3, #2
    45d6:	b.n	455a <flexpwmFrequency+0x72>
    45d8:	.word	0x20001258

000045dc <quadtimerFrequency>:
	p->CH[submodule].CMPLD1 = high;
}

void quadtimerFrequency(IMXRT_TMR_t *p, unsigned int submodule, float frequency)
{
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
    45dc:	ldr	r3, [pc, #140]	; (466c <quadtimerFrequency+0x90>)
    45de:	vmov.f64	d6, #96	; 0x3f000000  0.5
    45e2:	vldr	s15, [r3]
    45e6:	vcvt.f32.u32	s15, s15
	p->CH[submodule].LOAD = 65537 - low;
	p->CH[submodule].CMPLD1 = high;
}

void quadtimerFrequency(IMXRT_TMR_t *p, unsigned int submodule, float frequency)
{
    45ea:	push	{r4, r5}
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
    45ec:	vdiv.f32	s0, s15, s0
	uint32_t prescale = 0;
	//printf(" div=%lu\n", newdiv);
	while (newdiv > 65534 && prescale < 7) {
    45f0:	movw	r4, #65534	; 0xfffe
	p->CH[submodule].CMPLD1 = high;
}

void quadtimerFrequency(IMXRT_TMR_t *p, unsigned int submodule, float frequency)
{
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
    45f4:	vcvt.f64.f32	d0, s0
    45f8:	vadd.f64	d0, d0, d6
    45fc:	vcvt.u32.f64	s15, d0
    4600:	vmov	r3, s15
	uint32_t prescale = 0;
	//printf(" div=%lu\n", newdiv);
	while (newdiv > 65534 && prescale < 7) {
    4604:	cmp	r3, r4
    4606:	bls.n	465e <quadtimerFrequency+0x82>
    4608:	movs	r2, #0
    460a:	b.n	4610 <quadtimerFrequency+0x34>
    460c:	cmp	r2, #6
    460e:	bhi.n	4618 <quadtimerFrequency+0x3c>
		newdiv = newdiv >> 1; 
    4610:	lsrs	r3, r3, #1
		prescale = prescale + 1;
    4612:	adds	r2, #1
void quadtimerFrequency(IMXRT_TMR_t *p, unsigned int submodule, float frequency)
{
	uint32_t newdiv = (uint32_t)((float)F_BUS_ACTUAL / frequency + 0.5);
	uint32_t prescale = 0;
	//printf(" div=%lu\n", newdiv);
	while (newdiv > 65534 && prescale < 7) {
    4614:	cmp	r3, r4
    4616:	bhi.n	460c <quadtimerFrequency+0x30>
    4618:	adds	r2, #8
		newdiv = newdiv >> 1; 
		prescale = prescale + 1;
	}
	if (newdiv > 65534) {
    461a:	movw	r5, #65534	; 0xfffe
    461e:	movw	r4, #8230	; 0x2026
    4622:	lsls	r2, r2, #9
    4624:	cmp	r3, r5
    4626:	and.w	r2, r2, #7680	; 0x1e00
		newdiv = 65534;
    462a:	it	hi
    462c:	movhi	r3, r5
    462e:	orrs	r4, r2
	} else if (newdiv < 2) {
		newdiv = 2;
	}
	//printf(" div=%lu, scale=%lu\n", newdiv, prescale);
	uint32_t oldhigh = p->CH[submodule].CMPLD1;
    4630:	add.w	r1, r0, r1, lsl #5
    4634:	ldrh	r5, [r1, #16]
	uint32_t oldlow = 65537 - p->CH[submodule].LOAD;
    4636:	ldrh	r2, [r1, #6]
		newdiv = 65534;
	} else if (newdiv < 2) {
		newdiv = 2;
	}
	//printf(" div=%lu, scale=%lu\n", newdiv, prescale);
	uint32_t oldhigh = p->CH[submodule].CMPLD1;
    4638:	uxth	r5, r5
	uint32_t oldlow = 65537 - p->CH[submodule].LOAD;
    463a:	uxth	r2, r2
	uint32_t high = (oldhigh * newdiv) / (oldhigh + oldlow);
    463c:	mul.w	r0, r5, r3
    4640:	rsb	r2, r2, #65537	; 0x10001
    4644:	add	r2, r5
    4646:	udiv	r2, r0, r2
	// TODO: low must never be less than 2 - can it happen with this?
	uint32_t low = newdiv - high;
	//printf(" high=%lu, low=%lu\n", high, low);
	p->CH[submodule].LOAD = 65537 - low;
    464a:	subs	r3, r3, r2
	p->CH[submodule].CMPLD1 = high;
    464c:	uxth	r2, r2
	uint32_t oldlow = 65537 - p->CH[submodule].LOAD;
	uint32_t high = (oldhigh * newdiv) / (oldhigh + oldlow);
	// TODO: low must never be less than 2 - can it happen with this?
	uint32_t low = newdiv - high;
	//printf(" high=%lu, low=%lu\n", high, low);
	p->CH[submodule].LOAD = 65537 - low;
    464e:	rsb	r3, r3, #1
    4652:	uxth	r3, r3
    4654:	strh	r3, [r1, #6]
	p->CH[submodule].CMPLD1 = high;
    4656:	strh	r2, [r1, #16]
	p->CH[submodule].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8 + prescale) |
    4658:	strh	r4, [r1, #12]
		TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
}
    465a:	pop	{r4, r5}
    465c:	bx	lr
		newdiv = newdiv >> 1; 
		prescale = prescale + 1;
	}
	if (newdiv > 65534) {
		newdiv = 65534;
	} else if (newdiv < 2) {
    465e:	cmp	r3, #1
    4660:	movw	r4, #12326	; 0x3026
		newdiv = 2;
    4664:	it	ls
    4666:	movls	r3, #2
    4668:	b.n	4630 <quadtimerFrequency+0x54>
    466a:	nop
    466c:	.word	0x20001258

00004670 <analogWrite>:

void analogWrite(uint8_t pin, int val)
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
    4670:	cmp	r0, #39	; 0x27
    4672:	bhi.n	468e <analogWrite+0x1e>
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    4674:	ldr	r2, [pc, #164]	; (471c <analogWrite+0xac>)
	p->CH[submodule].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8 + prescale) |
		TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
}

void analogWrite(uint8_t pin, int val)
{
    4676:	push	{r3, r4, r5, r6, r7, lr}
    4678:	mov	r4, r0
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    467a:	sxth	r0, r0
	if (info->type == 1) {
    467c:	ldrb.w	r6, [r2, r0, lsl #2]
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    4680:	add.w	r5, r2, r0, lsl #2
	if (info->type == 1) {
    4684:	cmp	r6, #1
    4686:	beq.n	4690 <analogWrite+0x20>
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
    4688:	cmp	r6, #2
    468a:	beq.n	46ba <analogWrite+0x4a>
    468c:	pop	{r3, r4, r5, r6, r7, pc}
    468e:	bx	lr
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
	if (info->type == 1) {
		// FlexPWM pin
		IMXRT_FLEXPWM_t *flexpwm;
		switch ((info->module >> 4) & 3) {
    4690:	ldrb	r2, [r5, #1]
    4692:	ubfx	r3, r2, #4, #2
    4696:	cmp	r3, #3
    4698:	beq.n	4710 <analogWrite+0xa0>
    469a:	ldr	r0, [pc, #132]	; (4720 <analogWrite+0xb0>)
    469c:	ldr.w	r0, [r0, r3, lsl #2]
		  case 0: flexpwm = &IMXRT_FLEXPWM1; break;
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
    46a0:	uxth	r3, r1
    46a2:	and.w	r1, r2, #3
    46a6:	ldrb	r2, [r5, #2]
    46a8:	bl	4438 <flexpwmWrite>
		}
		quadtimerWrite(qtimer, info->module & 0x03, val);
	} else {
		return;
	}
	*(portConfigRegister(pin)) = info->muxval;
    46ac:	ldr	r0, [pc, #116]	; (4724 <analogWrite+0xb4>)
    46ae:	ldrb	r2, [r5, #3]
    46b0:	add.w	r0, r0, r4, lsl #4
    46b4:	ldr	r3, [r0, #4]
    46b6:	str	r2, [r3, #0]
    46b8:	pop	{r3, r4, r5, r6, r7, pc}
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    46ba:	ldrb	r6, [r5, #1]
    46bc:	ubfx	r3, r6, #4, #2
    46c0:	cmp	r3, #3
    46c2:	beq.n	4714 <analogWrite+0xa4>
    46c4:	ldr	r2, [pc, #96]	; (4728 <analogWrite+0xb8>)
    46c6:	ldr.w	lr, [r2, r3, lsl #2]
    46ca:	and.w	r6, r6, #3
}

void quadtimerWrite(IMXRT_TMR_t *p, unsigned int submodule, uint16_t val)
{
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    46ce:	ldr	r3, [pc, #92]	; (472c <analogWrite+0xbc>)
    46d0:	uxth	r1, r1
    46d2:	add.w	r7, lr, r6, lsl #5
    46d6:	ldrb.w	ip, [r3]
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
}

void quadtimerWrite(IMXRT_TMR_t *p, unsigned int submodule, uint16_t val)
{
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    46da:	lsls	r6, r6, #5
    46dc:	ldrh	r2, [r7, #6]
    46de:	add.w	r3, lr, r6
	//printf(" high=%lu\n", high);
	uint32_t low = modulo - high; // low must 2 or higher
	//printf(" low=%lu\n", low);

	p->CH[submodule].LOAD = 65537 - low;
	p->CH[submodule].CMPLD1 = high;
    46e2:	add	r6, lr
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
}

void quadtimerWrite(IMXRT_TMR_t *p, unsigned int submodule, uint16_t val)
{
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    46e4:	uxth	r2, r2
    46e6:	ldrh	r0, [r3, #16]
    46e8:	rsb	r2, r2, #65537	; 0x10001
    46ec:	uxtah	r2, r2, r0
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    46f0:	subs	r0, r2, #1
    46f2:	mul.w	r3, r0, r1
    46f6:	lsr.w	r3, r3, ip
	if (high >= modulo - 1) high = modulo - 2;
    46fa:	cmp	r0, r3
    46fc:	it	ls
    46fe:	subls	r3, r2, #2
	//printf(" modulo=%lu\n", modulo);
	//printf(" high=%lu\n", high);
	uint32_t low = modulo - high; // low must 2 or higher
	//printf(" low=%lu\n", low);

	p->CH[submodule].LOAD = 65537 - low;
    4700:	subs	r2, r2, r3
	p->CH[submodule].CMPLD1 = high;
    4702:	uxth	r3, r3
	//printf(" modulo=%lu\n", modulo);
	//printf(" high=%lu\n", high);
	uint32_t low = modulo - high; // low must 2 or higher
	//printf(" low=%lu\n", low);

	p->CH[submodule].LOAD = 65537 - low;
    4704:	rsb	r2, r2, #1
    4708:	uxth	r2, r2
    470a:	strh	r2, [r7, #6]
	p->CH[submodule].CMPLD1 = high;
    470c:	strh	r3, [r6, #16]
    470e:	b.n	46ac <analogWrite+0x3c>
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
	if (info->type == 1) {
		// FlexPWM pin
		IMXRT_FLEXPWM_t *flexpwm;
		switch ((info->module >> 4) & 3) {
    4710:	ldr	r0, [pc, #28]	; (4730 <analogWrite+0xc0>)
    4712:	b.n	46a0 <analogWrite+0x30>
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    4714:	ldr.w	lr, [pc, #28]	; 4734 <analogWrite+0xc4>
    4718:	b.n	46ca <analogWrite+0x5a>
    471a:	nop
    471c:	.word	0x20000560
    4720:	.word	0x20000600
    4724:	.word	0x20000618
    4728:	.word	0x2000060c
    472c:	.word	0x20001260
    4730:	.word	0x403e8000
    4734:	.word	0x401e8000

00004738 <analogWriteFrequency>:

void analogWriteFrequency(uint8_t pin, float frequency)
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
    4738:	cmp	r0, #39	; 0x27
    473a:	bhi.n	4750 <analogWriteFrequency+0x18>
	//printf("analogWriteFrequency, pin %d, freq %d\n", pin, (int)frequency);
	info = pwm_pin_info + pin;
    473c:	sxth	r0, r0
    473e:	ldr	r3, [pc, #76]	; (478c <analogWriteFrequency+0x54>)
	if (info->type == 1) {
    4740:	ldrb.w	r2, [r3, r0, lsl #2]
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
	//printf("analogWriteFrequency, pin %d, freq %d\n", pin, (int)frequency);
	info = pwm_pin_info + pin;
    4744:	add.w	r3, r3, r0, lsl #2
	if (info->type == 1) {
    4748:	cmp	r2, #1
    474a:	beq.n	4752 <analogWriteFrequency+0x1a>
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmFrequency(flexpwm, info->module & 0x03, info->channel, frequency);
	} else if (info->type == 2) {
    474c:	cmp	r2, #2
    474e:	beq.n	476c <analogWriteFrequency+0x34>
    4750:	bx	lr
	//printf("analogWriteFrequency, pin %d, freq %d\n", pin, (int)frequency);
	info = pwm_pin_info + pin;
	if (info->type == 1) {
		// FlexPWM pin
		IMXRT_FLEXPWM_t *flexpwm;
		switch ((info->module >> 4) & 3) {
    4752:	ldrb	r1, [r3, #1]
    4754:	ubfx	r2, r1, #4, #2
    4758:	cmp	r2, #3
    475a:	beq.n	4784 <analogWriteFrequency+0x4c>
    475c:	ldr	r0, [pc, #48]	; (4790 <analogWriteFrequency+0x58>)
    475e:	ldr.w	r0, [r0, r2, lsl #2]
		  case 0: flexpwm = &IMXRT_FLEXPWM1; break;
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmFrequency(flexpwm, info->module & 0x03, info->channel, frequency);
    4762:	ldrb	r2, [r3, #2]
    4764:	and.w	r1, r1, #3
    4768:	b.w	44e8 <flexpwmFrequency>
	} else if (info->type == 2) {
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    476c:	ldrb	r1, [r3, #1]
    476e:	ubfx	r3, r1, #4, #2
    4772:	cmp	r3, #3
    4774:	beq.n	4788 <analogWriteFrequency+0x50>
    4776:	ldr	r2, [pc, #28]	; (4794 <analogWriteFrequency+0x5c>)
    4778:	ldr.w	r0, [r2, r3, lsl #2]
		  case 0: qtimer = &IMXRT_TMR1; break;
		  case 1: qtimer = &IMXRT_TMR2; break;
		  case 2: qtimer = &IMXRT_TMR3; break;
		  default: qtimer = &IMXRT_TMR4;
		}
		quadtimerFrequency(qtimer, info->module & 0x03, frequency);
    477c:	and.w	r1, r1, #3
    4780:	b.w	45dc <quadtimerFrequency>
	//printf("analogWriteFrequency, pin %d, freq %d\n", pin, (int)frequency);
	info = pwm_pin_info + pin;
	if (info->type == 1) {
		// FlexPWM pin
		IMXRT_FLEXPWM_t *flexpwm;
		switch ((info->module >> 4) & 3) {
    4784:	ldr	r0, [pc, #16]	; (4798 <analogWriteFrequency+0x60>)
    4786:	b.n	4762 <analogWriteFrequency+0x2a>
		}
		flexpwmFrequency(flexpwm, info->module & 0x03, info->channel, frequency);
	} else if (info->type == 2) {
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    4788:	ldr	r0, [pc, #16]	; (479c <analogWriteFrequency+0x64>)
    478a:	b.n	477c <analogWriteFrequency+0x44>
    478c:	.word	0x20000560
    4790:	.word	0x20000600
    4794:	.word	0x2000060c
    4798:	.word	0x403e8000
    479c:	.word	0x401e8000

000047a0 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    47a0:	ldr	r0, [pc, #656]	; (4a34 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    47a2:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    47a6:	ldr	r3, [pc, #656]	; (4a38 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    47a8:	ldr	r2, [r0, #120]	; 0x78
    47aa:	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    47ae:	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    47b0:	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    47b2:	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    47b4:	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    47b8:	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    47bc:	ldr	r4, [pc, #636]	; (4a3c <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    47be:	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    47c2:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    47c4:	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    47c8:	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    47ca:	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    47cc:	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    47d0:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    47d4:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    47d8:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    47dc:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    47e0:	ldrh.w	r0, [r3, #392]	; 0x188
    47e4:	uxth	r0, r0
    47e6:	orr.w	r0, r0, #240	; 0xf0
    47ea:	strh.w	r0, [r3, #392]	; 0x188
    47ee:	add.w	r0, r1, r1, lsl #1
    47f2:	ldr	r3, [pc, #580]	; (4a38 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    47f4:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    47f6:	movs	r5, #0
    47f8:	lsls	r0, r0, #5
    47fa:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    47fc:	cmp	r1, #4
    47fe:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    4800:	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    4804:	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    4806:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    4808:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    480a:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    480c:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    480e:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    4810:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    4812:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    4814:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    4816:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    4818:	bne.n	47ee <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    481a:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    481e:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    4822:	ldr	r3, [pc, #540]	; (4a40 <pwm_init+0x2a0>)
    4824:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4828:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    482a:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    482c:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    4830:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4832:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    4836:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    483a:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    483e:	ldrh.w	r0, [r4, #392]	; 0x188
    4842:	uxth	r0, r0
    4844:	orr.w	r0, r0, #3840	; 0xf00
    4848:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    484c:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    4850:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    4854:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    4858:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    485c:	ldrh.w	r0, [r3, #392]	; 0x188
    4860:	uxth	r0, r0
    4862:	orr.w	r0, r0, #240	; 0xf0
    4866:	strh.w	r0, [r3, #392]	; 0x188
    486a:	add.w	r0, r1, r1, lsl #1
    486e:	ldr	r3, [pc, #464]	; (4a40 <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    4870:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    4872:	movs	r5, #0
    4874:	lsls	r0, r0, #5
    4876:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    4878:	cmp	r1, #4
    487a:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    487c:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    487e:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    4882:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    4884:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    4886:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    4888:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    488a:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    488c:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    488e:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    4890:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    4892:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    4894:	bne.n	486a <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4896:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    489a:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    489e:	ldr	r3, [pc, #420]	; (4a44 <pwm_init+0x2a4>)
    48a0:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    48a4:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    48a6:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    48a8:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    48ac:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    48ae:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    48b2:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    48b6:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    48ba:	ldrh.w	r0, [r4, #392]	; 0x188
    48be:	uxth	r0, r0
    48c0:	orr.w	r0, r0, #3840	; 0xf00
    48c4:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    48c8:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    48cc:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    48d0:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    48d4:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    48d8:	ldrh.w	r0, [r3, #392]	; 0x188
    48dc:	uxth	r0, r0
    48de:	orr.w	r0, r0, #240	; 0xf0
    48e2:	strh.w	r0, [r3, #392]	; 0x188
    48e6:	add.w	r0, r1, r1, lsl #1
    48ea:	ldr	r3, [pc, #344]	; (4a44 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    48ec:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    48ee:	movs	r5, #0
    48f0:	lsls	r0, r0, #5
    48f2:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    48f4:	cmp	r1, #4
    48f6:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    48f8:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    48fa:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    48fe:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    4900:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    4902:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    4904:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    4906:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    4908:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    490a:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    490c:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    490e:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    4910:	bne.n	48e6 <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4912:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    4916:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    491a:	ldr	r3, [pc, #300]	; (4a48 <pwm_init+0x2a8>)
    491c:	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4920:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    4922:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    4924:	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    4928:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    492a:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    492e:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4932:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    4936:	ldrh.w	r0, [r4, #392]	; 0x188
    493a:	uxth	r0, r0
    493c:	orr.w	r0, r0, #3840	; 0xf00
    4940:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    4944:	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    4948:	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    494c:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    4950:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    4954:	ldrh.w	r0, [r3, #392]	; 0x188
    4958:	uxth	r0, r0
    495a:	orr.w	r0, r0, #240	; 0xf0
    495e:	strh.w	r0, [r3, #392]	; 0x188
    4962:	add.w	r0, r1, r1, lsl #1
    4966:	ldr	r3, [pc, #224]	; (4a48 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    4968:	adds	r1, #1
    496a:	lsls	r0, r0, #5
    496c:	mov	r4, r3
    496e:	cmp	r1, #4
    4970:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    4972:	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    4974:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    4978:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    497a:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    497c:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    497e:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    4980:	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    4982:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    4984:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    4986:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    4988:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    498a:	bne.n	4962 <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    498c:	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    4990:	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    4992:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    4994:	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    4998:	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    499a:	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    499e:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    49a0:	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    49a4:	orrs	r3, r7
    49a6:	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    49aa:	ldrh.w	r3, [r4, #392]	; 0x188
    49ae:	uxth	r3, r3
    49b0:	orr.w	r3, r3, #3840	; 0xf00
    49b4:	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    49b8:	lsls	r0, r2, #5
    49ba:	ldr	r3, [pc, #144]	; (4a4c <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    49bc:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    49be:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    49c0:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    49c2:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    49c4:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    49c6:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    49c8:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    49ca:	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    49ce:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    49d0:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    49d2:	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    49d4:	bne.n	49b8 <pwm_init+0x218>
    49d6:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    49d8:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    49da:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    49de:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    49e2:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    49e4:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    49e8:	lsls	r0, r2, #5
    49ea:	ldr	r3, [pc, #100]	; (4a50 <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    49ec:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    49ee:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    49f0:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    49f2:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    49f4:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    49f6:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    49f8:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    49fa:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    49fc:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    49fe:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    4a00:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    4a02:	bne.n	49e8 <pwm_init+0x248>
    4a04:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    4a06:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    4a08:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    4a0c:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    4a10:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    4a12:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    4a16:	lsls	r0, r2, #5
    4a18:	ldr	r3, [pc, #56]	; (4a54 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    4a1a:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    4a1c:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    4a1e:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    4a20:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    4a22:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    4a24:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    4a26:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    4a28:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    4a2a:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    4a2c:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    4a2e:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    4a30:	bne.n	4a16 <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    4a32:	pop	{r4, r5, r6, r7, pc}
    4a34:	.word	0x400fc000
    4a38:	.word	0x403dc000
    4a3c:	.word	0xfc030000
    4a40:	.word	0x403e0000
    4a44:	.word	0x403e4000
    4a48:	.word	0x403e8000
    4a4c:	.word	0x401dc000
    4a50:	.word	0x401e0000
    4a54:	.word	0x401e4000

00004a58 <analogWriteRes>:
}

uint32_t analogWriteRes(uint32_t bits)
{
	uint32_t prior;
	if (bits < 1) {
    4a58:	cbz	r0, 4a6a <analogWriteRes+0x12>
    4a5a:	cmp	r0, #16
		bits = 1;
	} else if (bits > 16) {
		bits = 16;
	}
	prior = analog_write_res;
    4a5c:	ldr	r2, [pc, #20]	; (4a74 <analogWriteRes+0x1c>)
    4a5e:	it	cs
    4a60:	movcs	r0, #16
    4a62:	uxtb	r3, r0
    4a64:	ldrb	r0, [r2, #0]
	analog_write_res = bits;
    4a66:	strb	r3, [r2, #0]
	return prior;
}
    4a68:	bx	lr
	if (bits < 1) {
		bits = 1;
	} else if (bits > 16) {
		bits = 16;
	}
	prior = analog_write_res;
    4a6a:	ldr	r2, [pc, #8]	; (4a74 <analogWriteRes+0x1c>)
    4a6c:	movs	r3, #1
    4a6e:	ldrb	r0, [r2, #0]
	analog_write_res = bits;
    4a70:	strb	r3, [r2, #0]
	return prior;
}
    4a72:	bx	lr
    4a74:	.word	0x20001260

00004a78 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    4a78:	lsls	r0, r0, #4
    4a7a:	ldr	r3, [pc, #28]	; (4a98 <digitalWrite.part.0+0x20>)
    4a7c:	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    4a7e:	ldr	r3, [r3, r0]
	mask = p->mask;
    4a80:	ldr	r2, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    4a82:	ldr	r0, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    4a84:	tst	r0, r2
    4a86:	beq.n	4a8e <digitalWrite.part.0+0x16>
		// pin is configured for output mode
		if (val) {
    4a88:	cbnz	r1, 4a90 <digitalWrite.part.0+0x18>
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    4a8a:	str.w	r2, [r3, #136]	; 0x88
    4a8e:	bx	lr
	pinmode = *(p->reg + 1);
	mask = p->mask;
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
    4a90:	str.w	r2, [r3, #132]	; 0x84
    4a94:	bx	lr
    4a96:	nop
    4a98:	.word	0x20000618

00004a9c <digitalRead.part.1>:
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    4a9c:	lsls	r0, r0, #4
    4a9e:	ldr	r3, [pc, #20]	; (4ab4 <digitalRead.part.1+0x18>)
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    4aa0:	ldr	r2, [r3, r0]
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    4aa2:	adds	r1, r3, r0
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    4aa4:	ldr	r2, [r2, #8]
    4aa6:	ldr	r3, [r1, #12]
    4aa8:	tst	r2, r3
}
    4aaa:	ite	ne
    4aac:	movne	r0, #1
    4aae:	moveq	r0, #0
    4ab0:	bx	lr
    4ab2:	nop
    4ab4:	.word	0x20000618

00004ab8 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    4ab8:	cmp	r0, #39	; 0x27
    4aba:	bhi.n	4ac0 <digitalWrite+0x8>
    4abc:	b.w	4a78 <digitalWrite.part.0>
    4ac0:	bx	lr
    4ac2:	nop

00004ac4 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    4ac4:	cmp	r0, #39	; 0x27
    4ac6:	bhi.n	4acc <digitalRead+0x8>
    4ac8:	b.w	4a9c <digitalRead.part.1>
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}
    4acc:	movs	r0, #0
    4ace:	bx	lr

00004ad0 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    4ad0:	cmp	r0, #39	; 0x27
    4ad2:	bhi.n	4b0e <pinMode+0x3e>
	p = digital_pin_to_info_PGM + pin;
    4ad4:	lsls	r0, r0, #4
    4ad6:	ldr	r2, [pc, #104]	; (4b40 <pinMode+0x70>)
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    4ad8:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    4ada:	add.w	r3, r2, r0
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    4ade:	ldr	r0, [r2, r0]
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}

void pinMode(uint8_t pin, uint8_t mode)
{
    4ae0:	push	{r4}
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    4ae2:	beq.n	4b10 <pinMode+0x40>
    4ae4:	cmp	r1, #4
    4ae6:	beq.n	4b10 <pinMode+0x40>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    4ae8:	ldr	r4, [r3, #12]
    4aea:	ldr	r2, [r0, #4]
    4aec:	bic.w	r2, r2, r4
    4af0:	str	r2, [r0, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    4af2:	ldr	r2, [r3, #8]
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
    4af4:	cbz	r1, 4b32 <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
    4af6:	cmp	r1, #2
    4af8:	beq.n	4b38 <pinMode+0x68>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    4afa:	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    4afc:	ldr	r3, [r3, #4]
}
    4afe:	ldr.w	r4, [sp], #4
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    4b02:	ite	eq
    4b04:	ldreq	r1, [pc, #60]	; (4b44 <pinMode+0x74>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    4b06:	ldrne	r1, [pc, #64]	; (4b48 <pinMode+0x78>)
    4b08:	str	r1, [r2, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    4b0a:	movs	r2, #21
    4b0c:	str	r2, [r3, #0]
}
    4b0e:	bx	lr
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    4b10:	ldr	r2, [r3, #12]
		if (mode == OUTPUT) {
    4b12:	cmp	r1, #1
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    4b14:	ldr	r4, [r0, #4]
    4b16:	orr.w	r2, r2, r4
    4b1a:	str	r2, [r0, #4]
		if (mode == OUTPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    4b1c:	ldr	r2, [r3, #8]

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
		if (mode == OUTPUT) {
    4b1e:	beq.n	4b32 <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    4b20:	movw	r1, #2104	; 0x838
    4b24:	str	r1, [r2, #0]
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    4b26:	ldr	r3, [r3, #4]
    4b28:	movs	r2, #21
}
    4b2a:	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    4b2e:	str	r2, [r3, #0]
}
    4b30:	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    4b32:	movs	r1, #56	; 0x38
    4b34:	str	r1, [r2, #0]
    4b36:	b.n	4b26 <pinMode+0x56>
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    4b38:	ldr	r1, [pc, #16]	; (4b4c <pinMode+0x7c>)
    4b3a:	str	r1, [r2, #0]
    4b3c:	b.n	4b26 <pinMode+0x56>
    4b3e:	nop
    4b40:	.word	0x20000618
    4b44:	.word	0x00013038
    4b48:	.word	0x00010038
    4b4c:	.word	0x0001f038

00004b50 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    4b50:	ldr	r2, [pc, #72]	; (4b9c <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    4b52:	ldr	r3, [pc, #76]	; (4ba0 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    4b54:	ldr.w	r0, [r2, #544]	; 0x220
    4b58:	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    4b5c:	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    4b5e:	push	{r4, lr}
    4b60:	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    4b62:	bhi.n	4b6a <usb_init_serialnumber+0x1a>
    4b64:	add.w	r0, r0, r0, lsl #2
    4b68:	lsls	r0, r0, #1
    4b6a:	ldr	r4, [pc, #56]	; (4ba4 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    4b6c:	add	r1, sp, #4
    4b6e:	movs	r2, #10
    4b70:	bl	4f3c <ultoa>
    4b74:	add	r1, sp, #4
	for (i=0; i<10; i++) {
    4b76:	movs	r3, #0
    4b78:	mov	r0, r4
		char c = buf[i];
    4b7a:	ldrb.w	r2, [r1], #1
    4b7e:	adds	r3, #1
		if (!c) break;
    4b80:	cbz	r2, 4b92 <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    4b82:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    4b84:	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    4b88:	bne.n	4b7a <usb_init_serialnumber+0x2a>
    4b8a:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    4b8c:	strb	r3, [r4, #0]
}
    4b8e:	add	sp, #16
    4b90:	pop	{r4, pc}
    4b92:	lsls	r3, r3, #1
    4b94:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    4b96:	strb	r3, [r4, #0]
}
    4b98:	add	sp, #16
    4b9a:	pop	{r4, pc}
    4b9c:	.word	0x401f4400
    4ba0:	.word	0x0098967f
    4ba4:	.word	0x20001278

00004ba8 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    4ba8:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    4baa:	bl	7c <setup>
	while (1) {
		loop();
    4bae:	bl	168 <loop>
		yield();
    4bb2:	bl	4bb8 <yield>
    4bb6:	b.n	4bae <main+0x6>

00004bb8 <yield>:

extern uint8_t usb_enable_serial_event_processing; // from usb_inst.cpp

void yield(void) __attribute__ ((weak));
void yield(void)
{
    4bb8:	push	{r4, r5, r6, lr}
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
    4bba:	ldr	r4, [pc, #132]	; (4c40 <yield+0x88>)
    4bbc:	ldrb	r3, [r4, #0]
    4bbe:	cbnz	r3, 4be2 <yield+0x2a>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    4bc0:	ldr	r3, [pc, #128]	; (4c44 <yield+0x8c>)
void yield(void)
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    4bc2:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    4bc4:	ldrb	r3, [r3, #0]
void yield(void)
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    4bc6:	strb	r2, [r4, #0]


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    4bc8:	cbnz	r3, 4c12 <yield+0x5a>

	// Current workaround until integrate with EventResponder.
	if (HardwareSerial::serial_event_handlers_active) HardwareSerial::processSerialEvents();
    4bca:	ldr	r3, [pc, #124]	; (4c48 <yield+0x90>)
    4bcc:	ldrb	r3, [r3, #0]
    4bce:	cmp	r3, #0
    4bd0:	bne.n	4c26 <yield+0x6e>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;
    4bd2:	ldr	r3, [pc, #120]	; (4c4c <yield+0x94>)

	running = 0;
    4bd4:	movs	r1, #0
    4bd6:	ldr	r2, [r3, #0]
    4bd8:	strb	r1, [r4, #0]
    4bda:	cbz	r2, 4be2 <yield+0x2a>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    4bdc:	mrs	r2, IPSR
		if (ipsr != 0) return;
    4be0:	cbz	r2, 4be4 <yield+0x2c>
    4be2:	pop	{r4, r5, r6, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4be4:	mrs	r0, PRIMASK
		__disable_irq();
    4be8:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    4bea:	ldr	r2, [r3, #0]
		if (first == nullptr) {
    4bec:	cbz	r2, 4c2c <yield+0x74>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    4bee:	ldr	r4, [pc, #96]	; (4c50 <yield+0x98>)
    4bf0:	ldrb	r1, [r4, #0]
    4bf2:	cbnz	r1, 4c2c <yield+0x74>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    4bf4:	movs	r6, #1
		firstYield = first->_next;
    4bf6:	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    4bf8:	strb	r6, [r4, #0]
		firstYield = first->_next;
    4bfa:	str	r5, [r3, #0]
		if (firstYield) {
    4bfc:	cbz	r5, 4c34 <yield+0x7c>
			firstYield->_prev = nullptr;
    4bfe:	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4c00:	cbnz	r0, 4c04 <yield+0x4c>
    4c02:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    4c04:	movs	r5, #0
		(*(first->_function))(*first);
    4c06:	ldr	r3, [r2, #8]
    4c08:	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    4c0a:	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    4c0c:	blx	r3
		runningFromYield = false;
    4c0e:	strb	r5, [r4, #0]
    4c10:	pop	{r4, r5, r6, pc}
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    4c12:	bl	3598 <usb_serial_available>
	if (running) return; // TODO: does this need to be atomic?
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    4c16:	cmp	r0, #0
    4c18:	beq.n	4bca <yield+0x12>
    4c1a:	bl	4e68 <serialEvent()>

	// Current workaround until integrate with EventResponder.
	if (HardwareSerial::serial_event_handlers_active) HardwareSerial::processSerialEvents();
    4c1e:	ldr	r3, [pc, #40]	; (4c48 <yield+0x90>)
    4c20:	ldrb	r3, [r3, #0]
    4c22:	cmp	r3, #0
    4c24:	beq.n	4bd2 <yield+0x1a>
    4c26:	bl	4f8c <HardwareSerial::processSerialEvents()>
    4c2a:	b.n	4bd2 <yield+0x1a>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4c2c:	cmp	r0, #0
    4c2e:	bne.n	4be2 <yield+0x2a>
    4c30:	cpsie	i
    4c32:	pop	{r4, r5, r6, pc}
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    4c34:	ldr	r3, [pc, #28]	; (4c54 <yield+0x9c>)
    4c36:	str	r5, [r3, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4c38:	cmp	r0, #0
    4c3a:	bne.n	4c04 <yield+0x4c>
    4c3c:	b.n	4c02 <yield+0x4a>
    4c3e:	nop
    4c40:	.word	0x2000241c
    4c44:	.word	0x2000128e
    4c48:	.word	0x20002458
    4c4c:	.word	0x20002430
    4c50:	.word	0x20002434
    4c54:	.word	0x2000242c

00004c58 <EventResponder::triggerEventNotImmediate()>:
bool EventResponder::runningFromYield = false;

// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
    4c58:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4c5a:	mrs	r2, PRIMASK
		__disable_irq();
    4c5e:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    4c60:	ldrb	r3, [r0, #29]
    4c62:	cbnz	r3, 4c72 <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    4c64:	ldrb	r1, [r0, #28]
    4c66:	cmp	r1, #1
    4c68:	beq.n	4c7c <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    4c6a:	cmp	r1, #3
    4c6c:	beq.n	4c90 <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    4c6e:	movs	r3, #1
    4c70:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4c72:	cbnz	r2, 4c76 <EventResponder::triggerEventNotImmediate()+0x1e>
    4c74:	cpsie	i
	}
	enableInterrupts(irq);
}
    4c76:	ldr.w	r4, [sp], #4
    4c7a:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    4c7c:	ldr	r4, [pc, #68]	; (4cc4 <EventResponder::triggerEventNotImmediate()+0x6c>)
    4c7e:	ldr	r1, [r4, #0]
    4c80:	cbz	r1, 4cac <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    4c82:	ldr	r1, [pc, #68]	; (4cc8 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    4c84:	str	r3, [r0, #20]
				_prev = lastYield;
    4c86:	ldr	r3, [r1, #0]
				_prev->_next = this;
				lastYield = this;
    4c88:	str	r0, [r1, #0]
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    4c8a:	str	r3, [r0, #24]
				_prev->_next = this;
    4c8c:	str	r0, [r3, #20]
    4c8e:	b.n	4c6e <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    4c90:	ldr	r4, [pc, #56]	; (4ccc <EventResponder::triggerEventNotImmediate()+0x74>)
    4c92:	ldr	r1, [r4, #0]
    4c94:	cbz	r1, 4cb8 <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    4c96:	ldr	r1, [pc, #56]	; (4cd0 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    4c98:	str	r3, [r0, #20]
				_prev = lastInterrupt;
    4c9a:	ldr	r3, [r1, #0]
				_prev->_next = this;
				lastInterrupt = this;
    4c9c:	str	r0, [r1, #0]
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    4c9e:	str	r3, [r0, #24]
				_prev->_next = this;
    4ca0:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    4ca2:	ldr	r3, [pc, #48]	; (4cd4 <EventResponder::triggerEventNotImmediate()+0x7c>)
    4ca4:	mov.w	r1, #268435456	; 0x10000000
    4ca8:	str	r1, [r3, #0]
    4caa:	b.n	4c6e <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    4cac:	ldr	r3, [pc, #24]	; (4cc8 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    4cae:	str	r1, [r0, #20]
				_prev = nullptr;
    4cb0:	str	r1, [r0, #24]
				firstYield = this;
    4cb2:	str	r0, [r4, #0]
				lastYield = this;
    4cb4:	str	r0, [r3, #0]
    4cb6:	b.n	4c6e <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    4cb8:	ldr	r3, [pc, #20]	; (4cd0 <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    4cba:	str	r1, [r0, #20]
				_prev = nullptr;
    4cbc:	str	r1, [r0, #24]
				firstInterrupt = this;
    4cbe:	str	r0, [r4, #0]
				lastInterrupt = this;
    4cc0:	str	r0, [r3, #0]
    4cc2:	b.n	4ca2 <EventResponder::triggerEventNotImmediate()+0x4a>
    4cc4:	.word	0x20002430
    4cc8:	.word	0x2000242c
    4ccc:	.word	0x20002420
    4cd0:	.word	0x20002424
    4cd4:	.word	0xe000ed04

00004cd8 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    4cd8:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4cda:	mrs	r1, PRIMASK
		__disable_irq();
    4cde:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    4ce0:	ldr	r4, [pc, #48]	; (4d14 <EventResponder::runFromInterrupt()+0x3c>)
    4ce2:	ldr	r3, [r4, #0]
		if (first) {
    4ce4:	cbz	r3, 4d0a <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    4ce6:	ldr	r6, [pc, #48]	; (4d18 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    4ce8:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    4cea:	ldr	r2, [r3, #20]
    4cec:	str	r2, [r4, #0]
			if (firstInterrupt) {
    4cee:	cbz	r2, 4d10 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    4cf0:	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4cf2:	cbnz	r1, 4cf6 <EventResponder::runFromInterrupt()+0x1e>
    4cf4:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    4cf6:	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    4cf8:	mov	r0, r3
    4cfa:	ldr	r3, [r3, #8]
    4cfc:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4cfe:	mrs	r1, PRIMASK
		__disable_irq();
    4d02:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    4d04:	ldr	r3, [r4, #0]
		if (first) {
    4d06:	cmp	r3, #0
    4d08:	bne.n	4cea <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4d0a:	cbnz	r1, 4d0e <EventResponder::runFromInterrupt()+0x36>
    4d0c:	cpsie	i
    4d0e:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    4d10:	str	r2, [r6, #0]
    4d12:	b.n	4cf2 <EventResponder::runFromInterrupt()+0x1a>
    4d14:	.word	0x20002420
    4d18:	.word	0x20002424

00004d1c <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    4d1c:	b.w	4cd8 <EventResponder::runFromInterrupt()>

00004d20 <MillisTimer::addToActiveList()>:
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    4d20:	ldr	r2, [pc, #96]	; (4d84 <MillisTimer::addToActiveList()+0x64>)
	_state = TimerWaiting;
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
    4d22:	push	{r4, r5}
	if (listActive == nullptr) {
    4d24:	ldr	r4, [r2, #0]
    4d26:	cmp	r4, #0
    4d28:	beq.n	4d7c <MillisTimer::addToActiveList()+0x5c>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    4d2a:	ldr	r3, [r0, #0]
    4d2c:	ldr	r1, [r4, #0]
    4d2e:	cmp	r3, r1
    4d30:	bcs.n	4d52 <MillisTimer::addToActiveList()+0x32>
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    4d32:	subs	r3, r1, r3
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
    4d34:	movs	r1, #0
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    4d36:	str	r4, [r0, #8]
		_prev = nullptr;
    4d38:	str	r1, [r0, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    4d3a:	str	r3, [r4, #0]
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    4d3c:	str	r0, [r4, #12]
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
		listActive = this;
    4d3e:	str	r0, [r2, #0]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    4d40:	movs	r3, #2
}
    4d42:	pop	{r4, r5}
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    4d44:	strb	r3, [r0, #20]
}
    4d46:	bx	lr
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
    4d48:	str	r3, [r0, #0]
    4d4a:	mov	r4, r2
			timer = timer->_next;
			if (_ms < timer->_ms) {
    4d4c:	ldr	r1, [r2, #0]
    4d4e:	cmp	r3, r1
    4d50:	bcc.n	4d64 <MillisTimer::addToActiveList()+0x44>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    4d52:	ldr	r2, [r4, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    4d54:	subs	r3, r3, r1
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    4d56:	cmp	r2, #0
    4d58:	bne.n	4d48 <MillisTimer::addToActiveList()+0x28>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    4d5a:	str	r2, [r0, #8]
		_prev = timer;
    4d5c:	str	r4, [r0, #12]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    4d5e:	str	r3, [r0, #0]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
    4d60:	str	r0, [r4, #8]
    4d62:	b.n	4d40 <MillisTimer::addToActiveList()+0x20>
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    4d64:	ldr	r5, [r2, #12]
				timer->_prev = this;
				_prev->_next = this;
				timer->_ms -= _ms;
    4d66:	subs	r3, r1, r3
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    4d68:	str	r2, [r0, #8]
				_prev = timer->_prev;
				timer->_prev = this;
				_prev->_next = this;
				timer->_ms -= _ms;
				_state = TimerActive;
    4d6a:	movs	r2, #2
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    4d6c:	str	r5, [r0, #12]
				timer->_prev = this;
    4d6e:	str	r0, [r4, #12]
				_prev->_next = this;
    4d70:	ldr	r1, [r0, #12]
    4d72:	str	r0, [r1, #8]
				timer->_ms -= _ms;
    4d74:	str	r3, [r4, #0]
				_state = TimerActive;
    4d76:	strb	r2, [r0, #20]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
}
    4d78:	pop	{r4, r5}
    4d7a:	bx	lr

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    4d7c:	str	r4, [r0, #8]
		_prev = nullptr;
    4d7e:	str	r4, [r0, #12]
		listActive = this;
    4d80:	str	r0, [r2, #0]
    4d82:	b.n	4d40 <MillisTimer::addToActiveList()+0x20>
    4d84:	.word	0x20002428

00004d88 <MillisTimer::runFromTimer()>:
	}
	enableTimerInterrupt(irq);
}

void MillisTimer::runFromTimer()
{
    4d88:	push	{r3, r4, r5, r6, r7, lr}
	MillisTimer *timer = listActive;
    4d8a:	ldr	r6, [pc, #136]	; (4e14 <MillisTimer::runFromTimer()+0x8c>)
    4d8c:	ldr	r4, [r6, #0]
	while (timer) {
    4d8e:	cbz	r4, 4ddc <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    4d90:	ldr	r3, [r4, #0]
    4d92:	cmp	r3, #0
    4d94:	bne.n	4e0c <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
    4d96:	mov	r5, r3
    4d98:	ldr	r7, [pc, #124]	; (4e18 <MillisTimer::runFromTimer()+0x90>)
    4d9a:	b.n	4da6 <MillisTimer::runFromTimer()+0x1e>
			event.triggerEvent(0, timer);
			if (timer->_reload) {
				timer->_ms = timer->_reload;
				timer->addToActiveList();
			}
			timer = listActive;
    4d9c:	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    4d9e:	cbz	r4, 4ddc <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    4da0:	ldr	r3, [r4, #0]
    4da2:	cmp	r3, #0
    4da4:	bne.n	4e0c <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
    4da6:	ldr	r3, [r4, #8]
			if (next) next->_prev = nullptr;
    4da8:	cbz	r3, 4dac <MillisTimer::runFromTimer()+0x24>
    4daa:	str	r5, [r3, #12]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
    4dac:	ldr	r0, [r4, #16]
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
    4dae:	str	r3, [r6, #0]
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    4db0:	ldr	r3, [r0, #0]
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
    4db2:	strb	r5, [r4, #20]
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    4db4:	ldr	r3, [r3, #0]
    4db6:	cmp	r3, r7
    4db8:	bne.n	4dfe <MillisTimer::runFromTimer()+0x76>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    4dba:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    4dbc:	str	r5, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    4dbe:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    4dc0:	str	r4, [r0, #12]
		if (_type == EventTypeImmediate) {
    4dc2:	beq.n	4e06 <MillisTimer::runFromTimer()+0x7e>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    4dc4:	bl	4c58 <EventResponder::triggerEventNotImmediate()>
			if (timer->_reload) {
    4dc8:	ldr	r3, [r4, #4]
    4dca:	cmp	r3, #0
    4dcc:	beq.n	4d9c <MillisTimer::runFromTimer()+0x14>
				timer->_ms = timer->_reload;
    4dce:	str	r3, [r4, #0]
				timer->addToActiveList();
    4dd0:	mov	r0, r4
    4dd2:	bl	4d20 <MillisTimer::addToActiveList()>
			}
			timer = listActive;
    4dd6:	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    4dd8:	cmp	r4, #0
    4dda:	bne.n	4da0 <MillisTimer::runFromTimer()+0x18>
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4ddc:	mrs	r3, PRIMASK
		__disable_irq();
    4de0:	cpsid	i
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    4de2:	ldr	r2, [pc, #56]	; (4e1c <MillisTimer::runFromTimer()+0x94>)
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    4de4:	movs	r1, #0
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    4de6:	ldr	r0, [r2, #0]
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    4de8:	str	r1, [r2, #0]
		return (primask == 0) ? true : false;
	}
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    4dea:	cbnz	r3, 4dee <MillisTimer::runFromTimer()+0x66>
    4dec:	cpsie	i
	enableTimerInterrupt(irq);
	while (waiting) {
    4dee:	cbz	r0, 4dfc <MillisTimer::runFromTimer()+0x74>
		MillisTimer *next = waiting->_next;
    4df0:	ldr	r4, [r0, #8]
		waiting->addToActiveList();
    4df2:	bl	4d20 <MillisTimer::addToActiveList()>
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    4df6:	mov	r0, r4
    4df8:	cmp	r0, #0
    4dfa:	bne.n	4df0 <MillisTimer::runFromTimer()+0x68>
    4dfc:	pop	{r3, r4, r5, r6, r7, pc}
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    4dfe:	mov	r2, r4
    4e00:	movs	r1, #0
    4e02:	blx	r3
    4e04:	b.n	4dc8 <MillisTimer::runFromTimer()+0x40>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    4e06:	ldr	r3, [r0, #8]
    4e08:	blx	r3
    4e0a:	b.n	4dc8 <MillisTimer::runFromTimer()+0x40>
void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
    4e0c:	subs	r3, #1
    4e0e:	str	r3, [r4, #0]
			break;
    4e10:	b.n	4ddc <MillisTimer::runFromTimer()+0x54>
    4e12:	nop
    4e14:	.word	0x20002428
    4e18:	.word	0x00002dd5
    4e1c:	.word	0x20002438

00004e20 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    4e20:	ldr	r2, [pc, #16]	; (4e34 <systick_isr+0x14>)
    4e22:	ldr	r3, [pc, #20]	; (4e38 <systick_isr+0x18>)
    4e24:	ldr	r1, [r2, #0]
	systick_millis_count++;
    4e26:	ldr	r2, [pc, #20]	; (4e3c <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    4e28:	str	r1, [r3, #0]
	systick_millis_count++;
    4e2a:	ldr	r3, [r2, #0]
    4e2c:	adds	r3, #1
    4e2e:	str	r3, [r2, #0]
	MillisTimer::runFromTimer();
    4e30:	b.w	4d88 <MillisTimer::runFromTimer()>
    4e34:	.word	0xe0001004
    4e38:	.word	0x200023fc
    4e3c:	.word	0x20002404

00004e40 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    4e40:	b.w	35a4 <usb_serial_flush_input>

00004e44 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    4e44:	b.w	3554 <usb_serial_peekchar>

00004e48 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    4e48:	b.w	3618 <usb_serial_getchar>

00004e4c <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    4e4c:	b.w	3598 <usb_serial_available>

00004e50 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    4e50:	b.w	36c8 <usb_serial_flush_output>

00004e54 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    4e54:	b.w	367c <usb_serial_write_buffer_free>

00004e58 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    4e58:	mov	r0, r1
    4e5a:	mov	r1, r2
    4e5c:	b.w	3664 <usb_serial_write>

00004e60 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    4e60:	mov	r0, r1
    4e62:	b.w	3638 <usb_serial_putchar>
    4e66:	nop

00004e68 <serialEvent()>:
#endif

#endif // F_CPU
uint8_t usb_enable_serial_event_processing = 1;
void serialEvent() __attribute__((weak));
void serialEvent() {usb_enable_serial_event_processing = 0;}
    4e68:	ldr	r3, [pc, #4]	; (4e70 <serialEvent()+0x8>)
    4e6a:	movs	r2, #0
    4e6c:	strb	r2, [r3, #0]
    4e6e:	bx	lr
    4e70:	.word	0x2000128e

00004e74 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    4e74:	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    4e76:	ldr	r4, [pc, #24]	; (4e90 <Print::println()+0x1c>)
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    4e78:	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    4e7a:	ldr	r3, [r0, #0]
    4e7c:	movs	r2, #2
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    4e7e:	ldrh	r4, [r4, #0]
	return write(buf, 2);
    4e80:	add	r1, sp, #4
    4e82:	ldr	r3, [r3, #4]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    4e84:	strh.w	r4, [sp, #4]
	return write(buf, 2);
    4e88:	blx	r3
}
    4e8a:	add	sp, #8
    4e8c:	pop	{r4, pc}
    4e8e:	nop
    4e90:	.word	0x2000092c

00004e94 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    4e94:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    4e96:	push	{r4, lr}
    4e98:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    4e9a:	ldr	r3, [r3, #4]
    4e9c:	blx	r3
	return len;
}
    4e9e:	mov	r0, r4
    4ea0:	pop	{r4, pc}
    4ea2:	nop

00004ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	return vdprintf((int)this, (const char *)format, ap);
#endif
}

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    4ea4:	push	{r4, r5, r6, r7, lr}
    4ea6:	mov	r6, r0
    4ea8:	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    4eaa:	cmp	r2, #0
    4eac:	beq.n	4f16 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    4eae:	cmp	r2, #1
    4eb0:	it	eq
    4eb2:	moveq	r2, #10
	}


	if (n == 0) {
    4eb4:	cbz	r1, 4f0c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    4eb6:	movs	r5, #33	; 0x21
    4eb8:	b.n	4ebc <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    4eba:	uxtb	r5, r7
    4ebc:	subs	r7, r5, #1
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    4ebe:	udiv	r4, r1, r2
    4ec2:	mls	r1, r2, r4, r1
    4ec6:	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    4ec8:	cmp	r1, #9
    4eca:	add.w	r1, r0, #55	; 0x37
    4ece:	add.w	r0, r0, #48	; 0x30
    4ed2:	it	hi
    4ed4:	uxtbhi	r0, r1
			n /= base;
			if (n == 0) break;
    4ed6:	mov	r1, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    4ed8:	add	r4, sp, #40	; 0x28
    4eda:	it	ls
    4edc:	uxtbls	r0, r0
    4ede:	add	r4, r5
    4ee0:	strb.w	r0, [r4, #-36]
			n /= base;
			if (n == 0) break;
    4ee4:	cmp	r1, #0
    4ee6:	bne.n	4eba <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    4ee8:	cbz	r3, 4ef8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    4eea:	subs	r5, #1
		buf[i] = '-';
    4eec:	add	r3, sp, #40	; 0x28
    4eee:	movs	r2, #45	; 0x2d
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
		i--;
    4ef0:	uxtb	r5, r5
		buf[i] = '-';
    4ef2:	add	r3, r5
    4ef4:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    4ef8:	ldr	r3, [r6, #0]
    4efa:	add	r1, sp, #4
    4efc:	rsb	r2, r5, #34	; 0x22
    4f00:	mov	r0, r6
    4f02:	add	r1, r5
    4f04:	ldr	r3, [r3, #4]
    4f06:	blx	r3
}
    4f08:	add	sp, #44	; 0x2c
    4f0a:	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    4f0c:	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    4f0e:	movs	r5, #33	; 0x21
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    4f10:	strb.w	r2, [sp, #37]	; 0x25
    4f14:	b.n	4ee8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    4f16:	ldr	r3, [r0, #0]
    4f18:	uxtb	r1, r1
    4f1a:	ldr	r3, [r3, #0]
    4f1c:	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    4f1e:	add	sp, #44	; 0x2c
    4f20:	pop	{r4, r5, r6, r7, pc}
    4f22:	nop

00004f24 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    4f24:	cmp	r1, #0
    4f26:	blt.n	4f30 <Print::print(long)+0xc>
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    4f28:	movs	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    4f2a:	movs	r2, #10
    4f2c:	b.w	4ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
		n = -n;
    4f30:	negs	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    4f32:	movs	r3, #45	; 0x2d
		n = -n;
	}
	return printNumber(n, 10, sign);
    4f34:	movs	r2, #10
    4f36:	b.w	4ea4 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    4f3a:	nop

00004f3c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    4f3c:	push	{r4, r5, r6, r7}
    4f3e:	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    4f40:	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    4f42:	mov	r7, r6
    4f44:	b.n	4f48 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    4f46:	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    4f48:	udiv	r3, r0, r2
    4f4c:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    4f50:	add.w	r4, r0, #55	; 0x37
    4f54:	cmp	r0, #9
    4f56:	add.w	r0, r0, #48	; 0x30
    4f5a:	uxtb	r4, r4
    4f5c:	it	ls
    4f5e:	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    4f60:	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    4f62:	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    4f66:	cmp	r3, #0
    4f68:	bne.n	4f46 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    4f6a:	adds	r2, r1, r5
    4f6c:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    4f6e:	cbz	r5, 4f84 <ultoa+0x48>
    4f70:	adds	r3, #1
		t = buf[j];
    4f72:	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    4f76:	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    4f78:	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    4f7a:	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    4f7c:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    4f7e:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    4f82:	blt.n	4f70 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    4f84:	mov	r0, r1
    4f86:	pop	{r4, r5, r6, r7}
    4f88:	bx	lr
    4f8a:	nop

00004f8c <HardwareSerial::processSerialEvents()>:
	//digitalWrite(4, LOW);
}


void HardwareSerial::processSerialEvents()
{
    4f8c:	push	{r3, r4, r5, lr}
	if (!serial_event_handlers_active) return;	// bail quick if no one processing SerialEvents.
    4f8e:	ldr	r3, [pc, #28]	; (4fac <HardwareSerial::processSerialEvents()+0x20>)
    4f90:	ldrb	r4, [r3, #0]
    4f92:	cbz	r4, 4fa8 <HardwareSerial::processSerialEvents()+0x1c>
    4f94:	ldr	r5, [pc, #24]	; (4fb0 <HardwareSerial::processSerialEvents()+0x24>)
	uint8_t handlers_still_to_process = serial_event_handlers_active;
	for (uint8_t i = 0; i < 8; i++) {
		if (serial_event_handler_checks[i]) {
    4f96:	ldr.w	r3, [r5, #4]!
    4f9a:	cmp	r3, #0
    4f9c:	beq.n	4f96 <HardwareSerial::processSerialEvents()+0xa>
			(*serial_event_handler_checks[i])();
    4f9e:	blx	r3
			if (--handlers_still_to_process == 0) return;
    4fa0:	subs	r3, r4, #1
    4fa2:	ands.w	r4, r3, #255	; 0xff
    4fa6:	bne.n	4f96 <HardwareSerial::processSerialEvents()+0xa>
    4fa8:	pop	{r3, r4, r5, pc}
    4faa:	nop
    4fac:	.word	0x20002458
    4fb0:	.word	0x20002438
    4fb4:	.word	0x00000000

00004fb8 <sin>:
    4fb8:	push	{lr}
    4fba:	vmov.f64	d7, d0
    4fbe:	vmov	r3, s15
    4fc2:	ldr	r2, [pc, #140]	; (5050 <sin+0x98>)
    4fc4:	bic.w	r3, r3, #2147483648	; 0x80000000
    4fc8:	cmp	r3, r2
    4fca:	sub	sp, #20
    4fcc:	ble.n	5004 <sin+0x4c>
    4fce:	ldr	r2, [pc, #132]	; (5054 <sin+0x9c>)
    4fd0:	cmp	r3, r2
    4fd2:	ble.n	4fde <sin+0x26>
    4fd4:	vsub.f64	d0, d0, d0
    4fd8:	add	sp, #20
    4fda:	ldr.w	pc, [sp], #4
    4fde:	mov	r0, sp
    4fe0:	bl	6548 <__ieee754_rem_pio2>
    4fe4:	and.w	r0, r0, #3
    4fe8:	cmp	r0, #1
    4fea:	beq.n	5028 <sin+0x70>
    4fec:	cmp	r0, #2
    4fee:	beq.n	5014 <sin+0x5c>
    4ff0:	cbz	r0, 5036 <sin+0x7e>
    4ff2:	vldr	d1, [sp, #8]
    4ff6:	vldr	d0, [sp]
    4ffa:	bl	6e10 <__kernel_cos>
    4ffe:	vneg.f64	d0, d0
    5002:	b.n	4fd8 <sin+0x20>
    5004:	movs	r0, #0
    5006:	vldr	d1, [pc, #64]	; 5048 <sin+0x90>
    500a:	bl	75b0 <__kernel_sin>
    500e:	add	sp, #20
    5010:	ldr.w	pc, [sp], #4
    5014:	movs	r0, #1
    5016:	vldr	d1, [sp, #8]
    501a:	vldr	d0, [sp]
    501e:	bl	75b0 <__kernel_sin>
    5022:	vneg.f64	d0, d0
    5026:	b.n	4fd8 <sin+0x20>
    5028:	vldr	d1, [sp, #8]
    502c:	vldr	d0, [sp]
    5030:	bl	6e10 <__kernel_cos>
    5034:	b.n	4fd8 <sin+0x20>
    5036:	movs	r0, #1
    5038:	vldr	d1, [sp, #8]
    503c:	vldr	d0, [sp]
    5040:	bl	75b0 <__kernel_sin>
    5044:	b.n	4fd8 <sin+0x20>
    5046:	nop
	...
    5050:	.word	0x3fe921fb
    5054:	.word	0x7fefffff

00005058 <cosf>:
    5058:	push	{lr}
    505a:	vmov	r3, s0
    505e:	ldr	r2, [pc, #128]	; (50e0 <cosf+0x88>)
    5060:	bic.w	r3, r3, #2147483648	; 0x80000000
    5064:	cmp	r3, r2
    5066:	sub	sp, #12
    5068:	ble.n	509e <cosf+0x46>
    506a:	cmp.w	r3, #2139095040	; 0x7f800000
    506e:	blt.n	507a <cosf+0x22>
    5070:	vsub.f32	s0, s0, s0
    5074:	add	sp, #12
    5076:	ldr.w	pc, [sp], #4
    507a:	mov	r0, sp
    507c:	bl	6ad4 <__ieee754_rem_pio2f>
    5080:	and.w	r0, r0, #3
    5084:	cmp	r0, #1
    5086:	beq.n	50be <cosf+0x66>
    5088:	cmp	r0, #2
    508a:	beq.n	50ac <cosf+0x54>
    508c:	cbz	r0, 50d0 <cosf+0x78>
    508e:	movs	r0, #1
    5090:	vldr	s1, [sp, #4]
    5094:	vldr	s0, [sp]
    5098:	bl	7d94 <__kernel_sinf>
    509c:	b.n	5074 <cosf+0x1c>
    509e:	vldr	s1, [pc, #68]	; 50e4 <cosf+0x8c>
    50a2:	bl	7660 <__kernel_cosf>
    50a6:	add	sp, #12
    50a8:	ldr.w	pc, [sp], #4
    50ac:	vldr	s1, [sp, #4]
    50b0:	vldr	s0, [sp]
    50b4:	bl	7660 <__kernel_cosf>
    50b8:	vneg.f32	s0, s0
    50bc:	b.n	5074 <cosf+0x1c>
    50be:	vldr	s1, [sp, #4]
    50c2:	vldr	s0, [sp]
    50c6:	bl	7d94 <__kernel_sinf>
    50ca:	vneg.f32	s0, s0
    50ce:	b.n	5074 <cosf+0x1c>
    50d0:	vldr	s1, [sp, #4]
    50d4:	vldr	s0, [sp]
    50d8:	bl	7660 <__kernel_cosf>
    50dc:	b.n	5074 <cosf+0x1c>
    50de:	nop
    50e0:	.word	0x3f490fd8
    50e4:	.word	0x00000000

000050e8 <sinf>:
    50e8:	push	{lr}
    50ea:	vmov	r3, s0
    50ee:	ldr	r2, [pc, #132]	; (5174 <sinf+0x8c>)
    50f0:	bic.w	r3, r3, #2147483648	; 0x80000000
    50f4:	cmp	r3, r2
    50f6:	sub	sp, #12
    50f8:	ble.n	5130 <sinf+0x48>
    50fa:	cmp.w	r3, #2139095040	; 0x7f800000
    50fe:	blt.n	510a <sinf+0x22>
    5100:	vsub.f32	s0, s0, s0
    5104:	add	sp, #12
    5106:	ldr.w	pc, [sp], #4
    510a:	mov	r0, sp
    510c:	bl	6ad4 <__ieee754_rem_pio2f>
    5110:	and.w	r0, r0, #3
    5114:	cmp	r0, #1
    5116:	beq.n	5154 <sinf+0x6c>
    5118:	cmp	r0, #2
    511a:	beq.n	5140 <sinf+0x58>
    511c:	cbz	r0, 5162 <sinf+0x7a>
    511e:	vldr	s1, [sp, #4]
    5122:	vldr	s0, [sp]
    5126:	bl	7660 <__kernel_cosf>
    512a:	vneg.f32	s0, s0
    512e:	b.n	5104 <sinf+0x1c>
    5130:	movs	r0, #0
    5132:	vldr	s1, [pc, #68]	; 5178 <sinf+0x90>
    5136:	bl	7d94 <__kernel_sinf>
    513a:	add	sp, #12
    513c:	ldr.w	pc, [sp], #4
    5140:	movs	r0, #1
    5142:	vldr	s1, [sp, #4]
    5146:	vldr	s0, [sp]
    514a:	bl	7d94 <__kernel_sinf>
    514e:	vneg.f32	s0, s0
    5152:	b.n	5104 <sinf+0x1c>
    5154:	vldr	s1, [sp, #4]
    5158:	vldr	s0, [sp]
    515c:	bl	7660 <__kernel_cosf>
    5160:	b.n	5104 <sinf+0x1c>
    5162:	movs	r0, #1
    5164:	vldr	s1, [sp, #4]
    5168:	vldr	s0, [sp]
    516c:	bl	7d94 <__kernel_sinf>
    5170:	b.n	5104 <sinf+0x1c>
    5172:	nop
    5174:	.word	0x3f490fd8
    5178:	.word	0x00000000

0000517c <acos>:
    517c:	push	{r4, lr}
    517e:	vpush	{d8-d9}
    5182:	vmov.f64	d8, d0
    5186:	ldr	r4, [pc, #148]	; (521c <acos+0xa0>)
    5188:	sub	sp, #40	; 0x28
    518a:	bl	56b8 <__ieee754_acos>
    518e:	ldrsb.w	r3, [r4]
    5192:	vmov.f64	d9, d0
    5196:	adds	r3, #1
    5198:	beq.n	51f8 <acos+0x7c>
    519a:	vcmp.f64	d8, d8
    519e:	vmrs	APSR_nzcv, fpscr
    51a2:	bvs.n	51f8 <acos+0x7c>
    51a4:	vmov.f64	d0, d8
    51a8:	bl	802c <fabs>
    51ac:	vmov.f64	d7, #112	; 0x3f800000  1.0
    51b0:	vcmpe.f64	d0, d7
    51b4:	vmrs	APSR_nzcv, fpscr
    51b8:	ble.n	51f8 <acos+0x7c>
    51ba:	movs	r3, #1
    51bc:	ldr	r2, [pc, #96]	; (5220 <acos+0xa4>)
    51be:	str	r3, [sp, #0]
    51c0:	ldr	r0, [pc, #96]	; (5224 <acos+0xa8>)
    51c2:	str	r2, [sp, #4]
    51c4:	movs	r3, #0
    51c6:	str	r3, [sp, #32]
    51c8:	vstr	d8, [sp, #16]
    51cc:	vstr	d8, [sp, #8]
    51d0:	bl	8170 <nan>
    51d4:	ldrsb.w	r3, [r4]
    51d8:	cmp	r3, #2
    51da:	vstr	d0, [sp, #24]
    51de:	beq.n	5204 <acos+0x88>
    51e0:	mov	r0, sp
    51e2:	bl	8168 <matherr>
    51e6:	cbz	r0, 5204 <acos+0x88>
    51e8:	ldr	r3, [sp, #32]
    51ea:	cbnz	r3, 5212 <acos+0x96>
    51ec:	vldr	d0, [sp, #24]
    51f0:	add	sp, #40	; 0x28
    51f2:	vpop	{d8-d9}
    51f6:	pop	{r4, pc}
    51f8:	vmov.f64	d0, d9
    51fc:	add	sp, #40	; 0x28
    51fe:	vpop	{d8-d9}
    5202:	pop	{r4, pc}
    5204:	bl	8754 <__errno>
    5208:	movs	r3, #33	; 0x21
    520a:	str	r3, [r0, #0]
    520c:	ldr	r3, [sp, #32]
    520e:	cmp	r3, #0
    5210:	beq.n	51ec <acos+0x70>
    5212:	bl	8754 <__errno>
    5216:	ldr	r3, [sp, #32]
    5218:	str	r3, [r0, #0]
    521a:	b.n	51ec <acos+0x70>
    521c:	.word	0x200012a0
    5220:	.word	0x20000930
    5224:	.word	0x20000f7c

00005228 <asin>:
    5228:	push	{r4, lr}
    522a:	vpush	{d8-d9}
    522e:	vmov.f64	d8, d0
    5232:	ldr	r4, [pc, #148]	; (52c8 <asin+0xa0>)
    5234:	sub	sp, #40	; 0x28
    5236:	bl	5978 <__ieee754_asin>
    523a:	ldrsb.w	r3, [r4]
    523e:	vmov.f64	d9, d0
    5242:	adds	r3, #1
    5244:	beq.n	52a4 <asin+0x7c>
    5246:	vcmp.f64	d8, d8
    524a:	vmrs	APSR_nzcv, fpscr
    524e:	bvs.n	52a4 <asin+0x7c>
    5250:	vmov.f64	d0, d8
    5254:	bl	802c <fabs>
    5258:	vmov.f64	d7, #112	; 0x3f800000  1.0
    525c:	vcmpe.f64	d0, d7
    5260:	vmrs	APSR_nzcv, fpscr
    5264:	ble.n	52a4 <asin+0x7c>
    5266:	movs	r3, #1
    5268:	ldr	r2, [pc, #96]	; (52cc <asin+0xa4>)
    526a:	str	r3, [sp, #0]
    526c:	ldr	r0, [pc, #96]	; (52d0 <asin+0xa8>)
    526e:	str	r2, [sp, #4]
    5270:	movs	r3, #0
    5272:	str	r3, [sp, #32]
    5274:	vstr	d8, [sp, #16]
    5278:	vstr	d8, [sp, #8]
    527c:	bl	8170 <nan>
    5280:	ldrsb.w	r3, [r4]
    5284:	cmp	r3, #2
    5286:	vstr	d0, [sp, #24]
    528a:	beq.n	52b0 <asin+0x88>
    528c:	mov	r0, sp
    528e:	bl	8168 <matherr>
    5292:	cbz	r0, 52b0 <asin+0x88>
    5294:	ldr	r3, [sp, #32]
    5296:	cbnz	r3, 52be <asin+0x96>
    5298:	vldr	d0, [sp, #24]
    529c:	add	sp, #40	; 0x28
    529e:	vpop	{d8-d9}
    52a2:	pop	{r4, pc}
    52a4:	vmov.f64	d0, d9
    52a8:	add	sp, #40	; 0x28
    52aa:	vpop	{d8-d9}
    52ae:	pop	{r4, pc}
    52b0:	bl	8754 <__errno>
    52b4:	movs	r3, #33	; 0x21
    52b6:	str	r3, [r0, #0]
    52b8:	ldr	r3, [sp, #32]
    52ba:	cmp	r3, #0
    52bc:	beq.n	5298 <asin+0x70>
    52be:	bl	8754 <__errno>
    52c2:	ldr	r3, [sp, #32]
    52c4:	str	r3, [r0, #0]
    52c6:	b.n	5298 <asin+0x70>
    52c8:	.word	0x200012a0
    52cc:	.word	0x20000938
    52d0:	.word	0x20000f7c

000052d4 <atan2>:
    52d4:	b.w	5be0 <__ieee754_atan2>

000052d8 <pow>:
    52d8:	push	{r4, r5, r6, r7, lr}
    52da:	vpush	{d8-d11}
    52de:	vmov.f64	d10, d0
    52e2:	vmov.f64	d9, d1
    52e6:	ldr	r4, [pc, #600]	; (5540 <pow+0x268>)
    52e8:	sub	sp, #44	; 0x2c
    52ea:	bl	5dc0 <__ieee754_pow>
    52ee:	ldrsb.w	r3, [r4]
    52f2:	vmov.f64	d8, d0
    52f6:	adds	r2, r3, #1
    52f8:	beq.n	5364 <pow+0x8c>
    52fa:	vcmp.f64	d9, d9
    52fe:	vmrs	APSR_nzcv, fpscr
    5302:	bvs.n	5364 <pow+0x8c>
    5304:	vcmp.f64	d10, d10
    5308:	vmrs	APSR_nzcv, fpscr
    530c:	bvs.n	53fc <pow+0x124>
    530e:	vldr	d11, [pc, #552]	; 5538 <pow+0x260>
    5312:	vcmp.f64	d10, d11
    5316:	vmrs	APSR_nzcv, fpscr
    531a:	bne.n	5370 <pow+0x98>
    531c:	vcmp.f64	d9, d11
    5320:	vmrs	APSR_nzcv, fpscr
    5324:	bne.n	534e <pow+0x76>
    5326:	movs	r2, #1
    5328:	ldr	r1, [pc, #536]	; (5544 <pow+0x26c>)
    532a:	str	r2, [sp, #0]
    532c:	movs	r2, #0
    532e:	vstr	d10, [sp, #8]
    5332:	vstr	d9, [sp, #16]
    5336:	vstr	d11, [sp, #24]
    533a:	str	r1, [sp, #4]
    533c:	str	r2, [sp, #32]
    533e:	cmp	r3, #0
    5340:	beq.n	53da <pow+0x102>
    5342:	vmov.f64	d0, #112	; 0x3f800000  1.0
    5346:	add	sp, #44	; 0x2c
    5348:	vpop	{d8-d11}
    534c:	pop	{r4, r5, r6, r7, pc}
    534e:	vmov.f64	d0, d9
    5352:	bl	803c <finite>
    5356:	cbz	r0, 5364 <pow+0x8c>
    5358:	vcmpe.f64	d9, #0.0
    535c:	vmrs	APSR_nzcv, fpscr
    5360:	bmi.w	54a4 <pow+0x1cc>
    5364:	vmov.f64	d0, d8
    5368:	add	sp, #44	; 0x2c
    536a:	vpop	{d8-d11}
    536e:	pop	{r4, r5, r6, r7, pc}
    5370:	bl	803c <finite>
    5374:	mov	r5, r0
    5376:	cmp	r0, #0
    5378:	beq.n	542a <pow+0x152>
    537a:	vcmp.f64	d8, #0.0
    537e:	vmrs	APSR_nzcv, fpscr
    5382:	mov.w	r6, #0
    5386:	mov.w	r7, #0
    538a:	bne.n	5364 <pow+0x8c>
    538c:	vmov.f64	d0, d10
    5390:	bl	803c <finite>
    5394:	cmp	r0, #0
    5396:	beq.n	5364 <pow+0x8c>
    5398:	vmov.f64	d0, d9
    539c:	bl	803c <finite>
    53a0:	cmp	r0, #0
    53a2:	beq.n	5364 <pow+0x8c>
    53a4:	ldr	r2, [pc, #412]	; (5544 <pow+0x26c>)
    53a6:	str	r2, [sp, #4]
    53a8:	vstr	d10, [sp, #8]
    53ac:	vstr	d9, [sp, #16]
    53b0:	strd	r6, r7, [sp, #24]
    53b4:	movs	r1, #4
    53b6:	movs	r2, #0
    53b8:	ldrsb.w	r3, [r4]
    53bc:	str	r1, [sp, #0]
    53be:	str	r2, [sp, #32]
    53c0:	cmp	r3, #2
    53c2:	beq.n	53cc <pow+0xf4>
    53c4:	mov	r0, sp
    53c6:	bl	8168 <matherr>
    53ca:	cbnz	r0, 53e4 <pow+0x10c>
    53cc:	bl	8754 <__errno>
    53d0:	movs	r3, #34	; 0x22
    53d2:	str	r3, [r0, #0]
    53d4:	b.n	53e4 <pow+0x10c>
    53d6:	vstr	d11, [sp, #24]
    53da:	mov	r0, sp
    53dc:	bl	8168 <matherr>
    53e0:	cmp	r0, #0
    53e2:	beq.n	54cc <pow+0x1f4>
    53e4:	ldr	r3, [sp, #32]
    53e6:	cbz	r3, 53f0 <pow+0x118>
    53e8:	bl	8754 <__errno>
    53ec:	ldr	r3, [sp, #32]
    53ee:	str	r3, [r0, #0]
    53f0:	vldr	d0, [sp, #24]
    53f4:	add	sp, #44	; 0x2c
    53f6:	vpop	{d8-d11}
    53fa:	pop	{r4, r5, r6, r7, pc}
    53fc:	vcmp.f64	d9, #0.0
    5400:	vmrs	APSR_nzcv, fpscr
    5404:	bne.n	5364 <pow+0x8c>
    5406:	vmov.f64	d0, #112	; 0x3f800000  1.0
    540a:	movs	r2, #1
    540c:	ldr	r1, [pc, #308]	; (5544 <pow+0x26c>)
    540e:	str	r2, [sp, #0]
    5410:	cmp	r3, #2
    5412:	mov.w	r2, #0
    5416:	vstr	d10, [sp, #8]
    541a:	vstr	d9, [sp, #16]
    541e:	str	r1, [sp, #4]
    5420:	str	r2, [sp, #32]
    5422:	vstr	d0, [sp, #24]
    5426:	bne.n	53da <pow+0x102>
    5428:	b.n	5368 <pow+0x90>
    542a:	vmov.f64	d0, d10
    542e:	bl	803c <finite>
    5432:	cmp	r0, #0
    5434:	beq.n	537a <pow+0xa2>
    5436:	vmov.f64	d0, d9
    543a:	bl	803c <finite>
    543e:	cmp	r0, #0
    5440:	beq.n	537a <pow+0xa2>
    5442:	vcmp.f64	d8, d8
    5446:	vmrs	APSR_nzcv, fpscr
    544a:	ldrsb.w	r3, [r4]
    544e:	ldr	r2, [pc, #244]	; (5544 <pow+0x26c>)
    5450:	str	r5, [sp, #32]
    5452:	bvs.n	5512 <pow+0x23a>
    5454:	movs	r1, #3
    5456:	vstr	d10, [sp, #8]
    545a:	vstr	d9, [sp, #16]
    545e:	stmia.w	sp, {r1, r2}
    5462:	cmp	r3, #0
    5464:	bne.n	54d6 <pow+0x1fe>
    5466:	vcmpe.f64	d10, #0.0
    546a:	ldr	r3, [pc, #220]	; (5548 <pow+0x270>)
    546c:	mov.w	r2, #3758096384	; 0xe0000000
    5470:	vmrs	APSR_nzcv, fpscr
    5474:	strd	r2, r3, [sp, #24]
    5478:	bpl.n	53c4 <pow+0xec>
    547a:	vmov.f64	d7, #96	; 0x3f000000  0.5
    547e:	vmul.f64	d9, d9, d7
    5482:	vmov.f64	d0, d9
    5486:	bl	8180 <rint>
    548a:	vcmp.f64	d9, d0
    548e:	vmrs	APSR_nzcv, fpscr
    5492:	beq.n	550c <pow+0x234>
    5494:	ldr	r1, [pc, #180]	; (554c <pow+0x274>)
    5496:	ldrsb.w	r3, [r4]
    549a:	mov.w	r0, #3758096384	; 0xe0000000
    549e:	strd	r0, r1, [sp, #24]
    54a2:	b.n	53c0 <pow+0xe8>
    54a4:	ldr	r2, [pc, #156]	; (5544 <pow+0x26c>)
    54a6:	ldrsb.w	r3, [r4]
    54aa:	str	r2, [sp, #4]
    54ac:	movs	r1, #1
    54ae:	movs	r2, #0
    54b0:	vstr	d10, [sp, #8]
    54b4:	vstr	d9, [sp, #16]
    54b8:	str	r1, [sp, #0]
    54ba:	str	r2, [sp, #32]
    54bc:	cmp	r3, #0
    54be:	beq.n	53d6 <pow+0xfe>
    54c0:	ldr	r1, [pc, #140]	; (5550 <pow+0x278>)
    54c2:	movs	r0, #0
    54c4:	cmp	r3, #2
    54c6:	strd	r0, r1, [sp, #24]
    54ca:	bne.n	53da <pow+0x102>
    54cc:	bl	8754 <__errno>
    54d0:	movs	r3, #33	; 0x21
    54d2:	str	r3, [r0, #0]
    54d4:	b.n	53e4 <pow+0x10c>
    54d6:	ldr	r1, [pc, #124]	; (5554 <pow+0x27c>)
    54d8:	vcmpe.f64	d10, #0.0
    54dc:	movs	r0, #0
    54de:	vmrs	APSR_nzcv, fpscr
    54e2:	strd	r0, r1, [sp, #24]
    54e6:	bpl.w	53c0 <pow+0xe8>
    54ea:	vmov.f64	d7, #96	; 0x3f000000  0.5
    54ee:	vmul.f64	d9, d9, d7
    54f2:	vmov.f64	d0, d9
    54f6:	bl	8180 <rint>
    54fa:	vcmp.f64	d9, d0
    54fe:	vmrs	APSR_nzcv, fpscr
    5502:	beq.n	550c <pow+0x234>
    5504:	ldr	r3, [pc, #72]	; (5550 <pow+0x278>)
    5506:	movs	r2, #0
    5508:	strd	r2, r3, [sp, #24]
    550c:	ldrsb.w	r3, [r4]
    5510:	b.n	53c0 <pow+0xe8>
    5512:	movs	r1, #1
    5514:	vstr	d10, [sp, #8]
    5518:	vstr	d9, [sp, #16]
    551c:	stmia.w	sp, {r1, r2}
    5520:	cmp	r3, #0
    5522:	beq.w	53d6 <pow+0xfe>
    5526:	vdiv.f64	d7, d11, d11
    552a:	cmp	r3, #2
    552c:	vstr	d7, [sp, #24]
    5530:	beq.n	54cc <pow+0x1f4>
    5532:	b.n	53da <pow+0x102>
    5534:	nop.w
	...
    5540:	.word	0x200012a0
    5544:	.word	0x20000940
    5548:	.word	0x47efffff
    554c:	.word	0xc7efffff
    5550:	.word	0xfff00000
    5554:	.word	0x7ff00000

00005558 <sqrt>:
    5558:	push	{lr}
    555a:	vpush	{d8}
    555e:	vmov.f64	d8, d0
    5562:	sub	sp, #44	; 0x2c
    5564:	bl	67e4 <__ieee754_sqrt>
    5568:	ldr	r3, [pc, #140]	; (55f8 <sqrt+0xa0>)
    556a:	ldrsb.w	r3, [r3]
    556e:	adds	r2, r3, #1
    5570:	beq.n	558a <sqrt+0x32>
    5572:	vcmp.f64	d8, d8
    5576:	vmrs	APSR_nzcv, fpscr
    557a:	bvs.n	558a <sqrt+0x32>
    557c:	vldr	d7, [pc, #112]	; 55f0 <sqrt+0x98>
    5580:	vcmpe.f64	d8, d7
    5584:	vmrs	APSR_nzcv, fpscr
    5588:	bmi.n	5594 <sqrt+0x3c>
    558a:	add	sp, #44	; 0x2c
    558c:	vpop	{d8}
    5590:	ldr.w	pc, [sp], #4
    5594:	movs	r2, #1
    5596:	ldr	r1, [pc, #100]	; (55fc <sqrt+0xa4>)
    5598:	str	r2, [sp, #0]
    559a:	movs	r2, #0
    559c:	vstr	d8, [sp, #16]
    55a0:	vstr	d8, [sp, #8]
    55a4:	str	r1, [sp, #4]
    55a6:	str	r2, [sp, #32]
    55a8:	cbz	r3, 55d0 <sqrt+0x78>
    55aa:	vdiv.f64	d6, d7, d7
    55ae:	cmp	r3, #2
    55b0:	vstr	d6, [sp, #24]
    55b4:	bne.n	55d4 <sqrt+0x7c>
    55b6:	bl	8754 <__errno>
    55ba:	movs	r3, #33	; 0x21
    55bc:	str	r3, [r0, #0]
    55be:	ldr	r3, [sp, #32]
    55c0:	cbnz	r3, 55e0 <sqrt+0x88>
    55c2:	vldr	d0, [sp, #24]
    55c6:	add	sp, #44	; 0x2c
    55c8:	vpop	{d8}
    55cc:	ldr.w	pc, [sp], #4
    55d0:	vstr	d7, [sp, #24]
    55d4:	mov	r0, sp
    55d6:	bl	8168 <matherr>
    55da:	cmp	r0, #0
    55dc:	bne.n	55be <sqrt+0x66>
    55de:	b.n	55b6 <sqrt+0x5e>
    55e0:	bl	8754 <__errno>
    55e4:	ldr	r3, [sp, #32]
    55e6:	str	r3, [r0, #0]
    55e8:	b.n	55c2 <sqrt+0x6a>
    55ea:	nop
    55ec:	nop.w
	...
    55f8:	.word	0x200012a0
    55fc:	.word	0x20000944

00005600 <atan2f>:
    5600:	b.w	6968 <__ieee754_atan2f>
    5604:	movs	r0, r0
	...

00005608 <sqrtf>:
    5608:	push	{lr}
    560a:	vpush	{d8}
    560e:	sub	sp, #44	; 0x2c
    5610:	vmov.f32	s16, s0
    5614:	bl	6d6c <__ieee754_sqrtf>
    5618:	ldr	r3, [pc, #148]	; (56b0 <sqrtf+0xa8>)
    561a:	ldrsb.w	r3, [r3]
    561e:	adds	r2, r3, #1
    5620:	beq.n	5636 <sqrtf+0x2e>
    5622:	vcmp.f32	s16, s16
    5626:	vmrs	APSR_nzcv, fpscr
    562a:	bvs.n	5636 <sqrtf+0x2e>
    562c:	vcmpe.f32	s16, #0.0
    5630:	vmrs	APSR_nzcv, fpscr
    5634:	bmi.n	5640 <sqrtf+0x38>
    5636:	add	sp, #44	; 0x2c
    5638:	vpop	{d8}
    563c:	ldr.w	pc, [sp], #4
    5640:	vcvt.f64.f32	d0, s16
    5644:	movs	r2, #1
    5646:	ldr	r1, [pc, #108]	; (56b4 <sqrtf+0xac>)
    5648:	str	r2, [sp, #0]
    564a:	movs	r2, #0
    564c:	vstr	d0, [sp, #16]
    5650:	vstr	d0, [sp, #8]
    5654:	str	r1, [sp, #4]
    5656:	str	r2, [sp, #32]
    5658:	cbz	r3, 5688 <sqrtf+0x80>
    565a:	vldr	d7, [pc, #76]	; 56a8 <sqrtf+0xa0>
    565e:	cmp	r3, #2
    5660:	vdiv.f64	d6, d7, d7
    5664:	vstr	d6, [sp, #24]
    5668:	bne.n	5690 <sqrtf+0x88>
    566a:	bl	8754 <__errno>
    566e:	movs	r3, #33	; 0x21
    5670:	str	r3, [r0, #0]
    5672:	ldr	r3, [sp, #32]
    5674:	cbnz	r3, 569c <sqrtf+0x94>
    5676:	vldr	d0, [sp, #24]
    567a:	vcvt.f32.f64	s0, d0
    567e:	add	sp, #44	; 0x2c
    5680:	vpop	{d8}
    5684:	ldr.w	pc, [sp], #4
    5688:	movs	r2, #0
    568a:	movs	r3, #0
    568c:	strd	r2, r3, [sp, #24]
    5690:	mov	r0, sp
    5692:	bl	8168 <matherr>
    5696:	cmp	r0, #0
    5698:	bne.n	5672 <sqrtf+0x6a>
    569a:	b.n	566a <sqrtf+0x62>
    569c:	bl	8754 <__errno>
    56a0:	ldr	r3, [sp, #32]
    56a2:	str	r3, [r0, #0]
    56a4:	b.n	5676 <sqrtf+0x6e>
    56a6:	nop
	...
    56b0:	.word	0x200012a0
    56b4:	.word	0x2000094c

000056b8 <__ieee754_acos>:
    56b8:	push	{lr}
    56ba:	vpush	{d8-d9}
    56be:	sub	sp, #12
    56c0:	vstr	d0, [sp]
    56c4:	ldr	r2, [sp, #4]
    56c6:	ldr	r1, [pc, #672]	; (5968 <__ieee754_acos+0x2b0>)
    56c8:	bic.w	r3, r2, #2147483648	; 0x80000000
    56cc:	cmp	r3, r1
    56ce:	ble.n	56f8 <__ieee754_acos+0x40>
    56d0:	add.w	r3, r3, #3221225472	; 0xc0000000
    56d4:	ldr	r1, [sp, #0]
    56d6:	add.w	r3, r3, #1048576	; 0x100000
    56da:	orrs	r3, r1
    56dc:	bne.n	57c4 <__ieee754_acos+0x10c>
    56de:	vldr	d7, [pc, #528]	; 58f0 <__ieee754_acos+0x238>
    56e2:	vldr	d0, [pc, #532]	; 58f8 <__ieee754_acos+0x240>
    56e6:	cmp	r2, #0
    56e8:	it	gt
    56ea:	vmovgt.f64	d0, d7
    56ee:	add	sp, #12
    56f0:	vpop	{d8-d9}
    56f4:	ldr.w	pc, [sp], #4
    56f8:	ldr	r1, [pc, #624]	; (596c <__ieee754_acos+0x2b4>)
    56fa:	cmp	r3, r1
    56fc:	ble.n	57b0 <__ieee754_acos+0xf8>
    56fe:	cmp	r2, #0
    5700:	ldrd	r0, r1, [sp]
    5704:	blt.w	585c <__ieee754_acos+0x1a4>
    5708:	vmov.f64	d7, #96	; 0x3f000000  0.5
    570c:	vmov.f64	d9, #112	; 0x3f800000  1.0
    5710:	vmov	d6, r0, r1
    5714:	vsub.f64	d8, d9, d6
    5718:	vmul.f64	d8, d8, d7
    571c:	vmov.f64	d0, d8
    5720:	bl	67e4 <__ieee754_sqrt>
    5724:	vldr	d5, [pc, #472]	; 5900 <__ieee754_acos+0x248>
    5728:	vldr	d6, [pc, #476]	; 5908 <__ieee754_acos+0x250>
    572c:	vldr	d7, [pc, #480]	; 5910 <__ieee754_acos+0x258>
    5730:	vfma.f64	d6, d8, d5
    5734:	vldr	d5, [pc, #480]	; 5918 <__ieee754_acos+0x260>
    5738:	vfma.f64	d7, d8, d6
    573c:	vldr	d6, [pc, #480]	; 5920 <__ieee754_acos+0x268>
    5740:	vfma.f64	d5, d8, d7
    5744:	vldr	d7, [pc, #480]	; 5928 <__ieee754_acos+0x270>
    5748:	vfma.f64	d6, d8, d5
    574c:	vstr	d0, [sp]
    5750:	vfma.f64	d7, d8, d6
    5754:	vmul.f64	d4, d7, d8
    5758:	ldrd	r2, r3, [sp]
    575c:	vldr	d3, [pc, #464]	; 5930 <__ieee754_acos+0x278>
    5760:	vldr	d7, [pc, #468]	; 5938 <__ieee754_acos+0x280>
    5764:	vldr	d5, [pc, #472]	; 5940 <__ieee754_acos+0x288>
    5768:	vfma.f64	d7, d8, d3
    576c:	vmov.f64	d3, d8
    5770:	movs	r2, #0
    5772:	vldr	d6, [pc, #468]	; 5948 <__ieee754_acos+0x290>
    5776:	vfma.f64	d5, d8, d7
    577a:	vmov	d7, r2, r3
    577e:	vfma.f64	d6, d8, d5
    5782:	vfms.f64	d3, d7, d7
    5786:	vadd.f64	d5, d0, d7
    578a:	vdiv.f64	d0, d3, d5
    578e:	vldr	d5, [sp]
    5792:	vfma.f64	d9, d8, d6
    5796:	vdiv.f64	d6, d4, d9
    579a:	vfma.f64	d0, d5, d6
    579e:	vadd.f64	d0, d0, d7
    57a2:	vadd.f64	d0, d0, d0
    57a6:	add	sp, #12
    57a8:	vpop	{d8-d9}
    57ac:	ldr.w	pc, [sp], #4
    57b0:	ldr	r2, [pc, #444]	; (5970 <__ieee754_acos+0x2b8>)
    57b2:	cmp	r3, r2
    57b4:	bgt.n	57da <__ieee754_acos+0x122>
    57b6:	vldr	d0, [pc, #408]	; 5950 <__ieee754_acos+0x298>
    57ba:	add	sp, #12
    57bc:	vpop	{d8-d9}
    57c0:	ldr.w	pc, [sp], #4
    57c4:	vldr	d7, [sp]
    57c8:	vsub.f64	d7, d7, d7
    57cc:	vdiv.f64	d0, d7, d7
    57d0:	add	sp, #12
    57d2:	vpop	{d8-d9}
    57d6:	ldr.w	pc, [sp], #4
    57da:	vldr	d7, [sp]
    57de:	vmov.f64	d5, #112	; 0x3f800000  1.0
    57e2:	vldr	d3, [pc, #284]	; 5900 <__ieee754_acos+0x248>
    57e6:	vmul.f64	d7, d7, d7
    57ea:	vldr	d4, [pc, #284]	; 5908 <__ieee754_acos+0x250>
    57ee:	vldr	d6, [pc, #288]	; 5910 <__ieee754_acos+0x258>
    57f2:	vfma.f64	d4, d7, d3
    57f6:	vldr	d3, [pc, #288]	; 5918 <__ieee754_acos+0x260>
    57fa:	vfma.f64	d6, d7, d4
    57fe:	vldr	d4, [pc, #288]	; 5920 <__ieee754_acos+0x268>
    5802:	vfma.f64	d3, d7, d6
    5806:	vldr	d6, [pc, #288]	; 5928 <__ieee754_acos+0x270>
    580a:	vfma.f64	d4, d7, d3
    580e:	vldr	d1, [pc, #288]	; 5930 <__ieee754_acos+0x278>
    5812:	vfma.f64	d6, d7, d4
    5816:	vmul.f64	d6, d6, d7
    581a:	vldr	d2, [pc, #284]	; 5938 <__ieee754_acos+0x280>
    581e:	vldr	d3, [pc, #288]	; 5940 <__ieee754_acos+0x288>
    5822:	vfma.f64	d2, d7, d1
    5826:	vldr	d4, [pc, #288]	; 5948 <__ieee754_acos+0x290>
    582a:	vfma.f64	d3, d7, d2
    582e:	vldr	d0, [pc, #296]	; 5958 <__ieee754_acos+0x2a0>
    5832:	vfma.f64	d4, d7, d3
    5836:	vfma.f64	d5, d7, d4
    583a:	vldr	d7, [pc, #276]	; 5950 <__ieee754_acos+0x298>
    583e:	vdiv.f64	d4, d6, d5
    5842:	vldr	d6, [sp]
    5846:	vfms.f64	d0, d6, d4
    584a:	vsub.f64	d0, d6, d0
    584e:	vsub.f64	d0, d7, d0
    5852:	add	sp, #12
    5854:	vpop	{d8-d9}
    5858:	ldr.w	pc, [sp], #4
    585c:	vmov	d5, r0, r1
    5860:	vmov.f64	d6, #112	; 0x3f800000  1.0
    5864:	vldr	d4, [pc, #152]	; 5900 <__ieee754_acos+0x248>
    5868:	vadd.f64	d8, d5, d6
    586c:	vmov.f64	d7, #96	; 0x3f000000  0.5
    5870:	vldr	d5, [pc, #148]	; 5908 <__ieee754_acos+0x250>
    5874:	vmul.f64	d7, d8, d7
    5878:	vmov.f64	d0, d7
    587c:	vldr	d3, [pc, #144]	; 5910 <__ieee754_acos+0x258>
    5880:	vfma.f64	d5, d7, d4
    5884:	vldr	d8, [pc, #160]	; 5928 <__ieee754_acos+0x270>
    5888:	vfma.f64	d3, d7, d5
    588c:	vldr	d4, [pc, #136]	; 5918 <__ieee754_acos+0x260>
    5890:	vldr	d5, [pc, #140]	; 5920 <__ieee754_acos+0x268>
    5894:	vfma.f64	d4, d7, d3
    5898:	vldr	d2, [pc, #148]	; 5930 <__ieee754_acos+0x278>
    589c:	vfma.f64	d5, d7, d4
    58a0:	vfma.f64	d8, d7, d5
    58a4:	vldr	d3, [pc, #144]	; 5938 <__ieee754_acos+0x280>
    58a8:	vmul.f64	d8, d8, d7
    58ac:	vldr	d4, [pc, #144]	; 5940 <__ieee754_acos+0x288>
    58b0:	vfma.f64	d3, d7, d2
    58b4:	vldr	d5, [pc, #144]	; 5948 <__ieee754_acos+0x290>
    58b8:	vfma.f64	d4, d7, d3
    58bc:	vfma.f64	d5, d7, d4
    58c0:	vfma.f64	d6, d7, d5
    58c4:	vmov.f64	d9, d6
    58c8:	bl	67e4 <__ieee754_sqrt>
    58cc:	vdiv.f64	d4, d8, d9
    58d0:	vmov.f64	d5, #0	; 0x40000000  2.0
    58d4:	vldr	d6, [pc, #136]	; 5960 <__ieee754_acos+0x2a8>
    58d8:	vldr	d7, [pc, #28]	; 58f8 <__ieee754_acos+0x240>
    58dc:	vfma.f64	d6, d0, d4
    58e0:	vadd.f64	d0, d6, d0
    58e4:	vfms.f64	d7, d0, d5
    58e8:	vmov.f64	d0, d7
    58ec:	b.n	56ee <__ieee754_acos+0x36>
    58ee:	nop
	...
    58f8:	.word	0x54442d18
    58fc:	.word	0x400921fb
    5900:	.word	0x0dfdf709
    5904:	.word	0x3f023de1
    5908:	.word	0x7501b288
    590c:	.word	0x3f49efe0
    5910:	.word	0xb5688f3b
    5914:	.word	0xbfa48228
    5918:	.word	0x0e884455
    591c:	.word	0x3fc9c155
    5920:	.word	0x03eb6f7d
    5924:	.word	0xbfd4d612
    5928:	.word	0x55555555
    592c:	.word	0x3fc55555
    5930:	.word	0xb12e9282
    5934:	.word	0x3fb3b8c5
    5938:	.word	0x1b8d0159
    593c:	.word	0xbfe6066c
    5940:	.word	0x9c598ac8
    5944:	.word	0x40002ae5
    5948:	.word	0x1c8a2d4b
    594c:	.word	0xc0033a27
    5950:	.word	0x54442d18
    5954:	.word	0x3ff921fb
    5958:	.word	0x33145c07
    595c:	.word	0x3c91a626
    5960:	.word	0x33145c07
    5964:	.word	0xbc91a626
    5968:	.word	0x3fefffff
    596c:	.word	0x3fdfffff
    5970:	.word	0x3c600000
    5974:	.word	0x00000000

00005978 <__ieee754_asin>:
    5978:	push	{r4, r5, lr}
    597a:	vmov	r5, s1
    597e:	vpush	{d8-d10}
    5982:	ldr	r3, [pc, #588]	; (5bd0 <__ieee754_asin+0x258>)
    5984:	bic.w	r4, r5, #2147483648	; 0x80000000
    5988:	cmp	r4, r3
    598a:	sub	sp, #12
    598c:	ble.n	59b0 <__ieee754_asin+0x38>
    598e:	add.w	r4, r4, #3221225472	; 0xc0000000
    5992:	vmov	r3, s0
    5996:	add.w	r4, r4, #1048576	; 0x100000
    599a:	orrs	r3, r4
    599c:	beq.w	5ab0 <__ieee754_asin+0x138>
    59a0:	vsub.f64	d7, d0, d0
    59a4:	vdiv.f64	d0, d7, d7
    59a8:	add	sp, #12
    59aa:	vpop	{d8-d10}
    59ae:	pop	{r4, r5, pc}
    59b0:	ldr	r3, [pc, #544]	; (5bd4 <__ieee754_asin+0x25c>)
    59b2:	cmp	r4, r3
    59b4:	bgt.n	59d4 <__ieee754_asin+0x5c>
    59b6:	cmp.w	r4, #1044381696	; 0x3e400000
    59ba:	bge.w	5aee <__ieee754_asin+0x176>
    59be:	vmov.f64	d6, #112	; 0x3f800000  1.0
    59c2:	vldr	d7, [pc, #404]	; 5b58 <__ieee754_asin+0x1e0>
    59c6:	vadd.f64	d7, d0, d7
    59ca:	vcmpe.f64	d7, d6
    59ce:	vmrs	APSR_nzcv, fpscr
    59d2:	bgt.n	59a8 <__ieee754_asin+0x30>
    59d4:	bl	802c <fabs>
    59d8:	vmov.f64	d7, #112	; 0x3f800000  1.0
    59dc:	vmov.f64	d6, #96	; 0x3f000000  0.5
    59e0:	vsub.f64	d0, d7, d0
    59e4:	vldr	d5, [pc, #376]	; 5b60 <__ieee754_asin+0x1e8>
    59e8:	vmul.f64	d8, d0, d6
    59ec:	vmov.f64	d0, d8
    59f0:	vldr	d6, [pc, #372]	; 5b68 <__ieee754_asin+0x1f0>
    59f4:	vldr	d4, [pc, #376]	; 5b70 <__ieee754_asin+0x1f8>
    59f8:	vfma.f64	d6, d8, d5
    59fc:	vldr	d9, [pc, #376]	; 5b78 <__ieee754_asin+0x200>
    5a00:	vfma.f64	d4, d8, d6
    5a04:	vldr	d5, [pc, #376]	; 5b80 <__ieee754_asin+0x208>
    5a08:	vldr	d6, [pc, #380]	; 5b88 <__ieee754_asin+0x210>
    5a0c:	vfma.f64	d5, d8, d4
    5a10:	vldr	d3, [pc, #380]	; 5b90 <__ieee754_asin+0x218>
    5a14:	vfma.f64	d6, d8, d5
    5a18:	vfma.f64	d9, d8, d6
    5a1c:	vldr	d4, [pc, #376]	; 5b98 <__ieee754_asin+0x220>
    5a20:	vmul.f64	d9, d9, d8
    5a24:	vldr	d5, [pc, #376]	; 5ba0 <__ieee754_asin+0x228>
    5a28:	vfma.f64	d4, d8, d3
    5a2c:	vldr	d6, [pc, #376]	; 5ba8 <__ieee754_asin+0x230>
    5a30:	vfma.f64	d5, d8, d4
    5a34:	vfma.f64	d6, d8, d5
    5a38:	vfma.f64	d7, d8, d6
    5a3c:	vmov.f64	d10, d7
    5a40:	bl	67e4 <__ieee754_sqrt>
    5a44:	ldr	r3, [pc, #400]	; (5bd8 <__ieee754_asin+0x260>)
    5a46:	cmp	r4, r3
    5a48:	vstr	d0, [sp]
    5a4c:	bgt.n	5acc <__ieee754_asin+0x154>
    5a4e:	vmov.f64	d5, #0	; 0x40000000  2.0
    5a52:	vdiv.f64	d4, d9, d10
    5a56:	ldrd	r2, r3, [sp]
    5a5a:	vldr	d6, [sp]
    5a5e:	vldr	d7, [pc, #336]	; 5bb0 <__ieee754_asin+0x238>
    5a62:	vadd.f64	d2, d6, d6
    5a66:	vldr	d1, [sp]
    5a6a:	movs	r2, #0
    5a6c:	vldr	d0, [pc, #328]	; 5bb8 <__ieee754_asin+0x240>
    5a70:	vmov	d6, r2, r3
    5a74:	vneg.f64	d3, d6
    5a78:	vfma.f64	d8, d3, d6
    5a7c:	vadd.f64	d6, d1, d6
    5a80:	vmov.f64	d1, d7
    5a84:	vfma.f64	d1, d3, d5
    5a88:	vmov.f64	d3, d1
    5a8c:	vdiv.f64	d1, d8, d6
    5a90:	vfms.f64	d0, d1, d5
    5a94:	vfnms.f64	d0, d4, d2
    5a98:	vsub.f64	d0, d0, d3
    5a9c:	vsub.f64	d0, d7, d0
    5aa0:	cmp	r5, #0
    5aa2:	it	le
    5aa4:	vnegle.f64	d0, d0
    5aa8:	add	sp, #12
    5aaa:	vpop	{d8-d10}
    5aae:	pop	{r4, r5, pc}
    5ab0:	vldr	d6, [pc, #268]	; 5bc0 <__ieee754_asin+0x248>
    5ab4:	vldr	d7, [pc, #256]	; 5bb8 <__ieee754_asin+0x240>
    5ab8:	vmul.f64	d7, d0, d7
    5abc:	vfma.f64	d7, d0, d6
    5ac0:	vmov.f64	d0, d7
    5ac4:	add	sp, #12
    5ac6:	vpop	{d8-d10}
    5aca:	pop	{r4, r5, pc}
    5acc:	vldr	d5, [sp]
    5ad0:	vdiv.f64	d7, d9, d10
    5ad4:	vmov.f64	d6, #0	; 0x40000000  2.0
    5ad8:	vfma.f64	d5, d5, d7
    5adc:	vldr	d0, [pc, #232]	; 5bc8 <__ieee754_asin+0x250>
    5ae0:	vldr	d7, [pc, #220]	; 5bc0 <__ieee754_asin+0x248>
    5ae4:	vfma.f64	d0, d5, d6
    5ae8:	vsub.f64	d0, d7, d0
    5aec:	b.n	5aa0 <__ieee754_asin+0x128>
    5aee:	vldr	d4, [pc, #112]	; 5b60 <__ieee754_asin+0x1e8>
    5af2:	vmul.f64	d7, d0, d0
    5af6:	vmov.f64	d2, #112	; 0x3f800000  1.0
    5afa:	vldr	d5, [pc, #108]	; 5b68 <__ieee754_asin+0x1f0>
    5afe:	vldr	d6, [pc, #112]	; 5b70 <__ieee754_asin+0x1f8>
    5b02:	vfma.f64	d5, d7, d4
    5b06:	vldr	d4, [pc, #120]	; 5b80 <__ieee754_asin+0x208>
    5b0a:	vfma.f64	d6, d7, d5
    5b0e:	vldr	d5, [pc, #120]	; 5b88 <__ieee754_asin+0x210>
    5b12:	vfma.f64	d4, d7, d6
    5b16:	vldr	d6, [pc, #96]	; 5b78 <__ieee754_asin+0x200>
    5b1a:	vfma.f64	d5, d7, d4
    5b1e:	vldr	d1, [pc, #112]	; 5b90 <__ieee754_asin+0x218>
    5b22:	vfma.f64	d6, d7, d5
    5b26:	vmul.f64	d6, d6, d7
    5b2a:	vldr	d3, [pc, #108]	; 5b98 <__ieee754_asin+0x220>
    5b2e:	vldr	d4, [pc, #112]	; 5ba0 <__ieee754_asin+0x228>
    5b32:	vfma.f64	d3, d7, d1
    5b36:	vldr	d5, [pc, #112]	; 5ba8 <__ieee754_asin+0x230>
    5b3a:	vfma.f64	d4, d7, d3
    5b3e:	vfma.f64	d5, d7, d4
    5b42:	vfma.f64	d2, d7, d5
    5b46:	vdiv.f64	d5, d6, d2
    5b4a:	vfma.f64	d0, d0, d5
    5b4e:	add	sp, #12
    5b50:	vpop	{d8-d10}
    5b54:	pop	{r4, r5, pc}
    5b56:	nop
    5b58:	.word	0x8800759c
    5b5c:	.word	0x7e37e43c
    5b60:	.word	0x0dfdf709
    5b64:	.word	0x3f023de1
    5b68:	.word	0x7501b288
    5b6c:	.word	0x3f49efe0
    5b70:	.word	0xb5688f3b
    5b74:	.word	0xbfa48228
    5b78:	.word	0x55555555
    5b7c:	.word	0x3fc55555
    5b80:	.word	0x0e884455
    5b84:	.word	0x3fc9c155
    5b88:	.word	0x03eb6f7d
    5b8c:	.word	0xbfd4d612
    5b90:	.word	0xb12e9282
    5b94:	.word	0x3fb3b8c5
    5b98:	.word	0x1b8d0159
    5b9c:	.word	0xbfe6066c
    5ba0:	.word	0x9c598ac8
    5ba4:	.word	0x40002ae5
    5ba8:	.word	0x1c8a2d4b
    5bac:	.word	0xc0033a27
    5bb0:	.word	0x54442d18
    5bb4:	.word	0x3fe921fb
    5bb8:	.word	0x33145c07
    5bbc:	.word	0x3c91a626
    5bc0:	.word	0x54442d18
    5bc4:	.word	0x3ff921fb
    5bc8:	.word	0x33145c07
    5bcc:	.word	0xbc91a626
    5bd0:	.word	0x3fefffff
    5bd4:	.word	0x3fdfffff
    5bd8:	.word	0x3fef3332
    5bdc:	.word	0x00000000

00005be0 <__ieee754_atan2>:
    5be0:	push	{r4, r5, r6, r7, lr}
    5be2:	sub	sp, #20
    5be4:	vstr	d1, [sp, #8]
    5be8:	ldr	r2, [sp, #8]
    5bea:	ldr	r0, [sp, #12]
    5bec:	ldr	r1, [pc, #456]	; (5db8 <__ieee754_atan2+0x1d8>)
    5bee:	negs	r3, r2
    5bf0:	vstr	d0, [sp]
    5bf4:	orrs	r3, r2
    5bf6:	bic.w	r5, r0, #2147483648	; 0x80000000
    5bfa:	orr.w	r3, r5, r3, lsr #31
    5bfe:	cmp	r3, r1
    5c00:	ldmia.w	sp, {r4, r7}
    5c04:	bhi.n	5c8c <__ieee754_atan2+0xac>
    5c06:	negs	r3, r4
    5c08:	orrs	r3, r4
    5c0a:	bic.w	lr, r7, #2147483648	; 0x80000000
    5c0e:	orr.w	r3, lr, r3, lsr #31
    5c12:	cmp	r3, r1
    5c14:	bhi.n	5c8c <__ieee754_atan2+0xac>
    5c16:	add.w	r3, r0, #3221225472	; 0xc0000000
    5c1a:	add.w	r3, r3, #1048576	; 0x100000
    5c1e:	orrs	r3, r2
    5c20:	beq.n	5cca <__ieee754_atan2+0xea>
    5c22:	asrs	r6, r0, #30
    5c24:	and.w	r6, r6, #2
    5c28:	orrs.w	r3, r4, lr
    5c2c:	orr.w	r6, r6, r7, lsr #31
    5c30:	beq.n	5c9c <__ieee754_atan2+0xbc>
    5c32:	orrs.w	r3, r2, r5
    5c36:	beq.n	5cb6 <__ieee754_atan2+0xd6>
    5c38:	cmp	r5, r1
    5c3a:	beq.n	5ce2 <__ieee754_atan2+0x102>
    5c3c:	cmp	lr, r1
    5c3e:	beq.n	5cb6 <__ieee754_atan2+0xd6>
    5c40:	rsb	r5, r5, lr
    5c44:	asrs	r5, r5, #20
    5c46:	cmp	r5, #60	; 0x3c
    5c48:	bgt.n	5cd4 <__ieee754_atan2+0xf4>
    5c4a:	cmp	r0, #0
    5c4c:	blt.n	5d26 <__ieee754_atan2+0x146>
    5c4e:	ldrd	r2, r3, [sp]
    5c52:	vldr	d0, [sp, #8]
    5c56:	vmov	d7, r2, r3
    5c5a:	vdiv.f64	d0, d7, d0
    5c5e:	bl	802c <fabs>
    5c62:	bl	7e28 <atan>
    5c66:	vmov	r2, r3, d0
    5c6a:	cmp	r6, #1
    5c6c:	beq.n	5d1c <__ieee754_atan2+0x13c>
    5c6e:	cmp	r6, #2
    5c70:	beq.n	5d06 <__ieee754_atan2+0x126>
    5c72:	cmp	r6, #0
    5c74:	beq.n	5d00 <__ieee754_atan2+0x120>
    5c76:	vldr	d7, [pc, #232]	; 5d60 <__ieee754_atan2+0x180>
    5c7a:	vldr	d6, [pc, #236]	; 5d68 <__ieee754_atan2+0x188>
    5c7e:	vmov	d5, r2, r3
    5c82:	vsub.f64	d7, d5, d7
    5c86:	vsub.f64	d0, d7, d6
    5c8a:	b.n	5c98 <__ieee754_atan2+0xb8>
    5c8c:	vldr	d7, [sp, #8]
    5c90:	vldr	d6, [sp]
    5c94:	vadd.f64	d0, d7, d6
    5c98:	add	sp, #20
    5c9a:	pop	{r4, r5, r6, r7, pc}
    5c9c:	cmp	r6, #2
    5c9e:	beq.n	5cdc <__ieee754_atan2+0xfc>
    5ca0:	vldr	d0, [pc, #204]	; 5d70 <__ieee754_atan2+0x190>
    5ca4:	vldr	d7, [sp]
    5ca8:	cmp	r6, #3
    5caa:	it	eq
    5cac:	vmoveq.f64	d7, d0
    5cb0:	vmov.f64	d0, d7
    5cb4:	b.n	5c98 <__ieee754_atan2+0xb8>
    5cb6:	vldr	d7, [pc, #192]	; 5d78 <__ieee754_atan2+0x198>
    5cba:	vldr	d0, [pc, #196]	; 5d80 <__ieee754_atan2+0x1a0>
    5cbe:	cmp	r7, #0
    5cc0:	it	ge
    5cc2:	vmovge.f64	d0, d7
    5cc6:	add	sp, #20
    5cc8:	pop	{r4, r5, r6, r7, pc}
    5cca:	add	sp, #20
    5ccc:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    5cd0:	b.w	7e28 <atan>
    5cd4:	add	r3, pc, #160	; (adr r3, 5d78 <__ieee754_atan2+0x198>)
    5cd6:	ldrd	r2, r3, [r3]
    5cda:	b.n	5c6a <__ieee754_atan2+0x8a>
    5cdc:	vldr	d0, [pc, #136]	; 5d68 <__ieee754_atan2+0x188>
    5ce0:	b.n	5c98 <__ieee754_atan2+0xb8>
    5ce2:	cmp	lr, r5
    5ce4:	beq.n	5d30 <__ieee754_atan2+0x150>
    5ce6:	cmp	r6, #2
    5ce8:	beq.n	5cdc <__ieee754_atan2+0xfc>
    5cea:	cmp	r6, #3
    5cec:	beq.n	5d4a <__ieee754_atan2+0x16a>
    5cee:	vldr	d7, [pc, #152]	; 5d88 <__ieee754_atan2+0x1a8>
    5cf2:	vldr	d0, [pc, #156]	; 5d90 <__ieee754_atan2+0x1b0>
    5cf6:	cmp	r6, #1
    5cf8:	it	eq
    5cfa:	vmoveq.f64	d0, d7
    5cfe:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d00:	vmov	d0, r2, r3
    5d04:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d06:	vldr	d7, [pc, #88]	; 5d60 <__ieee754_atan2+0x180>
    5d0a:	vldr	d6, [pc, #92]	; 5d68 <__ieee754_atan2+0x188>
    5d0e:	vmov	d5, r2, r3
    5d12:	vsub.f64	d7, d5, d7
    5d16:	vsub.f64	d0, d6, d7
    5d1a:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d1c:	add.w	r3, r3, #2147483648	; 0x80000000
    5d20:	vmov	d0, r2, r3
    5d24:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d26:	adds	r5, #60	; 0x3c
    5d28:	bge.n	5c4e <__ieee754_atan2+0x6e>
    5d2a:	movs	r2, #0
    5d2c:	movs	r3, #0
    5d2e:	b.n	5c6a <__ieee754_atan2+0x8a>
    5d30:	cmp	r6, #2
    5d32:	beq.n	5d56 <__ieee754_atan2+0x176>
    5d34:	cmp	r6, #3
    5d36:	beq.n	5d50 <__ieee754_atan2+0x170>
    5d38:	vldr	d7, [pc, #92]	; 5d98 <__ieee754_atan2+0x1b8>
    5d3c:	vldr	d0, [pc, #96]	; 5da0 <__ieee754_atan2+0x1c0>
    5d40:	cmp	r6, #1
    5d42:	it	eq
    5d44:	vmoveq.f64	d0, d7
    5d48:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d4a:	vldr	d0, [pc, #36]	; 5d70 <__ieee754_atan2+0x190>
    5d4e:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d50:	vldr	d0, [pc, #84]	; 5da8 <__ieee754_atan2+0x1c8>
    5d54:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d56:	vldr	d0, [pc, #88]	; 5db0 <__ieee754_atan2+0x1d0>
    5d5a:	b.n	5c98 <__ieee754_atan2+0xb8>
    5d5c:	nop.w
    5d60:	.word	0x33145c07
    5d64:	.word	0x3ca1a626
    5d68:	.word	0x54442d18
    5d6c:	.word	0x400921fb
    5d70:	.word	0x54442d18
    5d74:	.word	0xc00921fb
    5d78:	.word	0x54442d18
    5d7c:	.word	0x3ff921fb
    5d80:	.word	0x54442d18
    5d84:	.word	0xbff921fb
    5d88:	.word	0x00000000
    5d8c:	.word	0x80000000
	...
    5d98:	.word	0x54442d18
    5d9c:	.word	0xbfe921fb
    5da0:	.word	0x54442d18
    5da4:	.word	0x3fe921fb
    5da8:	.word	0x7f3321d2
    5dac:	.word	0xc002d97c
    5db0:	.word	0x7f3321d2
    5db4:	.word	0x4002d97c
    5db8:	.word	0x7ff00000
    5dbc:	.word	0x00000000

00005dc0 <__ieee754_pow>:
    5dc0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5dc4:	vmov	r0, r1, d1
    5dc8:	vpush	{d8-d11}
    5dcc:	bic.w	r5, r1, #2147483648	; 0x80000000
    5dd0:	orrs.w	r4, r5, r0
    5dd4:	sub	sp, #28
    5dd6:	beq.n	5e4e <__ieee754_pow+0x8e>
    5dd8:	vmov	r2, r3, d0
    5ddc:	ldr	r7, [pc, #424]	; (5f88 <__ieee754_pow+0x1c8>)
    5dde:	bic.w	r4, r3, #2147483648	; 0x80000000
    5de2:	cmp	r4, r7
    5de4:	vmov	sl, s0
    5de8:	mov	r9, r3
    5dea:	bgt.n	5e40 <__ieee754_pow+0x80>
    5dec:	mov	r8, r1
    5dee:	vmov	r6, s2
    5df2:	beq.n	5e3e <__ieee754_pow+0x7e>
    5df4:	cmp	r5, r7
    5df6:	bgt.n	5e40 <__ieee754_pow+0x80>
    5df8:	ldr	r7, [pc, #396]	; (5f88 <__ieee754_pow+0x1c8>)
    5dfa:	cmp	r5, r7
    5dfc:	beq.n	5ef4 <__ieee754_pow+0x134>
    5dfe:	cmp.w	r9, #0
    5e02:	blt.n	5efa <__ieee754_pow+0x13a>
    5e04:	mov.w	fp, #0
    5e08:	cbnz	r6, 5e74 <__ieee754_pow+0xb4>
    5e0a:	ldr	r6, [pc, #380]	; (5f88 <__ieee754_pow+0x1c8>)
    5e0c:	cmp	r5, r6
    5e0e:	beq.w	5f32 <__ieee754_pow+0x172>
    5e12:	ldr	r6, [pc, #376]	; (5f8c <__ieee754_pow+0x1cc>)
    5e14:	cmp	r5, r6
    5e16:	beq.n	5ee6 <__ieee754_pow+0x126>
    5e18:	cmp.w	r8, #1073741824	; 0x40000000
    5e1c:	beq.w	62ce <__ieee754_pow+0x50e>
    5e20:	ldr	r6, [pc, #364]	; (5f90 <__ieee754_pow+0x1d0>)
    5e22:	cmp	r8, r6
    5e24:	bne.n	5e74 <__ieee754_pow+0xb4>
    5e26:	cmp.w	r9, #0
    5e2a:	blt.n	5e74 <__ieee754_pow+0xb4>
    5e2c:	vmov	d0, r2, r3
    5e30:	add	sp, #28
    5e32:	vpop	{d8-d11}
    5e36:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5e3a:	b.w	67e4 <__ieee754_sqrt>
    5e3e:	cbz	r2, 5e5c <__ieee754_pow+0x9c>
    5e40:	add.w	r4, r4, #3221225472	; 0xc0000000
    5e44:	add.w	r4, r4, #1048576	; 0x100000
    5e48:	orrs.w	r3, r4, sl
    5e4c:	bne.n	5e60 <__ieee754_pow+0xa0>
    5e4e:	vmov.f64	d0, #112	; 0x3f800000  1.0
    5e52:	add	sp, #28
    5e54:	vpop	{d8-d11}
    5e58:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5e5c:	cmp	r5, r4
    5e5e:	ble.n	5df8 <__ieee754_pow+0x38>
    5e60:	ldr	r0, [pc, #304]	; (5f94 <__ieee754_pow+0x1d4>)
    5e62:	add	sp, #28
    5e64:	vpop	{d8-d11}
    5e68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5e6c:	b.w	8170 <nan>
    5e70:	mov.w	fp, #0
    5e74:	mov	r6, r2
    5e76:	mov	r7, r3
    5e78:	vmov	d0, r6, r7
    5e7c:	strd	r0, r1, [sp, #8]
    5e80:	bl	802c <fabs>
    5e84:	vstr	d0, [sp]
    5e88:	cmp.w	sl, #0
    5e8c:	beq.n	5ec4 <__ieee754_pow+0x104>
    5e8e:	mov.w	r9, r9, lsr #31
    5e92:	add.w	r9, r9, #4294967295
    5e96:	orrs.w	r3, fp, r9
    5e9a:	beq.n	5f5a <__ieee754_pow+0x19a>
    5e9c:	ldr	r3, [pc, #248]	; (5f98 <__ieee754_pow+0x1d8>)
    5e9e:	cmp	r5, r3
    5ea0:	ble.w	5fa4 <__ieee754_pow+0x1e4>
    5ea4:	add.w	r3, r3, #34603008	; 0x2100000
    5ea8:	cmp	r5, r3
    5eaa:	ble.w	63e2 <__ieee754_pow+0x622>
    5eae:	ldr	r3, [pc, #236]	; (5f9c <__ieee754_pow+0x1dc>)
    5eb0:	cmp	r4, r3
    5eb2:	ble.n	5f68 <__ieee754_pow+0x1a8>
    5eb4:	cmp.w	r8, #0
    5eb8:	ble.n	5f6e <__ieee754_pow+0x1ae>
    5eba:	vldr	d0, [pc, #188]	; 5f78 <__ieee754_pow+0x1b8>
    5ebe:	vmul.f64	d0, d0, d0
    5ec2:	b.n	5e52 <__ieee754_pow+0x92>
    5ec4:	cbz	r4, 5ed0 <__ieee754_pow+0x110>
    5ec6:	ldr	r3, [pc, #196]	; (5f8c <__ieee754_pow+0x1cc>)
    5ec8:	bic.w	r2, r9, #3221225472	; 0xc0000000
    5ecc:	cmp	r2, r3
    5ece:	bne.n	5e8e <__ieee754_pow+0xce>
    5ed0:	cmp.w	r8, #0
    5ed4:	blt.w	63d0 <__ieee754_pow+0x610>
    5ed8:	cmp.w	r9, #0
    5edc:	blt.w	62ac <__ieee754_pow+0x4ec>
    5ee0:	vldr	d0, [sp]
    5ee4:	b.n	5e52 <__ieee754_pow+0x92>
    5ee6:	cmp.w	r8, #0
    5eea:	blt.w	6466 <__ieee754_pow+0x6a6>
    5eee:	vmov	d0, r2, r3
    5ef2:	b.n	5e52 <__ieee754_pow+0x92>
    5ef4:	cmp	r6, #0
    5ef6:	beq.n	5dfe <__ieee754_pow+0x3e>
    5ef8:	b.n	5e40 <__ieee754_pow+0x80>
    5efa:	ldr	r7, [pc, #164]	; (5fa0 <__ieee754_pow+0x1e0>)
    5efc:	cmp	r5, r7
    5efe:	bgt.n	5f54 <__ieee754_pow+0x194>
    5f00:	sub.w	r7, r7, #55574528	; 0x3500000
    5f04:	cmp	r5, r7
    5f06:	ble.w	5e04 <__ieee754_pow+0x44>
    5f0a:	asrs	r7, r5, #20
    5f0c:	subw	r7, r7, #1023	; 0x3ff
    5f10:	cmp	r7, #20
    5f12:	ble.w	6482 <__ieee754_pow+0x6c2>
    5f16:	rsb	r7, r7, #52	; 0x34
    5f1a:	lsr.w	lr, r6, r7
    5f1e:	lsl.w	r7, lr, r7
    5f22:	cmp	r6, r7
    5f24:	bne.w	5e04 <__ieee754_pow+0x44>
    5f28:	and.w	lr, lr, #1
    5f2c:	rsb	fp, lr, #2
    5f30:	b.n	5e08 <__ieee754_pow+0x48>
    5f32:	add.w	r3, r4, #3221225472	; 0xc0000000
    5f36:	add.w	r3, r3, #1048576	; 0x100000
    5f3a:	orrs.w	r3, r3, sl
    5f3e:	beq.n	5e4e <__ieee754_pow+0x8e>
    5f40:	ldr	r3, [pc, #88]	; (5f9c <__ieee754_pow+0x1dc>)
    5f42:	cmp	r4, r3
    5f44:	ble.w	63be <__ieee754_pow+0x5fe>
    5f48:	cmp.w	r8, #0
    5f4c:	blt.n	5f6e <__ieee754_pow+0x1ae>
    5f4e:	vmov	d0, r0, r1
    5f52:	b.n	5e52 <__ieee754_pow+0x92>
    5f54:	mov.w	fp, #2
    5f58:	b.n	5e08 <__ieee754_pow+0x48>
    5f5a:	vmov	d7, r6, r7
    5f5e:	vsub.f64	d7, d7, d7
    5f62:	vdiv.f64	d0, d7, d7
    5f66:	b.n	5e52 <__ieee754_pow+0x92>
    5f68:	cmp.w	r8, #0
    5f6c:	blt.n	5eba <__ieee754_pow+0xfa>
    5f6e:	vldr	d0, [pc, #16]	; 5f80 <__ieee754_pow+0x1c0>
    5f72:	b.n	5e52 <__ieee754_pow+0x92>
    5f74:	nop.w
    5f78:	.word	0x8800759c
    5f7c:	.word	0x7e37e43c
	...
    5f88:	.word	0x7ff00000
    5f8c:	.word	0x3ff00000
    5f90:	.word	0x3fe00000
    5f94:	.word	0x20000f7c
    5f98:	.word	0x41e00000
    5f9c:	.word	0x3fefffff
    5fa0:	.word	0x433fffff
    5fa4:	cmp.w	r4, #1048576	; 0x100000
    5fa8:	bge.w	6462 <__ieee754_pow+0x6a2>
    5fac:	vldr	d6, [sp]
    5fb0:	vldr	d7, [pc, #804]	; 62d8 <__ieee754_pow+0x518>
    5fb4:	vmul.f64	d7, d6, d7
    5fb8:	vstr	d7, [sp]
    5fbc:	ldr	r4, [sp, #4]
    5fbe:	mvn.w	r6, #52	; 0x34
    5fc2:	ldr	r2, [pc, #948]	; (6378 <__ieee754_pow+0x5b8>)
    5fc4:	asrs	r3, r4, #20
    5fc6:	ubfx	r4, r4, #0, #20
    5fca:	subw	r3, r3, #1023	; 0x3ff
    5fce:	orr.w	r1, r4, #1069547520	; 0x3fc00000
    5fd2:	cmp	r4, r2
    5fd4:	add	r6, r3
    5fd6:	orr.w	r1, r1, #3145728	; 0x300000
    5fda:	ble.w	6452 <__ieee754_pow+0x692>
    5fde:	ldr	r3, [pc, #924]	; (637c <__ieee754_pow+0x5bc>)
    5fe0:	cmp	r4, r3
    5fe2:	ble.w	64be <__ieee754_pow+0x6fe>
    5fe6:	vmov.f64	d7, #112	; 0x3f800000  1.0
    5fea:	vldr	d3, [pc, #756]	; 62e0 <__ieee754_pow+0x520>
    5fee:	adds	r6, #1
    5ff0:	sub.w	r1, r1, #1048576	; 0x100000
    5ff4:	movs	r5, #0
    5ff6:	vmov.f64	d0, d3
    5ffa:	ldrd	r2, r3, [sp]
    5ffe:	vmov.f64	d4, #112	; 0x3f800000  1.0
    6002:	mov	r3, r1
    6004:	vmov	d1, r2, r3
    6008:	asrs	r4, r1, #1
    600a:	vadd.f64	d6, d1, d7
    600e:	vsub.f64	d2, d1, d7
    6012:	vdiv.f64	d5, d4, d6
    6016:	vmul.f64	d6, d2, d5
    601a:	vstr	d6, [sp]
    601e:	ldrd	r2, r3, [sp]
    6022:	orr.w	r4, r4, #536870912	; 0x20000000
    6026:	add.w	r4, r4, #524288	; 0x80000
    602a:	movs	r2, #0
    602c:	movs	r0, #0
    602e:	adds	r1, r4, r5
    6030:	vmov	d4, r2, r3
    6034:	vmov	d6, r0, r1
    6038:	vneg.f64	d10, d4
    603c:	vsub.f64	d7, d6, d7
    6040:	vfma.f64	d2, d10, d6
    6044:	vsub.f64	d7, d1, d7
    6048:	vmov.f64	d6, d2
    604c:	vfma.f64	d6, d10, d7
    6050:	vldr	d7, [sp]
    6054:	vmul.f64	d2, d6, d5
    6058:	vldr	d6, [sp]
    605c:	vadd.f64	d7, d7, d4
    6060:	vmul.f64	d11, d6, d6
    6064:	vldr	d9, [pc, #640]	; 62e8 <__ieee754_pow+0x528>
    6068:	vmul.f64	d6, d7, d2
    606c:	vldr	d8, [pc, #640]	; 62f0 <__ieee754_pow+0x530>
    6070:	vldr	d1, [pc, #644]	; 62f8 <__ieee754_pow+0x538>
    6074:	vfma.f64	d8, d11, d9
    6078:	vldr	d7, [pc, #644]	; 6300 <__ieee754_pow+0x540>
    607c:	vfma.f64	d1, d11, d8
    6080:	vmul.f64	d8, d11, d11
    6084:	vldr	d5, [pc, #640]	; 6308 <__ieee754_pow+0x548>
    6088:	vfma.f64	d7, d11, d1
    608c:	vfma.f64	d5, d11, d7
    6090:	vldr	d7, [pc, #636]	; 6310 <__ieee754_pow+0x550>
    6094:	vfma.f64	d7, d11, d5
    6098:	vmov.f64	d5, #8	; 0x40400000  3.0
    609c:	vfma.f64	d6, d8, d7
    60a0:	vmov.f64	d7, d5
    60a4:	vfma.f64	d7, d4, d4
    60a8:	vadd.f64	d7, d7, d6
    60ac:	vstr	d7, [sp, #16]
    60b0:	str	r2, [sp, #16]
    60b2:	vldr	d9, [sp, #16]
    60b6:	vsub.f64	d5, d9, d5
    60ba:	vfma.f64	d5, d10, d4
    60be:	vsub.f64	d5, d6, d5
    60c2:	vldr	d6, [sp]
    60c6:	vmul.f64	d6, d5, d6
    60ca:	vfma.f64	d6, d2, d9
    60ce:	vmov.f64	d5, d6
    60d2:	vfma.f64	d5, d4, d9
    60d6:	vstr	d5, [sp]
    60da:	str	r2, [sp, #0]
    60dc:	vldr	d4, [sp]
    60e0:	vldr	d2, [pc, #564]	; 6318 <__ieee754_pow+0x558>
    60e4:	vmov.f64	d5, d4
    60e8:	vfma.f64	d5, d10, d9
    60ec:	vldr	d7, [pc, #560]	; 6320 <__ieee754_pow+0x560>
    60f0:	vsub.f64	d6, d6, d5
    60f4:	vldr	d8, [pc, #560]	; 6328 <__ieee754_pow+0x568>
    60f8:	vmul.f64	d7, d6, d7
    60fc:	vmov	s3, r6
    6100:	vfma.f64	d7, d4, d8
    6104:	vcvt.f64.s32	d1, s3
    6108:	vadd.f64	d7, d7, d0
    610c:	vmov.f64	d6, d7
    6110:	vfma.f64	d6, d4, d2
    6114:	vadd.f64	d6, d6, d3
    6118:	vadd.f64	d6, d6, d1
    611c:	vstr	d6, [sp]
    6120:	str	r2, [sp, #0]
    6122:	vldr	d5, [sp]
    6126:	vsub.f64	d6, d5, d1
    612a:	vsub.f64	d6, d6, d3
    612e:	vfms.f64	d6, d4, d2
    6132:	vsub.f64	d6, d7, d6
    6136:	ldrd	r3, r4, [sp, #8]
    613a:	vmov.f64	d0, #240	; 0xbf800000 -1.0
    613e:	mov	r1, r4
    6140:	movs	r0, #0
    6142:	vmov	d7, r3, r4
    6146:	vmov	d4, r0, r1
    614a:	vmul.f64	d6, d6, d7
    614e:	vsub.f64	d7, d7, d4
    6152:	vfma.f64	d6, d5, d7
    6156:	vmul.f64	d5, d5, d4
    615a:	vadd.f64	d7, d6, d5
    615e:	vstr	d7, [sp]
    6162:	vmov.f64	d7, #112	; 0x3f800000  1.0
    6166:	ldr	r3, [pc, #536]	; (6380 <__ieee754_pow+0x5c0>)
    6168:	ldr	r2, [sp, #4]
    616a:	add.w	fp, fp, #4294967295
    616e:	orrs.w	r4, fp, r9
    6172:	ite	ne
    6174:	vmovne.f64	d8, d7
    6178:	vmoveq.f64	d8, d0
    617c:	cmp	r2, r3
    617e:	ldr	r4, [sp, #0]
    6180:	ble.w	6388 <__ieee754_pow+0x5c8>
    6184:	add.w	r3, r2, #3204448256	; 0xbf000000
    6188:	add.w	r3, r3, #7340032	; 0x700000
    618c:	orrs	r3, r4
    618e:	bne.w	6474 <__ieee754_pow+0x6b4>
    6192:	vadd.f64	d4, d6, d5
    6196:	vsub.f64	d4, d4, d5
    619a:	vldr	d7, [pc, #404]	; 6330 <__ieee754_pow+0x570>
    619e:	vadd.f64	d7, d6, d7
    61a2:	vcmpe.f64	d7, d4
    61a6:	vmrs	APSR_nzcv, fpscr
    61aa:	bgt.w	6474 <__ieee754_pow+0x6b4>
    61ae:	mov	r3, r2
    61b0:	asrs	r3, r3, #20
    61b2:	mov.w	r1, #1048576	; 0x100000
    61b6:	subw	r3, r3, #1022	; 0x3fe
    61ba:	asr.w	r3, r1, r3
    61be:	adds	r1, r3, r2
    61c0:	ubfx	r0, r1, #20, #11
    61c4:	ldr	r6, [pc, #444]	; (6384 <__ieee754_pow+0x5c4>)
    61c6:	subw	r0, r0, #1023	; 0x3ff
    61ca:	asrs	r6, r0
    61cc:	bic.w	r5, r1, r6
    61d0:	movs	r4, #0
    61d2:	ubfx	r3, r1, #0, #20
    61d6:	vmov	d7, r4, r5
    61da:	rsb	r0, r0, #20
    61de:	orr.w	r3, r3, #1048576	; 0x100000
    61e2:	asr.w	r0, r3, r0
    61e6:	cmp	r2, #0
    61e8:	vsub.f64	d5, d5, d7
    61ec:	vadd.f64	d7, d6, d5
    61f0:	vstr	d7, [sp]
    61f4:	it	lt
    61f6:	neglt	r0, r0
    61f8:	lsls	r1, r0, #20
    61fa:	ldrd	r2, r3, [sp]
    61fe:	vmov.f64	d2, #0	; 0x40000000  2.0
    6202:	vmov.f64	d7, #112	; 0x3f800000  1.0
    6206:	vldr	d1, [pc, #304]	; 6338 <__ieee754_pow+0x578>
    620a:	vldr	d0, [pc, #308]	; 6340 <__ieee754_pow+0x580>
    620e:	movs	r2, #0
    6210:	vldr	d4, [pc, #308]	; 6348 <__ieee754_pow+0x588>
    6214:	vmov	d3, r2, r3
    6218:	vldr	d9, [pc, #308]	; 6350 <__ieee754_pow+0x590>
    621c:	vmul.f64	d4, d3, d4
    6220:	vsub.f64	d5, d3, d5
    6224:	vsub.f64	d5, d6, d5
    6228:	vmov.f64	d6, d4
    622c:	vfma.f64	d6, d5, d0
    6230:	vldr	d5, [pc, #292]	; 6358 <__ieee754_pow+0x598>
    6234:	vmov.f64	d4, d6
    6238:	vfma.f64	d4, d3, d1
    623c:	vmov.f64	d0, d4
    6240:	vfms.f64	d0, d3, d1
    6244:	vsub.f64	d6, d6, d0
    6248:	vldr	d0, [pc, #276]	; 6360 <__ieee754_pow+0x5a0>
    624c:	vmul.f64	d3, d4, d4
    6250:	vfma.f64	d5, d3, d9
    6254:	vldr	d1, [pc, #272]	; 6368 <__ieee754_pow+0x5a8>
    6258:	vfma.f64	d0, d3, d5
    625c:	vfma.f64	d6, d4, d6
    6260:	vldr	d5, [pc, #268]	; 6370 <__ieee754_pow+0x5b0>
    6264:	vfma.f64	d1, d3, d0
    6268:	vfma.f64	d5, d3, d1
    626c:	vmov.f64	d1, d4
    6270:	vfms.f64	d1, d3, d5
    6274:	vmul.f64	d3, d4, d1
    6278:	vsub.f64	d2, d1, d2
    627c:	vdiv.f64	d5, d3, d2
    6280:	vsub.f64	d6, d5, d6
    6284:	vsub.f64	d6, d6, d4
    6288:	vsub.f64	d7, d7, d6
    628c:	vstr	d7, [sp]
    6290:	ldr	r3, [sp, #4]
    6292:	add	r1, r3
    6294:	cmp.w	r1, #1048576	; 0x100000
    6298:	blt.w	64d0 <__ieee754_pow+0x710>
    629c:	ldrd	r2, r3, [sp]
    62a0:	mov	r3, r1
    62a2:	vmov	d0, r2, r3
    62a6:	vmul.f64	d0, d0, d8
    62aa:	b.n	5e52 <__ieee754_pow+0x92>
    62ac:	add.w	r4, r4, #3221225472	; 0xc0000000
    62b0:	add.w	r4, r4, #1048576	; 0x100000
    62b4:	orrs.w	r3, r4, fp
    62b8:	beq.w	64b0 <__ieee754_pow+0x6f0>
    62bc:	cmp.w	fp, #1
    62c0:	bne.w	5ee0 <__ieee754_pow+0x120>
    62c4:	vldr	d7, [sp]
    62c8:	vneg.f64	d0, d7
    62cc:	b.n	5e52 <__ieee754_pow+0x92>
    62ce:	vmov	d7, r2, r3
    62d2:	vmul.f64	d0, d7, d7
    62d6:	b.n	5e52 <__ieee754_pow+0x92>
    62d8:	.word	0x00000000
    62dc:	.word	0x43400000
	...
    62e8:	.word	0x4a454eef
    62ec:	.word	0x3fca7e28
    62f0:	.word	0x93c9db65
    62f4:	.word	0x3fcd864a
    62f8:	.word	0xa91d4101
    62fc:	.word	0x3fd17460
    6300:	.word	0x518f264d
    6304:	.word	0x3fd55555
    6308:	.word	0xdb6fabff
    630c:	.word	0x3fdb6db6
    6310:	.word	0x33333303
    6314:	.word	0x3fe33333
    6318:	.word	0xe0000000
    631c:	.word	0x3feec709
    6320:	.word	0xdc3a03fd
    6324:	.word	0x3feec709
    6328:	.word	0x145b01f5
    632c:	.word	0xbe3e2fe0
    6330:	.word	0x652b82fe
    6334:	.word	0x3c971547
    6338:	.word	0x00000000
    633c:	.word	0x3fe62e43
    6340:	.word	0xfefa39ef
    6344:	.word	0x3fe62e42
    6348:	.word	0x0ca86c39
    634c:	.word	0xbe205c61
    6350:	.word	0x72bea4d0
    6354:	.word	0x3e663769
    6358:	.word	0xc5d26bf1
    635c:	.word	0xbebbbd41
    6360:	.word	0xaf25de2c
    6364:	.word	0x3f11566a
    6368:	.word	0x16bebd93
    636c:	.word	0xbf66c16c
    6370:	.word	0x5555553e
    6374:	.word	0x3fc55555
    6378:	.word	0x0003988e
    637c:	.word	0x000bb679
    6380:	.word	0x408fffff
    6384:	.word	0x000fffff
    6388:	ldr	r5, [pc, #420]	; (6530 <__ieee754_pow+0x770>)
    638a:	bic.w	r3, r2, #2147483648	; 0x80000000
    638e:	cmp	r3, r5
    6390:	ble.w	649c <__ieee754_pow+0x6dc>
    6394:	ldr	r1, [pc, #412]	; (6534 <__ieee754_pow+0x774>)
    6396:	add	r1, r2
    6398:	orrs	r1, r4
    639a:	bne.n	63b0 <__ieee754_pow+0x5f0>
    639c:	vadd.f64	d7, d6, d5
    63a0:	vsub.f64	d7, d7, d5
    63a4:	vcmpe.f64	d6, d7
    63a8:	vmrs	APSR_nzcv, fpscr
    63ac:	bhi.w	61b0 <__ieee754_pow+0x3f0>
    63b0:	vldr	d0, [pc, #308]	; 64e8 <__ieee754_pow+0x728>
    63b4:	vmul.f64	d7, d8, d0
    63b8:	vmul.f64	d0, d7, d0
    63bc:	b.n	5e52 <__ieee754_pow+0x92>
    63be:	cmp.w	r8, #0
    63c2:	bge.w	5f6e <__ieee754_pow+0x1ae>
    63c6:	vmov	d7, r0, r1
    63ca:	vneg.f64	d0, d7
    63ce:	b.n	5e52 <__ieee754_pow+0x92>
    63d0:	vldr	d5, [sp]
    63d4:	vmov.f64	d7, #112	; 0x3f800000  1.0
    63d8:	vdiv.f64	d6, d7, d5
    63dc:	vstr	d6, [sp]
    63e0:	b.n	5ed8 <__ieee754_pow+0x118>
    63e2:	ldr	r3, [pc, #340]	; (6538 <__ieee754_pow+0x778>)
    63e4:	cmp	r4, r3
    63e6:	ble.w	5f68 <__ieee754_pow+0x1a8>
    63ea:	ldr	r3, [pc, #336]	; (653c <__ieee754_pow+0x77c>)
    63ec:	cmp	r4, r3
    63ee:	bgt.w	5eb4 <__ieee754_pow+0xf4>
    63f2:	vmov.f64	d7, #112	; 0x3f800000  1.0
    63f6:	vmov.f64	d8, #80	; 0x3e800000  0.250
    63fa:	vldr	d5, [sp]
    63fe:	vldr	d2, [pc, #240]	; 64f0 <__ieee754_pow+0x730>
    6402:	vsub.f64	d7, d5, d7
    6406:	vmov.f64	d5, #96	; 0x3f000000  0.5
    640a:	vldr	d3, [pc, #236]	; 64f8 <__ieee754_pow+0x738>
    640e:	vneg.f64	d4, d7
    6412:	vmul.f64	d0, d7, d7
    6416:	vldr	d6, [pc, #232]	; 6500 <__ieee754_pow+0x740>
    641a:	vfma.f64	d3, d4, d8
    641e:	vfma.f64	d5, d4, d3
    6422:	vldr	d1, [pc, #228]	; 6508 <__ieee754_pow+0x748>
    6426:	vmul.f64	d5, d5, d0
    642a:	vnmul.f64	d6, d6, d5
    642e:	vfma.f64	d6, d7, d1
    6432:	vmov.f64	d5, d6
    6436:	vfma.f64	d5, d7, d2
    643a:	vmov	r2, r3, d5
    643e:	movs	r2, #0
    6440:	vmov	d5, r2, r3
    6444:	vmov.f64	d7, d5
    6448:	vfma.f64	d7, d4, d2
    644c:	vsub.f64	d6, d6, d7
    6450:	b.n	6136 <__ieee754_pow+0x376>
    6452:	vldr	d3, [pc, #188]	; 6510 <__ieee754_pow+0x750>
    6456:	vmov.f64	d7, #112	; 0x3f800000  1.0
    645a:	vmov.f64	d0, d3
    645e:	movs	r5, #0
    6460:	b.n	5ffa <__ieee754_pow+0x23a>
    6462:	movs	r6, #0
    6464:	b.n	5fc2 <__ieee754_pow+0x202>
    6466:	vmov	d6, r2, r3
    646a:	vmov.f64	d7, #112	; 0x3f800000  1.0
    646e:	vdiv.f64	d0, d7, d6
    6472:	b.n	5e52 <__ieee754_pow+0x92>
    6474:	vldr	d0, [pc, #160]	; 6518 <__ieee754_pow+0x758>
    6478:	vmul.f64	d7, d8, d0
    647c:	vmul.f64	d0, d7, d0
    6480:	b.n	5e52 <__ieee754_pow+0x92>
    6482:	cmp	r6, #0
    6484:	bne.w	5e70 <__ieee754_pow+0xb0>
    6488:	rsb	r7, r7, #20
    648c:	asr.w	lr, r5, r7
    6490:	lsl.w	r7, lr, r7
    6494:	cmp	r5, r7
    6496:	beq.n	64da <__ieee754_pow+0x71a>
    6498:	mov	fp, r6
    649a:	b.n	5e12 <__ieee754_pow+0x52>
    649c:	ldr	r4, [pc, #160]	; (6540 <__ieee754_pow+0x780>)
    649e:	cmp	r3, r4
    64a0:	bgt.w	61b0 <__ieee754_pow+0x3f0>
    64a4:	vadd.f64	d7, d6, d5
    64a8:	mov	r1, r0
    64aa:	vstr	d7, [sp]
    64ae:	b.n	61fa <__ieee754_pow+0x43a>
    64b0:	vldr	d7, [sp]
    64b4:	vsub.f64	d7, d7, d7
    64b8:	vdiv.f64	d0, d7, d7
    64bc:	b.n	5e52 <__ieee754_pow+0x92>
    64be:	vldr	d3, [pc, #96]	; 6520 <__ieee754_pow+0x760>
    64c2:	vmov.f64	d7, #120	; 0x3fc00000  1.5
    64c6:	vldr	d0, [pc, #96]	; 6528 <__ieee754_pow+0x768>
    64ca:	mov.w	r5, #262144	; 0x40000
    64ce:	b.n	5ffa <__ieee754_pow+0x23a>
    64d0:	vmov.f64	d0, d7
    64d4:	bl	82a0 <scalbn>
    64d8:	b.n	62a6 <__ieee754_pow+0x4e6>
    64da:	and.w	lr, lr, #1
    64de:	rsb	fp, lr, #2
    64e2:	b.n	5e12 <__ieee754_pow+0x52>
    64e4:	nop.w
    64e8:	.word	0xc2f8f359
    64ec:	.word	0x01a56e1f
    64f0:	.word	0x60000000
    64f4:	.word	0x3ff71547
    64f8:	.word	0x55555555
    64fc:	.word	0x3fd55555
    6500:	.word	0x652b82fe
    6504:	.word	0x3ff71547
    6508:	.word	0xf85ddf44
    650c:	.word	0x3e54ae0b
	...
    6518:	.word	0x8800759c
    651c:	.word	0x7e37e43c
    6520:	.word	0x40000000
    6524:	.word	0x3fe2b803
    6528:	.word	0x43cfd006
    652c:	.word	0x3e4cfdeb
    6530:	.word	0x4090cbff
    6534:	.word	0x3f6f3400
    6538:	.word	0x3feffffe
    653c:	.word	0x3ff00000
    6540:	.word	0x3fe00000
    6544:	.word	0x00000000

00006548 <__ieee754_rem_pio2>:
    6548:	push	{r4, r5, r6, lr}
    654a:	vmov	r2, r3, d0
    654e:	ldr	r1, [pc, #632]	; (67c8 <__ieee754_rem_pio2+0x280>)
    6550:	bic.w	r6, r3, #2147483648	; 0x80000000
    6554:	cmp	r6, r1
    6556:	sub	sp, #32
    6558:	ble.n	6620 <__ieee754_rem_pio2+0xd8>
    655a:	ldr	r1, [pc, #624]	; (67cc <__ieee754_rem_pio2+0x284>)
    655c:	cmp	r6, r1
    655e:	mov	r5, r3
    6560:	bgt.n	659c <__ieee754_rem_pio2+0x54>
    6562:	cmp	r3, #0
    6564:	vldr	d7, [pc, #544]	; 6788 <__ieee754_rem_pio2+0x240>
    6568:	ble.w	672a <__ieee754_rem_pio2+0x1e2>
    656c:	vsub.f64	d7, d0, d7
    6570:	sub.w	r1, r1, #634880	; 0x9b000
    6574:	sub.w	r1, r1, #1920	; 0x780
    6578:	cmp	r6, r1
    657a:	beq.n	6644 <__ieee754_rem_pio2+0xfc>
    657c:	vldr	d6, [pc, #528]	; 6790 <__ieee754_rem_pio2+0x248>
    6580:	vsub.f64	d5, d7, d6
    6584:	vsub.f64	d7, d7, d5
    6588:	movs	r3, #1
    658a:	vstr	d5, [r0]
    658e:	vsub.f64	d7, d7, d6
    6592:	vstr	d7, [r0, #8]
    6596:	mov	r0, r3
    6598:	add	sp, #32
    659a:	pop	{r4, r5, r6, pc}
    659c:	ldr	r1, [pc, #560]	; (67d0 <__ieee754_rem_pio2+0x288>)
    659e:	cmp	r6, r1
    65a0:	mov	r4, r0
    65a2:	ble.n	6652 <__ieee754_rem_pio2+0x10a>
    65a4:	ldr	r1, [pc, #556]	; (67d4 <__ieee754_rem_pio2+0x28c>)
    65a6:	cmp	r6, r1
    65a8:	bgt.n	6634 <__ieee754_rem_pio2+0xec>
    65aa:	mov	r0, r2
    65ac:	asrs	r2, r6, #20
    65ae:	subw	r2, r2, #1046	; 0x416
    65b2:	sub.w	r1, r6, r2, lsl #20
    65b6:	vmov	d6, r0, r1
    65ba:	vldr	d7, [pc, #476]	; 6798 <__ieee754_rem_pio2+0x250>
    65be:	vcvt.s32.f64	s8, d6
    65c2:	movs	r3, #0
    65c4:	vcvt.f64.s32	d4, s8
    65c8:	vsub.f64	d6, d6, d4
    65cc:	vmul.f64	d6, d6, d7
    65d0:	vcvt.s32.f64	s10, d6
    65d4:	vstr	d4, [sp, #8]
    65d8:	vcvt.f64.s32	d5, s10
    65dc:	vsub.f64	d6, d6, d5
    65e0:	vmul.f64	d7, d6, d7
    65e4:	vcmp.f64	d7, #0.0
    65e8:	vmrs	APSR_nzcv, fpscr
    65ec:	vstr	d5, [sp, #16]
    65f0:	vstr	d7, [sp, #24]
    65f4:	bne.w	676e <__ieee754_rem_pio2+0x226>
    65f8:	vcmp.f64	d5, #0.0
    65fc:	vmrs	APSR_nzcv, fpscr
    6600:	ite	eq
    6602:	moveq	r3, #1
    6604:	movne	r3, #2
    6606:	ldr	r1, [pc, #464]	; (67d8 <__ieee754_rem_pio2+0x290>)
    6608:	str	r1, [sp, #4]
    660a:	movs	r1, #2
    660c:	str	r1, [sp, #0]
    660e:	add	r0, sp, #8
    6610:	mov	r1, r4
    6612:	bl	6f30 <__kernel_rem_pio2>
    6616:	cmp	r5, #0
    6618:	blt.w	6752 <__ieee754_rem_pio2+0x20a>
    661c:	mov	r3, r0
    661e:	b.n	662e <__ieee754_rem_pio2+0xe6>
    6620:	movs	r4, #0
    6622:	movs	r5, #0
    6624:	vstr	d0, [r0]
    6628:	strd	r4, r5, [r0, #8]
    662c:	movs	r3, #0
    662e:	mov	r0, r3
    6630:	add	sp, #32
    6632:	pop	{r4, r5, r6, pc}
    6634:	vsub.f64	d7, d0, d0
    6638:	movs	r3, #0
    663a:	vstr	d7, [r0, #8]
    663e:	vstr	d7, [r0]
    6642:	b.n	662e <__ieee754_rem_pio2+0xe6>
    6644:	vldr	d5, [pc, #344]	; 67a0 <__ieee754_rem_pio2+0x258>
    6648:	vldr	d6, [pc, #348]	; 67a8 <__ieee754_rem_pio2+0x260>
    664c:	vsub.f64	d7, d7, d5
    6650:	b.n	6580 <__ieee754_rem_pio2+0x38>
    6652:	bl	802c <fabs>
    6656:	vmov.f64	d7, #96	; 0x3f000000  0.5
    665a:	vldr	d6, [pc, #340]	; 67b0 <__ieee754_rem_pio2+0x268>
    665e:	vfma.f64	d7, d0, d6
    6662:	vcvt.s32.f64	s15, d7
    6666:	vldr	d3, [pc, #288]	; 6788 <__ieee754_rem_pio2+0x240>
    666a:	vmov	r3, s15
    666e:	vldr	d6, [pc, #288]	; 6790 <__ieee754_rem_pio2+0x248>
    6672:	cmp	r3, #31
    6674:	vcvt.f64.s32	d5, s15
    6678:	vneg.f64	d4, d5
    667c:	vmul.f64	d7, d5, d6
    6680:	vfma.f64	d0, d4, d3
    6684:	bgt.n	66be <__ieee754_rem_pio2+0x176>
    6686:	ldr	r2, [pc, #340]	; (67dc <__ieee754_rem_pio2+0x294>)
    6688:	subs	r1, r3, #1
    668a:	ldr.w	r2, [r2, r1, lsl #2]
    668e:	cmp	r6, r2
    6690:	beq.n	66be <__ieee754_rem_pio2+0x176>
    6692:	vsub.f64	d6, d0, d7
    6696:	vstr	d6, [r4]
    669a:	vsub.f64	d0, d0, d6
    669e:	vsub.f64	d0, d0, d7
    66a2:	cmp	r5, #0
    66a4:	vstr	d0, [r4, #8]
    66a8:	bge.n	662e <__ieee754_rem_pio2+0xe6>
    66aa:	vneg.f64	d6, d6
    66ae:	vneg.f64	d0, d0
    66b2:	vstr	d6, [r4]
    66b6:	vstr	d0, [r4, #8]
    66ba:	negs	r3, r3
    66bc:	b.n	662e <__ieee754_rem_pio2+0xe6>
    66be:	vsub.f64	d6, d0, d7
    66c2:	vmov	r2, s13
    66c6:	asrs	r6, r6, #20
    66c8:	ubfx	r2, r2, #20, #11
    66cc:	subs	r2, r6, r2
    66ce:	cmp	r2, #16
    66d0:	vstr	d6, [r4]
    66d4:	ble.n	669a <__ieee754_rem_pio2+0x152>
    66d6:	vmov.f64	d3, d0
    66da:	vldr	d7, [pc, #196]	; 67a0 <__ieee754_rem_pio2+0x258>
    66de:	vldr	d6, [pc, #200]	; 67a8 <__ieee754_rem_pio2+0x260>
    66e2:	vfma.f64	d3, d4, d7
    66e6:	vsub.f64	d0, d0, d3
    66ea:	vfma.f64	d0, d4, d7
    66ee:	vmov.f64	d7, d0
    66f2:	vfnms.f64	d7, d5, d6
    66f6:	vsub.f64	d6, d3, d7
    66fa:	vmov	r2, s13
    66fe:	ubfx	r2, r2, #20, #11
    6702:	subs	r6, r6, r2
    6704:	cmp	r6, #49	; 0x31
    6706:	vstr	d6, [r4]
    670a:	ble.n	6780 <__ieee754_rem_pio2+0x238>
    670c:	vmov.f64	d0, d3
    6710:	vldr	d6, [pc, #164]	; 67b8 <__ieee754_rem_pio2+0x270>
    6714:	vldr	d2, [pc, #168]	; 67c0 <__ieee754_rem_pio2+0x278>
    6718:	vfma.f64	d0, d4, d6
    671c:	vsub.f64	d7, d3, d0
    6720:	vfma.f64	d7, d4, d6
    6724:	vfnms.f64	d7, d5, d2
    6728:	b.n	6692 <__ieee754_rem_pio2+0x14a>
    672a:	ldr	r1, [pc, #180]	; (67e0 <__ieee754_rem_pio2+0x298>)
    672c:	vadd.f64	d7, d0, d7
    6730:	cmp	r6, r1
    6732:	beq.n	6772 <__ieee754_rem_pio2+0x22a>
    6734:	vldr	d6, [pc, #88]	; 6790 <__ieee754_rem_pio2+0x248>
    6738:	vadd.f64	d5, d7, d6
    673c:	vsub.f64	d7, d7, d5
    6740:	mov.w	r3, #4294967295
    6744:	vadd.f64	d7, d7, d6
    6748:	vstr	d5, [r0]
    674c:	vstr	d7, [r0, #8]
    6750:	b.n	662e <__ieee754_rem_pio2+0xe6>
    6752:	vldr	d6, [r4]
    6756:	vldr	d7, [r4, #8]
    675a:	vneg.f64	d6, d6
    675e:	vneg.f64	d7, d7
    6762:	negs	r3, r0
    6764:	vstr	d6, [r4]
    6768:	vstr	d7, [r4, #8]
    676c:	b.n	662e <__ieee754_rem_pio2+0xe6>
    676e:	movs	r3, #3
    6770:	b.n	6606 <__ieee754_rem_pio2+0xbe>
    6772:	vldr	d5, [pc, #44]	; 67a0 <__ieee754_rem_pio2+0x258>
    6776:	vldr	d6, [pc, #48]	; 67a8 <__ieee754_rem_pio2+0x260>
    677a:	vadd.f64	d7, d7, d5
    677e:	b.n	6738 <__ieee754_rem_pio2+0x1f0>
    6780:	vmov.f64	d0, d3
    6784:	b.n	669a <__ieee754_rem_pio2+0x152>
    6786:	nop
    6788:	.word	0x54400000
    678c:	.word	0x3ff921fb
    6790:	.word	0x1a626331
    6794:	.word	0x3dd0b461
    6798:	.word	0x00000000
    679c:	.word	0x41700000
    67a0:	.word	0x1a600000
    67a4:	.word	0x3dd0b461
    67a8:	.word	0x2e037073
    67ac:	.word	0x3ba3198a
    67b0:	.word	0x6dc9c883
    67b4:	.word	0x3fe45f30
    67b8:	.word	0x2e000000
    67bc:	.word	0x3ba3198a
    67c0:	.word	0x252049c1
    67c4:	.word	0x397b839a
    67c8:	.word	0x3fe921fb
    67cc:	.word	0x4002d97b
    67d0:	.word	0x413921fb
    67d4:	.word	0x7fefffff
    67d8:	.word	0x200009d4
    67dc:	.word	0x20000954
    67e0:	.word	0x3ff921fb

000067e4 <__ieee754_sqrt>:
    67e4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    67e8:	sub	sp, #8
    67ea:	vstr	d0, [sp]
    67ee:	ldr	r1, [pc, #372]	; (6964 <__ieee754_sqrt+0x180>)
    67f0:	ldr	r3, [sp, #4]
    67f2:	ldr	r0, [sp, #0]
    67f4:	mov	r4, r1
    67f6:	ands	r1, r3
    67f8:	cmp	r1, r4
    67fa:	beq.w	692e <__ieee754_sqrt+0x14a>
    67fe:	cmp	r3, #0
    6800:	mov	r2, r0
    6802:	ble.n	68f4 <__ieee754_sqrt+0x110>
    6804:	asrs	r7, r3, #20
    6806:	beq.w	690e <__ieee754_sqrt+0x12a>
    680a:	subw	r7, r7, #1023	; 0x3ff
    680e:	ubfx	r3, r3, #0, #20
    6812:	lsls	r1, r7, #31
    6814:	orr.w	r3, r3, #1048576	; 0x100000
    6818:	bmi.n	68ea <__ieee754_sqrt+0x106>
    681a:	add.w	r1, r3, r2, lsr #31
    681e:	movs	r6, #0
    6820:	add	r3, r1
    6822:	asrs	r7, r7, #1
    6824:	lsls	r2, r2, #1
    6826:	mov	lr, r6
    6828:	movs	r0, #22
    682a:	mov.w	r1, #2097152	; 0x200000
    682e:	add.w	r4, lr, r1
    6832:	cmp	r4, r3
    6834:	mov.w	r5, r2, lsr #31
    6838:	mov.w	r2, r2, lsl #1
    683c:	bgt.n	6846 <__ieee754_sqrt+0x62>
    683e:	subs	r3, r3, r4
    6840:	add.w	lr, r4, r1
    6844:	add	r6, r1
    6846:	subs	r0, #1
    6848:	add.w	r3, r5, r3, lsl #1
    684c:	mov.w	r1, r1, lsr #1
    6850:	bne.n	682e <__ieee754_sqrt+0x4a>
    6852:	mov	ip, r0
    6854:	movs	r4, #32
    6856:	mov.w	r1, #2147483648	; 0x80000000
    685a:	b.n	6870 <__ieee754_sqrt+0x8c>
    685c:	beq.n	68a0 <__ieee754_sqrt+0xbc>
    685e:	add.w	r5, r3, r2, lsr #31
    6862:	subs	r4, #1
    6864:	mov.w	r1, r1, lsr #1
    6868:	add	r3, r5
    686a:	mov.w	r2, r2, lsl #1
    686e:	beq.n	68b2 <__ieee754_sqrt+0xce>
    6870:	cmp	lr, r3
    6872:	add.w	r5, r1, ip
    6876:	bge.n	685c <__ieee754_sqrt+0x78>
    6878:	cmp	r5, #0
    687a:	add.w	ip, r5, r1
    687e:	blt.n	6894 <__ieee754_sqrt+0xb0>
    6880:	mov	r8, lr
    6882:	cmp	r5, r2
    6884:	rsb	r3, lr, r3
    6888:	bls.n	688c <__ieee754_sqrt+0xa8>
    688a:	subs	r3, #1
    688c:	subs	r2, r2, r5
    688e:	add	r0, r1
    6890:	mov	lr, r8
    6892:	b.n	685e <__ieee754_sqrt+0x7a>
    6894:	cmp.w	ip, #0
    6898:	blt.n	6880 <__ieee754_sqrt+0x9c>
    689a:	add.w	r8, lr, #1
    689e:	b.n	6882 <__ieee754_sqrt+0x9e>
    68a0:	cmp	r5, r2
    68a2:	bhi.n	68da <__ieee754_sqrt+0xf6>
    68a4:	cmp	r5, #0
    68a6:	add.w	ip, r5, r1
    68aa:	blt.n	693e <__ieee754_sqrt+0x15a>
    68ac:	mov	r8, r3
    68ae:	movs	r3, #0
    68b0:	b.n	688c <__ieee754_sqrt+0xa8>
    68b2:	orrs	r3, r2
    68b4:	bne.n	68de <__ieee754_sqrt+0xfa>
    68b6:	lsrs	r0, r0, #1
    68b8:	asrs	r1, r6, #1
    68ba:	lsls	r3, r6, #31
    68bc:	add.w	r1, r1, #1069547520	; 0x3fc00000
    68c0:	add.w	r1, r1, #2097152	; 0x200000
    68c4:	it	mi
    68c6:	orrmi.w	r0, r0, #2147483648	; 0x80000000
    68ca:	add.w	r3, r1, r7, lsl #20
    68ce:	mov	r2, r0
    68d0:	vmov	d0, r2, r3
    68d4:	add	sp, #8
    68d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    68da:	mov	r3, lr
    68dc:	b.n	685e <__ieee754_sqrt+0x7a>
    68de:	adds	r2, r0, #1
    68e0:	beq.n	6946 <__ieee754_sqrt+0x162>
    68e2:	and.w	r3, r0, #1
    68e6:	add	r0, r3
    68e8:	b.n	68b6 <__ieee754_sqrt+0xd2>
    68ea:	lsls	r3, r3, #1
    68ec:	add.w	r3, r3, r2, lsr #31
    68f0:	lsls	r2, r2, #1
    68f2:	b.n	681a <__ieee754_sqrt+0x36>
    68f4:	bic.w	r1, r3, #2147483648	; 0x80000000
    68f8:	orrs	r1, r0
    68fa:	beq.n	6938 <__ieee754_sqrt+0x154>
    68fc:	cbnz	r3, 6956 <__ieee754_sqrt+0x172>
    68fe:	mov	r7, r3
    6900:	lsrs	r3, r2, #11
    6902:	subs	r7, #21
    6904:	lsls	r2, r2, #21
    6906:	cmp	r3, #0
    6908:	beq.n	6900 <__ieee754_sqrt+0x11c>
    690a:	lsls	r5, r3, #11
    690c:	bmi.n	694c <__ieee754_sqrt+0x168>
    690e:	movs	r1, #0
    6910:	b.n	6914 <__ieee754_sqrt+0x130>
    6912:	mov	r1, r0
    6914:	lsls	r3, r3, #1
    6916:	lsls	r4, r3, #11
    6918:	add.w	r0, r1, #1
    691c:	bpl.n	6912 <__ieee754_sqrt+0x12e>
    691e:	rsb	r4, r0, #32
    6922:	lsr.w	r4, r2, r4
    6926:	orrs	r3, r4
    6928:	subs	r7, r7, r1
    692a:	lsls	r2, r0
    692c:	b.n	680a <__ieee754_sqrt+0x26>
    692e:	vfma.f64	d0, d0, d0
    6932:	add	sp, #8
    6934:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6938:	vldr	d0, [sp]
    693c:	b.n	68d4 <__ieee754_sqrt+0xf0>
    693e:	cmp.w	ip, #0
    6942:	bge.n	689a <__ieee754_sqrt+0xb6>
    6944:	b.n	68ac <__ieee754_sqrt+0xc8>
    6946:	adds	r6, #1
    6948:	mov	r0, r4
    694a:	b.n	68b8 <__ieee754_sqrt+0xd4>
    694c:	movs	r4, #32
    694e:	mov.w	r1, #4294967295
    6952:	movs	r0, #0
    6954:	b.n	6922 <__ieee754_sqrt+0x13e>
    6956:	vldr	d7, [sp]
    695a:	vsub.f64	d7, d7, d7
    695e:	vdiv.f64	d0, d7, d7
    6962:	b.n	68d4 <__ieee754_sqrt+0xf0>
    6964:	.word	0x7ff00000

00006968 <__ieee754_atan2f>:
    6968:	push	{r4, lr}
    696a:	sub	sp, #8
    696c:	vstr	s1, [sp, #4]
    6970:	ldr	r3, [sp, #4]
    6972:	bic.w	r2, r3, #2147483648	; 0x80000000
    6976:	cmp.w	r2, #2139095040	; 0x7f800000
    697a:	vmov.f32	s15, s0
    697e:	bgt.n	69b4 <__ieee754_atan2f+0x4c>
    6980:	vmov	r0, s0
    6984:	bic.w	r1, r0, #2147483648	; 0x80000000
    6988:	cmp.w	r1, #2139095040	; 0x7f800000
    698c:	bgt.n	69b4 <__ieee754_atan2f+0x4c>
    698e:	cmp.w	r3, #1065353216	; 0x3f800000
    6992:	beq.n	6a28 <__ieee754_atan2f+0xc0>
    6994:	asrs	r4, r3, #30
    6996:	and.w	r4, r4, #2
    699a:	orr.w	r4, r4, r0, lsr #31
    699e:	cbnz	r1, 69c0 <__ieee754_atan2f+0x58>
    69a0:	cmp	r4, #2
    69a2:	beq.n	6a22 <__ieee754_atan2f+0xba>
    69a4:	vldr	s0, [pc, #256]	; 6aa8 <__ieee754_atan2f+0x140>
    69a8:	cmp	r4, #3
    69aa:	it	ne
    69ac:	vmovne.f32	s0, s15
    69b0:	add	sp, #8
    69b2:	pop	{r4, pc}
    69b4:	vldr	s14, [sp, #4]
    69b8:	vadd.f32	s0, s14, s15
    69bc:	add	sp, #8
    69be:	pop	{r4, pc}
    69c0:	cbz	r2, 6a08 <__ieee754_atan2f+0xa0>
    69c2:	cmp.w	r2, #2139095040	; 0x7f800000
    69c6:	beq.n	6a32 <__ieee754_atan2f+0xca>
    69c8:	cmp.w	r1, #2139095040	; 0x7f800000
    69cc:	beq.n	6a08 <__ieee754_atan2f+0xa0>
    69ce:	subs	r2, r1, r2
    69d0:	asrs	r2, r2, #23
    69d2:	cmp	r2, #60	; 0x3c
    69d4:	bgt.n	6a1c <__ieee754_atan2f+0xb4>
    69d6:	cmp	r3, #0
    69d8:	blt.n	6a72 <__ieee754_atan2f+0x10a>
    69da:	vldr	s0, [sp, #4]
    69de:	vdiv.f32	s0, s15, s0
    69e2:	bl	8574 <fabsf>
    69e6:	bl	83bc <atanf>
    69ea:	cmp	r4, #1
    69ec:	beq.n	6a64 <__ieee754_atan2f+0xfc>
    69ee:	cmp	r4, #2
    69f0:	beq.n	6a52 <__ieee754_atan2f+0xea>
    69f2:	cmp	r4, #0
    69f4:	beq.n	69bc <__ieee754_atan2f+0x54>
    69f6:	vldr	s14, [pc, #180]	; 6aac <__ieee754_atan2f+0x144>
    69fa:	vldr	s15, [pc, #180]	; 6ab0 <__ieee754_atan2f+0x148>
    69fe:	vadd.f32	s0, s0, s14
    6a02:	vsub.f32	s0, s0, s15
    6a06:	b.n	69bc <__ieee754_atan2f+0x54>
    6a08:	vldr	s15, [pc, #168]	; 6ab4 <__ieee754_atan2f+0x14c>
    6a0c:	vldr	s0, [pc, #168]	; 6ab8 <__ieee754_atan2f+0x150>
    6a10:	cmp	r0, #0
    6a12:	it	ge
    6a14:	vmovge.f32	s0, s15
    6a18:	add	sp, #8
    6a1a:	pop	{r4, pc}
    6a1c:	vldr	s0, [pc, #148]	; 6ab4 <__ieee754_atan2f+0x14c>
    6a20:	b.n	69ea <__ieee754_atan2f+0x82>
    6a22:	vldr	s0, [pc, #140]	; 6ab0 <__ieee754_atan2f+0x148>
    6a26:	b.n	69bc <__ieee754_atan2f+0x54>
    6a28:	add	sp, #8
    6a2a:	ldmia.w	sp!, {r4, lr}
    6a2e:	b.w	83bc <atanf>
    6a32:	cmp.w	r1, #2139095040	; 0x7f800000
    6a36:	beq.n	6a7c <__ieee754_atan2f+0x114>
    6a38:	cmp	r4, #2
    6a3a:	beq.n	6a22 <__ieee754_atan2f+0xba>
    6a3c:	cmp	r4, #3
    6a3e:	beq.n	6a96 <__ieee754_atan2f+0x12e>
    6a40:	vldr	s15, [pc, #120]	; 6abc <__ieee754_atan2f+0x154>
    6a44:	vldr	s0, [pc, #120]	; 6ac0 <__ieee754_atan2f+0x158>
    6a48:	cmp	r4, #1
    6a4a:	it	eq
    6a4c:	vmoveq.f32	s0, s15
    6a50:	b.n	69bc <__ieee754_atan2f+0x54>
    6a52:	vldr	s14, [pc, #88]	; 6aac <__ieee754_atan2f+0x144>
    6a56:	vldr	s15, [pc, #88]	; 6ab0 <__ieee754_atan2f+0x148>
    6a5a:	vadd.f32	s0, s0, s14
    6a5e:	vsub.f32	s0, s15, s0
    6a62:	b.n	69bc <__ieee754_atan2f+0x54>
    6a64:	vmov	r3, s0
    6a68:	add.w	r3, r3, #2147483648	; 0x80000000
    6a6c:	vmov	s0, r3
    6a70:	b.n	69bc <__ieee754_atan2f+0x54>
    6a72:	adds	r2, #60	; 0x3c
    6a74:	bge.n	69da <__ieee754_atan2f+0x72>
    6a76:	vldr	s0, [pc, #72]	; 6ac0 <__ieee754_atan2f+0x158>
    6a7a:	b.n	69ea <__ieee754_atan2f+0x82>
    6a7c:	cmp	r4, #2
    6a7e:	beq.n	6aa2 <__ieee754_atan2f+0x13a>
    6a80:	cmp	r4, #3
    6a82:	beq.n	6a9c <__ieee754_atan2f+0x134>
    6a84:	vldr	s15, [pc, #60]	; 6ac4 <__ieee754_atan2f+0x15c>
    6a88:	vldr	s0, [pc, #60]	; 6ac8 <__ieee754_atan2f+0x160>
    6a8c:	cmp	r4, #1
    6a8e:	it	eq
    6a90:	vmoveq.f32	s0, s15
    6a94:	b.n	69bc <__ieee754_atan2f+0x54>
    6a96:	vldr	s0, [pc, #16]	; 6aa8 <__ieee754_atan2f+0x140>
    6a9a:	b.n	69bc <__ieee754_atan2f+0x54>
    6a9c:	vldr	s0, [pc, #44]	; 6acc <__ieee754_atan2f+0x164>
    6aa0:	b.n	69bc <__ieee754_atan2f+0x54>
    6aa2:	vldr	s0, [pc, #44]	; 6ad0 <__ieee754_atan2f+0x168>
    6aa6:	b.n	69bc <__ieee754_atan2f+0x54>
    6aa8:	.word	0xc0490fdb
    6aac:	.word	0x33bbbd2e
    6ab0:	.word	0x40490fdb
    6ab4:	.word	0x3fc90fdb
    6ab8:	.word	0xbfc90fdb
    6abc:	.word	0x80000000
    6ac0:	.word	0x00000000
    6ac4:	.word	0xbf490fdb
    6ac8:	.word	0x3f490fdb
    6acc:	.word	0xc016cbe4
    6ad0:	.word	0x4016cbe4

00006ad4 <__ieee754_rem_pio2f>:
    6ad4:	push	{r4, r5, r6, lr}
    6ad6:	vmov	r3, s0
    6ada:	ldr	r2, [pc, #600]	; (6d34 <__ieee754_rem_pio2f+0x260>)
    6adc:	bic.w	r4, r3, #2147483648	; 0x80000000
    6ae0:	cmp	r4, r2
    6ae2:	sub	sp, #24
    6ae4:	ble.n	6ba6 <__ieee754_rem_pio2f+0xd2>
    6ae6:	ldr	r2, [pc, #592]	; (6d38 <__ieee754_rem_pio2f+0x264>)
    6ae8:	cmp	r4, r2
    6aea:	vmov	r6, s0
    6aee:	bgt.n	6b28 <__ieee754_rem_pio2f+0x54>
    6af0:	cmp	r3, #0
    6af2:	vldr	s15, [pc, #584]	; 6d3c <__ieee754_rem_pio2f+0x268>
    6af6:	ldr	r2, [pc, #584]	; (6d40 <__ieee754_rem_pio2f+0x26c>)
    6af8:	bic.w	r4, r4, #15
    6afc:	ble.w	6caa <__ieee754_rem_pio2f+0x1d6>
    6b00:	cmp	r4, r2
    6b02:	vsub.f32	s15, s0, s15
    6b06:	beq.n	6bc6 <__ieee754_rem_pio2f+0xf2>
    6b08:	vldr	s14, [pc, #568]	; 6d44 <__ieee754_rem_pio2f+0x270>
    6b0c:	vsub.f32	s13, s15, s14
    6b10:	movs	r3, #1
    6b12:	vsub.f32	s15, s15, s13
    6b16:	vstr	s13, [r0]
    6b1a:	vsub.f32	s15, s15, s14
    6b1e:	vstr	s15, [r0, #4]
    6b22:	mov	r0, r3
    6b24:	add	sp, #24
    6b26:	pop	{r4, r5, r6, pc}
    6b28:	ldr	r2, [pc, #540]	; (6d48 <__ieee754_rem_pio2f+0x274>)
    6b2a:	cmp	r4, r2
    6b2c:	mov	r5, r0
    6b2e:	ble.n	6bea <__ieee754_rem_pio2f+0x116>
    6b30:	cmp.w	r4, #2139095040	; 0x7f800000
    6b34:	bge.n	6bb6 <__ieee754_rem_pio2f+0xe2>
    6b36:	asrs	r2, r4, #23
    6b38:	subs	r2, #134	; 0x86
    6b3a:	sub.w	r3, r4, r2, lsl #23
    6b3e:	vmov	s14, r3
    6b42:	vcvt.s32.f32	s13, s14
    6b46:	vldr	s15, [pc, #516]	; 6d4c <__ieee754_rem_pio2f+0x278>
    6b4a:	vcvt.f32.s32	s13, s13
    6b4e:	vsub.f32	s14, s14, s13
    6b52:	vstr	s13, [sp, #12]
    6b56:	vmul.f32	s14, s14, s15
    6b5a:	vcvt.s32.f32	s13, s14
    6b5e:	vcvt.f32.s32	s13, s13
    6b62:	vsub.f32	s14, s14, s13
    6b66:	vstr	s13, [sp, #16]
    6b6a:	vmul.f32	s15, s14, s15
    6b6e:	vcmp.f32	s15, #0.0
    6b72:	vmrs	APSR_nzcv, fpscr
    6b76:	vstr	s15, [sp, #20]
    6b7a:	bne.w	6cec <__ieee754_rem_pio2f+0x218>
    6b7e:	vcmp.f32	s13, #0.0
    6b82:	vmrs	APSR_nzcv, fpscr
    6b86:	ite	eq
    6b88:	moveq	r3, #1
    6b8a:	movne	r3, #2
    6b8c:	ldr	r1, [pc, #448]	; (6d50 <__ieee754_rem_pio2f+0x27c>)
    6b8e:	str	r1, [sp, #4]
    6b90:	movs	r1, #2
    6b92:	str	r1, [sp, #0]
    6b94:	add	r0, sp, #12
    6b96:	mov	r1, r5
    6b98:	bl	7764 <__kernel_rem_pio2f>
    6b9c:	cmp	r6, #0
    6b9e:	blt.w	6cd0 <__ieee754_rem_pio2f+0x1fc>
    6ba2:	mov	r3, r0
    6ba4:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6ba6:	movs	r2, #0
    6ba8:	vstr	s0, [r0]
    6bac:	str	r2, [r0, #4]
    6bae:	movs	r3, #0
    6bb0:	mov	r0, r3
    6bb2:	add	sp, #24
    6bb4:	pop	{r4, r5, r6, pc}
    6bb6:	vsub.f32	s15, s0, s0
    6bba:	movs	r3, #0
    6bbc:	vstr	s15, [r0, #4]
    6bc0:	vstr	s15, [r0]
    6bc4:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6bc6:	vldr	s13, [pc, #396]	; 6d54 <__ieee754_rem_pio2f+0x280>
    6bca:	vldr	s14, [pc, #396]	; 6d58 <__ieee754_rem_pio2f+0x284>
    6bce:	vsub.f32	s15, s15, s13
    6bd2:	movs	r3, #1
    6bd4:	vsub.f32	s13, s15, s14
    6bd8:	vsub.f32	s15, s15, s13
    6bdc:	vstr	s13, [r0]
    6be0:	vsub.f32	s15, s15, s14
    6be4:	vstr	s15, [r0, #4]
    6be8:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6bea:	bl	8574 <fabsf>
    6bee:	vldr	s13, [pc, #364]	; 6d5c <__ieee754_rem_pio2f+0x288>
    6bf2:	vldr	s11, [pc, #328]	; 6d3c <__ieee754_rem_pio2f+0x268>
    6bf6:	vldr	s14, [pc, #332]	; 6d44 <__ieee754_rem_pio2f+0x270>
    6bfa:	vmov.f32	s15, #96	; 0x3f000000  0.5
    6bfe:	vfma.f32	s15, s0, s13
    6c02:	vcvt.s32.f32	s15, s15
    6c06:	vmov	r3, s15
    6c0a:	vcvt.f32.s32	s13, s15
    6c0e:	cmp	r3, #31
    6c10:	vneg.f32	s12, s13
    6c14:	vfma.f32	s0, s12, s11
    6c18:	vmul.f32	s15, s13, s14
    6c1c:	bgt.n	6c5a <__ieee754_rem_pio2f+0x186>
    6c1e:	ldr	r1, [pc, #320]	; (6d60 <__ieee754_rem_pio2f+0x28c>)
    6c20:	subs	r0, r3, #1
    6c22:	bic.w	r2, r4, #255	; 0xff
    6c26:	ldr.w	r1, [r1, r0, lsl #2]
    6c2a:	cmp	r2, r1
    6c2c:	beq.n	6c5a <__ieee754_rem_pio2f+0x186>
    6c2e:	vsub.f32	s14, s0, s15
    6c32:	vstr	s14, [r5]
    6c36:	vsub.f32	s0, s0, s14
    6c3a:	cmp	r6, #0
    6c3c:	vsub.f32	s0, s0, s15
    6c40:	vstr	s0, [r5, #4]
    6c44:	bge.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6c46:	vneg.f32	s14, s14
    6c4a:	vneg.f32	s0, s0
    6c4e:	vstr	s14, [r5]
    6c52:	vstr	s0, [r5, #4]
    6c56:	negs	r3, r3
    6c58:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6c5a:	vsub.f32	s14, s0, s15
    6c5e:	asrs	r4, r4, #23
    6c60:	vmov	r2, s14
    6c64:	ubfx	r2, r2, #23, #8
    6c68:	subs	r2, r4, r2
    6c6a:	cmp	r2, #8
    6c6c:	ble.n	6c32 <__ieee754_rem_pio2f+0x15e>
    6c6e:	vldr	s15, [pc, #228]	; 6d54 <__ieee754_rem_pio2f+0x280>
    6c72:	vldr	s14, [pc, #228]	; 6d58 <__ieee754_rem_pio2f+0x284>
    6c76:	vmov.f32	s11, s0
    6c7a:	vfma.f32	s11, s12, s15
    6c7e:	vsub.f32	s0, s0, s11
    6c82:	vfma.f32	s0, s12, s15
    6c86:	vmov.f32	s15, s0
    6c8a:	vfnms.f32	s15, s13, s14
    6c8e:	vsub.f32	s14, s11, s15
    6c92:	vmov	r2, s14
    6c96:	ubfx	r2, r2, #23, #8
    6c9a:	subs	r4, r4, r2
    6c9c:	cmp	r4, #25
    6c9e:	bgt.n	6d16 <__ieee754_rem_pio2f+0x242>
    6ca0:	vstr	s14, [r5]
    6ca4:	vmov.f32	s0, s11
    6ca8:	b.n	6c36 <__ieee754_rem_pio2f+0x162>
    6caa:	cmp	r4, r2
    6cac:	vadd.f32	s15, s0, s15
    6cb0:	beq.n	6cf0 <__ieee754_rem_pio2f+0x21c>
    6cb2:	vldr	s14, [pc, #144]	; 6d44 <__ieee754_rem_pio2f+0x270>
    6cb6:	vadd.f32	s13, s15, s14
    6cba:	mov.w	r3, #4294967295
    6cbe:	vsub.f32	s15, s15, s13
    6cc2:	vstr	s13, [r0]
    6cc6:	vadd.f32	s15, s15, s14
    6cca:	vstr	s15, [r0, #4]
    6cce:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6cd0:	vldr	s14, [r5]
    6cd4:	vldr	s15, [r5, #4]
    6cd8:	vneg.f32	s14, s14
    6cdc:	vneg.f32	s15, s15
    6ce0:	negs	r3, r0
    6ce2:	vstr	s14, [r5]
    6ce6:	vstr	s15, [r5, #4]
    6cea:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6cec:	movs	r3, #3
    6cee:	b.n	6b8c <__ieee754_rem_pio2f+0xb8>
    6cf0:	vldr	s13, [pc, #96]	; 6d54 <__ieee754_rem_pio2f+0x280>
    6cf4:	vldr	s14, [pc, #96]	; 6d58 <__ieee754_rem_pio2f+0x284>
    6cf8:	vadd.f32	s15, s15, s13
    6cfc:	mov.w	r3, #4294967295
    6d00:	vadd.f32	s13, s15, s14
    6d04:	vsub.f32	s15, s15, s13
    6d08:	vstr	s13, [r0]
    6d0c:	vadd.f32	s15, s15, s14
    6d10:	vstr	s15, [r0, #4]
    6d14:	b.n	6bb0 <__ieee754_rem_pio2f+0xdc>
    6d16:	vldr	s14, [pc, #76]	; 6d64 <__ieee754_rem_pio2f+0x290>
    6d1a:	vldr	s10, [pc, #76]	; 6d68 <__ieee754_rem_pio2f+0x294>
    6d1e:	vmov.f32	s0, s11
    6d22:	vfma.f32	s0, s12, s14
    6d26:	vsub.f32	s15, s11, s0
    6d2a:	vfma.f32	s15, s12, s14
    6d2e:	vfnms.f32	s15, s13, s10
    6d32:	b.n	6c2e <__ieee754_rem_pio2f+0x15a>
    6d34:	.word	0x3f490fd8
    6d38:	.word	0x4016cbe3
    6d3c:	.word	0x3fc90f80
    6d40:	.word	0x3fc90fd0
    6d44:	.word	0x37354443
    6d48:	.word	0x43490f80
    6d4c:	.word	0x43800000
    6d50:	.word	0x20000b5c
    6d54:	.word	0x37354400
    6d58:	.word	0x2e85a308
    6d5c:	.word	0x3f22f984
    6d60:	.word	0x20000adc
    6d64:	.word	0x2e85a300
    6d68:	.word	0x248d3132

00006d6c <__ieee754_sqrtf>:
    6d6c:	vmov	r3, s0
    6d70:	bic.w	r2, r3, #2147483648	; 0x80000000
    6d74:	cmp.w	r2, #2139095040	; 0x7f800000
    6d78:	push	{r4, r5, r6}
    6d7a:	bcs.n	6dde <__ieee754_sqrtf+0x72>
    6d7c:	cbz	r2, 6dda <__ieee754_sqrtf+0x6e>
    6d7e:	cmp	r3, #0
    6d80:	blt.n	6dfe <__ieee754_sqrtf+0x92>
    6d82:	cmp.w	r2, #8388608	; 0x800000
    6d86:	mov.w	r0, r3, asr #23
    6d8a:	bcc.n	6de6 <__ieee754_sqrtf+0x7a>
    6d8c:	sub.w	r2, r0, #127	; 0x7f
    6d90:	ubfx	r3, r3, #0, #23
    6d94:	lsls	r1, r2, #31
    6d96:	orr.w	r3, r3, #8388608	; 0x800000
    6d9a:	it	mi
    6d9c:	lslmi	r3, r3, #1
    6d9e:	movs	r4, #0
    6da0:	asrs	r6, r2, #1
    6da2:	lsls	r3, r3, #1
    6da4:	mov	r5, r4
    6da6:	movs	r1, #25
    6da8:	mov.w	r2, #16777216	; 0x1000000
    6dac:	adds	r0, r5, r2
    6dae:	cmp	r0, r3
    6db0:	bgt.n	6db8 <__ieee754_sqrtf+0x4c>
    6db2:	subs	r3, r3, r0
    6db4:	adds	r5, r0, r2
    6db6:	add	r4, r2
    6db8:	subs	r1, #1
    6dba:	mov.w	r3, r3, lsl #1
    6dbe:	mov.w	r2, r2, lsr #1
    6dc2:	bne.n	6dac <__ieee754_sqrtf+0x40>
    6dc4:	cbz	r3, 6dcc <__ieee754_sqrtf+0x60>
    6dc6:	and.w	r3, r4, #1
    6dca:	add	r4, r3
    6dcc:	asrs	r4, r4, #1
    6dce:	add.w	r4, r4, #1056964608	; 0x3f000000
    6dd2:	add.w	r3, r4, r6, lsl #23
    6dd6:	vmov	s0, r3
    6dda:	pop	{r4, r5, r6}
    6ddc:	bx	lr
    6dde:	vfma.f32	s0, s0, s0
    6de2:	pop	{r4, r5, r6}
    6de4:	bx	lr
    6de6:	ands.w	r2, r3, #8388608	; 0x800000
    6dea:	beq.n	6df0 <__ieee754_sqrtf+0x84>
    6dec:	b.n	6e08 <__ieee754_sqrtf+0x9c>
    6dee:	mov	r2, r1
    6df0:	lsls	r3, r3, #1
    6df2:	lsls	r4, r3, #8
    6df4:	add.w	r1, r2, #1
    6df8:	bpl.n	6dee <__ieee754_sqrtf+0x82>
    6dfa:	subs	r0, r0, r2
    6dfc:	b.n	6d8c <__ieee754_sqrtf+0x20>
    6dfe:	vsub.f32	s15, s0, s0
    6e02:	vdiv.f32	s0, s15, s15
    6e06:	b.n	6dda <__ieee754_sqrtf+0x6e>
    6e08:	mov.w	r2, #4294967295
    6e0c:	b.n	6dfa <__ieee754_sqrtf+0x8e>
    6e0e:	nop

00006e10 <__kernel_cos>:
    6e10:	vmov	r3, s1
    6e14:	bic.w	r3, r3, #2147483648	; 0x80000000
    6e18:	cmp.w	r3, #1044381696	; 0x3e400000
    6e1c:	bge.n	6e78 <__kernel_cos+0x68>
    6e1e:	vcvt.s32.f64	s15, d0
    6e22:	vmov	r3, s15
    6e26:	cmp	r3, #0
    6e28:	beq.n	6eee <__kernel_cos+0xde>
    6e2a:	vmul.f64	d7, d0, d0
    6e2e:	vldr	d4, [pc, #200]	; 6ef8 <__kernel_cos+0xe8>
    6e32:	vldr	d5, [pc, #204]	; 6f00 <__kernel_cos+0xf0>
    6e36:	vldr	d6, [pc, #208]	; 6f08 <__kernel_cos+0xf8>
    6e3a:	vfma.f64	d5, d7, d4
    6e3e:	vldr	d4, [pc, #208]	; 6f10 <__kernel_cos+0x100>
    6e42:	vfma.f64	d6, d7, d5
    6e46:	vldr	d5, [pc, #208]	; 6f18 <__kernel_cos+0x108>
    6e4a:	vfma.f64	d4, d7, d6
    6e4e:	vldr	d6, [pc, #208]	; 6f20 <__kernel_cos+0x110>
    6e52:	vfma.f64	d5, d7, d4
    6e56:	vfma.f64	d6, d7, d5
    6e5a:	vmul.f64	d6, d6, d7
    6e5e:	vnmul.f64	d0, d1, d0
    6e62:	vmov.f64	d5, #96	; 0x3f000000  0.5
    6e66:	vfma.f64	d0, d7, d6
    6e6a:	vmov.f64	d6, #112	; 0x3f800000  1.0
    6e6e:	vfnms.f64	d0, d7, d5
    6e72:	vsub.f64	d0, d6, d0
    6e76:	bx	lr
    6e78:	vldr	d4, [pc, #124]	; 6ef8 <__kernel_cos+0xe8>
    6e7c:	vmul.f64	d7, d0, d0
    6e80:	vldr	d5, [pc, #124]	; 6f00 <__kernel_cos+0xf0>
    6e84:	vldr	d6, [pc, #128]	; 6f08 <__kernel_cos+0xf8>
    6e88:	vfma.f64	d5, d7, d4
    6e8c:	vldr	d4, [pc, #128]	; 6f10 <__kernel_cos+0x100>
    6e90:	vfma.f64	d6, d7, d5
    6e94:	ldr	r2, [pc, #144]	; (6f28 <__kernel_cos+0x118>)
    6e96:	vfma.f64	d4, d7, d6
    6e9a:	vldr	d5, [pc, #124]	; 6f18 <__kernel_cos+0x108>
    6e9e:	vldr	d6, [pc, #128]	; 6f20 <__kernel_cos+0x110>
    6ea2:	vfma.f64	d5, d7, d4
    6ea6:	cmp	r3, r2
    6ea8:	vfma.f64	d6, d7, d5
    6eac:	vmul.f64	d6, d6, d7
    6eb0:	ble.n	6e5e <__kernel_cos+0x4e>
    6eb2:	ldr	r2, [pc, #120]	; (6f2c <__kernel_cos+0x11c>)
    6eb4:	cmp	r3, r2
    6eb6:	bgt.n	6ee4 <__kernel_cos+0xd4>
    6eb8:	vmov.f64	d4, #112	; 0x3f800000  1.0
    6ebc:	movs	r0, #0
    6ebe:	sub.w	r1, r3, #2097152	; 0x200000
    6ec2:	vmov	d5, r0, r1
    6ec6:	vsub.f64	d4, d4, d5
    6eca:	vnmul.f64	d1, d1, d0
    6ece:	vmov.f64	d3, #96	; 0x3f000000  0.5
    6ed2:	vfma.f64	d1, d7, d6
    6ed6:	vfnms.f64	d5, d7, d3
    6eda:	vsub.f64	d5, d5, d1
    6ede:	vsub.f64	d0, d4, d5
    6ee2:	bx	lr
    6ee4:	vmov.f64	d4, #103	; 0x3f380000  0.7187500
    6ee8:	vmov.f64	d5, #82	; 0x3e900000  0.2812500
    6eec:	b.n	6eca <__kernel_cos+0xba>
    6eee:	vmov.f64	d0, #112	; 0x3f800000  1.0
    6ef2:	bx	lr
    6ef4:	nop.w
    6ef8:	.word	0xbe8838d4
    6efc:	.word	0xbda8fae9
    6f00:	.word	0xbdb4b1c4
    6f04:	.word	0x3e21ee9e
    6f08:	.word	0x809c52ad
    6f0c:	.word	0xbe927e4f
    6f10:	.word	0x19cb1590
    6f14:	.word	0x3efa01a0
    6f18:	.word	0x16c15177
    6f1c:	.word	0xbf56c16c
    6f20:	.word	0x5555554c
    6f24:	.word	0x3fa55555
    6f28:	.word	0x3fd33332
    6f2c:	.word	0x3fe90000

00006f30 <__kernel_rem_pio2>:
    6f30:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6f34:	vpush	{d8-d11}
    6f38:	sub.w	sp, sp, #588	; 0x24c
    6f3c:	ldr	r4, [pc, #704]	; (7200 <__kernel_rem_pio2+0x2d0>)
    6f3e:	ldr	r6, [sp, #656]	; 0x290
    6f40:	ldr	r5, [pc, #704]	; (7204 <__kernel_rem_pio2+0x2d4>)
    6f42:	ldr.w	r6, [r4, r6, lsl #2]
    6f46:	str	r3, [sp, #4]
    6f48:	subs	r4, r2, #3
    6f4a:	smull	r7, r5, r5, r4
    6f4e:	asrs	r4, r4, #31
    6f50:	rsb	r4, r4, r5, asr #2
    6f54:	bic.w	r4, r4, r4, asr #31
    6f58:	subs	r7, r3, #1
    6f5a:	add.w	sl, r4, #1
    6f5e:	sub.w	sl, sl, sl, lsl #2
    6f62:	mov	fp, r1
    6f64:	adds	r1, r6, r7
    6f66:	str	r4, [sp, #8]
    6f68:	mov	r9, r0
    6f6a:	add.w	sl, r2, sl, lsl #3
    6f6e:	sub.w	r3, r4, r7
    6f72:	bmi.n	6fa6 <__kernel_rem_pio2+0x76>
    6f74:	add	r1, r3
    6f76:	adds	r1, #1
    6f78:	add	r2, sp, #104	; 0x68
    6f7a:	ldr	r0, [sp, #660]	; 0x294
    6f7c:	b.n	6f94 <__kernel_rem_pio2+0x64>
    6f7e:	ldr.w	r4, [r0, r3, lsl #2]
    6f82:	vmov	s15, r4
    6f86:	adds	r3, #1
    6f88:	vcvt.f64.s32	d7, s15
    6f8c:	cmp	r3, r1
    6f8e:	vstmia	r2!, {d7}
    6f92:	beq.n	6fa6 <__kernel_rem_pio2+0x76>
    6f94:	cmp	r3, #0
    6f96:	bge.n	6f7e <__kernel_rem_pio2+0x4e>
    6f98:	vldr	d7, [pc, #588]	; 71e8 <__kernel_rem_pio2+0x2b8>
    6f9c:	adds	r3, #1
    6f9e:	cmp	r3, r1
    6fa0:	vstmia	r2!, {d7}
    6fa4:	bne.n	6f94 <__kernel_rem_pio2+0x64>
    6fa6:	cmp	r6, #0
    6fa8:	blt.w	7570 <__kernel_rem_pio2+0x640>
    6fac:	ldr	r3, [sp, #4]
    6fae:	add	r0, sp, #424	; 0x1a8
    6fb0:	add.w	lr, r6, #1
    6fb4:	lsls	r4, r3, #3
    6fb6:	add.w	lr, r0, lr, lsl #3
    6fba:	add.w	r1, r9, r4
    6fbe:	mov	r5, r7
    6fc0:	cmp	r7, #0
    6fc2:	blt.w	7356 <__kernel_rem_pio2+0x426>
    6fc6:	add	r3, sp, #104	; 0x68
    6fc8:	vldr	d7, [pc, #540]	; 71e8 <__kernel_rem_pio2+0x2b8>
    6fcc:	add.w	r2, r3, r5, lsl #3
    6fd0:	adds	r2, #8
    6fd2:	mov	r3, r9
    6fd4:	vldmia	r3!, {d5}
    6fd8:	vldmdb	r2!, {d6}
    6fdc:	cmp	r3, r1
    6fde:	vfma.f64	d7, d5, d6
    6fe2:	bne.n	6fd4 <__kernel_rem_pio2+0xa4>
    6fe4:	vstmia	r0!, {d7}
    6fe8:	cmp	r0, lr
    6fea:	add.w	r5, r5, #1
    6fee:	bne.n	6fc0 <__kernel_rem_pio2+0x90>
    6ff0:	add.w	r3, r6, #1073741824	; 0x40000000
    6ff4:	subs	r3, #2
    6ff6:	lsls	r3, r3, #2
    6ff8:	add	r2, sp, #24
    6ffa:	vldr	d9, [pc, #500]	; 71f0 <__kernel_rem_pio2+0x2c0>
    6ffe:	vldr	d8, [pc, #504]	; 71f8 <__kernel_rem_pio2+0x2c8>
    7002:	add.w	r8, r3, #4
    7006:	add	r3, r2
    7008:	add	r4, r9
    700a:	add	r8, r2
    700c:	str	r3, [sp, #12]
    700e:	mov	r5, r6
    7010:	str.w	fp, [sp, #16]
    7014:	add	r3, sp, #584	; 0x248
    7016:	add.w	r3, r3, r5, lsl #3
    701a:	cmp	r5, #0
    701c:	vldr	d0, [r3, #-160]	; 0xffffff60
    7020:	ble.n	7052 <__kernel_rem_pio2+0x122>
    7022:	add	r1, sp, #424	; 0x1a8
    7024:	add.w	r3, r1, r5, lsl #3
    7028:	add	r2, sp, #20
    702a:	vmul.f64	d7, d0, d9
    702e:	vcvt.s32.f64	s14, d7
    7032:	vldmdb	r3!, {d6}
    7036:	vcvt.f64.s32	d7, s14
    703a:	vfms.f64	d0, d7, d8
    703e:	vcvt.s32.f64	s11, d0
    7042:	cmp	r3, r1
    7044:	vmov	r0, s11
    7048:	vadd.f64	d0, d7, d6
    704c:	str.w	r0, [r2, #4]!
    7050:	bne.n	702a <__kernel_rem_pio2+0xfa>
    7052:	mov	r0, sl
    7054:	bl	82a0 <scalbn>
    7058:	vmov.f64	d10, d0
    705c:	vmov.f64	d0, #64	; 0x3e000000  0.125
    7060:	vmul.f64	d0, d10, d0
    7064:	bl	8050 <floor>
    7068:	vmov.f64	d7, #32	; 0x41000000  8.0
    706c:	vfms.f64	d10, d0, d7
    7070:	vcvt.s32.f64	s15, d10
    7074:	cmp.w	sl, #0
    7078:	vmov	fp, s15
    707c:	vcvt.f64.s32	d7, s15
    7080:	vsub.f64	d10, d10, d7
    7084:	ble.w	7320 <__kernel_rem_pio2+0x3f0>
    7088:	add.w	lr, r5, #4294967295
    708c:	add	r3, sp, #24
    708e:	rsb	r2, sl, #24
    7092:	ldr.w	r3, [r3, lr, lsl #2]
    7096:	asr.w	r0, r3, r2
    709a:	lsl.w	r2, r0, r2
    709e:	add	r1, sp, #24
    70a0:	subs	r3, r3, r2
    70a2:	rsb	r2, sl, #23
    70a6:	str.w	r3, [r1, lr, lsl #2]
    70aa:	add	fp, r0
    70ac:	asr.w	r1, r3, r2
    70b0:	cmp	r1, #0
    70b2:	ble.n	7128 <__kernel_rem_pio2+0x1f8>
    70b4:	cmp	r5, #0
    70b6:	add.w	fp, fp, #1
    70ba:	ble.w	7506 <__kernel_rem_pio2+0x5d6>
    70be:	movs	r2, #0
    70c0:	mov	r0, r2
    70c2:	add.w	lr, sp, #20
    70c6:	mov	ip, r1
    70c8:	b.n	70dc <__kernel_rem_pio2+0x1ac>
    70ca:	rsb	r1, r3, #16777216	; 0x1000000
    70ce:	cbz	r3, 70d6 <__kernel_rem_pio2+0x1a6>
    70d0:	str.w	r1, [lr]
    70d4:	movs	r0, #1
    70d6:	adds	r2, #1
    70d8:	cmp	r5, r2
    70da:	ble.n	70fa <__kernel_rem_pio2+0x1ca>
    70dc:	ldr.w	r3, [lr, #4]!
    70e0:	cmp	r0, #0
    70e2:	beq.n	70ca <__kernel_rem_pio2+0x19a>
    70e4:	rsb	r3, r3, #16711935	; 0xff00ff
    70e8:	adds	r2, #1
    70ea:	add.w	r3, r3, #65280	; 0xff00
    70ee:	cmp	r5, r2
    70f0:	str.w	r3, [lr]
    70f4:	mov.w	r0, #1
    70f8:	bgt.n	70dc <__kernel_rem_pio2+0x1ac>
    70fa:	mov	r1, ip
    70fc:	cmp.w	sl, #0
    7100:	ble.n	7124 <__kernel_rem_pio2+0x1f4>
    7102:	cmp.w	sl, #1
    7106:	beq.w	732e <__kernel_rem_pio2+0x3fe>
    710a:	cmp.w	sl, #2
    710e:	bne.n	7124 <__kernel_rem_pio2+0x1f4>
    7110:	subs	r2, r5, #1
    7112:	add	r3, sp, #24
    7114:	add.w	lr, sp, #24
    7118:	ldr.w	r3, [r3, r2, lsl #2]
    711c:	ubfx	r3, r3, #0, #22
    7120:	str.w	r3, [lr, r2, lsl #2]
    7124:	cmp	r1, #2
    7126:	beq.n	7208 <__kernel_rem_pio2+0x2d8>
    7128:	vcmp.f64	d10, #0.0
    712c:	vmrs	APSR_nzcv, fpscr
    7130:	bne.n	722c <__kernel_rem_pio2+0x2fc>
    7132:	add.w	lr, r5, #4294967295
    7136:	cmp	r6, lr
    7138:	bgt.n	715a <__kernel_rem_pio2+0x22a>
    713a:	add.w	r2, r5, #1073741824	; 0x40000000
    713e:	subs	r2, #1
    7140:	add	r3, sp, #24
    7142:	add.w	r2, r3, r2, lsl #2
    7146:	movs	r0, #0
    7148:	ldr.w	r3, [r2], #-4
    714c:	cmp	r2, r8
    714e:	orr.w	r0, r0, r3
    7152:	bne.n	7148 <__kernel_rem_pio2+0x218>
    7154:	cmp	r0, #0
    7156:	bne.w	7384 <__kernel_rem_pio2+0x454>
    715a:	subs	r3, r6, #1
    715c:	add	r2, sp, #24
    715e:	ldr.w	r3, [r2, r3, lsl #2]
    7162:	cmp	r3, #0
    7164:	bne.w	7500 <__kernel_rem_pio2+0x5d0>
    7168:	ldr	r3, [sp, #12]
    716a:	mov.w	lr, #1
    716e:	ldr.w	r2, [r3], #-4
    7172:	add.w	lr, lr, #1
    7176:	cmp	r2, #0
    7178:	beq.n	716e <__kernel_rem_pio2+0x23e>
    717a:	add	lr, r5
    717c:	adds	r3, r5, #1
    717e:	cmp	r3, lr
    7180:	bgt.n	71de <__kernel_rem_pio2+0x2ae>
    7182:	ldr	r2, [sp, #8]
    7184:	adds	r0, r3, r2
    7186:	ldr	r2, [sp, #4]
    7188:	add.w	r0, r0, #1073741824	; 0x40000000
    718c:	adds	r1, r2, r5
    718e:	add.w	ip, lr, r2
    7192:	ldr	r2, [sp, #660]	; 0x294
    7194:	subs	r0, #1
    7196:	add.w	r0, r2, r0, lsl #2
    719a:	add	r2, sp, #104	; 0x68
    719c:	add.w	r1, r2, r1, lsl #3
    71a0:	add.w	ip, r2, ip, lsl #3
    71a4:	add	r2, sp, #424	; 0x1a8
    71a6:	add.w	r5, r2, r3, lsl #3
    71aa:	ldr.w	r3, [r0, #4]!
    71ae:	vmov	s14, r3
    71b2:	vcvt.f64.s32	d7, s14
    71b6:	cmp	r7, #0
    71b8:	vstmia	r1!, {d7}
    71bc:	vldr	d7, [pc, #40]	; 71e8 <__kernel_rem_pio2+0x2b8>
    71c0:	blt.n	71d6 <__kernel_rem_pio2+0x2a6>
    71c2:	mov	r3, r9
    71c4:	mov	r2, r1
    71c6:	vldmia	r3!, {d5}
    71ca:	vldmdb	r2!, {d6}
    71ce:	cmp	r3, r4
    71d0:	vfma.f64	d7, d5, d6
    71d4:	bne.n	71c6 <__kernel_rem_pio2+0x296>
    71d6:	cmp	r1, ip
    71d8:	vstmia	r5!, {d7}
    71dc:	bne.n	71aa <__kernel_rem_pio2+0x27a>
    71de:	mov	r5, lr
    71e0:	b.n	7014 <__kernel_rem_pio2+0xe4>
    71e2:	nop
    71e4:	nop.w
	...
    71f4:	.word	0x3e700000
    71f8:	.word	0x00000000
    71fc:	.word	0x41700000
    7200:	.word	0x20000e74
    7204:	.word	0x2aaaaaab
    7208:	vmov.f64	d0, #112	; 0x3f800000  1.0
    720c:	vsub.f64	d10, d0, d10
    7210:	cmp	r0, #0
    7212:	beq.n	7128 <__kernel_rem_pio2+0x1f8>
    7214:	mov	r0, sl
    7216:	str	r1, [sp, #20]
    7218:	bl	82a0 <scalbn>
    721c:	vsub.f64	d10, d10, d0
    7220:	vcmp.f64	d10, #0.0
    7224:	vmrs	APSR_nzcv, fpscr
    7228:	ldr	r1, [sp, #20]
    722a:	beq.n	7132 <__kernel_rem_pio2+0x202>
    722c:	vmov.f64	d0, d10
    7230:	rsb	r0, sl, #0
    7234:	vmov	s22, fp
    7238:	mov	r9, r1
    723a:	ldr.w	fp, [sp, #16]
    723e:	bl	82a0 <scalbn>
    7242:	vldr	d6, [pc, #836]	; 7588 <__kernel_rem_pio2+0x658>
    7246:	vcmpe.f64	d0, d6
    724a:	vmrs	APSR_nzcv, fpscr
    724e:	blt.w	7536 <__kernel_rem_pio2+0x606>
    7252:	vldr	d7, [pc, #828]	; 7590 <__kernel_rem_pio2+0x660>
    7256:	vmul.f64	d7, d0, d7
    725a:	vcvt.s32.f64	s14, d7
    725e:	add	r1, sp, #24
    7260:	vcvt.f64.s32	d5, s14
    7264:	vfms.f64	d0, d5, d6
    7268:	vcvt.s32.f64	s0, d0
    726c:	adds	r3, r5, #1
    726e:	vmov	r2, s0
    7272:	str.w	r2, [r1, r5, lsl #2]
    7276:	vmov	r2, s14
    727a:	str.w	r2, [r1, r3, lsl #2]
    727e:	add.w	sl, sl, #24
    7282:	vmov.f64	d0, #112	; 0x3f800000  1.0
    7286:	mov	r0, sl
    7288:	str	r3, [sp, #4]
    728a:	bl	82a0 <scalbn>
    728e:	ldr	r3, [sp, #4]
    7290:	cmp	r3, #0
    7292:	blt.w	7552 <__kernel_rem_pio2+0x622>
    7296:	add	r4, sp, #424	; 0x1a8
    7298:	lsls	r7, r3, #3
    729a:	add	r2, sp, #24
    729c:	vldr	d6, [pc, #752]	; 7590 <__kernel_rem_pio2+0x660>
    72a0:	add.w	r2, r2, r3, lsl #2
    72a4:	add.w	ip, r4, r7
    72a8:	adds	r2, #4
    72aa:	add.w	r0, ip, #8
    72ae:	vldmdb	r2!, {s14}
    72b2:	vcvt.f64.s32	d7, s14
    72b6:	vmul.f64	d7, d7, d0
    72ba:	vstmdb	r0!, {d7}
    72be:	vmul.f64	d0, d0, d6
    72c2:	cmp	r0, r4
    72c4:	bne.n	72ae <__kernel_rem_pio2+0x37e>
    72c6:	add.w	r8, sp, #416	; 0x1a0
    72ca:	movs	r5, #0
    72cc:	add.w	lr, sp, #264	; 0x108
    72d0:	cmp	r6, #0
    72d2:	blt.w	74fa <__kernel_rem_pio2+0x5ca>
    72d6:	ldr	r0, [pc, #720]	; (75a8 <__kernel_rem_pio2+0x678>)
    72d8:	mov	r1, ip
    72da:	vldr	d6, [pc, #700]	; 7598 <__kernel_rem_pio2+0x668>
    72de:	vldr	d7, [pc, #704]	; 75a0 <__kernel_rem_pio2+0x670>
    72e2:	movs	r2, #0
    72e4:	b.n	72ee <__kernel_rem_pio2+0x3be>
    72e6:	cmp	r5, r2
    72e8:	blt.n	72fc <__kernel_rem_pio2+0x3cc>
    72ea:	vldmia	r0!, {d6}
    72ee:	vldmia	r1!, {d5}
    72f2:	adds	r2, #1
    72f4:	cmp	r6, r2
    72f6:	vfma.f64	d7, d5, d6
    72fa:	bge.n	72e6 <__kernel_rem_pio2+0x3b6>
    72fc:	sub.w	ip, ip, #8
    7300:	add.w	r2, lr, r5, lsl #3
    7304:	cmp	ip, r8
    7306:	vstr	d7, [r2]
    730a:	add.w	r5, r5, #1
    730e:	bne.n	72d0 <__kernel_rem_pio2+0x3a0>
    7310:	ldr	r2, [sp, #656]	; 0x290
    7312:	cmp	r2, #3
    7314:	bhi.w	7472 <__kernel_rem_pio2+0x542>
    7318:	tbb	[pc, r2]
    731c:	.word	0x50b5b5dd
    7320:	bne.n	7344 <__kernel_rem_pio2+0x414>
    7322:	subs	r3, r5, #1
    7324:	add	r2, sp, #24
    7326:	ldr.w	r1, [r2, r3, lsl #2]
    732a:	asrs	r1, r1, #23
    732c:	b.n	70b0 <__kernel_rem_pio2+0x180>
    732e:	subs	r2, r5, #1
    7330:	add	r3, sp, #24
    7332:	add.w	lr, sp, #24
    7336:	ldr.w	r3, [r3, r2, lsl #2]
    733a:	ubfx	r3, r3, #0, #23
    733e:	str.w	r3, [lr, r2, lsl #2]
    7342:	b.n	7124 <__kernel_rem_pio2+0x1f4>
    7344:	vmov.f64	d7, #96	; 0x3f000000  0.5
    7348:	vcmpe.f64	d10, d7
    734c:	vmrs	APSR_nzcv, fpscr
    7350:	bge.n	736a <__kernel_rem_pio2+0x43a>
    7352:	movs	r1, #0
    7354:	b.n	7128 <__kernel_rem_pio2+0x1f8>
    7356:	vldr	d7, [pc, #584]	; 75a0 <__kernel_rem_pio2+0x670>
    735a:	vstmia	r0!, {d7}
    735e:	cmp	r0, lr
    7360:	add.w	r5, r5, #1
    7364:	bne.w	6fc0 <__kernel_rem_pio2+0x90>
    7368:	b.n	6ff0 <__kernel_rem_pio2+0xc0>
    736a:	cmp	r5, #0
    736c:	add.w	fp, fp, #1
    7370:	it	gt
    7372:	movgt	r1, #2
    7374:	bgt.w	70be <__kernel_rem_pio2+0x18e>
    7378:	vmov.f64	d7, #112	; 0x3f800000  1.0
    737c:	movs	r1, #2
    737e:	vsub.f64	d10, d7, d10
    7382:	b.n	7128 <__kernel_rem_pio2+0x1f8>
    7384:	add	r2, sp, #24
    7386:	vmov	s22, fp
    738a:	ldr.w	r2, [r2, lr, lsl #2]
    738e:	ldr.w	fp, [sp, #16]
    7392:	mov	r3, lr
    7394:	mov	r9, r1
    7396:	sub.w	sl, sl, #24
    739a:	cmp	r2, #0
    739c:	bne.w	7282 <__kernel_rem_pio2+0x352>
    73a0:	add.w	r2, lr, #1073741824	; 0x40000000
    73a4:	subs	r2, #1
    73a6:	add	r1, sp, #24
    73a8:	add.w	r2, r1, r2, lsl #2
    73ac:	ldr.w	r1, [r2], #-4
    73b0:	subs	r3, #1
    73b2:	sub.w	sl, sl, #24
    73b6:	cmp	r1, #0
    73b8:	beq.n	73ac <__kernel_rem_pio2+0x47c>
    73ba:	b.n	7282 <__kernel_rem_pio2+0x352>
    73bc:	cmp	r3, #0
    73be:	ble.w	754c <__kernel_rem_pio2+0x61c>
    73c2:	add.w	r2, r3, #536870912	; 0x20000000
    73c6:	subs	r2, #1
    73c8:	add.w	r4, lr, r7
    73cc:	lsls	r0, r2, #3
    73ce:	vldr	d7, [r4]
    73d2:	add.w	r4, r0, #8
    73d6:	adds	r0, #16
    73d8:	add	r4, lr
    73da:	add	r0, lr
    73dc:	add	r5, sp, #272	; 0x110
    73de:	vldmdb	r4!, {d6}
    73e2:	vadd.f64	d5, d6, d7
    73e6:	vsub.f64	d6, d6, d5
    73ea:	vadd.f64	d7, d6, d7
    73ee:	vstmdb	r0!, {d7}
    73f2:	vmov.f64	d7, d5
    73f6:	cmp	r0, r5
    73f8:	vstr	d5, [r4]
    73fc:	bne.n	73de <__kernel_rem_pio2+0x4ae>
    73fe:	cmp	r3, #1
    7400:	ble.w	754c <__kernel_rem_pio2+0x61c>
    7404:	lsls	r2, r2, #3
    7406:	add	r7, lr
    7408:	add.w	r0, r2, #16
    740c:	vldr	d7, [r7]
    7410:	adds	r2, #8
    7412:	add	r0, lr
    7414:	add.w	r3, lr, r2
    7418:	add	r4, sp, #280	; 0x118
    741a:	mov	r2, r0
    741c:	vldmdb	r3!, {d6}
    7420:	vadd.f64	d5, d7, d6
    7424:	vsub.f64	d6, d6, d5
    7428:	vadd.f64	d7, d6, d7
    742c:	vstmdb	r2!, {d7}
    7430:	vmov.f64	d7, d5
    7434:	cmp	r4, r2
    7436:	vstr	d5, [r3]
    743a:	bne.n	741c <__kernel_rem_pio2+0x4ec>
    743c:	vldr	d7, [pc, #352]	; 75a0 <__kernel_rem_pio2+0x670>
    7440:	vldmdb	r0!, {d6}
    7444:	cmp	r4, r0
    7446:	vadd.f64	d7, d7, d6
    744a:	bne.n	7440 <__kernel_rem_pio2+0x510>
    744c:	mov	r3, r9
    744e:	cmp	r3, #0
    7450:	beq.n	7520 <__kernel_rem_pio2+0x5f0>
    7452:	vneg.f64	d7, d7
    7456:	vldr	d5, [lr]
    745a:	vldr	d6, [lr, #8]
    745e:	vneg.f64	d5, d5
    7462:	vstr	d5, [fp]
    7466:	vstr	d7, [fp, #16]
    746a:	vneg.f64	d7, d6
    746e:	vstr	d7, [fp, #8]
    7472:	vmov	r3, s22
    7476:	and.w	r0, r3, #7
    747a:	add.w	sp, sp, #588	; 0x24c
    747e:	vpop	{d8-d11}
    7482:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7486:	vldr	d7, [pc, #280]	; 75a0 <__kernel_rem_pio2+0x670>
    748a:	add.w	r2, r7, #8
    748e:	add	r2, lr
    7490:	vldmdb	r2!, {d6}
    7494:	cmp	r2, lr
    7496:	vadd.f64	d7, d7, d6
    749a:	bne.n	7490 <__kernel_rem_pio2+0x560>
    749c:	mov	r2, r9
    749e:	cbz	r2, 750a <__kernel_rem_pio2+0x5da>
    74a0:	vneg.f64	d5, d7
    74a4:	vldr	d6, [lr]
    74a8:	cmp	r3, #0
    74aa:	vstr	d5, [fp]
    74ae:	vsub.f64	d7, d6, d7
    74b2:	ble.n	74cc <__kernel_rem_pio2+0x59c>
    74b4:	add	r0, sp, #272	; 0x110
    74b6:	movs	r2, #1
    74b8:	vldmia	r0!, {d6}
    74bc:	adds	r2, #1
    74be:	cmp	r3, r2
    74c0:	vadd.f64	d7, d7, d6
    74c4:	bge.n	74b8 <__kernel_rem_pio2+0x588>
    74c6:	mov	r3, r9
    74c8:	cmp	r3, #0
    74ca:	beq.n	746e <__kernel_rem_pio2+0x53e>
    74cc:	vneg.f64	d7, d7
    74d0:	vstr	d7, [fp, #8]
    74d4:	b.n	7472 <__kernel_rem_pio2+0x542>
    74d6:	vldr	d7, [pc, #200]	; 75a0 <__kernel_rem_pio2+0x670>
    74da:	adds	r7, #8
    74dc:	add	lr, r7
    74de:	vldmdb	lr!, {d6}
    74e2:	subs	r3, #1
    74e4:	adds	r2, r3, #1
    74e6:	vadd.f64	d7, d7, d6
    74ea:	bne.n	74de <__kernel_rem_pio2+0x5ae>
    74ec:	mov	r3, r9
    74ee:	cbz	r3, 74f4 <__kernel_rem_pio2+0x5c4>
    74f0:	vneg.f64	d7, d7
    74f4:	vstr	d7, [fp]
    74f8:	b.n	7472 <__kernel_rem_pio2+0x542>
    74fa:	vldr	d7, [pc, #164]	; 75a0 <__kernel_rem_pio2+0x670>
    74fe:	b.n	72fc <__kernel_rem_pio2+0x3cc>
    7500:	mov.w	lr, #1
    7504:	b.n	717a <__kernel_rem_pio2+0x24a>
    7506:	movs	r0, #0
    7508:	b.n	70fc <__kernel_rem_pio2+0x1cc>
    750a:	vldr	d6, [lr]
    750e:	cmp	r3, #0
    7510:	vstr	d7, [fp]
    7514:	vsub.f64	d7, d6, d7
    7518:	bgt.n	74b4 <__kernel_rem_pio2+0x584>
    751a:	vstr	d7, [fp, #8]
    751e:	b.n	7472 <__kernel_rem_pio2+0x542>
    7520:	ldrd	r0, r1, [lr]
    7524:	ldrd	r2, r3, [lr, #8]
    7528:	vstr	d7, [fp, #16]
    752c:	strd	r0, r1, [fp]
    7530:	strd	r2, r3, [fp, #8]
    7534:	b.n	7472 <__kernel_rem_pio2+0x542>
    7536:	vcvt.s32.f64	s0, d0
    753a:	add	r1, sp, #24
    753c:	vmov	r2, s0
    7540:	mov	r3, r5
    7542:	str.w	r2, [r1, r5, lsl #2]
    7546:	b.n	7282 <__kernel_rem_pio2+0x352>
    7548:	add.w	lr, sp, #264	; 0x108
    754c:	vldr	d7, [pc, #80]	; 75a0 <__kernel_rem_pio2+0x670>
    7550:	b.n	744c <__kernel_rem_pio2+0x51c>
    7552:	ldr	r2, [sp, #656]	; 0x290
    7554:	cmp	r2, #3
    7556:	bhi.n	7472 <__kernel_rem_pio2+0x542>
    7558:	add	r1, pc, #4	; (adr r1, 7560 <__kernel_rem_pio2+0x630>)
    755a:	ldr.w	pc, [r1, r2, lsl #2]
    755e:	nop
    7560:	.word	0x00007581
    7564:	.word	0x00007577
    7568:	.word	0x00007577
    756c:	.word	0x00007549
    7570:	ldr	r3, [sp, #4]
    7572:	lsls	r4, r3, #3
    7574:	b.n	6ff0 <__kernel_rem_pio2+0xc0>
    7576:	vldr	d7, [pc, #40]	; 75a0 <__kernel_rem_pio2+0x670>
    757a:	add.w	lr, sp, #264	; 0x108
    757e:	b.n	749c <__kernel_rem_pio2+0x56c>
    7580:	vldr	d7, [pc, #28]	; 75a0 <__kernel_rem_pio2+0x670>
    7584:	b.n	74ec <__kernel_rem_pio2+0x5bc>
    7586:	nop
    7588:	.word	0x00000000
    758c:	.word	0x41700000
    7590:	.word	0x00000000
    7594:	.word	0x3e700000
    7598:	.word	0x40000000
    759c:	.word	0x3ff921fb
	...
    75a8:	.word	0x20000e90
    75ac:	.word	0x00000000

000075b0 <__kernel_sin>:
    75b0:	vmov	r3, s1
    75b4:	bic.w	r3, r3, #2147483648	; 0x80000000
    75b8:	cmp.w	r3, #1044381696	; 0x3e400000
    75bc:	bge.n	75c8 <__kernel_sin+0x18>
    75be:	vcvt.s32.f64	s15, d0
    75c2:	vmov	r3, s15
    75c6:	cbz	r3, 7612 <__kernel_sin+0x62>
    75c8:	vmul.f64	d7, d0, d0
    75cc:	vmul.f64	d4, d0, d7
    75d0:	vldr	d5, [pc, #84]	; 7628 <__kernel_sin+0x78>
    75d4:	vldr	d6, [pc, #88]	; 7630 <__kernel_sin+0x80>
    75d8:	vldr	d3, [pc, #92]	; 7638 <__kernel_sin+0x88>
    75dc:	vfma.f64	d6, d7, d5
    75e0:	vldr	d5, [pc, #92]	; 7640 <__kernel_sin+0x90>
    75e4:	vfma.f64	d3, d7, d6
    75e8:	vldr	d6, [pc, #92]	; 7648 <__kernel_sin+0x98>
    75ec:	vfma.f64	d5, d7, d3
    75f0:	vfma.f64	d6, d7, d5
    75f4:	cbz	r0, 7614 <__kernel_sin+0x64>
    75f6:	vnmul.f64	d6, d6, d4
    75fa:	vmov.f64	d3, #96	; 0x3f000000  0.5
    75fe:	vldr	d5, [pc, #80]	; 7650 <__kernel_sin+0xa0>
    7602:	vfma.f64	d6, d1, d3
    7606:	vfnms.f64	d1, d7, d6
    760a:	vfma.f64	d1, d4, d5
    760e:	vsub.f64	d0, d0, d1
    7612:	bx	lr
    7614:	vldr	d5, [pc, #64]	; 7658 <__kernel_sin+0xa8>
    7618:	vfma.f64	d5, d7, d6
    761c:	vfma.f64	d0, d4, d5
    7620:	bx	lr
    7622:	nop
    7624:	nop.w
    7628:	.word	0x5acfd57c
    762c:	.word	0x3de5d93a
    7630:	.word	0x8a2b9ceb
    7634:	.word	0xbe5ae5e6
    7638:	.word	0x57b1fe7d
    763c:	.word	0x3ec71de3
    7640:	.word	0x19c161d5
    7644:	.word	0xbf2a01a0
    7648:	.word	0x1110f8a6
    764c:	.word	0x3f811111
    7650:	.word	0x55555549
    7654:	.word	0x3fc55555
    7658:	.word	0x55555549
    765c:	.word	0xbfc55555

00007660 <__kernel_cosf>:
    7660:	vmov	r3, s0
    7664:	bic.w	r3, r3, #2147483648	; 0x80000000
    7668:	cmp.w	r3, #838860800	; 0x32000000
    766c:	bge.n	76c8 <__kernel_cosf+0x68>
    766e:	vcvt.s32.f32	s15, s0
    7672:	vmov	r3, s15
    7676:	cmp	r3, #0
    7678:	beq.n	773c <__kernel_cosf+0xdc>
    767a:	vmul.f32	s14, s0, s0
    767e:	vldr	s9, [pc, #196]	; 7744 <__kernel_cosf+0xe4>
    7682:	vldr	s10, [pc, #196]	; 7748 <__kernel_cosf+0xe8>
    7686:	vldr	s11, [pc, #196]	; 774c <__kernel_cosf+0xec>
    768a:	vldr	s12, [pc, #196]	; 7750 <__kernel_cosf+0xf0>
    768e:	vldr	s15, [pc, #196]	; 7754 <__kernel_cosf+0xf4>
    7692:	vldr	s13, [pc, #196]	; 7758 <__kernel_cosf+0xf8>
    7696:	vfma.f32	s10, s14, s9
    769a:	vfma.f32	s11, s14, s10
    769e:	vfma.f32	s12, s14, s11
    76a2:	vfma.f32	s15, s14, s12
    76a6:	vfma.f32	s13, s14, s15
    76aa:	vmul.f32	s13, s13, s14
    76ae:	vnmul.f32	s1, s1, s0
    76b2:	vmov.f32	s12, #96	; 0x3f000000  0.5
    76b6:	vfma.f32	s1, s14, s13
    76ba:	vmov.f32	s15, #112	; 0x3f800000  1.0
    76be:	vfnms.f32	s1, s14, s12
    76c2:	vsub.f32	s0, s15, s1
    76c6:	bx	lr
    76c8:	vmul.f32	s14, s0, s0
    76cc:	vldr	s9, [pc, #116]	; 7744 <__kernel_cosf+0xe4>
    76d0:	vldr	s10, [pc, #116]	; 7748 <__kernel_cosf+0xe8>
    76d4:	vldr	s11, [pc, #116]	; 774c <__kernel_cosf+0xec>
    76d8:	vldr	s12, [pc, #116]	; 7750 <__kernel_cosf+0xf0>
    76dc:	vldr	s15, [pc, #116]	; 7754 <__kernel_cosf+0xf4>
    76e0:	vldr	s13, [pc, #116]	; 7758 <__kernel_cosf+0xf8>
    76e4:	ldr	r2, [pc, #116]	; (775c <__kernel_cosf+0xfc>)
    76e6:	vfma.f32	s10, s14, s9
    76ea:	cmp	r3, r2
    76ec:	vfma.f32	s11, s14, s10
    76f0:	vfma.f32	s12, s14, s11
    76f4:	vfma.f32	s15, s14, s12
    76f8:	vfma.f32	s13, s14, s15
    76fc:	vmul.f32	s13, s13, s14
    7700:	ble.n	76ae <__kernel_cosf+0x4e>
    7702:	ldr	r2, [pc, #92]	; (7760 <__kernel_cosf+0x100>)
    7704:	cmp	r3, r2
    7706:	bgt.n	7732 <__kernel_cosf+0xd2>
    7708:	add.w	r3, r3, #4278190080	; 0xff000000
    770c:	vmov	s15, r3
    7710:	vmov.f32	s12, #112	; 0x3f800000  1.0
    7714:	vsub.f32	s12, s12, s15
    7718:	vnmul.f32	s1, s1, s0
    771c:	vmov.f32	s11, #96	; 0x3f000000  0.5
    7720:	vfma.f32	s1, s14, s13
    7724:	vfnms.f32	s15, s14, s11
    7728:	vsub.f32	s15, s15, s1
    772c:	vsub.f32	s0, s12, s15
    7730:	bx	lr
    7732:	vmov.f32	s12, #103	; 0x3f380000  0.7187500
    7736:	vmov.f32	s15, #82	; 0x3e900000  0.2812500
    773a:	b.n	7718 <__kernel_cosf+0xb8>
    773c:	vmov.f32	s0, #112	; 0x3f800000  1.0
    7740:	bx	lr
    7742:	nop
    7744:	.word	0xad47d74e
    7748:	.word	0x310f74f6
    774c:	.word	0xb493f27c
    7750:	.word	0x37d00d01
    7754:	.word	0xbab60b61
    7758:	.word	0x3d2aaaab
    775c:	.word	0x3e999999
    7760:	.word	0x3f480000

00007764 <__kernel_rem_pio2f>:
    7764:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7768:	vpush	{d8-d9}
    776c:	sub	sp, #348	; 0x15c
    776e:	subs	r7, r3, #1
    7770:	ldr	r4, [pc, #656]	; (7a04 <__kernel_rem_pio2f+0x2a0>)
    7772:	ldr	r5, [sp, #400]	; 0x190
    7774:	str	r3, [sp, #4]
    7776:	subs	r3, r2, #3
    7778:	it	mi
    777a:	addmi	r3, r2, #4
    777c:	ldr.w	r6, [r4, r5, lsl #2]
    7780:	asrs	r3, r3, #3
    7782:	bic.w	r3, r3, r3, asr #31
    7786:	add.w	sl, r3, #1
    778a:	mov	fp, r1
    778c:	adds	r1, r6, r7
    778e:	str	r3, [sp, #8]
    7790:	mov	r9, r0
    7792:	sub.w	sl, r2, sl, lsl #3
    7796:	sub.w	r3, r3, r7
    779a:	bmi.n	77c6 <__kernel_rem_pio2f+0x62>
    779c:	add	r1, r3
    779e:	ldr	r0, [sp, #404]	; 0x194
    77a0:	adds	r1, #1
    77a2:	add	r2, sp, #104	; 0x68
    77a4:	cmp	r3, #0
    77a6:	itet	ge
    77a8:	ldrge.w	r4, [r0, r3, lsl #2]
    77ac:	vldrlt	s15, [pc, #600]	; 7a08 <__kernel_rem_pio2f+0x2a4>
    77b0:	vmovge	s15, r4
    77b4:	add.w	r3, r3, #1
    77b8:	it	ge
    77ba:	vcvtge.f32.s32	s15, s15
    77be:	cmp	r3, r1
    77c0:	vstmia	r2!, {s15}
    77c4:	bne.n	77a4 <__kernel_rem_pio2f+0x40>
    77c6:	cmp	r6, #0
    77c8:	blt.w	7d74 <__kernel_rem_pio2f+0x610>
    77cc:	ldr	r3, [sp, #4]
    77ce:	add	r0, sp, #264	; 0x108
    77d0:	add.w	lr, r6, #1
    77d4:	lsls	r4, r3, #2
    77d6:	add.w	lr, r0, lr, lsl #2
    77da:	add.w	r1, r9, r4
    77de:	mov	r5, r7
    77e0:	cmp	r7, #0
    77e2:	blt.w	7b64 <__kernel_rem_pio2f+0x400>
    77e6:	add	r3, sp, #104	; 0x68
    77e8:	add.w	r2, r3, r5, lsl #2
    77ec:	vldr	s15, [pc, #536]	; 7a08 <__kernel_rem_pio2f+0x2a4>
    77f0:	adds	r2, #4
    77f2:	mov	r3, r9
    77f4:	vldmia	r3!, {s13}
    77f8:	vldmdb	r2!, {s14}
    77fc:	cmp	r3, r1
    77fe:	vfma.f32	s15, s13, s14
    7802:	bne.n	77f4 <__kernel_rem_pio2f+0x90>
    7804:	vstmia	r0!, {s15}
    7808:	cmp	r0, lr
    780a:	add.w	r5, r5, #1
    780e:	bne.n	77e0 <__kernel_rem_pio2f+0x7c>
    7810:	add.w	r3, r6, #1073741824	; 0x40000000
    7814:	subs	r3, #2
    7816:	lsls	r3, r3, #2
    7818:	add	r2, sp, #24
    781a:	add.w	r8, r3, #4
    781e:	vldr	s17, [pc, #496]	; 7a10 <__kernel_rem_pio2f+0x2ac>
    7822:	vldr	s16, [pc, #488]	; 7a0c <__kernel_rem_pio2f+0x2a8>
    7826:	str.w	fp, [sp, #16]
    782a:	add	r3, r2
    782c:	add	r4, r9
    782e:	add	r8, r2
    7830:	str	r3, [sp, #12]
    7832:	mov	r5, r6
    7834:	add	r3, sp, #344	; 0x158
    7836:	add.w	r3, r3, r5, lsl #2
    783a:	cmp	r5, #0
    783c:	vldr	s0, [r3, #-80]	; 0xffffffb0
    7840:	ble.n	7876 <__kernel_rem_pio2f+0x112>
    7842:	add	r1, sp, #264	; 0x108
    7844:	add.w	r3, r1, r5, lsl #2
    7848:	add	r2, sp, #20
    784a:	vmul.f32	s15, s0, s17
    784e:	vmov.f32	s14, s0
    7852:	vcvt.s32.f32	s15, s15
    7856:	vldmdb	r3!, {s13}
    785a:	vcvt.f32.s32	s15, s15
    785e:	cmp	r3, r1
    7860:	vfms.f32	s14, s15, s16
    7864:	vadd.f32	s0, s15, s13
    7868:	vcvt.s32.f32	s14, s14
    786c:	vmov	r0, s14
    7870:	str.w	r0, [r2, #4]!
    7874:	bne.n	784a <__kernel_rem_pio2f+0xe6>
    7876:	mov	r0, sl
    7878:	bl	8614 <scalbnf>
    787c:	vmov.f32	s18, s0
    7880:	vmov.f32	s0, #64	; 0x3e000000  0.125
    7884:	vmul.f32	s0, s18, s0
    7888:	bl	8584 <floorf>
    788c:	vmov.f32	s15, #32	; 0x41000000  8.0
    7890:	vfms.f32	s18, s0, s15
    7894:	cmp.w	sl, #0
    7898:	vcvt.s32.f32	s15, s18
    789c:	vmov	fp, s15
    78a0:	vcvt.f32.s32	s15, s15
    78a4:	vsub.f32	s18, s18, s15
    78a8:	ble.w	7b2e <__kernel_rem_pio2f+0x3ca>
    78ac:	add.w	lr, r5, #4294967295
    78b0:	add	r3, sp, #24
    78b2:	rsb	r2, sl, #8
    78b6:	ldr.w	r3, [r3, lr, lsl #2]
    78ba:	asr.w	r0, r3, r2
    78be:	lsl.w	r2, r0, r2
    78c2:	add	r1, sp, #24
    78c4:	subs	r3, r3, r2
    78c6:	rsb	r2, sl, #7
    78ca:	str.w	r3, [r1, lr, lsl #2]
    78ce:	add	fp, r0
    78d0:	asr.w	r1, r3, r2
    78d4:	cmp	r1, #0
    78d6:	ble.n	7948 <__kernel_rem_pio2f+0x1e4>
    78d8:	cmp	r5, #0
    78da:	add.w	fp, fp, #1
    78de:	ble.w	7d2a <__kernel_rem_pio2f+0x5c6>
    78e2:	movs	r2, #0
    78e4:	mov	r0, r2
    78e6:	add.w	lr, sp, #20
    78ea:	mov	ip, r1
    78ec:	b.n	7900 <__kernel_rem_pio2f+0x19c>
    78ee:	rsb	r1, r3, #256	; 0x100
    78f2:	cbz	r3, 78fa <__kernel_rem_pio2f+0x196>
    78f4:	str.w	r1, [lr]
    78f8:	movs	r0, #1
    78fa:	adds	r2, #1
    78fc:	cmp	r5, r2
    78fe:	ble.n	791a <__kernel_rem_pio2f+0x1b6>
    7900:	ldr.w	r3, [lr, #4]!
    7904:	cmp	r0, #0
    7906:	beq.n	78ee <__kernel_rem_pio2f+0x18a>
    7908:	adds	r2, #1
    790a:	rsb	r3, r3, #255	; 0xff
    790e:	cmp	r5, r2
    7910:	str.w	r3, [lr]
    7914:	mov.w	r0, #1
    7918:	bgt.n	7900 <__kernel_rem_pio2f+0x19c>
    791a:	mov	r1, ip
    791c:	cmp.w	sl, #0
    7920:	ble.n	7944 <__kernel_rem_pio2f+0x1e0>
    7922:	cmp.w	sl, #1
    7926:	beq.w	7b3c <__kernel_rem_pio2f+0x3d8>
    792a:	cmp.w	sl, #2
    792e:	bne.n	7944 <__kernel_rem_pio2f+0x1e0>
    7930:	subs	r2, r5, #1
    7932:	add	r3, sp, #24
    7934:	add.w	lr, sp, #24
    7938:	ldr.w	r3, [r3, r2, lsl #2]
    793c:	and.w	r3, r3, #63	; 0x3f
    7940:	str.w	r3, [lr, r2, lsl #2]
    7944:	cmp	r1, #2
    7946:	beq.n	7a14 <__kernel_rem_pio2f+0x2b0>
    7948:	vcmp.f32	s18, #0.0
    794c:	vmrs	APSR_nzcv, fpscr
    7950:	bne.n	7a38 <__kernel_rem_pio2f+0x2d4>
    7952:	add.w	lr, r5, #4294967295
    7956:	cmp	r6, lr
    7958:	bgt.n	797a <__kernel_rem_pio2f+0x216>
    795a:	add.w	r2, r5, #1073741824	; 0x40000000
    795e:	subs	r2, #1
    7960:	add	r3, sp, #24
    7962:	add.w	r2, r3, r2, lsl #2
    7966:	movs	r0, #0
    7968:	ldr.w	r3, [r2], #-4
    796c:	cmp	r2, r8
    796e:	orr.w	r0, r0, r3
    7972:	bne.n	7968 <__kernel_rem_pio2f+0x204>
    7974:	cmp	r0, #0
    7976:	bne.w	7b92 <__kernel_rem_pio2f+0x42e>
    797a:	subs	r3, r6, #1
    797c:	add	r2, sp, #24
    797e:	ldr.w	r3, [r2, r3, lsl #2]
    7982:	cmp	r3, #0
    7984:	bne.w	7d24 <__kernel_rem_pio2f+0x5c0>
    7988:	ldr	r3, [sp, #12]
    798a:	mov.w	lr, #1
    798e:	ldr.w	r2, [r3], #-4
    7992:	add.w	lr, lr, #1
    7996:	cmp	r2, #0
    7998:	beq.n	798e <__kernel_rem_pio2f+0x22a>
    799a:	add	lr, r5
    799c:	adds	r3, r5, #1
    799e:	cmp	r3, lr
    79a0:	bgt.n	79fe <__kernel_rem_pio2f+0x29a>
    79a2:	ldr	r2, [sp, #8]
    79a4:	adds	r0, r3, r2
    79a6:	ldr	r2, [sp, #4]
    79a8:	add.w	r0, r0, #1073741824	; 0x40000000
    79ac:	adds	r1, r2, r5
    79ae:	add.w	ip, lr, r2
    79b2:	ldr	r2, [sp, #404]	; 0x194
    79b4:	subs	r0, #1
    79b6:	add.w	r0, r2, r0, lsl #2
    79ba:	add	r2, sp, #104	; 0x68
    79bc:	add.w	r1, r2, r1, lsl #2
    79c0:	add.w	ip, r2, ip, lsl #2
    79c4:	add	r2, sp, #264	; 0x108
    79c6:	add.w	r5, r2, r3, lsl #2
    79ca:	ldr.w	r3, [r0, #4]!
    79ce:	vmov	s15, r3
    79d2:	vcvt.f32.s32	s15, s15
    79d6:	cmp	r7, #0
    79d8:	vstmia	r1!, {s15}
    79dc:	vldr	s15, [pc, #40]	; 7a08 <__kernel_rem_pio2f+0x2a4>
    79e0:	blt.n	79f6 <__kernel_rem_pio2f+0x292>
    79e2:	mov	r3, r9
    79e4:	mov	r2, r1
    79e6:	vldmia	r3!, {s13}
    79ea:	vldmdb	r2!, {s14}
    79ee:	cmp	r3, r4
    79f0:	vfma.f32	s15, s13, s14
    79f4:	bne.n	79e6 <__kernel_rem_pio2f+0x282>
    79f6:	cmp	r1, ip
    79f8:	vstmia	r5!, {s15}
    79fc:	bne.n	79ca <__kernel_rem_pio2f+0x266>
    79fe:	mov	r5, lr
    7a00:	b.n	7834 <__kernel_rem_pio2f+0xd0>
    7a02:	nop
    7a04:	.word	0x20000ec8
    7a08:	.word	0x00000000
    7a0c:	.word	0x43800000
    7a10:	.word	0x3b800000
    7a14:	vmov.f32	s0, #112	; 0x3f800000  1.0
    7a18:	vsub.f32	s18, s0, s18
    7a1c:	cmp	r0, #0
    7a1e:	beq.n	7948 <__kernel_rem_pio2f+0x1e4>
    7a20:	mov	r0, sl
    7a22:	str	r1, [sp, #20]
    7a24:	bl	8614 <scalbnf>
    7a28:	vsub.f32	s18, s18, s0
    7a2c:	ldr	r1, [sp, #20]
    7a2e:	vcmp.f32	s18, #0.0
    7a32:	vmrs	APSR_nzcv, fpscr
    7a36:	beq.n	7952 <__kernel_rem_pio2f+0x1ee>
    7a38:	vmov.f32	s0, s18
    7a3c:	rsb	r0, sl, #0
    7a40:	vmov	s19, fp
    7a44:	mov	r8, r1
    7a46:	ldr.w	fp, [sp, #16]
    7a4a:	bl	8614 <scalbnf>
    7a4e:	vldr	s14, [pc, #-68]	; 7a0c <__kernel_rem_pio2f+0x2a8>
    7a52:	vcmpe.f32	s0, s14
    7a56:	vmrs	APSR_nzcv, fpscr
    7a5a:	blt.w	7d40 <__kernel_rem_pio2f+0x5dc>
    7a5e:	vldr	s15, [pc, #-80]	; 7a10 <__kernel_rem_pio2f+0x2ac>
    7a62:	vmul.f32	s15, s0, s15
    7a66:	add	r1, sp, #24
    7a68:	vcvt.s32.f32	s15, s15
    7a6c:	adds	r3, r5, #1
    7a6e:	vcvt.f32.s32	s15, s15
    7a72:	add.w	sl, sl, #8
    7a76:	vfms.f32	s0, s15, s14
    7a7a:	vcvt.s32.f32	s15, s15
    7a7e:	vcvt.s32.f32	s0, s0
    7a82:	vmov	r2, s0
    7a86:	str.w	r2, [r1, r5, lsl #2]
    7a8a:	vmov	r2, s15
    7a8e:	str.w	r2, [r1, r3, lsl #2]
    7a92:	mov	r0, sl
    7a94:	vmov.f32	s0, #112	; 0x3f800000  1.0
    7a98:	str	r3, [sp, #4]
    7a9a:	bl	8614 <scalbnf>
    7a9e:	ldr	r3, [sp, #4]
    7aa0:	cmp	r3, #0
    7aa2:	blt.w	7d58 <__kernel_rem_pio2f+0x5f4>
    7aa6:	lsls	r7, r3, #2
    7aa8:	add	r4, sp, #264	; 0x108
    7aaa:	add	r2, sp, #24
    7aac:	adds	r0, r7, #4
    7aae:	add.w	lr, r4, r7
    7ab2:	vldr	s14, [pc, #-164]	; 7a10 <__kernel_rem_pio2f+0x2ac>
    7ab6:	add	r0, r2
    7ab8:	add.w	r2, lr, #4
    7abc:	vldmdb	r0!, {s15}
    7ac0:	vcvt.f32.s32	s15, s15
    7ac4:	vmul.f32	s15, s15, s0
    7ac8:	vmul.f32	s0, s0, s14
    7acc:	vstmdb	r2!, {s15}
    7ad0:	cmp	r2, r4
    7ad2:	bne.n	7abc <__kernel_rem_pio2f+0x358>
    7ad4:	add.w	ip, sp, #260	; 0x104
    7ad8:	movs	r5, #0
    7ada:	cmp	r6, #0
    7adc:	blt.w	7d08 <__kernel_rem_pio2f+0x5a4>
    7ae0:	ldr	r0, [pc, #676]	; (7d88 <__kernel_rem_pio2f+0x624>)
    7ae2:	vldr	s14, [pc, #680]	; 7d8c <__kernel_rem_pio2f+0x628>
    7ae6:	vldr	s15, [pc, #680]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7aea:	mov	r1, lr
    7aec:	movs	r2, #0
    7aee:	b.n	7afa <__kernel_rem_pio2f+0x396>
    7af0:	cmp	r5, r2
    7af2:	blt.n	7b08 <__kernel_rem_pio2f+0x3a4>
    7af4:	adds	r0, #4
    7af6:	vldr	s14, [r0]
    7afa:	vldmia	r1!, {s13}
    7afe:	adds	r2, #1
    7b00:	cmp	r6, r2
    7b02:	vfma.f32	s15, s13, s14
    7b06:	bge.n	7af0 <__kernel_rem_pio2f+0x38c>
    7b08:	sub.w	lr, lr, #4
    7b0c:	add	r2, sp, #344	; 0x158
    7b0e:	add.w	r2, r2, r5, lsl #2
    7b12:	cmp	ip, lr
    7b14:	vstr	s15, [r2, #-160]	; 0xffffff60
    7b18:	add.w	r5, r5, #1
    7b1c:	bne.n	7ada <__kernel_rem_pio2f+0x376>
    7b1e:	ldr	r2, [sp, #400]	; 0x190
    7b20:	cmp	r2, #3
    7b22:	bhi.w	7c82 <__kernel_rem_pio2f+0x51e>
    7b26:	tbb	[pc, r2]
    7b2a:	.short	0xb5dc
    7b2c:	.short	0x50b5
    7b2e:	bne.n	7b52 <__kernel_rem_pio2f+0x3ee>
    7b30:	subs	r3, r5, #1
    7b32:	add	r2, sp, #24
    7b34:	ldr.w	r1, [r2, r3, lsl #2]
    7b38:	asrs	r1, r1, #8
    7b3a:	b.n	78d4 <__kernel_rem_pio2f+0x170>
    7b3c:	subs	r2, r5, #1
    7b3e:	add	r3, sp, #24
    7b40:	add.w	lr, sp, #24
    7b44:	ldr.w	r3, [r3, r2, lsl #2]
    7b48:	and.w	r3, r3, #127	; 0x7f
    7b4c:	str.w	r3, [lr, r2, lsl #2]
    7b50:	b.n	7944 <__kernel_rem_pio2f+0x1e0>
    7b52:	vmov.f32	s15, #96	; 0x3f000000  0.5
    7b56:	vcmpe.f32	s18, s15
    7b5a:	vmrs	APSR_nzcv, fpscr
    7b5e:	bge.n	7b78 <__kernel_rem_pio2f+0x414>
    7b60:	movs	r1, #0
    7b62:	b.n	7948 <__kernel_rem_pio2f+0x1e4>
    7b64:	vldr	s15, [pc, #552]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7b68:	vstmia	r0!, {s15}
    7b6c:	cmp	r0, lr
    7b6e:	add.w	r5, r5, #1
    7b72:	bne.w	77e0 <__kernel_rem_pio2f+0x7c>
    7b76:	b.n	7810 <__kernel_rem_pio2f+0xac>
    7b78:	cmp	r5, #0
    7b7a:	add.w	fp, fp, #1
    7b7e:	it	gt
    7b80:	movgt	r1, #2
    7b82:	bgt.w	78e2 <__kernel_rem_pio2f+0x17e>
    7b86:	vmov.f32	s15, #112	; 0x3f800000  1.0
    7b8a:	vsub.f32	s18, s15, s18
    7b8e:	movs	r1, #2
    7b90:	b.n	7948 <__kernel_rem_pio2f+0x1e4>
    7b92:	add	r2, sp, #24
    7b94:	vmov	s19, fp
    7b98:	ldr.w	r2, [r2, lr, lsl #2]
    7b9c:	ldr.w	fp, [sp, #16]
    7ba0:	mov	r3, lr
    7ba2:	mov	r8, r1
    7ba4:	sub.w	sl, sl, #8
    7ba8:	cmp	r2, #0
    7baa:	bne.w	7a92 <__kernel_rem_pio2f+0x32e>
    7bae:	add.w	r2, lr, #1073741824	; 0x40000000
    7bb2:	subs	r2, #1
    7bb4:	add	r1, sp, #24
    7bb6:	add.w	r2, r1, r2, lsl #2
    7bba:	ldr.w	r1, [r2], #-4
    7bbe:	subs	r3, #1
    7bc0:	sub.w	sl, sl, #8
    7bc4:	cmp	r1, #0
    7bc6:	beq.n	7bba <__kernel_rem_pio2f+0x456>
    7bc8:	b.n	7a92 <__kernel_rem_pio2f+0x32e>
    7bca:	cmp	r3, #0
    7bcc:	ble.w	7d52 <__kernel_rem_pio2f+0x5ee>
    7bd0:	add.w	r2, r3, #1073741824	; 0x40000000
    7bd4:	subs	r2, #1
    7bd6:	lsls	r0, r2, #2
    7bd8:	add	r1, sp, #344	; 0x158
    7bda:	adds	r5, r1, r7
    7bdc:	adds	r4, r0, #4
    7bde:	add	r1, sp, #184	; 0xb8
    7be0:	adds	r0, #8
    7be2:	vldr	s14, [r5, #-160]	; 0xffffff60
    7be6:	add	r4, r1
    7be8:	add	r0, r1
    7bea:	add	r5, sp, #188	; 0xbc
    7bec:	vldmdb	r4!, {s15}
    7bf0:	vadd.f32	s13, s15, s14
    7bf4:	vsub.f32	s15, s15, s13
    7bf8:	vadd.f32	s15, s15, s14
    7bfc:	vmov.f32	s14, s13
    7c00:	vstmdb	r0!, {s15}
    7c04:	cmp	r0, r5
    7c06:	vstr	s13, [r4]
    7c0a:	bne.n	7bec <__kernel_rem_pio2f+0x488>
    7c0c:	cmp	r3, #1
    7c0e:	ble.w	7d52 <__kernel_rem_pio2f+0x5ee>
    7c12:	lsls	r2, r2, #2
    7c14:	add	r3, sp, #344	; 0x158
    7c16:	add	r7, r3
    7c18:	add.w	r0, r2, #8
    7c1c:	add	r3, sp, #184	; 0xb8
    7c1e:	add	r0, r3
    7c20:	adds	r2, #4
    7c22:	vldr	s14, [r7, #-160]	; 0xffffff60
    7c26:	add	r3, r2
    7c28:	add	r4, sp, #192	; 0xc0
    7c2a:	mov	r2, r0
    7c2c:	vldmdb	r3!, {s15}
    7c30:	vadd.f32	s13, s14, s15
    7c34:	vsub.f32	s15, s15, s13
    7c38:	vadd.f32	s15, s15, s14
    7c3c:	vmov.f32	s14, s13
    7c40:	vstmdb	r2!, {s15}
    7c44:	cmp	r4, r2
    7c46:	vstr	s13, [r3]
    7c4a:	bne.n	7c2c <__kernel_rem_pio2f+0x4c8>
    7c4c:	vldr	s15, [pc, #320]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7c50:	vldmdb	r0!, {s14}
    7c54:	cmp	r4, r0
    7c56:	vadd.f32	s15, s15, s14
    7c5a:	bne.n	7c50 <__kernel_rem_pio2f+0x4ec>
    7c5c:	mov	r3, r8
    7c5e:	cmp	r3, #0
    7c60:	beq.n	7d2e <__kernel_rem_pio2f+0x5ca>
    7c62:	vldr	s13, [sp, #184]	; 0xb8
    7c66:	vldr	s14, [sp, #188]	; 0xbc
    7c6a:	vneg.f32	s15, s15
    7c6e:	vneg.f32	s13, s13
    7c72:	vneg.f32	s14, s14
    7c76:	vstr	s15, [fp, #8]
    7c7a:	vstr	s13, [fp]
    7c7e:	vstr	s14, [fp, #4]
    7c82:	vmov	r3, s19
    7c86:	and.w	r0, r3, #7
    7c8a:	add	sp, #348	; 0x15c
    7c8c:	vpop	{d8-d9}
    7c90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7c94:	adds	r2, r7, #4
    7c96:	add	r0, sp, #184	; 0xb8
    7c98:	vldr	s15, [pc, #244]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7c9c:	add	r2, r0
    7c9e:	vldmdb	r2!, {s14}
    7ca2:	cmp	r2, r0
    7ca4:	vadd.f32	s15, s15, s14
    7ca8:	bne.n	7c9e <__kernel_rem_pio2f+0x53a>
    7caa:	mov	r2, r8
    7cac:	cbz	r2, 7d0e <__kernel_rem_pio2f+0x5aa>
    7cae:	vldr	s13, [sp, #184]	; 0xb8
    7cb2:	vneg.f32	s14, s15
    7cb6:	cmp	r3, #0
    7cb8:	vsub.f32	s15, s13, s15
    7cbc:	vstr	s14, [fp]
    7cc0:	ble.n	7cd8 <__kernel_rem_pio2f+0x574>
    7cc2:	add	r0, sp, #188	; 0xbc
    7cc4:	movs	r2, #1
    7cc6:	vldmia	r0!, {s14}
    7cca:	adds	r2, #1
    7ccc:	cmp	r3, r2
    7cce:	vadd.f32	s15, s15, s14
    7cd2:	bge.n	7cc6 <__kernel_rem_pio2f+0x562>
    7cd4:	mov	r3, r8
    7cd6:	cbz	r3, 7cdc <__kernel_rem_pio2f+0x578>
    7cd8:	vneg.f32	s15, s15
    7cdc:	vstr	s15, [fp, #4]
    7ce0:	b.n	7c82 <__kernel_rem_pio2f+0x51e>
    7ce2:	add	r2, sp, #344	; 0x158
    7ce4:	add	r2, r7
    7ce6:	vldr	s15, [pc, #168]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7cea:	subs	r2, #156	; 0x9c
    7cec:	vldmdb	r2!, {s14}
    7cf0:	subs	r3, #1
    7cf2:	adds	r1, r3, #1
    7cf4:	vadd.f32	s15, s15, s14
    7cf8:	bne.n	7cec <__kernel_rem_pio2f+0x588>
    7cfa:	mov	r3, r8
    7cfc:	cbz	r3, 7d02 <__kernel_rem_pio2f+0x59e>
    7cfe:	vneg.f32	s15, s15
    7d02:	vstr	s15, [fp]
    7d06:	b.n	7c82 <__kernel_rem_pio2f+0x51e>
    7d08:	vldr	s15, [pc, #132]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7d0c:	b.n	7b08 <__kernel_rem_pio2f+0x3a4>
    7d0e:	vldr	s14, [sp, #184]	; 0xb8
    7d12:	vstr	s15, [fp]
    7d16:	cmp	r3, #0
    7d18:	vsub.f32	s15, s14, s15
    7d1c:	bgt.n	7cc2 <__kernel_rem_pio2f+0x55e>
    7d1e:	vstr	s15, [fp, #4]
    7d22:	b.n	7c82 <__kernel_rem_pio2f+0x51e>
    7d24:	mov.w	lr, #1
    7d28:	b.n	799a <__kernel_rem_pio2f+0x236>
    7d2a:	movs	r0, #0
    7d2c:	b.n	791c <__kernel_rem_pio2f+0x1b8>
    7d2e:	ldr	r2, [sp, #184]	; 0xb8
    7d30:	ldr	r3, [sp, #188]	; 0xbc
    7d32:	vstr	s15, [fp, #8]
    7d36:	str.w	r2, [fp]
    7d3a:	str.w	r3, [fp, #4]
    7d3e:	b.n	7c82 <__kernel_rem_pio2f+0x51e>
    7d40:	vcvt.s32.f32	s0, s0
    7d44:	add	r1, sp, #24
    7d46:	vmov	r2, s0
    7d4a:	mov	r3, r5
    7d4c:	str.w	r2, [r1, r5, lsl #2]
    7d50:	b.n	7a92 <__kernel_rem_pio2f+0x32e>
    7d52:	vldr	s15, [pc, #60]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7d56:	b.n	7c5c <__kernel_rem_pio2f+0x4f8>
    7d58:	ldr	r2, [sp, #400]	; 0x190
    7d5a:	cmp	r2, #3
    7d5c:	bhi.n	7c82 <__kernel_rem_pio2f+0x51e>
    7d5e:	add	r1, pc, #4	; (adr r1, 7d64 <__kernel_rem_pio2f+0x600>)
    7d60:	ldr.w	pc, [r1, r2, lsl #2]
    7d64:	.word	0x00007d81
    7d68:	.word	0x00007d7b
    7d6c:	.word	0x00007d7b
    7d70:	.word	0x00007d53
    7d74:	ldr	r3, [sp, #4]
    7d76:	lsls	r4, r3, #2
    7d78:	b.n	7810 <__kernel_rem_pio2f+0xac>
    7d7a:	vldr	s15, [pc, #20]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7d7e:	b.n	7caa <__kernel_rem_pio2f+0x546>
    7d80:	vldr	s15, [pc, #12]	; 7d90 <__kernel_rem_pio2f+0x62c>
    7d84:	b.n	7cfa <__kernel_rem_pio2f+0x596>
    7d86:	nop
    7d88:	.word	0x20000ed4
    7d8c:	.word	0x3fc90000
    7d90:	.word	0x00000000

00007d94 <__kernel_sinf>:
    7d94:	vmov	r3, s0
    7d98:	bic.w	r3, r3, #2147483648	; 0x80000000
    7d9c:	cmp.w	r3, #838860800	; 0x32000000
    7da0:	bge.n	7dac <__kernel_sinf+0x18>
    7da2:	vcvt.s32.f32	s15, s0
    7da6:	vmov	r3, s15
    7daa:	cbz	r3, 7df6 <__kernel_sinf+0x62>
    7dac:	vmul.f32	s15, s0, s0
    7db0:	vldr	s10, [pc, #84]	; 7e08 <__kernel_sinf+0x74>
    7db4:	vldr	s11, [pc, #84]	; 7e0c <__kernel_sinf+0x78>
    7db8:	vldr	s12, [pc, #84]	; 7e10 <__kernel_sinf+0x7c>
    7dbc:	vldr	s13, [pc, #84]	; 7e14 <__kernel_sinf+0x80>
    7dc0:	vldr	s14, [pc, #84]	; 7e18 <__kernel_sinf+0x84>
    7dc4:	vfma.f32	s11, s15, s10
    7dc8:	vmul.f32	s10, s0, s15
    7dcc:	vfma.f32	s12, s15, s11
    7dd0:	vfma.f32	s13, s15, s12
    7dd4:	vfma.f32	s14, s15, s13
    7dd8:	cbz	r0, 7df8 <__kernel_sinf+0x64>
    7dda:	vnmul.f32	s14, s14, s10
    7dde:	vmov.f32	s13, #96	; 0x3f000000  0.5
    7de2:	vfma.f32	s14, s1, s13
    7de6:	vldr	s13, [pc, #52]	; 7e1c <__kernel_sinf+0x88>
    7dea:	vfnms.f32	s1, s15, s14
    7dee:	vfma.f32	s1, s10, s13
    7df2:	vsub.f32	s0, s0, s1
    7df6:	bx	lr
    7df8:	vldr	s13, [pc, #36]	; 7e20 <__kernel_sinf+0x8c>
    7dfc:	vfma.f32	s13, s15, s14
    7e00:	vfma.f32	s0, s10, s13
    7e04:	bx	lr
    7e06:	nop
    7e08:	.word	0x2f2ec9d3
    7e0c:	.word	0xb2d72f34
    7e10:	.word	0x3638ef1b
    7e14:	.word	0xb9500d01
    7e18:	.word	0x3c088889
    7e1c:	.word	0x3e2aaaab
    7e20:	.word	0xbe2aaaab
    7e24:	.word	0x00000000

00007e28 <atan>:
    7e28:	push	{r3, r4, r5, lr}
    7e2a:	vmov.f64	d7, d0
    7e2e:	vmov	r5, s15
    7e32:	ldr	r3, [pc, #476]	; (8010 <atan+0x1e8>)
    7e34:	bic.w	r4, r5, #2147483648	; 0x80000000
    7e38:	cmp	r4, r3
    7e3a:	ble.n	7e5a <atan+0x32>
    7e3c:	ldr	r3, [pc, #468]	; (8014 <atan+0x1ec>)
    7e3e:	cmp	r4, r3
    7e40:	vmov	r2, s0
    7e44:	bgt.n	7f00 <atan+0xd8>
    7e46:	beq.n	7efc <atan+0xd4>
    7e48:	vldr	d7, [pc, #340]	; 7fa0 <atan+0x178>
    7e4c:	vldr	d0, [pc, #344]	; 7fa8 <atan+0x180>
    7e50:	cmp	r5, #0
    7e52:	it	gt
    7e54:	vmovgt.f64	d0, d7
    7e58:	pop	{r3, r4, r5, pc}
    7e5a:	ldr	r3, [pc, #444]	; (8018 <atan+0x1f0>)
    7e5c:	cmp	r4, r3
    7e5e:	bgt.n	7f22 <atan+0xfa>
    7e60:	sub.w	r3, r3, #29097984	; 0x1bc0000
    7e64:	cmp	r4, r3
    7e66:	ble.n	7f06 <atan+0xde>
    7e68:	mov.w	r3, #4294967295
    7e6c:	vldr	d2, [pc, #320]	; 7fb0 <atan+0x188>
    7e70:	vmul.f64	d4, d7, d7
    7e74:	vmul.f64	d6, d4, d4
    7e78:	vldr	d3, [pc, #316]	; 7fb8 <atan+0x190>
    7e7c:	vldr	d5, [pc, #320]	; 7fc0 <atan+0x198>
    7e80:	vfma.f64	d3, d6, d2
    7e84:	vldr	d2, [pc, #320]	; 7fc8 <atan+0x1a0>
    7e88:	vfma.f64	d5, d6, d3
    7e8c:	vldr	d3, [pc, #320]	; 7fd0 <atan+0x1a8>
    7e90:	vfma.f64	d2, d6, d5
    7e94:	vldr	d5, [pc, #320]	; 7fd8 <atan+0x1b0>
    7e98:	vfma.f64	d3, d6, d2
    7e9c:	vldr	d1, [pc, #320]	; 7fe0 <atan+0x1b8>
    7ea0:	vfma.f64	d5, d6, d3
    7ea4:	vmul.f64	d5, d5, d4
    7ea8:	vldr	d2, [pc, #316]	; 7fe8 <atan+0x1c0>
    7eac:	vldr	d4, [pc, #320]	; 7ff0 <atan+0x1c8>
    7eb0:	vldr	d3, [pc, #324]	; 7ff8 <atan+0x1d0>
    7eb4:	vfma.f64	d4, d6, d1
    7eb8:	vfma.f64	d2, d6, d4
    7ebc:	vldr	d4, [pc, #320]	; 8000 <atan+0x1d8>
    7ec0:	vfma.f64	d3, d6, d2
    7ec4:	adds	r2, r3, #1
    7ec6:	vfma.f64	d4, d6, d3
    7eca:	vmul.f64	d6, d4, d6
    7ece:	beq.n	7f52 <atan+0x12a>
    7ed0:	vadd.f64	d5, d5, d6
    7ed4:	ldr	r2, [pc, #324]	; (801c <atan+0x1f4>)
    7ed6:	ldr	r1, [pc, #328]	; (8020 <atan+0x1f8>)
    7ed8:	lsls	r3, r3, #3
    7eda:	add	r2, r3
    7edc:	add	r3, r1
    7ede:	vldr	d6, [r2]
    7ee2:	vldr	d0, [r3]
    7ee6:	vfnms.f64	d6, d7, d5
    7eea:	vsub.f64	d7, d6, d7
    7eee:	cmp	r5, #0
    7ef0:	vsub.f64	d7, d0, d7
    7ef4:	blt.n	7f4c <atan+0x124>
    7ef6:	vmov.f64	d0, d7
    7efa:	pop	{r3, r4, r5, pc}
    7efc:	cmp	r2, #0
    7efe:	beq.n	7e48 <atan+0x20>
    7f00:	vadd.f64	d0, d7, d7
    7f04:	pop	{r3, r4, r5, pc}
    7f06:	vldr	d6, [pc, #256]	; 8008 <atan+0x1e0>
    7f0a:	vmov.f64	d5, #112	; 0x3f800000  1.0
    7f0e:	vadd.f64	d6, d0, d6
    7f12:	vcmpe.f64	d6, d5
    7f16:	vmrs	APSR_nzcv, fpscr
    7f1a:	ble.n	7e68 <atan+0x40>
    7f1c:	vmov.f64	d0, d7
    7f20:	pop	{r3, r4, r5, pc}
    7f22:	bl	802c <fabs>
    7f26:	ldr	r3, [pc, #252]	; (8024 <atan+0x1fc>)
    7f28:	cmp	r4, r3
    7f2a:	bgt.n	7f60 <atan+0x138>
    7f2c:	sub.w	r3, r3, #851968	; 0xd0000
    7f30:	cmp	r4, r3
    7f32:	bgt.n	7f8a <atan+0x162>
    7f34:	vmov.f64	d7, #0	; 0x40000000  2.0
    7f38:	vmov.f64	d6, #240	; 0xbf800000 -1.0
    7f3c:	vadd.f64	d5, d0, d7
    7f40:	vfma.f64	d6, d0, d7
    7f44:	movs	r3, #0
    7f46:	vdiv.f64	d7, d6, d5
    7f4a:	b.n	7e6c <atan+0x44>
    7f4c:	vneg.f64	d0, d7
    7f50:	pop	{r3, r4, r5, pc}
    7f52:	vadd.f64	d6, d5, d6
    7f56:	vfms.f64	d7, d7, d6
    7f5a:	vmov.f64	d0, d7
    7f5e:	pop	{r3, r4, r5, pc}
    7f60:	ldr	r3, [pc, #196]	; (8028 <atan+0x200>)
    7f62:	cmp	r4, r3
    7f64:	bgt.n	7f7e <atan+0x156>
    7f66:	vmov.f64	d7, #120	; 0x3fc00000  1.5
    7f6a:	vmov.f64	d6, #112	; 0x3f800000  1.0
    7f6e:	vsub.f64	d5, d0, d7
    7f72:	vfma.f64	d6, d0, d7
    7f76:	movs	r3, #2
    7f78:	vdiv.f64	d7, d5, d6
    7f7c:	b.n	7e6c <atan+0x44>
    7f7e:	vmov.f64	d6, #240	; 0xbf800000 -1.0
    7f82:	movs	r3, #3
    7f84:	vdiv.f64	d7, d6, d0
    7f88:	b.n	7e6c <atan+0x44>
    7f8a:	vmov.f64	d7, #112	; 0x3f800000  1.0
    7f8e:	movs	r3, #1
    7f90:	vsub.f64	d6, d0, d7
    7f94:	vadd.f64	d0, d0, d7
    7f98:	vdiv.f64	d7, d6, d0
    7f9c:	b.n	7e6c <atan+0x44>
    7f9e:	nop
    7fa0:	.word	0x54442d18
    7fa4:	.word	0x3ff921fb
    7fa8:	.word	0x54442d18
    7fac:	.word	0xbff921fb
    7fb0:	.word	0xe322da11
    7fb4:	.word	0x3f90ad3a
    7fb8:	.word	0x24760deb
    7fbc:	.word	0x3fa97b4b
    7fc0:	.word	0xa0d03d51
    7fc4:	.word	0x3fb10d66
    7fc8:	.word	0xc54c206e
    7fcc:	.word	0x3fb745cd
    7fd0:	.word	0x920083ff
    7fd4:	.word	0x3fc24924
    7fd8:	.word	0x5555550d
    7fdc:	.word	0x3fd55555
    7fe0:	.word	0x2c6a6c2f
    7fe4:	.word	0xbfa2b444
    7fe8:	.word	0xaf749a6d
    7fec:	.word	0xbfb3b0f2
    7ff0:	.word	0x52defd9a
    7ff4:	.word	0xbfadde2d
    7ff8:	.word	0xfe231671
    7ffc:	.word	0xbfbc71c6
    8000:	.word	0x9998ebc4
    8004:	.word	0xbfc99999
    8008:	.word	0x8800759c
    800c:	.word	0x7e37e43c
    8010:	.word	0x440fffff
    8014:	.word	0x7ff00000
    8018:	.word	0x3fdbffff
    801c:	.word	0x20000f00
    8020:	.word	0x20000f20
    8024:	.word	0x3ff2ffff
    8028:	.word	0x40037fff

0000802c <fabs>:
    802c:	vmov	r2, r3, d0
    8030:	bic.w	r3, r3, #2147483648	; 0x80000000
    8034:	vmov	d0, r2, r3
    8038:	bx	lr
    803a:	nop

0000803c <finite>:
    803c:	vmov	r3, s1
    8040:	orr.w	r0, r3, #2147483648	; 0x80000000
    8044:	add.w	r0, r0, #1048576	; 0x100000
    8048:	lsrs	r0, r0, #31
    804a:	bx	lr
    804c:	movs	r0, r0
	...

00008050 <floor>:
    8050:	push	{r4, r5, r6}
    8052:	sub	sp, #12
    8054:	vstr	d0, [sp]
    8058:	ldr	r1, [sp, #4]
    805a:	ldr	r4, [sp, #0]
    805c:	ubfx	r2, r1, #20, #11
    8060:	subw	r3, r2, #1023	; 0x3ff
    8064:	cmp	r3, #19
    8066:	mov	r5, r1
    8068:	mov	r0, r4
    806a:	bgt.n	80aa <floor+0x5a>
    806c:	cmp	r3, #0
    806e:	blt.n	80f8 <floor+0xa8>
    8070:	ldr	r2, [pc, #236]	; (8160 <floor+0x110>)
    8072:	asrs	r2, r3
    8074:	and.w	r6, r1, r2
    8078:	orrs	r4, r6
    807a:	beq.n	80b4 <floor+0x64>
    807c:	vldr	d7, [pc, #216]	; 8158 <floor+0x108>
    8080:	vldr	d6, [sp]
    8084:	vadd.f64	d7, d6, d7
    8088:	vcmpe.f64	d7, #0.0
    808c:	vmrs	APSR_nzcv, fpscr
    8090:	ble.n	809c <floor+0x4c>
    8092:	cmp	r1, #0
    8094:	blt.n	811e <floor+0xce>
    8096:	bic.w	r1, r5, r2
    809a:	movs	r0, #0
    809c:	mov	r3, r1
    809e:	mov	r2, r0
    80a0:	vmov	d0, r2, r3
    80a4:	add	sp, #12
    80a6:	pop	{r4, r5, r6}
    80a8:	bx	lr
    80aa:	cmp	r3, #51	; 0x33
    80ac:	ble.n	80be <floor+0x6e>
    80ae:	cmp.w	r3, #1024	; 0x400
    80b2:	beq.n	8114 <floor+0xc4>
    80b4:	vldr	d0, [sp]
    80b8:	add	sp, #12
    80ba:	pop	{r4, r5, r6}
    80bc:	bx	lr
    80be:	subw	r2, r2, #1043	; 0x413
    80c2:	mov.w	r4, #4294967295
    80c6:	lsr.w	r2, r4, r2
    80ca:	tst	r0, r2
    80cc:	beq.n	80b4 <floor+0x64>
    80ce:	vldr	d7, [pc, #136]	; 8158 <floor+0x108>
    80d2:	vldr	d6, [sp]
    80d6:	vadd.f64	d7, d6, d7
    80da:	vcmpe.f64	d7, #0.0
    80de:	vmrs	APSR_nzcv, fpscr
    80e2:	ble.n	809c <floor+0x4c>
    80e4:	cmp	r1, #0
    80e6:	blt.n	812a <floor+0xda>
    80e8:	mov	r1, r5
    80ea:	bic.w	r0, r0, r2
    80ee:	mov	r3, r1
    80f0:	mov	r2, r0
    80f2:	vmov	d0, r2, r3
    80f6:	b.n	80a4 <floor+0x54>
    80f8:	vldr	d7, [pc, #92]	; 8158 <floor+0x108>
    80fc:	vadd.f64	d7, d0, d7
    8100:	vcmpe.f64	d7, #0.0
    8104:	vmrs	APSR_nzcv, fpscr
    8108:	ble.n	809c <floor+0x4c>
    810a:	cmp	r1, #0
    810c:	blt.n	8140 <floor+0xf0>
    810e:	movs	r0, #0
    8110:	mov	r1, r0
    8112:	b.n	809c <floor+0x4c>
    8114:	vldr	d7, [sp]
    8118:	vadd.f64	d0, d7, d7
    811c:	b.n	80b8 <floor+0x68>
    811e:	mov.w	r1, #1048576	; 0x100000
    8122:	asr.w	r3, r1, r3
    8126:	add	r5, r3
    8128:	b.n	8096 <floor+0x46>
    812a:	cmp	r3, #20
    812c:	beq.n	8150 <floor+0x100>
    812e:	movs	r1, #1
    8130:	rsb	r3, r3, #52	; 0x34
    8134:	lsl.w	r3, r1, r3
    8138:	adds	r0, r3, r0
    813a:	it	cs
    813c:	addcs	r5, r5, r1
    813e:	b.n	80e8 <floor+0x98>
    8140:	bic.w	r2, r1, #2147483648	; 0x80000000
    8144:	ldr	r3, [pc, #28]	; (8164 <floor+0x114>)
    8146:	orrs	r2, r4
    8148:	it	ne
    814a:	movne	r1, r3
    814c:	movs	r0, #0
    814e:	b.n	809c <floor+0x4c>
    8150:	adds	r5, #1
    8152:	b.n	80e8 <floor+0x98>
    8154:	nop.w
    8158:	.word	0x8800759c
    815c:	.word	0x7e37e43c
    8160:	.word	0x000fffff
    8164:	.word	0xbff00000

00008168 <matherr>:
    8168:	movs	r0, #0
    816a:	bx	lr
    816c:	movs	r0, r0
	...

00008170 <nan>:
    8170:	vldr	d0, [pc, #4]	; 8178 <nan+0x8>
    8174:	bx	lr
    8176:	nop
    8178:	.word	0x00000000
    817c:	.word	0x7ff80000

00008180 <rint>:
    8180:	push	{r4, r5, r6, r7}
    8182:	vmov	r2, r3, d0
    8186:	ubfx	r5, r3, #20, #11
    818a:	subw	r0, r5, #1023	; 0x3ff
    818e:	cmp	r0, #19
    8190:	sub	sp, #16
    8192:	mov	r1, r3
    8194:	mov.w	r7, r3, lsr #31
    8198:	vmov	r4, s0
    819c:	bgt.n	81f8 <rint+0x78>
    819e:	cmp	r0, #0
    81a0:	blt.n	8232 <rint+0xb2>
    81a2:	ldr	r5, [pc, #240]	; (8294 <rint+0x114>)
    81a4:	asrs	r5, r0
    81a6:	and.w	r6, r3, r5
    81aa:	orrs	r6, r2
    81ac:	beq.n	8202 <rint+0x82>
    81ae:	lsrs	r5, r5, #1
    81b0:	ands	r3, r5
    81b2:	orrs	r4, r3
    81b4:	beq.n	81d0 <rint+0x50>
    81b6:	mov.w	r3, #262144	; 0x40000
    81ba:	cmp	r0, #19
    81bc:	bic.w	r5, r1, r5
    81c0:	asr.w	r1, r3, r0
    81c4:	orr.w	r1, r1, r5
    81c8:	ite	eq
    81ca:	moveq.w	r4, #2147483648	; 0x80000000
    81ce:	movne	r4, #0
    81d0:	ldr	r0, [pc, #196]	; (8298 <rint+0x118>)
    81d2:	add.w	r7, r0, r7, lsl #3
    81d6:	vldr	d0, [r7]
    81da:	mov	r3, r1
    81dc:	mov	r2, r4
    81de:	vmov	d7, r2, r3
    81e2:	vadd.f64	d7, d7, d0
    81e6:	vstr	d7, [sp, #8]
    81ea:	vldr	d7, [sp, #8]
    81ee:	vsub.f64	d0, d7, d0
    81f2:	add	sp, #16
    81f4:	pop	{r4, r5, r6, r7}
    81f6:	bx	lr
    81f8:	cmp	r0, #51	; 0x33
    81fa:	ble.n	820c <rint+0x8c>
    81fc:	cmp.w	r0, #1024	; 0x400
    8200:	beq.n	828c <rint+0x10c>
    8202:	vmov	d0, r2, r3
    8206:	add	sp, #16
    8208:	pop	{r4, r5, r6, r7}
    820a:	bx	lr
    820c:	subw	r5, r5, #1043	; 0x413
    8210:	mov.w	r0, #4294967295
    8214:	lsrs	r0, r5
    8216:	tst	r2, r0
    8218:	beq.n	8202 <rint+0x82>
    821a:	lsrs	r0, r0, #1
    821c:	tst	r2, r0
    821e:	beq.n	81d0 <rint+0x50>
    8220:	mov.w	r3, #1073741824	; 0x40000000
    8224:	bic.w	r0, r4, r0
    8228:	asr.w	r5, r3, r5
    822c:	orr.w	r4, r5, r0
    8230:	b.n	81d0 <rint+0x50>
    8232:	bic.w	r0, r3, #2147483648	; 0x80000000
    8236:	orrs	r0, r2
    8238:	vmov	r6, s0
    823c:	beq.n	8202 <rint+0x82>
    823e:	ubfx	r0, r3, #0, #20
    8242:	orrs	r6, r0
    8244:	negs	r0, r6
    8246:	orrs	r6, r0
    8248:	ldr	r0, [pc, #76]	; (8298 <rint+0x118>)
    824a:	lsrs	r1, r3, #17
    824c:	lsrs	r6, r6, #12
    824e:	lsls	r1, r1, #17
    8250:	and.w	r6, r6, #524288	; 0x80000
    8254:	add.w	r0, r0, r7, lsl #3
    8258:	orr.w	r3, r6, r1
    825c:	vldr	d6, [r0]
    8260:	vmov	d7, r2, r3
    8264:	vadd.f64	d7, d7, d6
    8268:	vstr	d7, [sp, #8]
    826c:	vldr	d7, [sp, #8]
    8270:	vsub.f64	d7, d7, d6
    8274:	vstr	d7, [sp]
    8278:	ldr	r1, [sp, #4]
    827a:	ldrd	r2, r3, [sp]
    827e:	bic.w	r1, r1, #2147483648	; 0x80000000
    8282:	orr.w	r3, r1, r7, lsl #31
    8286:	vmov	d0, r2, r3
    828a:	b.n	8206 <rint+0x86>
    828c:	vadd.f64	d0, d0, d0
    8290:	b.n	8206 <rint+0x86>
    8292:	nop
    8294:	.word	0x000fffff
    8298:	.word	0x20000f40
    829c:	.word	0x00000000

000082a0 <scalbn>:
    82a0:	push	{r4, lr}
    82a2:	vpush	{d8}
    82a6:	sub	sp, #8
    82a8:	vstr	d0, [sp]
    82ac:	ldr	r3, [sp, #4]
    82ae:	ldr	r1, [sp, #0]
    82b0:	ubfx	r2, r3, #20, #11
    82b4:	cbnz	r2, 8302 <scalbn+0x62>
    82b6:	bic.w	r3, r3, #2147483648	; 0x80000000
    82ba:	orrs	r3, r1
    82bc:	beq.n	831a <scalbn+0x7a>
    82be:	vldr	d7, [pc, #216]	; 8398 <scalbn+0xf8>
    82c2:	ldr	r2, [pc, #244]	; (83b8 <scalbn+0x118>)
    82c4:	vmul.f64	d7, d0, d7
    82c8:	cmp	r0, r2
    82ca:	vstr	d7, [sp]
    82ce:	ldr	r3, [sp, #4]
    82d0:	blt.n	8326 <scalbn+0x86>
    82d2:	ubfx	r2, r3, #20, #11
    82d6:	subs	r2, #54	; 0x36
    82d8:	adds	r4, r0, r2
    82da:	movw	r2, #2046	; 0x7fe
    82de:	cmp	r4, r2
    82e0:	bgt.n	8344 <scalbn+0xa4>
    82e2:	cmp	r4, #0
    82e4:	ble.n	8336 <scalbn+0x96>
    82e6:	bic.w	r1, r3, #2139095040	; 0x7f800000
    82ea:	ldrd	r2, r3, [sp]
    82ee:	bic.w	r1, r1, #7340032	; 0x700000
    82f2:	orr.w	r3, r1, r4, lsl #20
    82f6:	vmov	d0, r2, r3
    82fa:	add	sp, #8
    82fc:	vpop	{d8}
    8300:	pop	{r4, pc}
    8302:	movw	r1, #2047	; 0x7ff
    8306:	cmp	r2, r1
    8308:	bne.n	82d8 <scalbn+0x38>
    830a:	vldr	d7, [sp]
    830e:	vadd.f64	d0, d7, d7
    8312:	add	sp, #8
    8314:	vpop	{d8}
    8318:	pop	{r4, pc}
    831a:	vldr	d0, [sp]
    831e:	add	sp, #8
    8320:	vpop	{d8}
    8324:	pop	{r4, pc}
    8326:	vldr	d0, [pc, #120]	; 83a0 <scalbn+0x100>
    832a:	vmul.f64	d0, d7, d0
    832e:	add	sp, #8
    8330:	vpop	{d8}
    8334:	pop	{r4, pc}
    8336:	cmn.w	r4, #53	; 0x35
    833a:	bge.n	8360 <scalbn+0xc0>
    833c:	movw	r3, #50000	; 0xc350
    8340:	cmp	r0, r3
    8342:	ble.n	8380 <scalbn+0xe0>
    8344:	vldr	d8, [pc, #96]	; 83a8 <scalbn+0x108>
    8348:	vldr	d1, [sp]
    834c:	vmov.f64	d0, d8
    8350:	bl	86e4 <copysign>
    8354:	vmul.f64	d0, d0, d8
    8358:	add	sp, #8
    835a:	vpop	{d8}
    835e:	pop	{r4, pc}
    8360:	bic.w	r1, r3, #2139095040	; 0x7f800000
    8364:	ldrd	r2, r3, [sp]
    8368:	bic.w	r1, r1, #7340032	; 0x700000
    836c:	adds	r4, #54	; 0x36
    836e:	orr.w	r3, r1, r4, lsl #20
    8372:	vldr	d0, [pc, #60]	; 83b0 <scalbn+0x110>
    8376:	vmov	d7, r2, r3
    837a:	vmul.f64	d0, d7, d0
    837e:	b.n	82fa <scalbn+0x5a>
    8380:	vldr	d8, [pc, #28]	; 83a0 <scalbn+0x100>
    8384:	vldr	d1, [sp]
    8388:	vmov.f64	d0, d8
    838c:	bl	86e4 <copysign>
    8390:	vmul.f64	d0, d0, d8
    8394:	b.n	82fa <scalbn+0x5a>
    8396:	nop
    8398:	.word	0x00000000
    839c:	.word	0x43500000
    83a0:	.word	0xc2f8f359
    83a4:	.word	0x01a56e1f
    83a8:	.word	0x8800759c
    83ac:	.word	0x7e37e43c
    83b0:	.word	0x00000000
    83b4:	.word	0x3c900000
    83b8:	.word	0xffff3cb0

000083bc <atanf>:
    83bc:	push	{r3, r4, r5, lr}
    83be:	vmov	r5, s0
    83c2:	bic.w	r4, r5, #2147483648	; 0x80000000
    83c6:	cmp.w	r4, #1350565888	; 0x50800000
    83ca:	vmov.f32	s15, s0
    83ce:	blt.n	83e8 <atanf+0x2c>
    83d0:	cmp.w	r4, #2139095040	; 0x7f800000
    83d4:	bgt.n	8488 <atanf+0xcc>
    83d6:	vldr	s15, [pc, #336]	; 8528 <atanf+0x16c>
    83da:	vldr	s0, [pc, #336]	; 852c <atanf+0x170>
    83de:	cmp	r5, #0
    83e0:	it	gt
    83e2:	vmovgt.f32	s0, s15
    83e6:	pop	{r3, r4, r5, pc}
    83e8:	ldr	r3, [pc, #324]	; (8530 <atanf+0x174>)
    83ea:	cmp	r4, r3
    83ec:	bgt.n	84aa <atanf+0xee>
    83ee:	cmp.w	r4, #822083584	; 0x31000000
    83f2:	blt.n	848e <atanf+0xd2>
    83f4:	mov.w	r3, #4294967295
    83f8:	vmul.f32	s11, s15, s15
    83fc:	vldr	s2, [pc, #308]	; 8534 <atanf+0x178>
    8400:	vldr	s4, [pc, #308]	; 8538 <atanf+0x17c>
    8404:	vldr	s6, [pc, #308]	; 853c <atanf+0x180>
    8408:	vldr	s3, [pc, #308]	; 8540 <atanf+0x184>
    840c:	vldr	s5, [pc, #308]	; 8544 <atanf+0x188>
    8410:	vldr	s8, [pc, #308]	; 8548 <atanf+0x18c>
    8414:	vldr	s7, [pc, #308]	; 854c <atanf+0x190>
    8418:	vldr	s10, [pc, #308]	; 8550 <atanf+0x194>
    841c:	vldr	s9, [pc, #308]	; 8554 <atanf+0x198>
    8420:	vldr	s12, [pc, #308]	; 8558 <atanf+0x19c>
    8424:	vldr	s13, [pc, #308]	; 855c <atanf+0x1a0>
    8428:	vmul.f32	s14, s11, s11
    842c:	adds	r2, r3, #1
    842e:	vfma.f32	s4, s14, s2
    8432:	vfma.f32	s5, s14, s3
    8436:	vfma.f32	s6, s14, s4
    843a:	vfma.f32	s7, s14, s5
    843e:	vfma.f32	s8, s14, s6
    8442:	vfma.f32	s9, s14, s7
    8446:	vfma.f32	s10, s14, s8
    844a:	vfma.f32	s13, s14, s9
    844e:	vfma.f32	s12, s14, s10
    8452:	vmul.f32	s14, s13, s14
    8456:	vmul.f32	s13, s12, s11
    845a:	beq.n	84da <atanf+0x11e>
    845c:	ldr	r2, [pc, #256]	; (8560 <atanf+0x1a4>)
    845e:	ldr	r1, [pc, #260]	; (8564 <atanf+0x1a8>)
    8460:	lsls	r3, r3, #2
    8462:	add	r2, r3
    8464:	vadd.f32	s13, s13, s14
    8468:	vldr	s14, [r2]
    846c:	vfnms.f32	s14, s15, s13
    8470:	add	r3, r1
    8472:	cmp	r5, #0
    8474:	vldr	s0, [r3]
    8478:	vsub.f32	s15, s14, s15
    847c:	vsub.f32	s15, s0, s15
    8480:	blt.n	84d4 <atanf+0x118>
    8482:	vmov.f32	s0, s15
    8486:	pop	{r3, r4, r5, pc}
    8488:	vadd.f32	s0, s0, s0
    848c:	pop	{r3, r4, r5, pc}
    848e:	vldr	s14, [pc, #216]	; 8568 <atanf+0x1ac>
    8492:	vadd.f32	s14, s0, s14
    8496:	vmov.f32	s13, #112	; 0x3f800000  1.0
    849a:	vcmpe.f32	s14, s13
    849e:	vmrs	APSR_nzcv, fpscr
    84a2:	ble.n	83f4 <atanf+0x38>
    84a4:	vmov.f32	s0, s15
    84a8:	pop	{r3, r4, r5, pc}
    84aa:	bl	8574 <fabsf>
    84ae:	ldr	r3, [pc, #188]	; (856c <atanf+0x1b0>)
    84b0:	cmp	r4, r3
    84b2:	bgt.n	84e8 <atanf+0x12c>
    84b4:	sub.w	r3, r3, #6815744	; 0x680000
    84b8:	cmp	r4, r3
    84ba:	bgt.n	8512 <atanf+0x156>
    84bc:	vmov.f32	s15, #0	; 0x40000000  2.0
    84c0:	vmov.f32	s14, #240	; 0xbf800000 -1.0
    84c4:	vfma.f32	s14, s0, s15
    84c8:	movs	r3, #0
    84ca:	vadd.f32	s0, s0, s15
    84ce:	vdiv.f32	s15, s14, s0
    84d2:	b.n	83f8 <atanf+0x3c>
    84d4:	vneg.f32	s0, s15
    84d8:	pop	{r3, r4, r5, pc}
    84da:	vadd.f32	s13, s13, s14
    84de:	vfms.f32	s15, s15, s13
    84e2:	vmov.f32	s0, s15
    84e6:	pop	{r3, r4, r5, pc}
    84e8:	ldr	r3, [pc, #132]	; (8570 <atanf+0x1b4>)
    84ea:	cmp	r4, r3
    84ec:	bgt.n	8506 <atanf+0x14a>
    84ee:	vmov.f32	s15, #120	; 0x3fc00000  1.5
    84f2:	vmov.f32	s14, #112	; 0x3f800000  1.0
    84f6:	vfma.f32	s14, s0, s15
    84fa:	movs	r3, #2
    84fc:	vsub.f32	s0, s0, s15
    8500:	vdiv.f32	s15, s0, s14
    8504:	b.n	83f8 <atanf+0x3c>
    8506:	vmov.f32	s14, #240	; 0xbf800000 -1.0
    850a:	vdiv.f32	s15, s14, s0
    850e:	movs	r3, #3
    8510:	b.n	83f8 <atanf+0x3c>
    8512:	vmov.f32	s15, #112	; 0x3f800000  1.0
    8516:	vsub.f32	s14, s0, s15
    851a:	vadd.f32	s0, s0, s15
    851e:	movs	r3, #1
    8520:	vdiv.f32	s15, s14, s0
    8524:	b.n	83f8 <atanf+0x3c>
    8526:	nop
    8528:	.word	0x3fc90fdb
    852c:	.word	0xbfc90fdb
    8530:	.word	0x3edfffff
    8534:	.word	0x3c8569d7
    8538:	.word	0x3d4bda59
    853c:	.word	0x3d886b35
    8540:	.word	0xbd15a221
    8544:	.word	0xbd6ef16b
    8548:	.word	0x3dba2e6e
    854c:	.word	0xbd9d8795
    8550:	.word	0x3e124925
    8554:	.word	0xbde38e38
    8558:	.word	0x3eaaaaab
    855c:	.word	0xbe4ccccd
    8560:	.word	0x20000f50
    8564:	.word	0x20000f60
    8568:	.word	0x7149f2ca
    856c:	.word	0x3f97ffff
    8570:	.word	0x401bffff

00008574 <fabsf>:
    8574:	vmov	r3, s0
    8578:	bic.w	r3, r3, #2147483648	; 0x80000000
    857c:	vmov	s0, r3
    8580:	bx	lr
    8582:	nop

00008584 <floorf>:
    8584:	vmov	r2, s0
    8588:	bic.w	r1, r2, #2147483648	; 0x80000000
    858c:	lsrs	r3, r1, #23
    858e:	subs	r3, #127	; 0x7f
    8590:	cmp	r3, #22
    8592:	bgt.n	85c4 <floorf+0x40>
    8594:	cmp	r3, #0
    8596:	vmov	r0, s0
    859a:	blt.n	85d0 <floorf+0x4c>
    859c:	ldr	r1, [pc, #104]	; (8608 <floorf+0x84>)
    859e:	asrs	r1, r3
    85a0:	tst	r2, r1
    85a2:	beq.n	85ea <floorf+0x66>
    85a4:	vldr	s15, [pc, #100]	; 860c <floorf+0x88>
    85a8:	vadd.f32	s15, s0, s15
    85ac:	vcmpe.f32	s15, #0.0
    85b0:	vmrs	APSR_nzcv, fpscr
    85b4:	ble.n	85ea <floorf+0x66>
    85b6:	cmp	r2, #0
    85b8:	blt.n	85ec <floorf+0x68>
    85ba:	bic.w	r3, r0, r1
    85be:	vmov	s0, r3
    85c2:	bx	lr
    85c4:	cmp.w	r1, #2139095040	; 0x7f800000
    85c8:	bcc.n	85ea <floorf+0x66>
    85ca:	vadd.f32	s0, s0, s0
    85ce:	bx	lr
    85d0:	vldr	s15, [pc, #56]	; 860c <floorf+0x88>
    85d4:	vadd.f32	s15, s0, s15
    85d8:	vcmpe.f32	s15, #0.0
    85dc:	vmrs	APSR_nzcv, fpscr
    85e0:	ble.n	85ea <floorf+0x66>
    85e2:	cmp	r2, #0
    85e4:	blt.n	85f8 <floorf+0x74>
    85e6:	vldr	s0, [pc, #40]	; 8610 <floorf+0x8c>
    85ea:	bx	lr
    85ec:	mov.w	r2, #8388608	; 0x800000
    85f0:	asr.w	r3, r2, r3
    85f4:	add	r0, r3
    85f6:	b.n	85ba <floorf+0x36>
    85f8:	cmp	r1, #0
    85fa:	vmov.f32	s15, #240	; 0xbf800000 -1.0
    85fe:	it	ne
    8600:	vmovne.f32	s0, s15
    8604:	bx	lr
    8606:	nop
    8608:	.word	0x007fffff
    860c:	.word	0x7149f2ca
    8610:	.word	0x00000000

00008614 <scalbnf>:
    8614:	push	{r3, lr}
    8616:	vmov	r3, s0
    861a:	bics.w	r2, r3, #2147483648	; 0x80000000
    861e:	vpush	{d8}
    8622:	beq.n	8648 <scalbnf+0x34>
    8624:	cmp.w	r2, #2139095040	; 0x7f800000
    8628:	bcs.n	864e <scalbnf+0x3a>
    862a:	cmp.w	r2, #8388608	; 0x800000
    862e:	bcc.n	8658 <scalbnf+0x44>
    8630:	lsrs	r2, r2, #23
    8632:	add	r2, r0
    8634:	cmp	r2, #254	; 0xfe
    8636:	bgt.n	8696 <scalbnf+0x82>
    8638:	cmp	r2, #0
    863a:	ble.n	8672 <scalbnf+0x5e>
    863c:	bic.w	r3, r3, #2139095040	; 0x7f800000
    8640:	orr.w	r3, r3, r2, lsl #23
    8644:	vmov	s0, r3
    8648:	vpop	{d8}
    864c:	pop	{r3, pc}
    864e:	vpop	{d8}
    8652:	vadd.f32	s0, s0, s0
    8656:	pop	{r3, pc}
    8658:	ldr	r3, [pc, #116]	; (86d0 <scalbnf+0xbc>)
    865a:	vldr	s15, [pc, #120]	; 86d4 <scalbnf+0xc0>
    865e:	cmp	r0, r3
    8660:	vmul.f32	s0, s0, s15
    8664:	blt.n	86ac <scalbnf+0x98>
    8666:	vmov	r3, s0
    866a:	ubfx	r2, r3, #23, #8
    866e:	subs	r2, #25
    8670:	b.n	8632 <scalbnf+0x1e>
    8672:	cmn.w	r2, #22
    8676:	bge.n	86b6 <scalbnf+0xa2>
    8678:	movw	r3, #50000	; 0xc350
    867c:	cmp	r0, r3
    867e:	bgt.n	8696 <scalbnf+0x82>
    8680:	vldr	s16, [pc, #84]	; 86d8 <scalbnf+0xc4>
    8684:	vmov.f32	s1, s0
    8688:	vmov.f32	s0, s16
    868c:	bl	8700 <copysignf>
    8690:	vmul.f32	s0, s0, s16
    8694:	b.n	8648 <scalbnf+0x34>
    8696:	vldr	s16, [pc, #68]	; 86dc <scalbnf+0xc8>
    869a:	vmov.f32	s1, s0
    869e:	vmov.f32	s0, s16
    86a2:	bl	8700 <copysignf>
    86a6:	vmul.f32	s0, s0, s16
    86aa:	b.n	8648 <scalbnf+0x34>
    86ac:	vldr	s1, [pc, #40]	; 86d8 <scalbnf+0xc4>
    86b0:	vmul.f32	s0, s0, s1
    86b4:	b.n	8648 <scalbnf+0x34>
    86b6:	adds	r2, #25
    86b8:	bic.w	r3, r3, #2139095040	; 0x7f800000
    86bc:	orr.w	r3, r3, r2, lsl #23
    86c0:	vldr	s15, [pc, #28]	; 86e0 <scalbnf+0xcc>
    86c4:	vmov	s0, r3
    86c8:	vmul.f32	s0, s0, s15
    86cc:	b.n	8648 <scalbnf+0x34>
    86ce:	nop
    86d0:	.word	0xffff3cb0
    86d4:	.word	0x4c000000
    86d8:	.word	0x0da24260
    86dc:	.word	0x7149f2ca
    86e0:	.word	0x33000000

000086e4 <copysign>:
    86e4:	vmov	r2, r3, d0
    86e8:	vmov	r0, s3
    86ec:	bic.w	r1, r3, #2147483648	; 0x80000000
    86f0:	and.w	r0, r0, #2147483648	; 0x80000000
    86f4:	orr.w	r3, r1, r0
    86f8:	vmov	d0, r2, r3
    86fc:	bx	lr
    86fe:	nop

00008700 <copysignf>:
    8700:	vmov	r3, s0
    8704:	bic.w	r2, r3, #2147483648	; 0x80000000
    8708:	vmov	r3, s1
    870c:	and.w	r3, r3, #2147483648	; 0x80000000
    8710:	orrs	r3, r2
    8712:	vmov	s0, r3
    8716:	bx	lr

00008718 <__assert_func>:
    8718:	push	{lr}
    871a:	ldr	r4, [pc, #40]	; (8744 <__assert_func+0x2c>)
    871c:	ldr	r6, [r4, #0]
    871e:	mov	r5, r0
    8720:	sub	sp, #20
    8722:	mov	r4, r3
    8724:	ldr	r0, [r6, #12]
    8726:	cbz	r2, 873e <__assert_func+0x26>
    8728:	ldr	r3, [pc, #28]	; (8748 <__assert_func+0x30>)
    872a:	str	r2, [sp, #8]
    872c:	stmia.w	sp, {r1, r3}
    8730:	mov	r2, r4
    8732:	mov	r3, r5
    8734:	ldr	r1, [pc, #20]	; (874c <__assert_func+0x34>)
    8736:	bl	8760 <fiprintf>
    873a:	bl	3024 <abort>
    873e:	ldr	r3, [pc, #16]	; (8750 <__assert_func+0x38>)
    8740:	mov	r2, r3
    8742:	b.n	872a <__assert_func+0x12>
    8744:	.word	0x200016d0
    8748:	.word	0x20000f70
    874c:	.word	0x20000f80
    8750:	.word	0x20000f7c

00008754 <__errno>:
    8754:	ldr	r3, [pc, #4]	; (875c <__errno+0x8>)
    8756:	ldr	r0, [r3, #0]
    8758:	bx	lr
    875a:	nop
    875c:	.word	0x200016d0

00008760 <fiprintf>:
    8760:	push	{r1, r2, r3}
    8762:	push	{r4, lr}
    8764:	sub	sp, #12
    8766:	add	r3, sp, #20
    8768:	ldr	r4, [pc, #24]	; (8784 <fiprintf+0x24>)
    876a:	ldr.w	r2, [r3], #4
    876e:	str	r3, [sp, #4]
    8770:	mov	r1, r0
    8772:	ldr	r0, [r4, #0]
    8774:	bl	aa48 <_vfiprintf_r>
    8778:	add	sp, #12
    877a:	ldmia.w	sp!, {r4, lr}
    877e:	add	sp, #12
    8780:	bx	lr
    8782:	nop
    8784:	.word	0x200016d0

00008788 <__libc_init_array>:
    8788:	push	{r4, r5, r6, lr}
    878a:	ldr	r6, [pc, #60]	; (87c8 <__libc_init_array+0x40>)
    878c:	ldr	r5, [pc, #60]	; (87cc <__libc_init_array+0x44>)
    878e:	subs	r6, r6, r5
    8790:	asrs	r6, r6, #2
    8792:	it	ne
    8794:	movne	r4, #0
    8796:	beq.n	87a4 <__libc_init_array+0x1c>
    8798:	adds	r4, #1
    879a:	ldr.w	r3, [r5], #4
    879e:	blx	r3
    87a0:	cmp	r6, r4
    87a2:	bne.n	8798 <__libc_init_array+0x10>
    87a4:	ldr	r6, [pc, #40]	; (87d0 <__libc_init_array+0x48>)
    87a6:	ldr	r5, [pc, #44]	; (87d4 <__libc_init_array+0x4c>)
    87a8:	subs	r6, r6, r5
    87aa:	bl	df90 <___init_veneer>
    87ae:	asrs	r6, r6, #2
    87b0:	it	ne
    87b2:	movne	r4, #0
    87b4:	beq.n	87c4 <__libc_init_array+0x3c>
    87b6:	adds	r4, #1
    87b8:	ldr.w	r3, [r5], #4
    87bc:	blx	r3
    87be:	cmp	r6, r4
    87c0:	bne.n	87b6 <__libc_init_array+0x2e>
    87c2:	pop	{r4, r5, r6, pc}
    87c4:	pop	{r4, r5, r6, pc}
    87c6:	nop
    87c8:	.word	0x60001740
    87cc:	.word	0x60001740
    87d0:	.word	0x60001748
    87d4:	.word	0x60001740

000087d8 <__locale_mb_cur_max>:
    87d8:	ldr	r3, [pc, #16]	; (87ec <__locale_mb_cur_max+0x14>)
    87da:	ldr	r2, [pc, #20]	; (87f0 <__locale_mb_cur_max+0x18>)
    87dc:	ldr	r3, [r3, #0]
    87de:	ldr	r3, [r3, #52]	; 0x34
    87e0:	cmp	r3, #0
    87e2:	it	eq
    87e4:	moveq	r3, r2
    87e6:	ldrb.w	r0, [r3, #296]	; 0x128
    87ea:	bx	lr
    87ec:	.word	0x200016d0
    87f0:	.word	0x200016d4

000087f4 <_malloc_r>:
    87f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    87f8:	add.w	r5, r1, #11
    87fc:	cmp	r5, #22
    87fe:	sub	sp, #12
    8800:	mov	r6, r0
    8802:	bls.w	8944 <_malloc_r+0x150>
    8806:	bics.w	r5, r5, #7
    880a:	bmi.w	898c <_malloc_r+0x198>
    880e:	cmp	r1, r5
    8810:	bhi.w	898c <_malloc_r+0x198>
    8814:	bl	8ef4 <__malloc_lock>
    8818:	cmp.w	r5, #504	; 0x1f8
    881c:	bcc.w	8d58 <_malloc_r+0x564>
    8820:	lsrs	r3, r5, #9
    8822:	beq.w	899a <_malloc_r+0x1a6>
    8826:	cmp	r3, #4
    8828:	bhi.w	8b32 <_malloc_r+0x33e>
    882c:	lsrs	r0, r5, #6
    882e:	add.w	lr, r0, #57	; 0x39
    8832:	mov.w	r3, lr, lsl #1
    8836:	adds	r0, #56	; 0x38
    8838:	ldr	r7, [pc, #784]	; (8b4c <_malloc_r+0x358>)
    883a:	add.w	r3, r7, r3, lsl #2
    883e:	sub.w	r1, r3, #8
    8842:	ldr	r4, [r3, #4]
    8844:	cmp	r1, r4
    8846:	bne.n	8858 <_malloc_r+0x64>
    8848:	b.n	89a4 <_malloc_r+0x1b0>
    884a:	cmp	r2, #0
    884c:	bge.w	89a8 <_malloc_r+0x1b4>
    8850:	ldr	r4, [r4, #12]
    8852:	cmp	r1, r4
    8854:	beq.w	89a4 <_malloc_r+0x1b0>
    8858:	ldr	r3, [r4, #4]
    885a:	bic.w	r3, r3, #3
    885e:	subs	r2, r3, r5
    8860:	cmp	r2, #15
    8862:	ble.n	884a <_malloc_r+0x56>
    8864:	ldr	r1, [pc, #740]	; (8b4c <_malloc_r+0x358>)
    8866:	ldr	r4, [r7, #16]
    8868:	add.w	lr, r1, #8
    886c:	cmp	r4, lr
    886e:	beq.w	8bd8 <_malloc_r+0x3e4>
    8872:	ldr	r3, [r4, #4]
    8874:	bic.w	r3, r3, #3
    8878:	subs	r2, r3, r5
    887a:	cmp	r2, #15
    887c:	bgt.w	8bb2 <_malloc_r+0x3be>
    8880:	cmp	r2, #0
    8882:	str.w	lr, [r1, #20]
    8886:	str.w	lr, [r1, #16]
    888a:	bge.w	89ca <_malloc_r+0x1d6>
    888e:	cmp.w	r3, #512	; 0x200
    8892:	bcs.w	8b64 <_malloc_r+0x370>
    8896:	lsrs	r3, r3, #3
    8898:	add.w	ip, r3, #1
    889c:	movs	r2, #1
    889e:	asrs	r3, r3, #2
    88a0:	lsl.w	r3, r2, r3
    88a4:	ldr	r2, [r1, #4]
    88a6:	ldr.w	r8, [r1, ip, lsl #3]
    88aa:	str.w	r8, [r4, #8]
    88ae:	add.w	r9, r1, ip, lsl #3
    88b2:	orrs	r2, r3
    88b4:	sub.w	r3, r9, #8
    88b8:	str	r3, [r4, #12]
    88ba:	str	r2, [r1, #4]
    88bc:	str.w	r4, [r1, ip, lsl #3]
    88c0:	str.w	r4, [r8, #12]
    88c4:	asrs	r3, r0, #2
    88c6:	movs	r4, #1
    88c8:	lsls	r4, r3
    88ca:	cmp	r4, r2
    88cc:	bhi.w	89e4 <_malloc_r+0x1f0>
    88d0:	tst	r4, r2
    88d2:	bne.n	88e2 <_malloc_r+0xee>
    88d4:	bic.w	r0, r0, #3
    88d8:	lsls	r4, r4, #1
    88da:	tst	r4, r2
    88dc:	add.w	r0, r0, #4
    88e0:	beq.n	88d8 <_malloc_r+0xe4>
    88e2:	add.w	r9, r7, r0, lsl #3
    88e6:	mov	ip, r9
    88e8:	mov	r8, r0
    88ea:	ldr.w	r1, [ip, #12]
    88ee:	cmp	ip, r1
    88f0:	bne.n	8902 <_malloc_r+0x10e>
    88f2:	b.n	8bdc <_malloc_r+0x3e8>
    88f4:	cmp	r2, #0
    88f6:	bge.w	8bfc <_malloc_r+0x408>
    88fa:	ldr	r1, [r1, #12]
    88fc:	cmp	ip, r1
    88fe:	beq.w	8bdc <_malloc_r+0x3e8>
    8902:	ldr	r3, [r1, #4]
    8904:	bic.w	r3, r3, #3
    8908:	subs	r2, r3, r5
    890a:	cmp	r2, #15
    890c:	ble.n	88f4 <_malloc_r+0x100>
    890e:	mov	r4, r1
    8910:	ldr.w	ip, [r1, #12]
    8914:	ldr.w	r8, [r4, #8]!
    8918:	adds	r3, r1, r5
    891a:	orr.w	r5, r5, #1
    891e:	str	r5, [r1, #4]
    8920:	orr.w	r1, r2, #1
    8924:	str.w	ip, [r8, #12]
    8928:	mov	r0, r6
    892a:	str.w	r8, [ip, #8]
    892e:	str	r3, [r7, #20]
    8930:	str	r3, [r7, #16]
    8932:	str.w	lr, [r3, #12]
    8936:	str.w	lr, [r3, #8]
    893a:	str	r1, [r3, #4]
    893c:	str	r2, [r3, r2]
    893e:	bl	8ef8 <__malloc_unlock>
    8942:	b.n	8984 <_malloc_r+0x190>
    8944:	cmp	r1, #16
    8946:	bhi.n	898c <_malloc_r+0x198>
    8948:	bl	8ef4 <__malloc_lock>
    894c:	movs	r5, #16
    894e:	movs	r3, #6
    8950:	movs	r0, #2
    8952:	ldr	r7, [pc, #504]	; (8b4c <_malloc_r+0x358>)
    8954:	add.w	r3, r7, r3, lsl #2
    8958:	sub.w	r2, r3, #8
    895c:	ldr	r4, [r3, #4]
    895e:	cmp	r4, r2
    8960:	beq.w	8bee <_malloc_r+0x3fa>
    8964:	ldr	r3, [r4, #4]
    8966:	ldr	r1, [r4, #12]
    8968:	ldr	r5, [r4, #8]
    896a:	bic.w	r3, r3, #3
    896e:	add	r3, r4
    8970:	mov	r0, r6
    8972:	ldr	r2, [r3, #4]
    8974:	str	r1, [r5, #12]
    8976:	orr.w	r2, r2, #1
    897a:	str	r5, [r1, #8]
    897c:	str	r2, [r3, #4]
    897e:	bl	8ef8 <__malloc_unlock>
    8982:	adds	r4, #8
    8984:	mov	r0, r4
    8986:	add	sp, #12
    8988:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    898c:	movs	r4, #0
    898e:	movs	r3, #12
    8990:	mov	r0, r4
    8992:	str	r3, [r6, #0]
    8994:	add	sp, #12
    8996:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    899a:	movs	r3, #128	; 0x80
    899c:	mov.w	lr, #64	; 0x40
    89a0:	movs	r0, #63	; 0x3f
    89a2:	b.n	8838 <_malloc_r+0x44>
    89a4:	mov	r0, lr
    89a6:	b.n	8864 <_malloc_r+0x70>
    89a8:	add	r3, r4
    89aa:	ldr	r1, [r4, #12]
    89ac:	ldr	r2, [r3, #4]
    89ae:	ldr	r5, [r4, #8]
    89b0:	orr.w	r2, r2, #1
    89b4:	str	r1, [r5, #12]
    89b6:	mov	r0, r6
    89b8:	str	r5, [r1, #8]
    89ba:	str	r2, [r3, #4]
    89bc:	bl	8ef8 <__malloc_unlock>
    89c0:	adds	r4, #8
    89c2:	mov	r0, r4
    89c4:	add	sp, #12
    89c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    89ca:	add	r3, r4
    89cc:	mov	r0, r6
    89ce:	ldr	r2, [r3, #4]
    89d0:	orr.w	r2, r2, #1
    89d4:	str	r2, [r3, #4]
    89d6:	bl	8ef8 <__malloc_unlock>
    89da:	adds	r4, #8
    89dc:	mov	r0, r4
    89de:	add	sp, #12
    89e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    89e4:	ldr	r4, [r7, #8]
    89e6:	ldr	r3, [r4, #4]
    89e8:	bic.w	r8, r3, #3
    89ec:	cmp	r8, r5
    89ee:	bcc.n	89fa <_malloc_r+0x206>
    89f0:	rsb	r3, r5, r8
    89f4:	cmp	r3, #15
    89f6:	bgt.w	8b12 <_malloc_r+0x31e>
    89fa:	ldr	r3, [pc, #340]	; (8b50 <_malloc_r+0x35c>)
    89fc:	ldr.w	r9, [pc, #352]	; 8b60 <_malloc_r+0x36c>
    8a00:	ldr	r2, [r3, #0]
    8a02:	ldr.w	r3, [r9]
    8a06:	adds	r3, #1
    8a08:	add	r2, r5
    8a0a:	add.w	sl, r4, r8
    8a0e:	beq.w	8cd2 <_malloc_r+0x4de>
    8a12:	add.w	r2, r2, #4096	; 0x1000
    8a16:	adds	r2, #15
    8a18:	bic.w	r2, r2, #4080	; 0xff0
    8a1c:	bic.w	r2, r2, #15
    8a20:	mov	r1, r2
    8a22:	mov	r0, r6
    8a24:	str	r2, [sp, #4]
    8a26:	bl	92dc <_sbrk_r>
    8a2a:	cmp.w	r0, #4294967295
    8a2e:	mov	fp, r0
    8a30:	ldr	r2, [sp, #4]
    8a32:	beq.w	8ce6 <_malloc_r+0x4f2>
    8a36:	cmp	sl, r0
    8a38:	bhi.w	8c34 <_malloc_r+0x440>
    8a3c:	ldr	r3, [pc, #276]	; (8b54 <_malloc_r+0x360>)
    8a3e:	ldr	r1, [r3, #0]
    8a40:	cmp	sl, fp
    8a42:	add	r1, r2
    8a44:	str	r1, [r3, #0]
    8a46:	beq.w	8cf0 <_malloc_r+0x4fc>
    8a4a:	ldr.w	r0, [r9]
    8a4e:	ldr.w	lr, [pc, #272]	; 8b60 <_malloc_r+0x36c>
    8a52:	adds	r0, #1
    8a54:	ittet	ne
    8a56:	rsbne	sl, sl, fp
    8a5a:	addne	r1, sl
    8a5c:	streq.w	fp, [lr]
    8a60:	strne	r1, [r3, #0]
    8a62:	ands.w	r1, fp, #7
    8a66:	beq.w	8c98 <_malloc_r+0x4a4>
    8a6a:	rsb	r0, r1, #8
    8a6e:	rsb	r1, r1, #4096	; 0x1000
    8a72:	add	fp, r0
    8a74:	adds	r1, #8
    8a76:	add	r2, fp
    8a78:	ubfx	r2, r2, #0, #12
    8a7c:	rsb	r9, r2, r1
    8a80:	mov	r1, r9
    8a82:	mov	r0, r6
    8a84:	str	r3, [sp, #4]
    8a86:	bl	92dc <_sbrk_r>
    8a8a:	adds	r3, r0, #1
    8a8c:	ldr	r3, [sp, #4]
    8a8e:	beq.w	8d10 <_malloc_r+0x51c>
    8a92:	rsb	r2, fp, r0
    8a96:	add	r2, r9
    8a98:	orr.w	r2, r2, #1
    8a9c:	ldr	r1, [r3, #0]
    8a9e:	str.w	fp, [r7, #8]
    8aa2:	add	r1, r9
    8aa4:	cmp	r4, r7
    8aa6:	str.w	r2, [fp, #4]
    8aaa:	str	r1, [r3, #0]
    8aac:	ldr.w	r9, [pc, #164]	; 8b54 <_malloc_r+0x360>
    8ab0:	beq.n	8ae0 <_malloc_r+0x2ec>
    8ab2:	cmp.w	r8, #15
    8ab6:	bls.w	8cb4 <_malloc_r+0x4c0>
    8aba:	ldr	r2, [r4, #4]
    8abc:	sub.w	r3, r8, #12
    8ac0:	bic.w	r3, r3, #7
    8ac4:	adds	r0, r4, r3
    8ac6:	and.w	r2, r2, #1
    8aca:	mov.w	lr, #5
    8ace:	orrs	r2, r3
    8ad0:	cmp	r3, #15
    8ad2:	str	r2, [r4, #4]
    8ad4:	str.w	lr, [r0, #4]
    8ad8:	str.w	lr, [r0, #8]
    8adc:	bhi.w	8d18 <_malloc_r+0x524>
    8ae0:	ldr	r3, [pc, #116]	; (8b58 <_malloc_r+0x364>)
    8ae2:	ldr	r4, [r7, #8]
    8ae4:	ldr	r2, [r3, #0]
    8ae6:	cmp	r1, r2
    8ae8:	it	hi
    8aea:	strhi	r1, [r3, #0]
    8aec:	ldr	r3, [pc, #108]	; (8b5c <_malloc_r+0x368>)
    8aee:	ldr	r2, [r3, #0]
    8af0:	cmp	r1, r2
    8af2:	ldr	r2, [r4, #4]
    8af4:	it	hi
    8af6:	strhi	r1, [r3, #0]
    8af8:	bic.w	r2, r2, #3
    8afc:	cmp	r5, r2
    8afe:	sub.w	r3, r2, r5
    8b02:	bhi.n	8b08 <_malloc_r+0x314>
    8b04:	cmp	r3, #15
    8b06:	bgt.n	8b12 <_malloc_r+0x31e>
    8b08:	mov	r0, r6
    8b0a:	bl	8ef8 <__malloc_unlock>
    8b0e:	movs	r4, #0
    8b10:	b.n	8984 <_malloc_r+0x190>
    8b12:	adds	r2, r4, r5
    8b14:	orr.w	r3, r3, #1
    8b18:	orr.w	r5, r5, #1
    8b1c:	str	r5, [r4, #4]
    8b1e:	mov	r0, r6
    8b20:	str	r2, [r7, #8]
    8b22:	str	r3, [r2, #4]
    8b24:	bl	8ef8 <__malloc_unlock>
    8b28:	adds	r4, #8
    8b2a:	mov	r0, r4
    8b2c:	add	sp, #12
    8b2e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8b32:	cmp	r3, #20
    8b34:	bls.n	8c1a <_malloc_r+0x426>
    8b36:	cmp	r3, #84	; 0x54
    8b38:	bhi.w	8c84 <_malloc_r+0x490>
    8b3c:	lsrs	r0, r5, #12
    8b3e:	add.w	lr, r0, #111	; 0x6f
    8b42:	mov.w	r3, lr, lsl #1
    8b46:	adds	r0, #110	; 0x6e
    8b48:	b.n	8838 <_malloc_r+0x44>
    8b4a:	nop
    8b4c:	.word	0x20001840
    8b50:	.word	0x20002464
    8b54:	.word	0x20002468
    8b58:	.word	0x20002460
    8b5c:	.word	0x2000245c
    8b60:	.word	0x20001c4c
    8b64:	lsrs	r2, r3, #9
    8b66:	cmp	r2, #4
    8b68:	bls.n	8c28 <_malloc_r+0x434>
    8b6a:	cmp	r2, #20
    8b6c:	bhi.w	8cd6 <_malloc_r+0x4e2>
    8b70:	add.w	r1, r2, #92	; 0x5c
    8b74:	lsls	r1, r1, #1
    8b76:	adds	r2, #91	; 0x5b
    8b78:	add.w	ip, r7, r1, lsl #2
    8b7c:	ldr.w	r1, [r7, r1, lsl #2]
    8b80:	ldr.w	r8, [pc, #476]	; 8d60 <_malloc_r+0x56c>
    8b84:	sub.w	ip, ip, #8
    8b88:	cmp	ip, r1
    8b8a:	beq.w	8c9e <_malloc_r+0x4aa>
    8b8e:	ldr	r2, [r1, #4]
    8b90:	bic.w	r2, r2, #3
    8b94:	cmp	r3, r2
    8b96:	bcs.n	8b9e <_malloc_r+0x3aa>
    8b98:	ldr	r1, [r1, #8]
    8b9a:	cmp	ip, r1
    8b9c:	bne.n	8b8e <_malloc_r+0x39a>
    8b9e:	ldr.w	ip, [r1, #12]
    8ba2:	ldr	r2, [r7, #4]
    8ba4:	str.w	ip, [r4, #12]
    8ba8:	str	r1, [r4, #8]
    8baa:	str.w	r4, [ip, #8]
    8bae:	str	r4, [r1, #12]
    8bb0:	b.n	88c4 <_malloc_r+0xd0>
    8bb2:	adds	r3, r4, r5
    8bb4:	orr.w	r7, r2, #1
    8bb8:	orr.w	r5, r5, #1
    8bbc:	str	r5, [r4, #4]
    8bbe:	mov	r0, r6
    8bc0:	str	r3, [r1, #20]
    8bc2:	str	r3, [r1, #16]
    8bc4:	str.w	lr, [r3, #12]
    8bc8:	str.w	lr, [r3, #8]
    8bcc:	str	r7, [r3, #4]
    8bce:	str	r2, [r3, r2]
    8bd0:	adds	r4, #8
    8bd2:	bl	8ef8 <__malloc_unlock>
    8bd6:	b.n	8984 <_malloc_r+0x190>
    8bd8:	ldr	r2, [r1, #4]
    8bda:	b.n	88c4 <_malloc_r+0xd0>
    8bdc:	add.w	r8, r8, #1
    8be0:	tst.w	r8, #3
    8be4:	add.w	ip, ip, #8
    8be8:	bne.w	88ea <_malloc_r+0xf6>
    8bec:	b.n	8c50 <_malloc_r+0x45c>
    8bee:	ldr	r4, [r3, #12]
    8bf0:	cmp	r3, r4
    8bf2:	it	eq
    8bf4:	addeq	r0, #2
    8bf6:	beq.w	8864 <_malloc_r+0x70>
    8bfa:	b.n	8964 <_malloc_r+0x170>
    8bfc:	add	r3, r1
    8bfe:	mov	r4, r1
    8c00:	ldr	r2, [r3, #4]
    8c02:	ldr	r1, [r1, #12]
    8c04:	ldr.w	r5, [r4, #8]!
    8c08:	orr.w	r2, r2, #1
    8c0c:	str	r2, [r3, #4]
    8c0e:	mov	r0, r6
    8c10:	str	r1, [r5, #12]
    8c12:	str	r5, [r1, #8]
    8c14:	bl	8ef8 <__malloc_unlock>
    8c18:	b.n	8984 <_malloc_r+0x190>
    8c1a:	add.w	lr, r3, #92	; 0x5c
    8c1e:	add.w	r0, r3, #91	; 0x5b
    8c22:	mov.w	r3, lr, lsl #1
    8c26:	b.n	8838 <_malloc_r+0x44>
    8c28:	lsrs	r2, r3, #6
    8c2a:	add.w	r1, r2, #57	; 0x39
    8c2e:	lsls	r1, r1, #1
    8c30:	adds	r2, #56	; 0x38
    8c32:	b.n	8b78 <_malloc_r+0x384>
    8c34:	cmp	r4, r7
    8c36:	ldr	r3, [pc, #296]	; (8d60 <_malloc_r+0x56c>)
    8c38:	beq.w	8a3c <_malloc_r+0x248>
    8c3c:	ldr	r4, [r3, #8]
    8c3e:	ldr	r2, [r4, #4]
    8c40:	bic.w	r2, r2, #3
    8c44:	b.n	8afc <_malloc_r+0x308>
    8c46:	ldr.w	r3, [r9], #-8
    8c4a:	cmp	r9, r3
    8c4c:	bne.w	8d54 <_malloc_r+0x560>
    8c50:	tst.w	r0, #3
    8c54:	add.w	r0, r0, #4294967295
    8c58:	bne.n	8c46 <_malloc_r+0x452>
    8c5a:	ldr	r3, [r7, #4]
    8c5c:	bic.w	r3, r3, r4
    8c60:	str	r3, [r7, #4]
    8c62:	lsls	r4, r4, #1
    8c64:	cmp	r4, r3
    8c66:	bhi.w	89e4 <_malloc_r+0x1f0>
    8c6a:	cmp	r4, #0
    8c6c:	beq.w	89e4 <_malloc_r+0x1f0>
    8c70:	tst	r4, r3
    8c72:	mov	r0, r8
    8c74:	bne.w	88e2 <_malloc_r+0xee>
    8c78:	lsls	r4, r4, #1
    8c7a:	tst	r4, r3
    8c7c:	add.w	r0, r0, #4
    8c80:	beq.n	8c78 <_malloc_r+0x484>
    8c82:	b.n	88e2 <_malloc_r+0xee>
    8c84:	cmp.w	r3, #340	; 0x154
    8c88:	bhi.n	8cbc <_malloc_r+0x4c8>
    8c8a:	lsrs	r0, r5, #15
    8c8c:	add.w	lr, r0, #120	; 0x78
    8c90:	mov.w	r3, lr, lsl #1
    8c94:	adds	r0, #119	; 0x77
    8c96:	b.n	8838 <_malloc_r+0x44>
    8c98:	mov.w	r1, #4096	; 0x1000
    8c9c:	b.n	8a76 <_malloc_r+0x282>
    8c9e:	movs	r1, #1
    8ca0:	ldr.w	r3, [r8, #4]
    8ca4:	asrs	r2, r2, #2
    8ca6:	lsl.w	r2, r1, r2
    8caa:	orrs	r2, r3
    8cac:	str.w	r2, [r8, #4]
    8cb0:	mov	r1, ip
    8cb2:	b.n	8ba4 <_malloc_r+0x3b0>
    8cb4:	movs	r3, #1
    8cb6:	str.w	r3, [fp, #4]
    8cba:	b.n	8b08 <_malloc_r+0x314>
    8cbc:	movw	r2, #1364	; 0x554
    8cc0:	cmp	r3, r2
    8cc2:	bhi.n	8d06 <_malloc_r+0x512>
    8cc4:	lsrs	r0, r5, #18
    8cc6:	add.w	lr, r0, #125	; 0x7d
    8cca:	mov.w	r3, lr, lsl #1
    8cce:	adds	r0, #124	; 0x7c
    8cd0:	b.n	8838 <_malloc_r+0x44>
    8cd2:	adds	r2, #16
    8cd4:	b.n	8a20 <_malloc_r+0x22c>
    8cd6:	cmp	r2, #84	; 0x54
    8cd8:	bhi.n	8d28 <_malloc_r+0x534>
    8cda:	lsrs	r2, r3, #12
    8cdc:	add.w	r1, r2, #111	; 0x6f
    8ce0:	lsls	r1, r1, #1
    8ce2:	adds	r2, #110	; 0x6e
    8ce4:	b.n	8b78 <_malloc_r+0x384>
    8ce6:	ldr	r4, [r7, #8]
    8ce8:	ldr	r2, [r4, #4]
    8cea:	bic.w	r2, r2, #3
    8cee:	b.n	8afc <_malloc_r+0x308>
    8cf0:	ubfx	r0, sl, #0, #12
    8cf4:	cmp	r0, #0
    8cf6:	bne.w	8a4a <_malloc_r+0x256>
    8cfa:	add	r2, r8
    8cfc:	ldr	r3, [r7, #8]
    8cfe:	orr.w	r2, r2, #1
    8d02:	str	r2, [r3, #4]
    8d04:	b.n	8ae0 <_malloc_r+0x2ec>
    8d06:	movs	r3, #254	; 0xfe
    8d08:	mov.w	lr, #127	; 0x7f
    8d0c:	movs	r0, #126	; 0x7e
    8d0e:	b.n	8838 <_malloc_r+0x44>
    8d10:	movs	r2, #1
    8d12:	mov.w	r9, #0
    8d16:	b.n	8a9c <_malloc_r+0x2a8>
    8d18:	add.w	r1, r4, #8
    8d1c:	mov	r0, r6
    8d1e:	bl	cb4c <_free_r>
    8d22:	ldr.w	r1, [r9]
    8d26:	b.n	8ae0 <_malloc_r+0x2ec>
    8d28:	cmp.w	r2, #340	; 0x154
    8d2c:	bhi.n	8d3a <_malloc_r+0x546>
    8d2e:	lsrs	r2, r3, #15
    8d30:	add.w	r1, r2, #120	; 0x78
    8d34:	lsls	r1, r1, #1
    8d36:	adds	r2, #119	; 0x77
    8d38:	b.n	8b78 <_malloc_r+0x384>
    8d3a:	movw	r1, #1364	; 0x554
    8d3e:	cmp	r2, r1
    8d40:	bhi.n	8d4e <_malloc_r+0x55a>
    8d42:	lsrs	r2, r3, #18
    8d44:	add.w	r1, r2, #125	; 0x7d
    8d48:	lsls	r1, r1, #1
    8d4a:	adds	r2, #124	; 0x7c
    8d4c:	b.n	8b78 <_malloc_r+0x384>
    8d4e:	movs	r1, #254	; 0xfe
    8d50:	movs	r2, #126	; 0x7e
    8d52:	b.n	8b78 <_malloc_r+0x384>
    8d54:	ldr	r3, [r7, #4]
    8d56:	b.n	8c62 <_malloc_r+0x46e>
    8d58:	lsrs	r0, r5, #3
    8d5a:	adds	r3, r0, #1
    8d5c:	lsls	r3, r3, #1
    8d5e:	b.n	8952 <_malloc_r+0x15e>
    8d60:	.word	0x20001840

00008d64 <__ascii_mbtowc>:
    8d64:	sub	sp, #8
    8d66:	cbz	r1, 8d7c <__ascii_mbtowc+0x18>
    8d68:	cbz	r2, 8d82 <__ascii_mbtowc+0x1e>
    8d6a:	cbz	r3, 8d88 <__ascii_mbtowc+0x24>
    8d6c:	ldrb	r3, [r2, #0]
    8d6e:	str	r3, [r1, #0]
    8d70:	ldrb	r2, [r2, #0]
    8d72:	adds	r0, r2, #0
    8d74:	it	ne
    8d76:	movne	r0, #1
    8d78:	add	sp, #8
    8d7a:	bx	lr
    8d7c:	add	r1, sp, #4
    8d7e:	cmp	r2, #0
    8d80:	bne.n	8d6a <__ascii_mbtowc+0x6>
    8d82:	mov	r0, r2
    8d84:	add	sp, #8
    8d86:	bx	lr
    8d88:	mvn.w	r0, #1
    8d8c:	b.n	8d78 <__ascii_mbtowc+0x14>
    8d8e:	nop

00008d90 <memmove>:
    8d90:	cmp	r0, r1
    8d92:	push	{r4, r5, r6, r7, lr}
    8d94:	bls.n	8db2 <memmove+0x22>
    8d96:	adds	r3, r1, r2
    8d98:	cmp	r0, r3
    8d9a:	bcs.n	8db2 <memmove+0x22>
    8d9c:	adds	r1, r0, r2
    8d9e:	cmp	r2, #0
    8da0:	beq.n	8e46 <memmove+0xb6>
    8da2:	subs	r2, r3, r2
    8da4:	ldrb.w	r4, [r3, #-1]!
    8da8:	strb.w	r4, [r1, #-1]!
    8dac:	cmp	r3, r2
    8dae:	bne.n	8da4 <memmove+0x14>
    8db0:	pop	{r4, r5, r6, r7, pc}
    8db2:	cmp	r2, #15
    8db4:	bls.n	8e48 <memmove+0xb8>
    8db6:	orr.w	r3, r1, r0
    8dba:	lsls	r3, r3, #30
    8dbc:	bne.n	8e4c <memmove+0xbc>
    8dbe:	add.w	r4, r0, #16
    8dc2:	add.w	r3, r1, #16
    8dc6:	mov	r5, r2
    8dc8:	ldr.w	r6, [r3, #-16]
    8dcc:	str.w	r6, [r4, #-16]
    8dd0:	ldr.w	r6, [r3, #-12]
    8dd4:	str.w	r6, [r4, #-12]
    8dd8:	ldr.w	r6, [r3, #-8]
    8ddc:	str.w	r6, [r4, #-8]
    8de0:	subs	r5, #16
    8de2:	ldr.w	r6, [r3, #-4]
    8de6:	str.w	r6, [r4, #-4]
    8dea:	cmp	r5, #15
    8dec:	add.w	r3, r3, #16
    8df0:	add.w	r4, r4, #16
    8df4:	bhi.n	8dc8 <memmove+0x38>
    8df6:	sub.w	r3, r2, #16
    8dfa:	bic.w	r3, r3, #15
    8dfe:	and.w	lr, r2, #15
    8e02:	adds	r3, #16
    8e04:	cmp.w	lr, #3
    8e08:	add	r1, r3
    8e0a:	add	r3, r0
    8e0c:	bls.n	8e52 <memmove+0xc2>
    8e0e:	subs	r6, r3, #4
    8e10:	mov	r5, r1
    8e12:	mov	r4, lr
    8e14:	subs	r4, #4
    8e16:	ldr.w	r7, [r5], #4
    8e1a:	str.w	r7, [r6, #4]!
    8e1e:	cmp	r4, #3
    8e20:	bhi.n	8e14 <memmove+0x84>
    8e22:	sub.w	r4, lr, #4
    8e26:	bic.w	r4, r4, #3
    8e2a:	adds	r4, #4
    8e2c:	add	r3, r4
    8e2e:	add	r1, r4
    8e30:	and.w	r2, r2, #3
    8e34:	cbz	r2, 8e50 <memmove+0xc0>
    8e36:	subs	r3, #1
    8e38:	add	r2, r1
    8e3a:	ldrb.w	r4, [r1], #1
    8e3e:	strb.w	r4, [r3, #1]!
    8e42:	cmp	r2, r1
    8e44:	bne.n	8e3a <memmove+0xaa>
    8e46:	pop	{r4, r5, r6, r7, pc}
    8e48:	mov	r3, r0
    8e4a:	b.n	8e34 <memmove+0xa4>
    8e4c:	mov	r3, r0
    8e4e:	b.n	8e36 <memmove+0xa6>
    8e50:	pop	{r4, r5, r6, r7, pc}
    8e52:	mov	r2, lr
    8e54:	b.n	8e34 <memmove+0xa4>
    8e56:	nop

00008e58 <memset>:
    8e58:	push	{r4, r5, r6}
    8e5a:	lsls	r4, r0, #30
    8e5c:	beq.n	8eec <memset+0x94>
    8e5e:	subs	r4, r2, #1
    8e60:	cmp	r2, #0
    8e62:	beq.n	8ee8 <memset+0x90>
    8e64:	uxtb	r5, r1
    8e66:	mov	r3, r0
    8e68:	b.n	8e70 <memset+0x18>
    8e6a:	subs	r2, r4, #1
    8e6c:	cbz	r4, 8ee8 <memset+0x90>
    8e6e:	mov	r4, r2
    8e70:	strb.w	r5, [r3], #1
    8e74:	lsls	r2, r3, #30
    8e76:	bne.n	8e6a <memset+0x12>
    8e78:	cmp	r4, #3
    8e7a:	bls.n	8eda <memset+0x82>
    8e7c:	uxtb	r5, r1
    8e7e:	orr.w	r5, r5, r5, lsl #8
    8e82:	cmp	r4, #15
    8e84:	orr.w	r5, r5, r5, lsl #16
    8e88:	bls.n	8ebe <memset+0x66>
    8e8a:	add.w	r2, r3, #16
    8e8e:	mov	r6, r4
    8e90:	subs	r6, #16
    8e92:	cmp	r6, #15
    8e94:	str.w	r5, [r2, #-16]
    8e98:	str.w	r5, [r2, #-12]
    8e9c:	str.w	r5, [r2, #-8]
    8ea0:	str.w	r5, [r2, #-4]
    8ea4:	add.w	r2, r2, #16
    8ea8:	bhi.n	8e90 <memset+0x38>
    8eaa:	sub.w	r2, r4, #16
    8eae:	bic.w	r2, r2, #15
    8eb2:	and.w	r4, r4, #15
    8eb6:	adds	r2, #16
    8eb8:	cmp	r4, #3
    8eba:	add	r3, r2
    8ebc:	bls.n	8eda <memset+0x82>
    8ebe:	mov	r6, r3
    8ec0:	mov	r2, r4
    8ec2:	subs	r2, #4
    8ec4:	cmp	r2, #3
    8ec6:	str.w	r5, [r6], #4
    8eca:	bhi.n	8ec2 <memset+0x6a>
    8ecc:	subs	r2, r4, #4
    8ece:	bic.w	r2, r2, #3
    8ed2:	adds	r2, #4
    8ed4:	add	r3, r2
    8ed6:	and.w	r4, r4, #3
    8eda:	cbz	r4, 8ee8 <memset+0x90>
    8edc:	uxtb	r1, r1
    8ede:	add	r4, r3
    8ee0:	strb.w	r1, [r3], #1
    8ee4:	cmp	r3, r4
    8ee6:	bne.n	8ee0 <memset+0x88>
    8ee8:	pop	{r4, r5, r6}
    8eea:	bx	lr
    8eec:	mov	r4, r2
    8eee:	mov	r3, r0
    8ef0:	b.n	8e78 <memset+0x20>
    8ef2:	nop

00008ef4 <__malloc_lock>:
    8ef4:	bx	lr
    8ef6:	nop

00008ef8 <__malloc_unlock>:
    8ef8:	bx	lr
    8efa:	nop

00008efc <_realloc_r>:
    8efc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f00:	mov	r7, r2
    8f02:	sub	sp, #12
    8f04:	cmp	r1, #0
    8f06:	beq.w	908c <_realloc_r+0x190>
    8f0a:	mov	r6, r1
    8f0c:	mov	r9, r0
    8f0e:	add.w	r5, r7, #11
    8f12:	bl	8ef4 <__malloc_lock>
    8f16:	ldr.w	lr, [r6, #-4]
    8f1a:	cmp	r5, #22
    8f1c:	bic.w	r4, lr, #3
    8f20:	sub.w	r8, r6, #8
    8f24:	bhi.n	8fa8 <_realloc_r+0xac>
    8f26:	movs	r2, #16
    8f28:	mov	r5, r2
    8f2a:	cmp	r7, r5
    8f2c:	bhi.n	8fb2 <_realloc_r+0xb6>
    8f2e:	cmp	r4, r2
    8f30:	bge.n	901e <_realloc_r+0x122>
    8f32:	ldr	r3, [pc, #804]	; (9258 <_realloc_r+0x35c>)
    8f34:	ldr	r1, [r3, #8]
    8f36:	add.w	r0, r8, r4
    8f3a:	cmp	r0, r1
    8f3c:	ldr	r1, [r0, #4]
    8f3e:	beq.w	90f4 <_realloc_r+0x1f8>
    8f42:	bic.w	r3, r1, #1
    8f46:	add	r3, r0
    8f48:	ldr	r3, [r3, #4]
    8f4a:	lsls	r3, r3, #31
    8f4c:	bpl.n	904a <_realloc_r+0x14e>
    8f4e:	tst.w	lr, #1
    8f52:	beq.n	8fc0 <_realloc_r+0xc4>
    8f54:	mov	r1, r7
    8f56:	mov	r0, r9
    8f58:	bl	87f4 <_malloc_r>
    8f5c:	mov	r7, r0
    8f5e:	cbz	r0, 8f9a <_realloc_r+0x9e>
    8f60:	ldr.w	r3, [r6, #-4]
    8f64:	bic.w	r3, r3, #1
    8f68:	add	r3, r8
    8f6a:	sub.w	r2, r0, #8
    8f6e:	cmp	r2, r3
    8f70:	beq.w	91fc <_realloc_r+0x300>
    8f74:	subs	r2, r4, #4
    8f76:	cmp	r2, #36	; 0x24
    8f78:	bhi.w	91de <_realloc_r+0x2e2>
    8f7c:	cmp	r2, #19
    8f7e:	bhi.w	918a <_realloc_r+0x28e>
    8f82:	mov	r3, r0
    8f84:	mov	r2, r6
    8f86:	ldr	r1, [r2, #0]
    8f88:	str	r1, [r3, #0]
    8f8a:	ldr	r1, [r2, #4]
    8f8c:	str	r1, [r3, #4]
    8f8e:	ldr	r2, [r2, #8]
    8f90:	str	r2, [r3, #8]
    8f92:	mov	r1, r6
    8f94:	mov	r0, r9
    8f96:	bl	cb4c <_free_r>
    8f9a:	mov	r0, r9
    8f9c:	bl	8ef8 <__malloc_unlock>
    8fa0:	mov	r0, r7
    8fa2:	add	sp, #12
    8fa4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8fa8:	bic.w	r5, r5, #7
    8fac:	cmp	r5, #0
    8fae:	mov	r2, r5
    8fb0:	bge.n	8f2a <_realloc_r+0x2e>
    8fb2:	movs	r3, #12
    8fb4:	movs	r0, #0
    8fb6:	str.w	r3, [r9]
    8fba:	add	sp, #12
    8fbc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8fc0:	ldr.w	r3, [r6, #-8]
    8fc4:	rsb	sl, r3, r8
    8fc8:	ldr.w	r3, [sl, #4]
    8fcc:	bic.w	ip, r3, #3
    8fd0:	add.w	r3, r4, ip
    8fd4:	cmp	r3, r2
    8fd6:	blt.n	8f54 <_realloc_r+0x58>
    8fd8:	mov	r7, sl
    8fda:	ldr.w	r1, [sl, #12]
    8fde:	ldr.w	r0, [r7, #8]!
    8fe2:	subs	r2, r4, #4
    8fe4:	cmp	r2, #36	; 0x24
    8fe6:	str	r1, [r0, #12]
    8fe8:	str	r0, [r1, #8]
    8fea:	bhi.w	921c <_realloc_r+0x320>
    8fee:	cmp	r2, #19
    8ff0:	bls.w	9218 <_realloc_r+0x31c>
    8ff4:	ldr	r1, [r6, #0]
    8ff6:	str.w	r1, [sl, #8]
    8ffa:	ldr	r1, [r6, #4]
    8ffc:	str.w	r1, [sl, #12]
    9000:	cmp	r2, #27
    9002:	bhi.w	925c <_realloc_r+0x360>
    9006:	adds	r6, #8
    9008:	add.w	r2, sl, #16
    900c:	ldr	r1, [r6, #0]
    900e:	str	r1, [r2, #0]
    9010:	ldr	r1, [r6, #4]
    9012:	str	r1, [r2, #4]
    9014:	ldr	r1, [r6, #8]
    9016:	str	r1, [r2, #8]
    9018:	mov	r6, r7
    901a:	mov	r4, r3
    901c:	mov	r8, sl
    901e:	subs	r3, r4, r5
    9020:	cmp	r3, #15
    9022:	bhi.n	9060 <_realloc_r+0x164>
    9024:	ldr.w	r3, [r8, #4]
    9028:	and.w	r3, r3, #1
    902c:	orrs	r3, r4
    902e:	add	r4, r8
    9030:	str.w	r3, [r8, #4]
    9034:	ldr	r3, [r4, #4]
    9036:	orr.w	r3, r3, #1
    903a:	str	r3, [r4, #4]
    903c:	mov	r0, r9
    903e:	bl	8ef8 <__malloc_unlock>
    9042:	mov	r0, r6
    9044:	add	sp, #12
    9046:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    904a:	bic.w	r1, r1, #3
    904e:	add	r1, r4
    9050:	cmp	r1, r2
    9052:	blt.n	9098 <_realloc_r+0x19c>
    9054:	ldr	r3, [r0, #12]
    9056:	ldr	r2, [r0, #8]
    9058:	mov	r4, r1
    905a:	str	r3, [r2, #12]
    905c:	str	r2, [r3, #8]
    905e:	b.n	901e <_realloc_r+0x122>
    9060:	ldr.w	r2, [r8, #4]
    9064:	add.w	r1, r8, r5
    9068:	and.w	r2, r2, #1
    906c:	orrs	r5, r2
    906e:	orr.w	r2, r3, #1
    9072:	add	r3, r1
    9074:	str.w	r5, [r8, #4]
    9078:	str	r2, [r1, #4]
    907a:	ldr	r2, [r3, #4]
    907c:	orr.w	r2, r2, #1
    9080:	adds	r1, #8
    9082:	str	r2, [r3, #4]
    9084:	mov	r0, r9
    9086:	bl	cb4c <_free_r>
    908a:	b.n	903c <_realloc_r+0x140>
    908c:	mov	r1, r2
    908e:	add	sp, #12
    9090:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9094:	b.w	87f4 <_malloc_r>
    9098:	tst.w	lr, #1
    909c:	bne.w	8f54 <_realloc_r+0x58>
    90a0:	ldr.w	r3, [r6, #-8]
    90a4:	rsb	sl, r3, r8
    90a8:	ldr.w	r3, [sl, #4]
    90ac:	bic.w	ip, r3, #3
    90b0:	add.w	lr, r1, ip
    90b4:	cmp	lr, r2
    90b6:	blt.n	8fd0 <_realloc_r+0xd4>
    90b8:	ldr	r3, [r0, #12]
    90ba:	ldr	r2, [r0, #8]
    90bc:	mov	r7, sl
    90be:	str	r3, [r2, #12]
    90c0:	str	r2, [r3, #8]
    90c2:	ldr.w	r1, [r7, #8]!
    90c6:	ldr.w	r3, [sl, #12]
    90ca:	str	r3, [r1, #12]
    90cc:	subs	r2, r4, #4
    90ce:	cmp	r2, #36	; 0x24
    90d0:	str	r1, [r3, #8]
    90d2:	bhi.w	9208 <_realloc_r+0x30c>
    90d6:	cmp	r2, #19
    90d8:	bls.n	91a0 <_realloc_r+0x2a4>
    90da:	ldr	r3, [r6, #0]
    90dc:	str.w	r3, [sl, #8]
    90e0:	ldr	r3, [r6, #4]
    90e2:	str.w	r3, [sl, #12]
    90e6:	cmp	r2, #27
    90e8:	bhi.w	922c <_realloc_r+0x330>
    90ec:	adds	r6, #8
    90ee:	add.w	r3, sl, #16
    90f2:	b.n	91a2 <_realloc_r+0x2a6>
    90f4:	bic.w	fp, r1, #3
    90f8:	add	fp, r4
    90fa:	add.w	r0, r5, #16
    90fe:	cmp	fp, r0
    9100:	bge.n	91b6 <_realloc_r+0x2ba>
    9102:	tst.w	lr, #1
    9106:	bne.w	8f54 <_realloc_r+0x58>
    910a:	ldr.w	r1, [r6, #-8]
    910e:	rsb	sl, r1, r8
    9112:	ldr.w	r1, [sl, #4]
    9116:	bic.w	ip, r1, #3
    911a:	add	fp, ip
    911c:	cmp	r0, fp
    911e:	bgt.w	8fd0 <_realloc_r+0xd4>
    9122:	mov	r7, sl
    9124:	ldr.w	r1, [sl, #12]
    9128:	ldr.w	r0, [r7, #8]!
    912c:	subs	r2, r4, #4
    912e:	cmp	r2, #36	; 0x24
    9130:	str	r1, [r0, #12]
    9132:	str	r0, [r1, #8]
    9134:	bhi.w	92a0 <_realloc_r+0x3a4>
    9138:	cmp	r2, #19
    913a:	bls.w	9288 <_realloc_r+0x38c>
    913e:	ldr	r1, [r6, #0]
    9140:	str.w	r1, [sl, #8]
    9144:	ldr	r1, [r6, #4]
    9146:	str.w	r1, [sl, #12]
    914a:	cmp	r2, #27
    914c:	bhi.w	92ae <_realloc_r+0x3b2>
    9150:	adds	r6, #8
    9152:	add.w	r2, sl, #16
    9156:	ldr	r1, [r6, #0]
    9158:	str	r1, [r2, #0]
    915a:	ldr	r1, [r6, #4]
    915c:	str	r1, [r2, #4]
    915e:	ldr	r1, [r6, #8]
    9160:	str	r1, [r2, #8]
    9162:	add.w	r1, sl, r5
    9166:	rsb	r2, r5, fp
    916a:	orr.w	r2, r2, #1
    916e:	str	r1, [r3, #8]
    9170:	str	r2, [r1, #4]
    9172:	ldr.w	r3, [sl, #4]
    9176:	and.w	r3, r3, #1
    917a:	orrs	r5, r3
    917c:	mov	r0, r9
    917e:	str.w	r5, [sl, #4]
    9182:	bl	8ef8 <__malloc_unlock>
    9186:	mov	r0, r7
    9188:	b.n	9044 <_realloc_r+0x148>
    918a:	ldr	r3, [r6, #0]
    918c:	str	r3, [r0, #0]
    918e:	ldr	r3, [r6, #4]
    9190:	str	r3, [r0, #4]
    9192:	cmp	r2, #27
    9194:	bhi.n	91e6 <_realloc_r+0x2ea>
    9196:	add.w	r3, r0, #8
    919a:	add.w	r2, r6, #8
    919e:	b.n	8f86 <_realloc_r+0x8a>
    91a0:	mov	r3, r7
    91a2:	ldr	r2, [r6, #0]
    91a4:	str	r2, [r3, #0]
    91a6:	ldr	r2, [r6, #4]
    91a8:	str	r2, [r3, #4]
    91aa:	ldr	r2, [r6, #8]
    91ac:	str	r2, [r3, #8]
    91ae:	mov	r6, r7
    91b0:	mov	r4, lr
    91b2:	mov	r8, sl
    91b4:	b.n	901e <_realloc_r+0x122>
    91b6:	add.w	r1, r8, r5
    91ba:	rsb	fp, r5, fp
    91be:	orr.w	r2, fp, #1
    91c2:	str	r1, [r3, #8]
    91c4:	str	r2, [r1, #4]
    91c6:	ldr.w	r3, [r6, #-4]
    91ca:	and.w	r3, r3, #1
    91ce:	orrs	r5, r3
    91d0:	mov	r0, r9
    91d2:	str.w	r5, [r6, #-4]
    91d6:	bl	8ef8 <__malloc_unlock>
    91da:	mov	r0, r6
    91dc:	b.n	9044 <_realloc_r+0x148>
    91de:	mov	r1, r6
    91e0:	bl	8d90 <memmove>
    91e4:	b.n	8f92 <_realloc_r+0x96>
    91e6:	ldr	r3, [r6, #8]
    91e8:	str	r3, [r0, #8]
    91ea:	ldr	r3, [r6, #12]
    91ec:	str	r3, [r0, #12]
    91ee:	cmp	r2, #36	; 0x24
    91f0:	beq.n	9244 <_realloc_r+0x348>
    91f2:	add.w	r3, r0, #16
    91f6:	add.w	r2, r6, #16
    91fa:	b.n	8f86 <_realloc_r+0x8a>
    91fc:	ldr.w	r3, [r0, #-4]
    9200:	bic.w	r3, r3, #3
    9204:	add	r4, r3
    9206:	b.n	901e <_realloc_r+0x122>
    9208:	mov	r1, r6
    920a:	mov	r0, r7
    920c:	mov	r4, lr
    920e:	mov	r8, sl
    9210:	bl	8d90 <memmove>
    9214:	mov	r6, r7
    9216:	b.n	901e <_realloc_r+0x122>
    9218:	mov	r2, r7
    921a:	b.n	900c <_realloc_r+0x110>
    921c:	mov	r1, r6
    921e:	mov	r0, r7
    9220:	mov	r4, r3
    9222:	mov	r8, sl
    9224:	bl	8d90 <memmove>
    9228:	mov	r6, r7
    922a:	b.n	901e <_realloc_r+0x122>
    922c:	ldr	r3, [r6, #8]
    922e:	str.w	r3, [sl, #16]
    9232:	ldr	r3, [r6, #12]
    9234:	str.w	r3, [sl, #20]
    9238:	cmp	r2, #36	; 0x24
    923a:	beq.n	9274 <_realloc_r+0x378>
    923c:	adds	r6, #16
    923e:	add.w	r3, sl, #24
    9242:	b.n	91a2 <_realloc_r+0x2a6>
    9244:	ldr	r3, [r6, #16]
    9246:	str	r3, [r0, #16]
    9248:	ldr	r3, [r6, #20]
    924a:	str	r3, [r0, #20]
    924c:	add.w	r2, r6, #24
    9250:	add.w	r3, r0, #24
    9254:	b.n	8f86 <_realloc_r+0x8a>
    9256:	nop
    9258:	.word	0x20001840
    925c:	ldr	r1, [r6, #8]
    925e:	str.w	r1, [sl, #16]
    9262:	ldr	r1, [r6, #12]
    9264:	str.w	r1, [sl, #20]
    9268:	cmp	r2, #36	; 0x24
    926a:	beq.n	928c <_realloc_r+0x390>
    926c:	adds	r6, #16
    926e:	add.w	r2, sl, #24
    9272:	b.n	900c <_realloc_r+0x110>
    9274:	ldr	r3, [r6, #16]
    9276:	str.w	r3, [sl, #24]
    927a:	ldr	r3, [r6, #20]
    927c:	str.w	r3, [sl, #28]
    9280:	adds	r6, #24
    9282:	add.w	r3, sl, #32
    9286:	b.n	91a2 <_realloc_r+0x2a6>
    9288:	mov	r2, r7
    928a:	b.n	9156 <_realloc_r+0x25a>
    928c:	ldr	r2, [r6, #16]
    928e:	str.w	r2, [sl, #24]
    9292:	ldr	r2, [r6, #20]
    9294:	str.w	r2, [sl, #28]
    9298:	adds	r6, #24
    929a:	add.w	r2, sl, #32
    929e:	b.n	900c <_realloc_r+0x110>
    92a0:	mov	r1, r6
    92a2:	mov	r0, r7
    92a4:	str	r3, [sp, #4]
    92a6:	bl	8d90 <memmove>
    92aa:	ldr	r3, [sp, #4]
    92ac:	b.n	9162 <_realloc_r+0x266>
    92ae:	ldr	r1, [r6, #8]
    92b0:	str.w	r1, [sl, #16]
    92b4:	ldr	r1, [r6, #12]
    92b6:	str.w	r1, [sl, #20]
    92ba:	cmp	r2, #36	; 0x24
    92bc:	beq.n	92c6 <_realloc_r+0x3ca>
    92be:	adds	r6, #16
    92c0:	add.w	r2, sl, #24
    92c4:	b.n	9156 <_realloc_r+0x25a>
    92c6:	ldr	r2, [r6, #16]
    92c8:	str.w	r2, [sl, #24]
    92cc:	ldr	r2, [r6, #20]
    92ce:	str.w	r2, [sl, #28]
    92d2:	adds	r6, #24
    92d4:	add.w	r2, sl, #32
    92d8:	b.n	9156 <_realloc_r+0x25a>
    92da:	nop

000092dc <_sbrk_r>:
    92dc:	push	{r3, r4, r5, lr}
    92de:	ldr	r4, [pc, #28]	; (92fc <_sbrk_r+0x20>)
    92e0:	movs	r3, #0
    92e2:	mov	r5, r0
    92e4:	mov	r0, r1
    92e6:	str	r3, [r4, #0]
    92e8:	bl	2fd0 <_sbrk>
    92ec:	adds	r3, r0, #1
    92ee:	beq.n	92f2 <_sbrk_r+0x16>
    92f0:	pop	{r3, r4, r5, pc}
    92f2:	ldr	r3, [r4, #0]
    92f4:	cmp	r3, #0
    92f6:	beq.n	92f0 <_sbrk_r+0x14>
    92f8:	str	r3, [r5, #0]
    92fa:	pop	{r3, r4, r5, pc}
    92fc:	.word	0x20004284

00009300 <sprintf>:
    9300:	push	{r1, r2, r3}
    9302:	push	{r4, r5, r6, r7, lr}
    9304:	sub	sp, #112	; 0x70
    9306:	add	r3, sp, #132	; 0x84
    9308:	ldr	r1, [pc, #60]	; (9348 <sprintf+0x48>)
    930a:	ldr.w	r2, [r3], #4
    930e:	str	r3, [sp, #4]
    9310:	mov	r5, r0
    9312:	mvn.w	r4, #2147483648	; 0x80000000
    9316:	ldr	r0, [r1, #0]
    9318:	str	r5, [sp, #8]
    931a:	mov.w	r7, #520	; 0x208
    931e:	movw	r6, #65535	; 0xffff
    9322:	add	r1, sp, #8
    9324:	str	r5, [sp, #24]
    9326:	strh.w	r7, [sp, #20]
    932a:	str	r4, [sp, #16]
    932c:	str	r4, [sp, #28]
    932e:	strh.w	r6, [sp, #22]
    9332:	bl	9460 <_svfprintf_r>
    9336:	ldr	r3, [sp, #8]
    9338:	movs	r2, #0
    933a:	strb	r2, [r3, #0]
    933c:	add	sp, #112	; 0x70
    933e:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    9342:	add	sp, #12
    9344:	bx	lr
    9346:	nop
    9348:	.word	0x200016d0
	...

00009380 <strlen>:
    9380:	pld	[r0]
    9384:	strd	r4, r5, [sp, #-8]!
    9388:	bic.w	r1, r0, #7
    938c:	mvn.w	ip, #0
    9390:	ands.w	r4, r0, #7
    9394:	pld	[r1, #32]
    9398:	bne.w	942e <strlen+0xae>
    939c:	mov.w	r4, #0
    93a0:	mvn.w	r0, #7
    93a4:	ldrd	r2, r3, [r1]
    93a8:	pld	[r1, #64]	; 0x40
    93ac:	add.w	r0, r0, #8
    93b0:	uadd8	r2, r2, ip
    93b4:	sel	r2, r4, ip
    93b8:	uadd8	r3, r3, ip
    93bc:	sel	r3, r2, ip
    93c0:	cbnz	r3, 9416 <strlen+0x96>
    93c2:	ldrd	r2, r3, [r1, #8]
    93c6:	uadd8	r2, r2, ip
    93ca:	add.w	r0, r0, #8
    93ce:	sel	r2, r4, ip
    93d2:	uadd8	r3, r3, ip
    93d6:	sel	r3, r2, ip
    93da:	cbnz	r3, 9416 <strlen+0x96>
    93dc:	ldrd	r2, r3, [r1, #16]
    93e0:	uadd8	r2, r2, ip
    93e4:	add.w	r0, r0, #8
    93e8:	sel	r2, r4, ip
    93ec:	uadd8	r3, r3, ip
    93f0:	sel	r3, r2, ip
    93f4:	cbnz	r3, 9416 <strlen+0x96>
    93f6:	ldrd	r2, r3, [r1, #24]
    93fa:	add.w	r1, r1, #32
    93fe:	uadd8	r2, r2, ip
    9402:	add.w	r0, r0, #8
    9406:	sel	r2, r4, ip
    940a:	uadd8	r3, r3, ip
    940e:	sel	r3, r2, ip
    9412:	cmp	r3, #0
    9414:	beq.n	93a4 <strlen+0x24>
    9416:	cmp	r2, #0
    9418:	itt	eq
    941a:	addeq	r0, #4
    941c:	moveq	r2, r3
    941e:	rev	r2, r2
    9420:	clz	r2, r2
    9424:	ldrd	r4, r5, [sp], #8
    9428:	add.w	r0, r0, r2, lsr #3
    942c:	bx	lr
    942e:	ldrd	r2, r3, [r1]
    9432:	and.w	r5, r4, #3
    9436:	rsb	r0, r4, #0
    943a:	mov.w	r5, r5, lsl #3
    943e:	tst.w	r4, #4
    9442:	pld	[r1, #64]	; 0x40
    9446:	lsl.w	r5, ip, r5
    944a:	orn	r2, r2, r5
    944e:	itt	ne
    9450:	ornne	r3, r3, r5
    9454:	movne	r2, ip
    9456:	mov.w	r4, #0
    945a:	b.n	93b0 <strlen+0x30>
    945c:	movs	r0, r0
	...

00009460 <_svfprintf_r>:
    9460:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9464:	vpush	{d8-d10}
    9468:	sub	sp, #228	; 0xe4
    946a:	mov	r4, r1
    946c:	str	r1, [sp, #12]
    946e:	mov	sl, r2
    9470:	str	r3, [sp, #36]	; 0x24
    9472:	str	r0, [sp, #20]
    9474:	bl	d074 <_localeconv_r>
    9478:	ldr	r3, [r0, #0]
    947a:	str	r3, [sp, #64]	; 0x40
    947c:	mov	r0, r3
    947e:	bl	9380 <strlen>
    9482:	ldrh	r3, [r4, #12]
    9484:	str	r0, [sp, #60]	; 0x3c
    9486:	lsls	r1, r3, #24
    9488:	bpl.n	9492 <_svfprintf_r+0x32>
    948a:	ldr	r3, [r4, #16]
    948c:	cmp	r3, #0
    948e:	beq.w	a58c <_svfprintf_r+0x112c>
    9492:	movs	r3, #0
    9494:	vldr	d8, [pc, #656]	; 9728 <_svfprintf_r+0x2c8>
    9498:	vldr	d9, [pc, #660]	; 9730 <_svfprintf_r+0x2d0>
    949c:	str	r3, [sp, #52]	; 0x34
    949e:	str	r3, [sp, #116]	; 0x74
    94a0:	str	r3, [sp, #112]	; 0x70
    94a2:	str	r3, [sp, #68]	; 0x44
    94a4:	str	r3, [sp, #24]
    94a6:	add	r3, sp, #160	; 0xa0
    94a8:	str	r3, [sp, #108]	; 0x6c
    94aa:	mov	r9, r3
    94ac:	ldrb.w	r3, [sl]
    94b0:	mov	r4, sl
    94b2:	cbz	r3, 94f0 <_svfprintf_r+0x90>
    94b4:	cmp	r3, #37	; 0x25
    94b6:	bne.n	94be <_svfprintf_r+0x5e>
    94b8:	b.n	94f0 <_svfprintf_r+0x90>
    94ba:	cmp	r3, #37	; 0x25
    94bc:	beq.n	94c6 <_svfprintf_r+0x66>
    94be:	ldrb.w	r3, [r4, #1]!
    94c2:	cmp	r3, #0
    94c4:	bne.n	94ba <_svfprintf_r+0x5a>
    94c6:	rsb	r5, sl, r4
    94ca:	cbz	r5, 94f0 <_svfprintf_r+0x90>
    94cc:	ldr	r3, [sp, #112]	; 0x70
    94ce:	ldr	r2, [sp, #116]	; 0x74
    94d0:	str.w	sl, [r9]
    94d4:	adds	r3, #1
    94d6:	add	r2, r5
    94d8:	cmp	r3, #7
    94da:	str.w	r5, [r9, #4]
    94de:	str	r2, [sp, #116]	; 0x74
    94e0:	str	r3, [sp, #112]	; 0x70
    94e2:	bgt.w	962c <_svfprintf_r+0x1cc>
    94e6:	add.w	r9, r9, #8
    94ea:	ldr	r3, [sp, #24]
    94ec:	add	r3, r5
    94ee:	str	r3, [sp, #24]
    94f0:	ldrb	r3, [r4, #0]
    94f2:	cmp	r3, #0
    94f4:	beq.w	963e <_svfprintf_r+0x1de>
    94f8:	movs	r3, #0
    94fa:	mov	r2, r3
    94fc:	strb.w	r3, [sp, #79]	; 0x4f
    9500:	mov	r1, r3
    9502:	str	r3, [sp, #28]
    9504:	mov	fp, r3
    9506:	mov.w	r8, #4294967295
    950a:	ldrb	r3, [r4, #1]
    950c:	add.w	sl, r4, #1
    9510:	mov	r5, r8
    9512:	add.w	sl, sl, #1
    9516:	sub.w	r0, r3, #32
    951a:	cmp	r0, #88	; 0x58
    951c:	bhi.w	9d10 <_svfprintf_r+0x8b0>
    9520:	tbh	[pc, r0, lsl #1]
    9524:	.word	0x03f60363
    9528:	.word	0x036b03f6
    952c:	.word	0x03f603f6
    9530:	.word	0x03f603f6
    9534:	.word	0x03f603f6
    9538:	.word	0x037e0370
    953c:	.word	0x005d03f6
    9540:	.word	0x03f600df
    9544:	.word	0x010c00fb
    9548:	.word	0x010c010c
    954c:	.word	0x010c010c
    9550:	.word	0x010c010c
    9554:	.word	0x010c010c
    9558:	.word	0x03f603f6
    955c:	.word	0x03f603f6
    9560:	.word	0x03f603f6
    9564:	.word	0x03f603f6
    9568:	.word	0x03f603f6
    956c:	.word	0x015e011c
    9570:	.word	0x015e03f6
    9574:	.word	0x03f603f6
    9578:	.word	0x03f603f6
    957c:	.word	0x03f602a1
    9580:	.word	0x02a603f6
    9584:	.word	0x03f603f6
    9588:	.word	0x03f603f6
    958c:	.word	0x02d803f6
    9590:	.word	0x03f603f6
    9594:	.word	0x03f60305
    9598:	.word	0x03f603f6
    959c:	.word	0x03f603f6
    95a0:	.word	0x03f603f6
    95a4:	.word	0x03f603f6
    95a8:	.word	0x034303f6
    95ac:	.word	0x015e0356
    95b0:	.word	0x015e015e
    95b4:	.word	0x0356035e
    95b8:	.word	0x03f603f6
    95bc:	.word	0x03f603a4
    95c0:	.word	0x00a203b1
    95c4:	.word	0x03c30062
    95c8:	.word	0x03c803f6
    95cc:	.word	0x038303f6
    95d0:	.word	0x03f603f6
    95d4:	.short	0x038b
    95d6:	ldr	r0, [sp, #28]
    95d8:	str	r3, [sp, #36]	; 0x24
    95da:	negs	r0, r0
    95dc:	str	r0, [sp, #28]
    95de:	orr.w	fp, fp, #4
    95e2:	ldrb.w	r3, [sl]
    95e6:	b.n	9512 <_svfprintf_r+0xb2>
    95e8:	mov	r8, r5
    95ea:	ldr	r0, [sp, #36]	; 0x24
    95ec:	movs	r1, #0
    95ee:	movs	r3, #48	; 0x30
    95f0:	movs	r2, #120	; 0x78
    95f2:	cmp	r8, r1
    95f4:	strb.w	r3, [sp, #80]	; 0x50
    95f8:	ldr	r4, [r0, #0]
    95fa:	strb.w	r2, [sp, #81]	; 0x51
    95fe:	add.w	r7, r0, #4
    9602:	mov.w	r5, #0
    9606:	strb.w	r1, [sp, #79]	; 0x4f
    960a:	orr.w	r3, fp, #2
    960e:	blt.w	9d4a <_svfprintf_r+0x8ea>
    9612:	bic.w	r3, fp, #128	; 0x80
    9616:	orr.w	fp, r3, #2
    961a:	orrs.w	r3, r4, r5
    961e:	str	r7, [sp, #36]	; 0x24
    9620:	beq.w	9cf6 <_svfprintf_r+0x896>
    9624:	mov	r7, r1
    9626:	str	r2, [sp, #48]	; 0x30
    9628:	ldr	r0, [pc, #268]	; (9738 <_svfprintf_r+0x2d8>)
    962a:	b.n	9b8a <_svfprintf_r+0x72a>
    962c:	add	r2, sp, #108	; 0x6c
    962e:	ldr	r1, [sp, #12]
    9630:	ldr	r0, [sp, #20]
    9632:	bl	d8cc <__ssprint_r>
    9636:	cbnz	r0, 964c <_svfprintf_r+0x1ec>
    9638:	add.w	r9, sp, #160	; 0xa0
    963c:	b.n	94ea <_svfprintf_r+0x8a>
    963e:	ldr	r3, [sp, #116]	; 0x74
    9640:	cbz	r3, 964c <_svfprintf_r+0x1ec>
    9642:	ldr	r0, [sp, #20]
    9644:	ldr	r1, [sp, #12]
    9646:	add	r2, sp, #108	; 0x6c
    9648:	bl	d8cc <__ssprint_r>
    964c:	ldr	r3, [sp, #12]
    964e:	ldrh	r3, [r3, #12]
    9650:	tst.w	r3, #64	; 0x40
    9654:	ldr	r3, [sp, #24]
    9656:	it	ne
    9658:	movne.w	r3, #4294967295
    965c:	mov	r0, r3
    965e:	add	sp, #228	; 0xe4
    9660:	vpop	{d8-d10}
    9664:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9668:	str	r3, [sp, #48]	; 0x30
    966a:	mov	r8, r5
    966c:	cmp	r2, #0
    966e:	bne.w	a9a6 <_svfprintf_r+0x1546>
    9672:	ands.w	r3, fp, #32
    9676:	beq.w	9a86 <_svfprintf_r+0x626>
    967a:	ldr	r7, [sp, #36]	; 0x24
    967c:	adds	r7, #7
    967e:	bic.w	r3, r7, #7
    9682:	movs	r7, #0
    9684:	add.w	r2, r3, #8
    9688:	cmp	r8, r7
    968a:	str	r2, [sp, #36]	; 0x24
    968c:	ldrd	r4, r5, [r3]
    9690:	strb.w	r7, [sp, #79]	; 0x4f
    9694:	blt.w	a354 <_svfprintf_r+0xef4>
    9698:	orrs.w	r3, r4, r5
    969c:	bic.w	fp, fp, #128	; 0x80
    96a0:	beq.w	9d3a <_svfprintf_r+0x8da>
    96a4:	add	r6, sp, #160	; 0xa0
    96a6:	lsrs	r2, r4, #3
    96a8:	orr.w	r2, r2, r5, lsl #29
    96ac:	lsrs	r1, r5, #3
    96ae:	and.w	r3, r4, #7
    96b2:	mov	r5, r1
    96b4:	mov	r4, r2
    96b6:	adds	r3, #48	; 0x30
    96b8:	orrs.w	r2, r4, r5
    96bc:	strb.w	r3, [r6, #-1]!
    96c0:	bne.n	96a6 <_svfprintf_r+0x246>
    96c2:	tst.w	fp, #1
    96c6:	beq.w	9b18 <_svfprintf_r+0x6b8>
    96ca:	cmp	r3, #48	; 0x30
    96cc:	beq.w	9b18 <_svfprintf_r+0x6b8>
    96d0:	movs	r2, #48	; 0x30
    96d2:	subs	r3, r6, #1
    96d4:	strb.w	r2, [r6, #-1]
    96d8:	add	r2, sp, #160	; 0xa0
    96da:	subs	r2, r2, r3
    96dc:	str	r2, [sp, #32]
    96de:	mov	r6, r3
    96e0:	b.n	9b1e <_svfprintf_r+0x6be>
    96e2:	ldrb.w	r3, [sl]
    96e6:	cmp	r3, #42	; 0x2a
    96e8:	add.w	r4, sl, #1
    96ec:	beq.w	a94e <_svfprintf_r+0x14ee>
    96f0:	sub.w	r0, r3, #48	; 0x30
    96f4:	cmp	r0, #9
    96f6:	it	ls
    96f8:	movls	r5, #0
    96fa:	bhi.w	a8a8 <_svfprintf_r+0x1448>
    96fe:	ldrb.w	r3, [r4], #1
    9702:	add.w	r5, r5, r5, lsl #2
    9706:	add.w	r5, r0, r5, lsl #1
    970a:	sub.w	r0, r3, #48	; 0x30
    970e:	cmp	r0, #9
    9710:	bls.n	96fe <_svfprintf_r+0x29e>
    9712:	orr.w	r5, r5, r5, asr #31
    9716:	mov	sl, r4
    9718:	b.n	9516 <_svfprintf_r+0xb6>
    971a:	orr.w	fp, fp, #128	; 0x80
    971e:	ldrb.w	r3, [sl]
    9722:	b.n	9512 <_svfprintf_r+0xb2>
    9724:	nop.w
	...
    9730:	.word	0xffffffff
    9734:	.word	0x7fefffff
    9738:	.word	0x20000ff4
    973c:	sub.w	r0, r3, #48	; 0x30
    9740:	movs	r3, #0
    9742:	mov	r4, r3
    9744:	ldrb.w	r3, [sl], #1
    9748:	add.w	r4, r4, r4, lsl #2
    974c:	add.w	r4, r0, r4, lsl #1
    9750:	sub.w	r0, r3, #48	; 0x30
    9754:	cmp	r0, #9
    9756:	bls.n	9744 <_svfprintf_r+0x2e4>
    9758:	str	r4, [sp, #28]
    975a:	b.n	9516 <_svfprintf_r+0xb6>
    975c:	str	r3, [sp, #48]	; 0x30
    975e:	mov	r8, r5
    9760:	cmp	r2, #0
    9762:	bne.w	a9be <_svfprintf_r+0x155e>
    9766:	orr.w	fp, fp, #16
    976a:	tst.w	fp, #32
    976e:	beq.w	a178 <_svfprintf_r+0xd18>
    9772:	ldr	r7, [sp, #36]	; 0x24
    9774:	adds	r7, #7
    9776:	bic.w	r7, r7, #7
    977a:	ldrd	r2, r3, [r7]
    977e:	add.w	r1, r7, #8
    9782:	str	r1, [sp, #36]	; 0x24
    9784:	mov	r4, r2
    9786:	mov	r5, r3
    9788:	cmp	r2, #0
    978a:	sbcs.w	r3, r3, #0
    978e:	blt.w	a200 <_svfprintf_r+0xda0>
    9792:	cmp.w	r8, #0
    9796:	ldrb.w	r7, [sp, #79]	; 0x4f
    979a:	blt.w	9b08 <_svfprintf_r+0x6a8>
    979e:	orrs.w	r3, r4, r5
    97a2:	bic.w	fp, fp, #128	; 0x80
    97a6:	beq.w	9f96 <_svfprintf_r+0xb36>
    97aa:	cmp	r5, #0
    97ac:	it	eq
    97ae:	cmpeq	r4, #10
    97b0:	bcc.w	9b10 <_svfprintf_r+0x6b0>
    97b4:	add	r6, sp, #160	; 0xa0
    97b6:	mov	r0, r4
    97b8:	mov	r1, r5
    97ba:	movs	r2, #10
    97bc:	movs	r3, #0
    97be:	bl	dc78 <__aeabi_uldivmod>
    97c2:	adds	r2, #48	; 0x30
    97c4:	strb.w	r2, [r6, #-1]!
    97c8:	mov	r0, r4
    97ca:	mov	r1, r5
    97cc:	movs	r3, #0
    97ce:	movs	r2, #10
    97d0:	bl	dc78 <__aeabi_uldivmod>
    97d4:	mov	r4, r0
    97d6:	mov	r5, r1
    97d8:	orrs.w	r3, r4, r5
    97dc:	bne.n	97b6 <_svfprintf_r+0x356>
    97de:	b.n	9b18 <_svfprintf_r+0x6b8>
    97e0:	str	r3, [sp, #48]	; 0x30
    97e2:	mov	r8, r5
    97e4:	cmp	r2, #0
    97e6:	bne.w	a9b6 <_svfprintf_r+0x1556>
    97ea:	ldr	r7, [sp, #36]	; 0x24
    97ec:	tst.w	fp, #8
    97f0:	add.w	r7, r7, #7
    97f4:	beq.w	a478 <_svfprintf_r+0x1018>
    97f8:	bic.w	r3, r7, #7
    97fc:	vldr	d8, [r3]
    9800:	add.w	r2, r3, #8
    9804:	str	r2, [sp, #36]	; 0x24
    9806:	vabs.f64	d7, d8
    980a:	vcmp.f64	d7, d9
    980e:	vmrs	APSR_nzcv, fpscr
    9812:	ble.w	a38e <_svfprintf_r+0xf2e>
    9816:	vcmpe.f64	d8, #0.0
    981a:	vmrs	APSR_nzcv, fpscr
    981e:	bmi.w	a7b6 <_svfprintf_r+0x1356>
    9822:	ldrb.w	r7, [sp, #79]	; 0x4f
    9826:	ldr	r6, [pc, #668]	; (9ac4 <_svfprintf_r+0x664>)
    9828:	ldr	r3, [pc, #668]	; (9ac8 <_svfprintf_r+0x668>)
    982a:	ldr	r1, [sp, #48]	; 0x30
    982c:	movs	r2, #3
    982e:	mov.w	r8, #0
    9832:	str	r2, [sp, #16]
    9834:	bic.w	fp, fp, #128	; 0x80
    9838:	cmp	r1, #71	; 0x47
    983a:	it	le
    983c:	movle	r6, r3
    983e:	str	r2, [sp, #32]
    9840:	str.w	r8, [sp, #56]	; 0x38
    9844:	cbz	r7, 984c <_svfprintf_r+0x3ec>
    9846:	ldr	r3, [sp, #16]
    9848:	adds	r3, #1
    984a:	str	r3, [sp, #16]
    984c:	ands.w	r3, fp, #2
    9850:	str	r3, [sp, #40]	; 0x28
    9852:	beq.n	985a <_svfprintf_r+0x3fa>
    9854:	ldr	r3, [sp, #16]
    9856:	adds	r3, #2
    9858:	str	r3, [sp, #16]
    985a:	ands.w	r3, fp, #132	; 0x84
    985e:	str	r3, [sp, #44]	; 0x2c
    9860:	bne.w	9d64 <_svfprintf_r+0x904>
    9864:	ldr	r3, [sp, #28]
    9866:	ldr	r2, [sp, #16]
    9868:	subs	r4, r3, r2
    986a:	cmp	r4, #0
    986c:	ble.w	9d64 <_svfprintf_r+0x904>
    9870:	cmp	r4, #16
    9872:	ldr	r1, [sp, #116]	; 0x74
    9874:	ldr	r2, [sp, #112]	; 0x70
    9876:	ldr	r7, [pc, #596]	; (9acc <_svfprintf_r+0x66c>)
    9878:	ble.n	98c2 <_svfprintf_r+0x462>
    987a:	mov	r0, r9
    987c:	movs	r5, #16
    987e:	mov	r9, r8
    9880:	mov	r8, r6
    9882:	ldr	r6, [sp, #20]
    9884:	b.n	9890 <_svfprintf_r+0x430>
    9886:	subs	r4, #16
    9888:	cmp	r4, #16
    988a:	add.w	r0, r0, #8
    988e:	ble.n	98bc <_svfprintf_r+0x45c>
    9890:	adds	r2, #1
    9892:	adds	r1, #16
    9894:	cmp	r2, #7
    9896:	str	r1, [sp, #116]	; 0x74
    9898:	str	r2, [sp, #112]	; 0x70
    989a:	str	r7, [r0, #0]
    989c:	str	r5, [r0, #4]
    989e:	ble.n	9886 <_svfprintf_r+0x426>
    98a0:	add	r2, sp, #108	; 0x6c
    98a2:	ldr	r1, [sp, #12]
    98a4:	mov	r0, r6
    98a6:	bl	d8cc <__ssprint_r>
    98aa:	cmp	r0, #0
    98ac:	bne.w	964c <_svfprintf_r+0x1ec>
    98b0:	subs	r4, #16
    98b2:	cmp	r4, #16
    98b4:	ldr	r1, [sp, #116]	; 0x74
    98b6:	ldr	r2, [sp, #112]	; 0x70
    98b8:	add	r0, sp, #160	; 0xa0
    98ba:	bgt.n	9890 <_svfprintf_r+0x430>
    98bc:	mov	r6, r8
    98be:	mov	r8, r9
    98c0:	mov	r9, r0
    98c2:	adds	r2, #1
    98c4:	adds	r3, r4, r1
    98c6:	cmp	r2, #7
    98c8:	str	r3, [sp, #116]	; 0x74
    98ca:	str	r2, [sp, #112]	; 0x70
    98cc:	str.w	r7, [r9]
    98d0:	str.w	r4, [r9, #4]
    98d4:	bgt.w	a09c <_svfprintf_r+0xc3c>
    98d8:	ldrb.w	r7, [sp, #79]	; 0x4f
    98dc:	add.w	r9, r9, #8
    98e0:	cbz	r7, 9900 <_svfprintf_r+0x4a0>
    98e2:	ldr	r2, [sp, #112]	; 0x70
    98e4:	adds	r2, #1
    98e6:	adds	r3, #1
    98e8:	add.w	r0, sp, #79	; 0x4f
    98ec:	movs	r1, #1
    98ee:	cmp	r2, #7
    98f0:	str	r3, [sp, #116]	; 0x74
    98f2:	str	r2, [sp, #112]	; 0x70
    98f4:	stmia.w	r9, {r0, r1}
    98f8:	bgt.w	9fba <_svfprintf_r+0xb5a>
    98fc:	add.w	r9, r9, #8
    9900:	ldr	r2, [sp, #40]	; 0x28
    9902:	cbz	r2, 9920 <_svfprintf_r+0x4c0>
    9904:	ldr	r2, [sp, #112]	; 0x70
    9906:	adds	r2, #1
    9908:	adds	r3, #2
    990a:	add	r0, sp, #80	; 0x50
    990c:	movs	r1, #2
    990e:	cmp	r2, #7
    9910:	str	r3, [sp, #116]	; 0x74
    9912:	str	r2, [sp, #112]	; 0x70
    9914:	stmia.w	r9, {r0, r1}
    9918:	bgt.w	9fd2 <_svfprintf_r+0xb72>
    991c:	add.w	r9, r9, #8
    9920:	ldr	r2, [sp, #44]	; 0x2c
    9922:	cmp	r2, #128	; 0x80
    9924:	beq.w	9e24 <_svfprintf_r+0x9c4>
    9928:	ldr	r2, [sp, #32]
    992a:	rsb	r4, r2, r8
    992e:	cmp	r4, #0
    9930:	ble.n	999c <_svfprintf_r+0x53c>
    9932:	cmp	r4, #16
    9934:	ldr	r2, [sp, #112]	; 0x70
    9936:	ldr	r7, [pc, #408]	; (9ad0 <_svfprintf_r+0x670>)
    9938:	ble.n	9982 <_svfprintf_r+0x522>
    993a:	mov	r1, r9
    993c:	mov.w	r8, #16
    9940:	mov	r9, r6
    9942:	ldr	r5, [sp, #20]
    9944:	ldr	r6, [sp, #12]
    9946:	b.n	9952 <_svfprintf_r+0x4f2>
    9948:	subs	r4, #16
    994a:	cmp	r4, #16
    994c:	add.w	r1, r1, #8
    9950:	ble.n	997e <_svfprintf_r+0x51e>
    9952:	adds	r2, #1
    9954:	adds	r3, #16
    9956:	cmp	r2, #7
    9958:	str	r3, [sp, #116]	; 0x74
    995a:	str	r2, [sp, #112]	; 0x70
    995c:	stmia.w	r1, {r7, r8}
    9960:	ble.n	9948 <_svfprintf_r+0x4e8>
    9962:	add	r2, sp, #108	; 0x6c
    9964:	mov	r1, r6
    9966:	mov	r0, r5
    9968:	bl	d8cc <__ssprint_r>
    996c:	cmp	r0, #0
    996e:	bne.w	964c <_svfprintf_r+0x1ec>
    9972:	subs	r4, #16
    9974:	cmp	r4, #16
    9976:	ldr	r3, [sp, #116]	; 0x74
    9978:	ldr	r2, [sp, #112]	; 0x70
    997a:	add	r1, sp, #160	; 0xa0
    997c:	bgt.n	9952 <_svfprintf_r+0x4f2>
    997e:	mov	r6, r9
    9980:	mov	r9, r1
    9982:	adds	r2, #1
    9984:	add	r3, r4
    9986:	cmp	r2, #7
    9988:	str	r3, [sp, #116]	; 0x74
    998a:	str	r2, [sp, #112]	; 0x70
    998c:	str.w	r7, [r9]
    9990:	str.w	r4, [r9, #4]
    9994:	bgt.w	9fa2 <_svfprintf_r+0xb42>
    9998:	add.w	r9, r9, #8
    999c:	tst.w	fp, #256	; 0x100
    99a0:	bne.w	9d68 <_svfprintf_r+0x908>
    99a4:	ldr	r2, [sp, #112]	; 0x70
    99a6:	ldr	r0, [sp, #32]
    99a8:	str.w	r6, [r9]
    99ac:	adds	r2, #1
    99ae:	add	r3, r0
    99b0:	cmp	r2, #7
    99b2:	str	r3, [sp, #116]	; 0x74
    99b4:	str.w	r0, [r9, #4]
    99b8:	str	r2, [sp, #112]	; 0x70
    99ba:	bgt.w	9f42 <_svfprintf_r+0xae2>
    99be:	add.w	r9, r9, #8
    99c2:	tst.w	fp, #4
    99c6:	beq.n	9a46 <_svfprintf_r+0x5e6>
    99c8:	ldr	r2, [sp, #28]
    99ca:	ldr	r1, [sp, #16]
    99cc:	subs	r4, r2, r1
    99ce:	cmp	r4, #0
    99d0:	ble.n	9a46 <_svfprintf_r+0x5e6>
    99d2:	cmp	r4, #16
    99d4:	ldr	r2, [sp, #112]	; 0x70
    99d6:	ldr	r7, [pc, #244]	; (9acc <_svfprintf_r+0x66c>)
    99d8:	ble.n	9a20 <_svfprintf_r+0x5c0>
    99da:	movs	r5, #16
    99dc:	ldr	r6, [sp, #20]
    99de:	ldr.w	r8, [sp, #12]
    99e2:	b.n	99ee <_svfprintf_r+0x58e>
    99e4:	subs	r4, #16
    99e6:	cmp	r4, #16
    99e8:	add.w	r9, r9, #8
    99ec:	ble.n	9a20 <_svfprintf_r+0x5c0>
    99ee:	adds	r2, #1
    99f0:	adds	r3, #16
    99f2:	cmp	r2, #7
    99f4:	str	r3, [sp, #116]	; 0x74
    99f6:	str	r2, [sp, #112]	; 0x70
    99f8:	str.w	r7, [r9]
    99fc:	str.w	r5, [r9, #4]
    9a00:	ble.n	99e4 <_svfprintf_r+0x584>
    9a02:	add	r2, sp, #108	; 0x6c
    9a04:	mov	r1, r8
    9a06:	mov	r0, r6
    9a08:	bl	d8cc <__ssprint_r>
    9a0c:	cmp	r0, #0
    9a0e:	bne.w	964c <_svfprintf_r+0x1ec>
    9a12:	subs	r4, #16
    9a14:	cmp	r4, #16
    9a16:	ldr	r3, [sp, #116]	; 0x74
    9a18:	ldr	r2, [sp, #112]	; 0x70
    9a1a:	add.w	r9, sp, #160	; 0xa0
    9a1e:	bgt.n	99ee <_svfprintf_r+0x58e>
    9a20:	adds	r2, #1
    9a22:	add	r3, r4
    9a24:	cmp	r2, #7
    9a26:	str	r3, [sp, #116]	; 0x74
    9a28:	str	r2, [sp, #112]	; 0x70
    9a2a:	str.w	r7, [r9]
    9a2e:	str.w	r4, [r9, #4]
    9a32:	ble.n	9a46 <_svfprintf_r+0x5e6>
    9a34:	add	r2, sp, #108	; 0x6c
    9a36:	ldr	r1, [sp, #12]
    9a38:	ldr	r0, [sp, #20]
    9a3a:	bl	d8cc <__ssprint_r>
    9a3e:	cmp	r0, #0
    9a40:	bne.w	964c <_svfprintf_r+0x1ec>
    9a44:	ldr	r3, [sp, #116]	; 0x74
    9a46:	ldr	r2, [sp, #24]
    9a48:	ldr	r1, [sp, #28]
    9a4a:	ldr	r0, [sp, #16]
    9a4c:	cmp	r1, r0
    9a4e:	ite	ge
    9a50:	addge	r2, r2, r1
    9a52:	addlt	r2, r2, r0
    9a54:	str	r2, [sp, #24]
    9a56:	cmp	r3, #0
    9a58:	bne.w	9f5a <_svfprintf_r+0xafa>
    9a5c:	movs	r3, #0
    9a5e:	str	r3, [sp, #112]	; 0x70
    9a60:	add.w	r9, sp, #160	; 0xa0
    9a64:	b.n	94ac <_svfprintf_r+0x4c>
    9a66:	orr.w	fp, fp, #8
    9a6a:	ldrb.w	r3, [sl]
    9a6e:	b.n	9512 <_svfprintf_r+0xb2>
    9a70:	str	r3, [sp, #48]	; 0x30
    9a72:	mov	r8, r5
    9a74:	cmp	r2, #0
    9a76:	bne.w	a9ae <_svfprintf_r+0x154e>
    9a7a:	orr.w	fp, fp, #16
    9a7e:	ands.w	r3, fp, #32
    9a82:	bne.w	967a <_svfprintf_r+0x21a>
    9a86:	ands.w	r2, fp, #16
    9a8a:	bne.w	a1b0 <_svfprintf_r+0xd50>
    9a8e:	ands.w	r3, fp, #64	; 0x40
    9a92:	beq.w	a1b0 <_svfprintf_r+0xd50>
    9a96:	ldr	r1, [sp, #36]	; 0x24
    9a98:	strb.w	r2, [sp, #79]	; 0x4f
    9a9c:	mov	r3, r1
    9a9e:	cmp.w	r8, #0
    9aa2:	add.w	r3, r3, #4
    9aa6:	ldrh	r4, [r1, #0]
    9aa8:	mov.w	r5, #0
    9aac:	blt.w	a606 <_svfprintf_r+0x11a6>
    9ab0:	orrs.w	r1, r4, r5
    9ab4:	bic.w	fp, fp, #128	; 0x80
    9ab8:	str	r3, [sp, #36]	; 0x24
    9aba:	beq.w	9d3a <_svfprintf_r+0x8da>
    9abe:	mov	r7, r2
    9ac0:	b.n	96a4 <_svfprintf_r+0x244>
    9ac2:	nop
    9ac4:	.word	0x20000fd4
    9ac8:	.word	0x20000fd0
    9acc:	.word	0x20001010
    9ad0:	.word	0x20000fc0
    9ad4:	str	r3, [sp, #48]	; 0x30
    9ad6:	mov	r8, r5
    9ad8:	cmp	r2, #0
    9ada:	bne.w	a990 <_svfprintf_r+0x1530>
    9ade:	orr.w	fp, fp, #16
    9ae2:	ands.w	r3, fp, #32
    9ae6:	beq.w	a0b8 <_svfprintf_r+0xc58>
    9aea:	ldr	r7, [sp, #36]	; 0x24
    9aec:	adds	r7, #7
    9aee:	bic.w	r3, r7, #7
    9af2:	movs	r7, #0
    9af4:	add.w	r2, r3, #8
    9af8:	cmp	r8, r7
    9afa:	str	r2, [sp, #36]	; 0x24
    9afc:	ldrd	r4, r5, [r3]
    9b00:	strb.w	r7, [sp, #79]	; 0x4f
    9b04:	bge.w	979e <_svfprintf_r+0x33e>
    9b08:	orrs.w	r3, r4, r5
    9b0c:	bne.w	97aa <_svfprintf_r+0x34a>
    9b10:	add	r6, sp, #224	; 0xe0
    9b12:	adds	r4, #48	; 0x30
    9b14:	strb.w	r4, [r6, #-65]!
    9b18:	add	r3, sp, #160	; 0xa0
    9b1a:	subs	r3, r3, r6
    9b1c:	str	r3, [sp, #32]
    9b1e:	ldr	r3, [sp, #32]
    9b20:	cmp	r3, r8
    9b22:	it	lt
    9b24:	movlt	r3, r8
    9b26:	str	r3, [sp, #16]
    9b28:	movs	r3, #0
    9b2a:	str	r3, [sp, #56]	; 0x38
    9b2c:	b.n	9844 <_svfprintf_r+0x3e4>
    9b2e:	str	r3, [sp, #48]	; 0x30
    9b30:	mov	r8, r5
    9b32:	cmp	r2, #0
    9b34:	bne.w	a988 <_svfprintf_r+0x1528>
    9b38:	tst.w	fp, #32
    9b3c:	ldr	r0, [pc, #776]	; (9e48 <_svfprintf_r+0x9e8>)
    9b3e:	beq.w	9c4e <_svfprintf_r+0x7ee>
    9b42:	ldr	r7, [sp, #36]	; 0x24
    9b44:	adds	r7, #7
    9b46:	bic.w	r3, r7, #7
    9b4a:	ldrd	r4, r5, [r3]
    9b4e:	add.w	r2, r3, #8
    9b52:	str	r2, [sp, #36]	; 0x24
    9b54:	ands.w	r7, fp, #1
    9b58:	beq.w	9fea <_svfprintf_r+0xb8a>
    9b5c:	orrs.w	r3, r4, r5
    9b60:	beq.w	a4aa <_svfprintf_r+0x104a>
    9b64:	movs	r7, #0
    9b66:	movs	r3, #48	; 0x30
    9b68:	ldrb.w	r2, [sp, #48]	; 0x30
    9b6c:	strb.w	r3, [sp, #80]	; 0x50
    9b70:	cmp	r8, r7
    9b72:	strb.w	r2, [sp, #81]	; 0x51
    9b76:	strb.w	r7, [sp, #79]	; 0x4f
    9b7a:	orr.w	r3, fp, #2
    9b7e:	blt.w	a7b0 <_svfprintf_r+0x1350>
    9b82:	bic.w	r3, fp, #128	; 0x80
    9b86:	orr.w	fp, r3, #2
    9b8a:	add	r6, sp, #160	; 0xa0
    9b8c:	lsrs	r3, r4, #4
    9b8e:	and.w	r1, r4, #15
    9b92:	orr.w	r3, r3, r5, lsl #28
    9b96:	lsrs	r2, r5, #4
    9b98:	mov	r4, r3
    9b9a:	mov	r5, r2
    9b9c:	ldrb	r3, [r0, r1]
    9b9e:	strb.w	r3, [r6, #-1]!
    9ba2:	orrs.w	r3, r4, r5
    9ba6:	bne.n	9b8c <_svfprintf_r+0x72c>
    9ba8:	b.n	9b18 <_svfprintf_r+0x6b8>
    9baa:	ldr	r1, [sp, #36]	; 0x24
    9bac:	str	r3, [sp, #48]	; 0x30
    9bae:	ldr	r2, [r1, #0]
    9bb0:	strb.w	r2, [sp, #120]	; 0x78
    9bb4:	movs	r3, #0
    9bb6:	mov	r2, r1
    9bb8:	mov	r7, r3
    9bba:	strb.w	r3, [sp, #79]	; 0x4f
    9bbe:	adds	r2, #4
    9bc0:	movs	r3, #1
    9bc2:	str	r3, [sp, #16]
    9bc4:	mov	r8, r7
    9bc6:	str	r7, [sp, #56]	; 0x38
    9bc8:	str	r2, [sp, #36]	; 0x24
    9bca:	str	r3, [sp, #32]
    9bcc:	add	r6, sp, #120	; 0x78
    9bce:	b.n	984c <_svfprintf_r+0x3ec>
    9bd0:	str	r3, [sp, #48]	; 0x30
    9bd2:	mov	r8, r5
    9bd4:	cmp	r2, #0
    9bd6:	beq.w	976a <_svfprintf_r+0x30a>
    9bda:	strb.w	r1, [sp, #79]	; 0x4f
    9bde:	b.n	976a <_svfprintf_r+0x30a>
    9be0:	orr.w	fp, fp, #64	; 0x40
    9be4:	ldrb.w	r3, [sl]
    9be8:	b.n	9512 <_svfprintf_r+0xb2>
    9bea:	ldrb.w	r3, [sl]
    9bee:	cmp	r1, #0
    9bf0:	bne.w	9512 <_svfprintf_r+0xb2>
    9bf4:	movs	r2, #1
    9bf6:	movs	r1, #32
    9bf8:	b.n	9512 <_svfprintf_r+0xb2>
    9bfa:	orr.w	fp, fp, #1
    9bfe:	ldrb.w	r3, [sl]
    9c02:	b.n	9512 <_svfprintf_r+0xb2>
    9c04:	ldr	r4, [sp, #36]	; 0x24
    9c06:	ldr	r3, [r4, #0]
    9c08:	str	r3, [sp, #28]
    9c0a:	mov	r0, r3
    9c0c:	cmp	r0, #0
    9c0e:	mov	r3, r4
    9c10:	add.w	r3, r3, #4
    9c14:	blt.w	95d6 <_svfprintf_r+0x176>
    9c18:	str	r3, [sp, #36]	; 0x24
    9c1a:	ldrb.w	r3, [sl]
    9c1e:	b.n	9512 <_svfprintf_r+0xb2>
    9c20:	ldrb.w	r3, [sl]
    9c24:	movs	r2, #1
    9c26:	movs	r1, #43	; 0x2b
    9c28:	b.n	9512 <_svfprintf_r+0xb2>
    9c2a:	str	r3, [sp, #48]	; 0x30
    9c2c:	mov	r8, r5
    9c2e:	cmp	r2, #0
    9c30:	beq.w	9ae2 <_svfprintf_r+0x682>
    9c34:	strb.w	r1, [sp, #79]	; 0x4f
    9c38:	b.n	9ae2 <_svfprintf_r+0x682>
    9c3a:	str	r3, [sp, #48]	; 0x30
    9c3c:	mov	r8, r5
    9c3e:	cmp	r2, #0
    9c40:	bne.w	a998 <_svfprintf_r+0x1538>
    9c44:	tst.w	fp, #32
    9c48:	ldr	r0, [pc, #512]	; (9e4c <_svfprintf_r+0x9ec>)
    9c4a:	bne.w	9b42 <_svfprintf_r+0x6e2>
    9c4e:	ldr	r2, [sp, #36]	; 0x24
    9c50:	tst.w	fp, #16
    9c54:	mov	r3, r2
    9c56:	bne.w	a1dc <_svfprintf_r+0xd7c>
    9c5a:	tst.w	fp, #64	; 0x40
    9c5e:	beq.w	a1dc <_svfprintf_r+0xd7c>
    9c62:	adds	r3, #4
    9c64:	ldrh	r4, [r2, #0]
    9c66:	str	r3, [sp, #36]	; 0x24
    9c68:	movs	r5, #0
    9c6a:	b.n	9b54 <_svfprintf_r+0x6f4>
    9c6c:	ldrb.w	r3, [sl]
    9c70:	cmp	r3, #108	; 0x6c
    9c72:	ittte	eq
    9c74:	ldrbeq.w	r3, [sl, #1]
    9c78:	orreq.w	fp, fp, #32
    9c7c:	addeq.w	sl, sl, #1
    9c80:	orrne.w	fp, fp, #16
    9c84:	b.n	9512 <_svfprintf_r+0xb2>
    9c86:	cmp	r2, #0
    9c88:	bne.w	a96a <_svfprintf_r+0x150a>
    9c8c:	tst.w	fp, #32
    9c90:	beq.w	a360 <_svfprintf_r+0xf00>
    9c94:	ldr	r2, [sp, #36]	; 0x24
    9c96:	ldr	r1, [sp, #24]
    9c98:	ldr	r3, [r2, #0]
    9c9a:	asrs	r5, r1, #31
    9c9c:	mov	r0, r1
    9c9e:	adds	r2, #4
    9ca0:	mov	r1, r5
    9ca2:	str	r2, [sp, #36]	; 0x24
    9ca4:	strd	r0, r1, [r3]
    9ca8:	b.n	94ac <_svfprintf_r+0x4c>
    9caa:	orr.w	fp, fp, #32
    9cae:	ldrb.w	r3, [sl]
    9cb2:	b.n	9512 <_svfprintf_r+0xb2>
    9cb4:	ldr	r2, [sp, #36]	; 0x24
    9cb6:	str	r3, [sp, #48]	; 0x30
    9cb8:	ldr	r6, [r2, #0]
    9cba:	movs	r4, #0
    9cbc:	strb.w	r4, [sp, #79]	; 0x4f
    9cc0:	adds	r7, r2, #4
    9cc2:	cmp	r6, #0
    9cc4:	beq.w	a792 <_svfprintf_r+0x1332>
    9cc8:	cmp	r5, #0
    9cca:	blt.w	a612 <_svfprintf_r+0x11b2>
    9cce:	mov	r2, r5
    9cd0:	mov	r1, r4
    9cd2:	mov	r0, r6
    9cd4:	bl	d180 <memchr>
    9cd8:	cmp	r0, #0
    9cda:	beq.w	a876 <_svfprintf_r+0x1416>
    9cde:	subs	r3, r0, r6
    9ce0:	str	r3, [sp, #32]
    9ce2:	mov	r8, r4
    9ce4:	bic.w	r3, r3, r3, asr #31
    9ce8:	str	r7, [sp, #36]	; 0x24
    9cea:	str	r3, [sp, #16]
    9cec:	str.w	r8, [sp, #56]	; 0x38
    9cf0:	ldrb.w	r7, [sp, #79]	; 0x4f
    9cf4:	b.n	9844 <_svfprintf_r+0x3e4>
    9cf6:	ldr	r0, [pc, #340]	; (9e4c <_svfprintf_r+0x9ec>)
    9cf8:	str	r2, [sp, #48]	; 0x30
    9cfa:	cmp.w	r8, #0
    9cfe:	bne.w	a00a <_svfprintf_r+0xbaa>
    9d02:	mov	r7, r8
    9d04:	mov.w	r8, #0
    9d08:	str.w	r8, [sp, #32]
    9d0c:	add	r6, sp, #160	; 0xa0
    9d0e:	b.n	9b1e <_svfprintf_r+0x6be>
    9d10:	str	r3, [sp, #48]	; 0x30
    9d12:	cmp	r2, #0
    9d14:	bne.w	a972 <_svfprintf_r+0x1512>
    9d18:	ldr	r2, [sp, #48]	; 0x30
    9d1a:	cmp	r2, #0
    9d1c:	beq.w	963e <_svfprintf_r+0x1de>
    9d20:	movs	r3, #0
    9d22:	movs	r1, #1
    9d24:	mov	r7, r3
    9d26:	str	r1, [sp, #16]
    9d28:	strb.w	r2, [sp, #120]	; 0x78
    9d2c:	strb.w	r3, [sp, #79]	; 0x4f
    9d30:	mov	r8, r3
    9d32:	str	r3, [sp, #56]	; 0x38
    9d34:	str	r1, [sp, #32]
    9d36:	add	r6, sp, #120	; 0x78
    9d38:	b.n	984c <_svfprintf_r+0x3ec>
    9d3a:	cmp.w	r8, #0
    9d3e:	beq.w	a858 <_svfprintf_r+0x13f8>
    9d42:	movs	r7, #0
    9d44:	movs	r4, #0
    9d46:	movs	r5, #0
    9d48:	b.n	96a4 <_svfprintf_r+0x244>
    9d4a:	ldr	r0, [pc, #256]	; (9e4c <_svfprintf_r+0x9ec>)
    9d4c:	str	r2, [sp, #48]	; 0x30
    9d4e:	mov	fp, r3
    9d50:	orrs.w	r3, r4, r5
    9d54:	str	r7, [sp, #36]	; 0x24
    9d56:	mov.w	r7, #0
    9d5a:	bne.w	9b8a <_svfprintf_r+0x72a>
    9d5e:	movs	r4, #0
    9d60:	movs	r5, #0
    9d62:	b.n	9b8a <_svfprintf_r+0x72a>
    9d64:	ldr	r3, [sp, #116]	; 0x74
    9d66:	b.n	98e0 <_svfprintf_r+0x480>
    9d68:	ldr	r2, [sp, #48]	; 0x30
    9d6a:	cmp	r2, #101	; 0x65
    9d6c:	ble.w	9eb2 <_svfprintf_r+0xa52>
    9d70:	vcmp.f64	d8, #0.0
    9d74:	vmrs	APSR_nzcv, fpscr
    9d78:	bne.w	a00e <_svfprintf_r+0xbae>
    9d7c:	ldr	r2, [sp, #112]	; 0x70
    9d7e:	ldr	r1, [pc, #208]	; (9e50 <_svfprintf_r+0x9f0>)
    9d80:	str.w	r1, [r9]
    9d84:	adds	r2, #1
    9d86:	adds	r3, #1
    9d88:	movs	r1, #1
    9d8a:	cmp	r2, #7
    9d8c:	str	r3, [sp, #116]	; 0x74
    9d8e:	str	r2, [sp, #112]	; 0x70
    9d90:	str.w	r1, [r9, #4]
    9d94:	bgt.w	a4bc <_svfprintf_r+0x105c>
    9d98:	add.w	r9, r9, #8
    9d9c:	ldr	r2, [sp, #84]	; 0x54
    9d9e:	ldr	r1, [sp, #52]	; 0x34
    9da0:	cmp	r2, r1
    9da2:	blt.n	9dac <_svfprintf_r+0x94c>
    9da4:	tst.w	fp, #1
    9da8:	beq.w	99c2 <_svfprintf_r+0x562>
    9dac:	ldr	r2, [sp, #112]	; 0x70
    9dae:	ldr	r0, [sp, #60]	; 0x3c
    9db0:	ldr	r1, [sp, #64]	; 0x40
    9db2:	str.w	r1, [r9]
    9db6:	adds	r2, #1
    9db8:	add	r3, r0
    9dba:	cmp	r2, #7
    9dbc:	str	r3, [sp, #116]	; 0x74
    9dbe:	str.w	r0, [r9, #4]
    9dc2:	str	r2, [sp, #112]	; 0x70
    9dc4:	bgt.w	a574 <_svfprintf_r+0x1114>
    9dc8:	add.w	r9, r9, #8
    9dcc:	ldr	r2, [sp, #52]	; 0x34
    9dce:	subs	r4, r2, #1
    9dd0:	cmp	r4, #0
    9dd2:	ble.w	99c2 <_svfprintf_r+0x562>
    9dd6:	cmp	r4, #16
    9dd8:	ldr	r2, [sp, #112]	; 0x70
    9dda:	ldr	r7, [pc, #120]	; (9e54 <_svfprintf_r+0x9f4>)
    9ddc:	ble.w	a198 <_svfprintf_r+0xd38>
    9de0:	movs	r5, #16
    9de2:	ldr	r6, [sp, #20]
    9de4:	ldr.w	r8, [sp, #12]
    9de8:	b.n	9df6 <_svfprintf_r+0x996>
    9dea:	add.w	r9, r9, #8
    9dee:	subs	r4, #16
    9df0:	cmp	r4, #16
    9df2:	ble.w	a198 <_svfprintf_r+0xd38>
    9df6:	adds	r2, #1
    9df8:	adds	r3, #16
    9dfa:	cmp	r2, #7
    9dfc:	str	r3, [sp, #116]	; 0x74
    9dfe:	str	r2, [sp, #112]	; 0x70
    9e00:	str.w	r7, [r9]
    9e04:	str.w	r5, [r9, #4]
    9e08:	ble.n	9dea <_svfprintf_r+0x98a>
    9e0a:	add	r2, sp, #108	; 0x6c
    9e0c:	mov	r1, r8
    9e0e:	mov	r0, r6
    9e10:	bl	d8cc <__ssprint_r>
    9e14:	cmp	r0, #0
    9e16:	bne.w	964c <_svfprintf_r+0x1ec>
    9e1a:	ldr	r3, [sp, #116]	; 0x74
    9e1c:	ldr	r2, [sp, #112]	; 0x70
    9e1e:	add.w	r9, sp, #160	; 0xa0
    9e22:	b.n	9dee <_svfprintf_r+0x98e>
    9e24:	ldr	r2, [sp, #28]
    9e26:	ldr	r1, [sp, #16]
    9e28:	subs	r4, r2, r1
    9e2a:	cmp	r4, #0
    9e2c:	ble.w	9928 <_svfprintf_r+0x4c8>
    9e30:	cmp	r4, #16
    9e32:	ldr	r2, [sp, #112]	; 0x70
    9e34:	ldr	r7, [pc, #28]	; (9e54 <_svfprintf_r+0x9f4>)
    9e36:	ble.n	9e96 <_svfprintf_r+0xa36>
    9e38:	mov	r1, r9
    9e3a:	movs	r5, #16
    9e3c:	mov	r9, r8
    9e3e:	mov	r0, r3
    9e40:	mov	r8, r6
    9e42:	ldr	r6, [sp, #20]
    9e44:	b.n	9e62 <_svfprintf_r+0xa02>
    9e46:	nop
    9e48:	.word	0x20000fe0
    9e4c:	.word	0x20000ff4
    9e50:	.word	0x20000404
    9e54:	.word	0x20000fc0
    9e58:	subs	r4, #16
    9e5a:	cmp	r4, #16
    9e5c:	add.w	r1, r1, #8
    9e60:	ble.n	9e8e <_svfprintf_r+0xa2e>
    9e62:	adds	r2, #1
    9e64:	adds	r0, #16
    9e66:	cmp	r2, #7
    9e68:	str	r0, [sp, #116]	; 0x74
    9e6a:	str	r2, [sp, #112]	; 0x70
    9e6c:	str	r7, [r1, #0]
    9e6e:	str	r5, [r1, #4]
    9e70:	ble.n	9e58 <_svfprintf_r+0x9f8>
    9e72:	add	r2, sp, #108	; 0x6c
    9e74:	ldr	r1, [sp, #12]
    9e76:	mov	r0, r6
    9e78:	bl	d8cc <__ssprint_r>
    9e7c:	cmp	r0, #0
    9e7e:	bne.w	964c <_svfprintf_r+0x1ec>
    9e82:	subs	r4, #16
    9e84:	cmp	r4, #16
    9e86:	ldr	r0, [sp, #116]	; 0x74
    9e88:	ldr	r2, [sp, #112]	; 0x70
    9e8a:	add	r1, sp, #160	; 0xa0
    9e8c:	bgt.n	9e62 <_svfprintf_r+0xa02>
    9e8e:	mov	r6, r8
    9e90:	mov	r3, r0
    9e92:	mov	r8, r9
    9e94:	mov	r9, r1
    9e96:	adds	r2, #1
    9e98:	add	r3, r4
    9e9a:	cmp	r2, #7
    9e9c:	str	r3, [sp, #116]	; 0x74
    9e9e:	str	r2, [sp, #112]	; 0x70
    9ea0:	str.w	r7, [r9]
    9ea4:	str.w	r4, [r9, #4]
    9ea8:	bgt.w	a338 <_svfprintf_r+0xed8>
    9eac:	add.w	r9, r9, #8
    9eb0:	b.n	9928 <_svfprintf_r+0x4c8>
    9eb2:	ldr	r2, [sp, #52]	; 0x34
    9eb4:	str.w	r6, [r9]
    9eb8:	cmp	r2, #1
    9eba:	ldr	r2, [sp, #112]	; 0x70
    9ebc:	add.w	r3, r3, #1
    9ec0:	add.w	r2, r2, #1
    9ec4:	mov.w	r1, #1
    9ec8:	str	r3, [sp, #116]	; 0x74
    9eca:	str	r2, [sp, #112]	; 0x70
    9ecc:	str.w	r1, [r9, #4]
    9ed0:	ble.w	a2f4 <_svfprintf_r+0xe94>
    9ed4:	cmp	r2, #7
    9ed6:	bgt.w	a304 <_svfprintf_r+0xea4>
    9eda:	add.w	r9, r9, #8
    9ede:	ldr	r0, [sp, #60]	; 0x3c
    9ee0:	ldr	r1, [sp, #64]	; 0x40
    9ee2:	str.w	r1, [r9]
    9ee6:	adds	r2, #1
    9ee8:	add	r3, r0
    9eea:	cmp	r2, #7
    9eec:	str	r3, [sp, #116]	; 0x74
    9eee:	str	r2, [sp, #112]	; 0x70
    9ef0:	str.w	r0, [r9, #4]
    9ef4:	bgt.w	a31e <_svfprintf_r+0xebe>
    9ef8:	add.w	r9, r9, #8
    9efc:	vcmp.f64	d8, #0.0
    9f00:	vmrs	APSR_nzcv, fpscr
    9f04:	ldr	r1, [sp, #52]	; 0x34
    9f06:	beq.w	a0f4 <_svfprintf_r+0xc94>
    9f0a:	subs	r1, #1
    9f0c:	adds	r2, #1
    9f0e:	adds	r6, #1
    9f10:	add	r3, r1
    9f12:	cmp	r2, #7
    9f14:	str.w	r6, [r9]
    9f18:	str	r2, [sp, #112]	; 0x70
    9f1a:	str	r3, [sp, #116]	; 0x74
    9f1c:	str.w	r1, [r9, #4]
    9f20:	bgt.w	a15e <_svfprintf_r+0xcfe>
    9f24:	add.w	r9, r9, #8
    9f28:	ldr	r0, [sp, #68]	; 0x44
    9f2a:	str.w	r0, [r9, #4]
    9f2e:	adds	r2, #1
    9f30:	add	r3, r0
    9f32:	add	r1, sp, #92	; 0x5c
    9f34:	cmp	r2, #7
    9f36:	str	r3, [sp, #116]	; 0x74
    9f38:	str	r2, [sp, #112]	; 0x70
    9f3a:	str.w	r1, [r9]
    9f3e:	ble.w	99be <_svfprintf_r+0x55e>
    9f42:	add	r2, sp, #108	; 0x6c
    9f44:	ldr	r1, [sp, #12]
    9f46:	ldr	r0, [sp, #20]
    9f48:	bl	d8cc <__ssprint_r>
    9f4c:	cmp	r0, #0
    9f4e:	bne.w	964c <_svfprintf_r+0x1ec>
    9f52:	ldr	r3, [sp, #116]	; 0x74
    9f54:	add.w	r9, sp, #160	; 0xa0
    9f58:	b.n	99c2 <_svfprintf_r+0x562>
    9f5a:	add	r2, sp, #108	; 0x6c
    9f5c:	ldr	r1, [sp, #12]
    9f5e:	ldr	r0, [sp, #20]
    9f60:	bl	d8cc <__ssprint_r>
    9f64:	cmp	r0, #0
    9f66:	beq.w	9a5c <_svfprintf_r+0x5fc>
    9f6a:	b.w	964c <_svfprintf_r+0x1ec>
    9f6e:	ldr	r1, [sp, #36]	; 0x24
    9f70:	cmp.w	r8, #0
    9f74:	ldr	r4, [r1, #0]
    9f76:	strb.w	r3, [sp, #79]	; 0x4f
    9f7a:	add.w	r7, r1, #4
    9f7e:	mov.w	r5, #0
    9f82:	blt.w	a668 <_svfprintf_r+0x1208>
    9f86:	orrs.w	r2, r4, r5
    9f8a:	str	r7, [sp, #36]	; 0x24
    9f8c:	bic.w	fp, fp, #128	; 0x80
    9f90:	mov	r7, r3
    9f92:	bne.w	97aa <_svfprintf_r+0x34a>
    9f96:	cmp.w	r8, #0
    9f9a:	beq.w	9d04 <_svfprintf_r+0x8a4>
    9f9e:	movs	r4, #0
    9fa0:	b.n	9b10 <_svfprintf_r+0x6b0>
    9fa2:	add	r2, sp, #108	; 0x6c
    9fa4:	ldr	r1, [sp, #12]
    9fa6:	ldr	r0, [sp, #20]
    9fa8:	bl	d8cc <__ssprint_r>
    9fac:	cmp	r0, #0
    9fae:	bne.w	964c <_svfprintf_r+0x1ec>
    9fb2:	ldr	r3, [sp, #116]	; 0x74
    9fb4:	add.w	r9, sp, #160	; 0xa0
    9fb8:	b.n	999c <_svfprintf_r+0x53c>
    9fba:	add	r2, sp, #108	; 0x6c
    9fbc:	ldr	r1, [sp, #12]
    9fbe:	ldr	r0, [sp, #20]
    9fc0:	bl	d8cc <__ssprint_r>
    9fc4:	cmp	r0, #0
    9fc6:	bne.w	964c <_svfprintf_r+0x1ec>
    9fca:	ldr	r3, [sp, #116]	; 0x74
    9fcc:	add.w	r9, sp, #160	; 0xa0
    9fd0:	b.n	9900 <_svfprintf_r+0x4a0>
    9fd2:	add	r2, sp, #108	; 0x6c
    9fd4:	ldr	r1, [sp, #12]
    9fd6:	ldr	r0, [sp, #20]
    9fd8:	bl	d8cc <__ssprint_r>
    9fdc:	cmp	r0, #0
    9fde:	bne.w	964c <_svfprintf_r+0x1ec>
    9fe2:	ldr	r3, [sp, #116]	; 0x74
    9fe4:	add.w	r9, sp, #160	; 0xa0
    9fe8:	b.n	9920 <_svfprintf_r+0x4c0>
    9fea:	cmp.w	r8, #0
    9fee:	strb.w	r7, [sp, #79]	; 0x4f
    9ff2:	blt.w	a4d4 <_svfprintf_r+0x1074>
    9ff6:	orrs.w	r3, r4, r5
    9ffa:	bic.w	fp, fp, #128	; 0x80
    9ffe:	bne.w	9b8a <_svfprintf_r+0x72a>
    a002:	cmp.w	r8, #0
    a006:	beq.w	9d02 <_svfprintf_r+0x8a2>
    a00a:	movs	r7, #0
    a00c:	b.n	9d5e <_svfprintf_r+0x8fe>
    a00e:	ldr	r4, [sp, #84]	; 0x54
    a010:	cmp	r4, #0
    a012:	ble.w	a4d8 <_svfprintf_r+0x1078>
    a016:	ldr	r2, [sp, #56]	; 0x38
    a018:	ldr	r1, [sp, #52]	; 0x34
    a01a:	cmp	r2, r1
    a01c:	it	ge
    a01e:	movge	r2, r1
    a020:	cmp	r2, #0
    a022:	mov	r4, r2
    a024:	ble.n	a042 <_svfprintf_r+0xbe2>
    a026:	ldr	r2, [sp, #112]	; 0x70
    a028:	str.w	r6, [r9]
    a02c:	adds	r2, #1
    a02e:	add	r3, r4
    a030:	cmp	r2, #7
    a032:	str	r3, [sp, #116]	; 0x74
    a034:	str.w	r4, [r9, #4]
    a038:	str	r2, [sp, #112]	; 0x70
    a03a:	bgt.w	a722 <_svfprintf_r+0x12c2>
    a03e:	add.w	r9, r9, #8
    a042:	ldr	r2, [sp, #56]	; 0x38
    a044:	cmp	r4, #0
    a046:	it	ge
    a048:	subge	r2, r2, r4
    a04a:	cmp	r2, #0
    a04c:	mov	r4, r2
    a04e:	ble.w	a234 <_svfprintf_r+0xdd4>
    a052:	cmp	r4, #16
    a054:	ldr	r2, [sp, #112]	; 0x70
    a056:	ldr	r7, [pc, #772]	; (a35c <_svfprintf_r+0xefc>)
    a058:	ble.w	a48e <_svfprintf_r+0x102e>
    a05c:	mov	r1, r9
    a05e:	movs	r5, #16
    a060:	mov	r9, r6
    a062:	ldr.w	r8, [sp, #20]
    a066:	ldr	r6, [sp, #12]
    a068:	b.n	a074 <_svfprintf_r+0xc14>
    a06a:	adds	r1, #8
    a06c:	subs	r4, #16
    a06e:	cmp	r4, #16
    a070:	ble.w	a48a <_svfprintf_r+0x102a>
    a074:	adds	r2, #1
    a076:	adds	r3, #16
    a078:	cmp	r2, #7
    a07a:	str	r3, [sp, #116]	; 0x74
    a07c:	str	r2, [sp, #112]	; 0x70
    a07e:	str	r7, [r1, #0]
    a080:	str	r5, [r1, #4]
    a082:	ble.n	a06a <_svfprintf_r+0xc0a>
    a084:	add	r2, sp, #108	; 0x6c
    a086:	mov	r1, r6
    a088:	mov	r0, r8
    a08a:	bl	d8cc <__ssprint_r>
    a08e:	cmp	r0, #0
    a090:	bne.w	964c <_svfprintf_r+0x1ec>
    a094:	ldr	r3, [sp, #116]	; 0x74
    a096:	ldr	r2, [sp, #112]	; 0x70
    a098:	add	r1, sp, #160	; 0xa0
    a09a:	b.n	a06c <_svfprintf_r+0xc0c>
    a09c:	add	r2, sp, #108	; 0x6c
    a09e:	ldr	r1, [sp, #12]
    a0a0:	ldr	r0, [sp, #20]
    a0a2:	bl	d8cc <__ssprint_r>
    a0a6:	cmp	r0, #0
    a0a8:	bne.w	964c <_svfprintf_r+0x1ec>
    a0ac:	ldrb.w	r7, [sp, #79]	; 0x4f
    a0b0:	ldr	r3, [sp, #116]	; 0x74
    a0b2:	add.w	r9, sp, #160	; 0xa0
    a0b6:	b.n	98e0 <_svfprintf_r+0x480>
    a0b8:	ands.w	r2, fp, #16
    a0bc:	bne.w	9f6e <_svfprintf_r+0xb0e>
    a0c0:	ands.w	r3, fp, #64	; 0x40
    a0c4:	beq.w	9f6e <_svfprintf_r+0xb0e>
    a0c8:	ldr	r1, [sp, #36]	; 0x24
    a0ca:	strb.w	r2, [sp, #79]	; 0x4f
    a0ce:	mov	r3, r1
    a0d0:	cmp.w	r8, #0
    a0d4:	add.w	r3, r3, #4
    a0d8:	ldrh	r4, [r1, #0]
    a0da:	mov.w	r5, #0
    a0de:	blt.w	a60a <_svfprintf_r+0x11aa>
    a0e2:	orrs.w	r1, r4, r5
    a0e6:	bic.w	fp, fp, #128	; 0x80
    a0ea:	str	r3, [sp, #36]	; 0x24
    a0ec:	mov	r7, r2
    a0ee:	bne.w	97aa <_svfprintf_r+0x34a>
    a0f2:	b.n	9f96 <_svfprintf_r+0xb36>
    a0f4:	subs	r4, r1, #1
    a0f6:	cmp	r4, #0
    a0f8:	ble.w	9f28 <_svfprintf_r+0xac8>
    a0fc:	cmp	r4, #16
    a0fe:	ldr	r7, [pc, #604]	; (a35c <_svfprintf_r+0xefc>)
    a100:	ble.n	a148 <_svfprintf_r+0xce8>
    a102:	movs	r5, #16
    a104:	ldr	r6, [sp, #20]
    a106:	ldr.w	r8, [sp, #12]
    a10a:	b.n	a116 <_svfprintf_r+0xcb6>
    a10c:	subs	r4, #16
    a10e:	cmp	r4, #16
    a110:	add.w	r9, r9, #8
    a114:	ble.n	a148 <_svfprintf_r+0xce8>
    a116:	adds	r2, #1
    a118:	adds	r3, #16
    a11a:	cmp	r2, #7
    a11c:	str	r3, [sp, #116]	; 0x74
    a11e:	str	r2, [sp, #112]	; 0x70
    a120:	str.w	r7, [r9]
    a124:	str.w	r5, [r9, #4]
    a128:	ble.n	a10c <_svfprintf_r+0xcac>
    a12a:	add	r2, sp, #108	; 0x6c
    a12c:	mov	r1, r8
    a12e:	mov	r0, r6
    a130:	bl	d8cc <__ssprint_r>
    a134:	cmp	r0, #0
    a136:	bne.w	964c <_svfprintf_r+0x1ec>
    a13a:	subs	r4, #16
    a13c:	cmp	r4, #16
    a13e:	ldr	r3, [sp, #116]	; 0x74
    a140:	ldr	r2, [sp, #112]	; 0x70
    a142:	add.w	r9, sp, #160	; 0xa0
    a146:	bgt.n	a116 <_svfprintf_r+0xcb6>
    a148:	adds	r2, #1
    a14a:	add	r3, r4
    a14c:	cmp	r2, #7
    a14e:	str	r3, [sp, #116]	; 0x74
    a150:	str	r2, [sp, #112]	; 0x70
    a152:	str.w	r7, [r9]
    a156:	str.w	r4, [r9, #4]
    a15a:	ble.w	9f24 <_svfprintf_r+0xac4>
    a15e:	add	r2, sp, #108	; 0x6c
    a160:	ldr	r1, [sp, #12]
    a162:	ldr	r0, [sp, #20]
    a164:	bl	d8cc <__ssprint_r>
    a168:	cmp	r0, #0
    a16a:	bne.w	964c <_svfprintf_r+0x1ec>
    a16e:	ldr	r3, [sp, #116]	; 0x74
    a170:	ldr	r2, [sp, #112]	; 0x70
    a172:	add.w	r9, sp, #160	; 0xa0
    a176:	b.n	9f28 <_svfprintf_r+0xac8>
    a178:	tst.w	fp, #16
    a17c:	bne.n	a1e6 <_svfprintf_r+0xd86>
    a17e:	tst.w	fp, #64	; 0x40
    a182:	beq.n	a1e6 <_svfprintf_r+0xd86>
    a184:	ldr	r1, [sp, #36]	; 0x24
    a186:	ldrsh.w	r4, [r1]
    a18a:	adds	r1, #4
    a18c:	asrs	r5, r4, #31
    a18e:	mov	r2, r4
    a190:	mov	r3, r5
    a192:	str	r1, [sp, #36]	; 0x24
    a194:	b.w	9788 <_svfprintf_r+0x328>
    a198:	adds	r2, #1
    a19a:	add	r3, r4
    a19c:	cmp	r2, #7
    a19e:	str	r3, [sp, #116]	; 0x74
    a1a0:	str	r2, [sp, #112]	; 0x70
    a1a2:	str.w	r7, [r9]
    a1a6:	str.w	r4, [r9, #4]
    a1aa:	ble.w	99be <_svfprintf_r+0x55e>
    a1ae:	b.n	9f42 <_svfprintf_r+0xae2>
    a1b0:	ldr	r1, [sp, #36]	; 0x24
    a1b2:	cmp.w	r8, #0
    a1b6:	ldr	r4, [r1, #0]
    a1b8:	strb.w	r3, [sp, #79]	; 0x4f
    a1bc:	add.w	r7, r1, #4
    a1c0:	mov.w	r5, #0
    a1c4:	blt.w	a352 <_svfprintf_r+0xef2>
    a1c8:	orrs.w	r2, r4, r5
    a1cc:	bic.w	fp, fp, #128	; 0x80
    a1d0:	str	r7, [sp, #36]	; 0x24
    a1d2:	beq.w	9d3a <_svfprintf_r+0x8da>
    a1d6:	mov	r7, r3
    a1d8:	b.w	96a4 <_svfprintf_r+0x244>
    a1dc:	ldr	r4, [r3, #0]
    a1de:	adds	r3, #4
    a1e0:	str	r3, [sp, #36]	; 0x24
    a1e2:	movs	r5, #0
    a1e4:	b.n	9b54 <_svfprintf_r+0x6f4>
    a1e6:	ldr	r2, [sp, #36]	; 0x24
    a1e8:	ldr	r4, [r2, #0]
    a1ea:	mov	r3, r2
    a1ec:	adds	r3, #4
    a1ee:	asrs	r5, r4, #31
    a1f0:	mov	r2, r4
    a1f2:	str	r3, [sp, #36]	; 0x24
    a1f4:	cmp	r2, #0
    a1f6:	mov	r3, r5
    a1f8:	sbcs.w	r3, r3, #0
    a1fc:	bge.w	9792 <_svfprintf_r+0x332>
    a200:	negs	r4, r4
    a202:	mov.w	r7, #45	; 0x2d
    a206:	sbc.w	r5, r5, r5, lsl #1
    a20a:	cmp.w	r8, #0
    a20e:	strb.w	r7, [sp, #79]	; 0x4f
    a212:	blt.w	97aa <_svfprintf_r+0x34a>
    a216:	bic.w	fp, fp, #128	; 0x80
    a21a:	b.w	97aa <_svfprintf_r+0x34a>
    a21e:	add	r2, sp, #108	; 0x6c
    a220:	ldr	r1, [sp, #12]
    a222:	ldr	r0, [sp, #20]
    a224:	bl	d8cc <__ssprint_r>
    a228:	cmp	r0, #0
    a22a:	bne.w	964c <_svfprintf_r+0x1ec>
    a22e:	ldr	r3, [sp, #116]	; 0x74
    a230:	add.w	r9, sp, #160	; 0xa0
    a234:	ldr	r1, [sp, #56]	; 0x38
    a236:	ldr	r2, [sp, #84]	; 0x54
    a238:	add	r1, r6
    a23a:	mov	r5, r1
    a23c:	ldr	r1, [sp, #52]	; 0x34
    a23e:	cmp	r2, r1
    a240:	blt.n	a2d2 <_svfprintf_r+0xe72>
    a242:	tst.w	fp, #1
    a246:	bne.n	a2d2 <_svfprintf_r+0xe72>
    a248:	ldr	r0, [sp, #52]	; 0x34
    a24a:	add	r6, r0
    a24c:	subs	r4, r6, r5
    a24e:	subs	r2, r0, r2
    a250:	cmp	r4, r2
    a252:	it	ge
    a254:	movge	r4, r2
    a256:	cmp	r4, #0
    a258:	mov	r6, r4
    a25a:	ble.n	a278 <_svfprintf_r+0xe18>
    a25c:	ldr	r1, [sp, #112]	; 0x70
    a25e:	str.w	r5, [r9]
    a262:	adds	r1, #1
    a264:	add	r3, r4
    a266:	cmp	r1, #7
    a268:	str	r3, [sp, #116]	; 0x74
    a26a:	str.w	r4, [r9, #4]
    a26e:	str	r1, [sp, #112]	; 0x70
    a270:	bgt.w	a774 <_svfprintf_r+0x1314>
    a274:	add.w	r9, r9, #8
    a278:	cmp	r6, #0
    a27a:	ite	ge
    a27c:	subge	r4, r2, r6
    a27e:	movlt	r4, r2
    a280:	cmp	r4, #0
    a282:	ble.w	99c2 <_svfprintf_r+0x562>
    a286:	cmp	r4, #16
    a288:	ldr	r2, [sp, #112]	; 0x70
    a28a:	ldr	r7, [pc, #208]	; (a35c <_svfprintf_r+0xefc>)
    a28c:	ble.n	a198 <_svfprintf_r+0xd38>
    a28e:	movs	r5, #16
    a290:	ldr	r6, [sp, #20]
    a292:	ldr.w	r8, [sp, #12]
    a296:	b.n	a2a4 <_svfprintf_r+0xe44>
    a298:	add.w	r9, r9, #8
    a29c:	subs	r4, #16
    a29e:	cmp	r4, #16
    a2a0:	ble.w	a198 <_svfprintf_r+0xd38>
    a2a4:	adds	r2, #1
    a2a6:	adds	r3, #16
    a2a8:	cmp	r2, #7
    a2aa:	str	r3, [sp, #116]	; 0x74
    a2ac:	str	r2, [sp, #112]	; 0x70
    a2ae:	str.w	r7, [r9]
    a2b2:	str.w	r5, [r9, #4]
    a2b6:	ble.n	a298 <_svfprintf_r+0xe38>
    a2b8:	add	r2, sp, #108	; 0x6c
    a2ba:	mov	r1, r8
    a2bc:	mov	r0, r6
    a2be:	bl	d8cc <__ssprint_r>
    a2c2:	cmp	r0, #0
    a2c4:	bne.w	964c <_svfprintf_r+0x1ec>
    a2c8:	ldr	r3, [sp, #116]	; 0x74
    a2ca:	ldr	r2, [sp, #112]	; 0x70
    a2cc:	add.w	r9, sp, #160	; 0xa0
    a2d0:	b.n	a29c <_svfprintf_r+0xe3c>
    a2d2:	ldr	r1, [sp, #112]	; 0x70
    a2d4:	ldr	r4, [sp, #60]	; 0x3c
    a2d6:	ldr	r0, [sp, #64]	; 0x40
    a2d8:	str.w	r0, [r9]
    a2dc:	adds	r1, #1
    a2de:	add	r3, r4
    a2e0:	cmp	r1, #7
    a2e2:	str	r3, [sp, #116]	; 0x74
    a2e4:	str.w	r4, [r9, #4]
    a2e8:	str	r1, [sp, #112]	; 0x70
    a2ea:	bgt.w	a73a <_svfprintf_r+0x12da>
    a2ee:	add.w	r9, r9, #8
    a2f2:	b.n	a248 <_svfprintf_r+0xde8>
    a2f4:	tst.w	fp, #1
    a2f8:	bne.w	9ed4 <_svfprintf_r+0xa74>
    a2fc:	cmp	r2, #7
    a2fe:	ble.w	9f24 <_svfprintf_r+0xac4>
    a302:	b.n	a15e <_svfprintf_r+0xcfe>
    a304:	add	r2, sp, #108	; 0x6c
    a306:	ldr	r1, [sp, #12]
    a308:	ldr	r0, [sp, #20]
    a30a:	bl	d8cc <__ssprint_r>
    a30e:	cmp	r0, #0
    a310:	bne.w	964c <_svfprintf_r+0x1ec>
    a314:	ldr	r3, [sp, #116]	; 0x74
    a316:	ldr	r2, [sp, #112]	; 0x70
    a318:	add.w	r9, sp, #160	; 0xa0
    a31c:	b.n	9ede <_svfprintf_r+0xa7e>
    a31e:	add	r2, sp, #108	; 0x6c
    a320:	ldr	r1, [sp, #12]
    a322:	ldr	r0, [sp, #20]
    a324:	bl	d8cc <__ssprint_r>
    a328:	cmp	r0, #0
    a32a:	bne.w	964c <_svfprintf_r+0x1ec>
    a32e:	ldr	r3, [sp, #116]	; 0x74
    a330:	ldr	r2, [sp, #112]	; 0x70
    a332:	add.w	r9, sp, #160	; 0xa0
    a336:	b.n	9efc <_svfprintf_r+0xa9c>
    a338:	add	r2, sp, #108	; 0x6c
    a33a:	ldr	r1, [sp, #12]
    a33c:	ldr	r0, [sp, #20]
    a33e:	bl	d8cc <__ssprint_r>
    a342:	cmp	r0, #0
    a344:	bne.w	964c <_svfprintf_r+0x1ec>
    a348:	ldr	r3, [sp, #116]	; 0x74
    a34a:	add.w	r9, sp, #160	; 0xa0
    a34e:	b.w	9928 <_svfprintf_r+0x4c8>
    a352:	str	r7, [sp, #36]	; 0x24
    a354:	movs	r7, #0
    a356:	b.w	96a4 <_svfprintf_r+0x244>
    a35a:	nop
    a35c:	.word	0x20000fc0
    a360:	tst.w	fp, #16
    a364:	bne.n	a37e <_svfprintf_r+0xf1e>
    a366:	tst.w	fp, #64	; 0x40
    a36a:	beq.n	a37e <_svfprintf_r+0xf1e>
    a36c:	ldr	r2, [sp, #36]	; 0x24
    a36e:	ldr	r3, [r2, #0]
    a370:	adds	r2, #4
    a372:	str	r2, [sp, #36]	; 0x24
    a374:	ldrh.w	r2, [sp, #24]
    a378:	strh	r2, [r3, #0]
    a37a:	b.w	94ac <_svfprintf_r+0x4c>
    a37e:	ldr	r2, [sp, #36]	; 0x24
    a380:	ldr	r3, [r2, #0]
    a382:	adds	r2, #4
    a384:	str	r2, [sp, #36]	; 0x24
    a386:	ldr	r2, [sp, #24]
    a388:	str	r2, [r3, #0]
    a38a:	b.w	94ac <_svfprintf_r+0x4c>
    a38e:	vcmp.f64	d8, d8
    a392:	vmrs	APSR_nzcv, fpscr
    a396:	bvs.w	a8d6 <_svfprintf_r+0x1476>
    a39a:	ldr	r3, [sp, #48]	; 0x30
    a39c:	cmp.w	r8, #4294967295
    a3a0:	bic.w	r5, r3, #32
    a3a4:	beq.w	a7f2 <_svfprintf_r+0x1392>
    a3a8:	cmp	r5, #71	; 0x47
    a3aa:	beq.w	a5fa <_svfprintf_r+0x119a>
    a3ae:	orr.w	r3, fp, #256	; 0x100
    a3b2:	str	r3, [sp, #40]	; 0x28
    a3b4:	vmov	r3, s17
    a3b8:	cmp	r3, #0
    a3ba:	blt.w	a7f8 <_svfprintf_r+0x1398>
    a3be:	vmov.f64	d10, d8
    a3c2:	movs	r7, #0
    a3c4:	ldr	r3, [sp, #48]	; 0x30
    a3c6:	cmp	r3, #102	; 0x66
    a3c8:	beq.w	a7d0 <_svfprintf_r+0x1370>
    a3cc:	cmp	r3, #70	; 0x46
    a3ce:	beq.w	a5aa <_svfprintf_r+0x114a>
    a3d2:	vmov.f64	d0, d10
    a3d6:	cmp	r5, #69	; 0x45
    a3d8:	ite	eq
    a3da:	addeq.w	r4, r8, #1
    a3de:	movne	r4, r8
    a3e0:	add	r2, sp, #100	; 0x64
    a3e2:	add	r3, sp, #88	; 0x58
    a3e4:	str	r2, [sp, #4]
    a3e6:	str	r3, [sp, #0]
    a3e8:	mov	r2, r4
    a3ea:	add	r3, sp, #84	; 0x54
    a3ec:	movs	r1, #2
    a3ee:	ldr	r0, [sp, #20]
    a3f0:	bl	bae8 <_dtoa_r>
    a3f4:	ldr	r3, [sp, #48]	; 0x30
    a3f6:	cmp	r3, #103	; 0x67
    a3f8:	mov	r6, r0
    a3fa:	bne.w	a81a <_svfprintf_r+0x13ba>
    a3fe:	tst.w	fp, #1
    a402:	beq.w	a8d2 <_svfprintf_r+0x1472>
    a406:	adds	r1, r6, r4
    a408:	vcmp.f64	d10, #0.0
    a40c:	vmrs	APSR_nzcv, fpscr
    a410:	beq.w	a71e <_svfprintf_r+0x12be>
    a414:	ldr	r3, [sp, #100]	; 0x64
    a416:	cmp	r1, r3
    a418:	bls.n	a428 <_svfprintf_r+0xfc8>
    a41a:	movs	r0, #48	; 0x30
    a41c:	adds	r2, r3, #1
    a41e:	str	r2, [sp, #100]	; 0x64
    a420:	strb	r0, [r3, #0]
    a422:	ldr	r3, [sp, #100]	; 0x64
    a424:	cmp	r1, r3
    a426:	bhi.n	a41c <_svfprintf_r+0xfbc>
    a428:	subs	r3, r3, r6
    a42a:	cmp	r5, #71	; 0x47
    a42c:	str	r3, [sp, #52]	; 0x34
    a42e:	beq.w	a670 <_svfprintf_r+0x1210>
    a432:	ldr	r3, [sp, #48]	; 0x30
    a434:	cmp	r3, #101	; 0x65
    a436:	ble.w	a838 <_svfprintf_r+0x13d8>
    a43a:	ldr	r3, [sp, #48]	; 0x30
    a43c:	cmp	r3, #102	; 0x66
    a43e:	ldr	r3, [sp, #84]	; 0x54
    a440:	beq.w	a83c <_svfprintf_r+0x13dc>
    a444:	str	r3, [sp, #56]	; 0x38
    a446:	ldr	r2, [sp, #56]	; 0x38
    a448:	ldr	r1, [sp, #52]	; 0x34
    a44a:	cmp	r2, r1
    a44c:	blt.w	a800 <_svfprintf_r+0x13a0>
    a450:	tst.w	fp, #1
    a454:	bne.w	a8c0 <_svfprintf_r+0x1460>
    a458:	bic.w	r3, r2, r2, asr #31
    a45c:	str	r2, [sp, #32]
    a45e:	movs	r2, #103	; 0x67
    a460:	str	r2, [sp, #48]	; 0x30
    a462:	cmp	r7, #0
    a464:	bne.w	a654 <_svfprintf_r+0x11f4>
    a468:	mov	r8, r7
    a46a:	str	r3, [sp, #16]
    a46c:	ldr.w	fp, [sp, #40]	; 0x28
    a470:	ldrb.w	r7, [sp, #79]	; 0x4f
    a474:	b.w	9844 <_svfprintf_r+0x3e4>
    a478:	bic.w	r7, r7, #7
    a47c:	add.w	r3, r7, #8
    a480:	vldr	d8, [r7]
    a484:	str	r3, [sp, #36]	; 0x24
    a486:	b.w	9806 <_svfprintf_r+0x3a6>
    a48a:	mov	r6, r9
    a48c:	mov	r9, r1
    a48e:	adds	r2, #1
    a490:	add	r3, r4
    a492:	cmp	r2, #7
    a494:	str	r3, [sp, #116]	; 0x74
    a496:	str	r2, [sp, #112]	; 0x70
    a498:	str.w	r7, [r9]
    a49c:	str.w	r4, [r9, #4]
    a4a0:	bgt.w	a21e <_svfprintf_r+0xdbe>
    a4a4:	add.w	r9, r9, #8
    a4a8:	b.n	a234 <_svfprintf_r+0xdd4>
    a4aa:	movs	r7, #0
    a4ac:	cmp	r8, r7
    a4ae:	strb.w	r7, [sp, #79]	; 0x4f
    a4b2:	blt.w	9d5e <_svfprintf_r+0x8fe>
    a4b6:	bic.w	fp, fp, #128	; 0x80
    a4ba:	b.n	9cfa <_svfprintf_r+0x89a>
    a4bc:	add	r2, sp, #108	; 0x6c
    a4be:	ldr	r1, [sp, #12]
    a4c0:	ldr	r0, [sp, #20]
    a4c2:	bl	d8cc <__ssprint_r>
    a4c6:	cmp	r0, #0
    a4c8:	bne.w	964c <_svfprintf_r+0x1ec>
    a4cc:	ldr	r3, [sp, #116]	; 0x74
    a4ce:	add.w	r9, sp, #160	; 0xa0
    a4d2:	b.n	9d9c <_svfprintf_r+0x93c>
    a4d4:	ldr	r7, [sp, #36]	; 0x24
    a4d6:	b.n	9d50 <_svfprintf_r+0x8f0>
    a4d8:	ldr	r2, [sp, #112]	; 0x70
    a4da:	ldr	r1, [pc, #740]	; (a7c0 <_svfprintf_r+0x1360>)
    a4dc:	str.w	r1, [r9]
    a4e0:	adds	r2, #1
    a4e2:	adds	r3, #1
    a4e4:	movs	r1, #1
    a4e6:	cmp	r2, #7
    a4e8:	str	r3, [sp, #116]	; 0x74
    a4ea:	str	r2, [sp, #112]	; 0x70
    a4ec:	str.w	r1, [r9, #4]
    a4f0:	bgt.n	a5e0 <_svfprintf_r+0x1180>
    a4f2:	add.w	r9, r9, #8
    a4f6:	cbnz	r4, a504 <_svfprintf_r+0x10a4>
    a4f8:	ldr	r2, [sp, #52]	; 0x34
    a4fa:	cbnz	r2, a504 <_svfprintf_r+0x10a4>
    a4fc:	tst.w	fp, #1
    a500:	beq.w	99c2 <_svfprintf_r+0x562>
    a504:	ldr	r2, [sp, #112]	; 0x70
    a506:	ldr	r0, [sp, #60]	; 0x3c
    a508:	ldr	r1, [sp, #64]	; 0x40
    a50a:	str.w	r1, [r9]
    a50e:	adds	r2, #1
    a510:	add	r3, r0
    a512:	cmp	r2, #7
    a514:	str	r3, [sp, #116]	; 0x74
    a516:	str.w	r0, [r9, #4]
    a51a:	str	r2, [sp, #112]	; 0x70
    a51c:	bgt.w	a88c <_svfprintf_r+0x142c>
    a520:	add.w	r9, r9, #8
    a524:	negs	r4, r4
    a526:	cmp	r4, #0
    a528:	ble.w	a63a <_svfprintf_r+0x11da>
    a52c:	cmp	r4, #16
    a52e:	ldr	r7, [pc, #660]	; (a7c4 <_svfprintf_r+0x1364>)
    a530:	ble.w	a758 <_svfprintf_r+0x12f8>
    a534:	mov	r1, r9
    a536:	movs	r5, #16
    a538:	mov	r9, r6
    a53a:	ldr.w	r8, [sp, #20]
    a53e:	ldr	r6, [sp, #12]
    a540:	b.n	a54c <_svfprintf_r+0x10ec>
    a542:	adds	r1, #8
    a544:	subs	r4, #16
    a546:	cmp	r4, #16
    a548:	ble.w	a754 <_svfprintf_r+0x12f4>
    a54c:	adds	r2, #1
    a54e:	adds	r3, #16
    a550:	cmp	r2, #7
    a552:	str	r3, [sp, #116]	; 0x74
    a554:	str	r2, [sp, #112]	; 0x70
    a556:	str	r7, [r1, #0]
    a558:	str	r5, [r1, #4]
    a55a:	ble.n	a542 <_svfprintf_r+0x10e2>
    a55c:	add	r2, sp, #108	; 0x6c
    a55e:	mov	r1, r6
    a560:	mov	r0, r8
    a562:	bl	d8cc <__ssprint_r>
    a566:	cmp	r0, #0
    a568:	bne.w	964c <_svfprintf_r+0x1ec>
    a56c:	ldr	r3, [sp, #116]	; 0x74
    a56e:	ldr	r2, [sp, #112]	; 0x70
    a570:	add	r1, sp, #160	; 0xa0
    a572:	b.n	a544 <_svfprintf_r+0x10e4>
    a574:	add	r2, sp, #108	; 0x6c
    a576:	ldr	r1, [sp, #12]
    a578:	ldr	r0, [sp, #20]
    a57a:	bl	d8cc <__ssprint_r>
    a57e:	cmp	r0, #0
    a580:	bne.w	964c <_svfprintf_r+0x1ec>
    a584:	ldr	r3, [sp, #116]	; 0x74
    a586:	add.w	r9, sp, #160	; 0xa0
    a58a:	b.n	9dcc <_svfprintf_r+0x96c>
    a58c:	movs	r1, #64	; 0x40
    a58e:	ldr	r0, [sp, #20]
    a590:	bl	87f4 <_malloc_r>
    a594:	ldr	r2, [sp, #12]
    a596:	str	r0, [r2, #0]
    a598:	str	r0, [r2, #16]
    a59a:	cmp	r0, #0
    a59c:	beq.w	a97a <_svfprintf_r+0x151a>
    a5a0:	ldr	r2, [sp, #12]
    a5a2:	movs	r3, #64	; 0x40
    a5a4:	str	r3, [r2, #20]
    a5a6:	b.w	9492 <_svfprintf_r+0x32>
    a5aa:	add	r2, sp, #100	; 0x64
    a5ac:	add	r3, sp, #88	; 0x58
    a5ae:	str	r2, [sp, #4]
    a5b0:	str	r3, [sp, #0]
    a5b2:	mov	r2, r8
    a5b4:	add	r3, sp, #84	; 0x54
    a5b6:	movs	r1, #3
    a5b8:	vmov.f64	d0, d10
    a5bc:	ldr	r0, [sp, #20]
    a5be:	bl	bae8 <_dtoa_r>
    a5c2:	mov	r4, r8
    a5c4:	mov	r6, r0
    a5c6:	ldr	r3, [sp, #48]	; 0x30
    a5c8:	cmp	r3, #70	; 0x46
    a5ca:	add.w	r1, r6, r4
    a5ce:	bne.w	a408 <_svfprintf_r+0xfa8>
    a5d2:	ldrb	r3, [r6, #0]
    a5d4:	cmp	r3, #48	; 0x30
    a5d6:	beq.w	a8f4 <_svfprintf_r+0x1494>
    a5da:	ldr	r4, [sp, #84]	; 0x54
    a5dc:	add	r1, r4
    a5de:	b.n	a408 <_svfprintf_r+0xfa8>
    a5e0:	add	r2, sp, #108	; 0x6c
    a5e2:	ldr	r1, [sp, #12]
    a5e4:	ldr	r0, [sp, #20]
    a5e6:	bl	d8cc <__ssprint_r>
    a5ea:	cmp	r0, #0
    a5ec:	bne.w	964c <_svfprintf_r+0x1ec>
    a5f0:	ldr	r4, [sp, #84]	; 0x54
    a5f2:	ldr	r3, [sp, #116]	; 0x74
    a5f4:	add.w	r9, sp, #160	; 0xa0
    a5f8:	b.n	a4f6 <_svfprintf_r+0x1096>
    a5fa:	cmp.w	r8, #0
    a5fe:	it	eq
    a600:	moveq.w	r8, #1
    a604:	b.n	a3ae <_svfprintf_r+0xf4e>
    a606:	str	r3, [sp, #36]	; 0x24
    a608:	b.n	a354 <_svfprintf_r+0xef4>
    a60a:	str	r3, [sp, #36]	; 0x24
    a60c:	mov	r7, r2
    a60e:	b.w	9b08 <_svfprintf_r+0x6a8>
    a612:	mov	r0, r6
    a614:	bl	9380 <strlen>
    a618:	mov	r8, r4
    a61a:	mov	r3, r0
    a61c:	str	r0, [sp, #32]
    a61e:	b.w	9ce4 <_svfprintf_r+0x884>
    a622:	add	r2, sp, #108	; 0x6c
    a624:	ldr	r1, [sp, #12]
    a626:	ldr	r0, [sp, #20]
    a628:	bl	d8cc <__ssprint_r>
    a62c:	cmp	r0, #0
    a62e:	bne.w	964c <_svfprintf_r+0x1ec>
    a632:	ldr	r3, [sp, #116]	; 0x74
    a634:	ldr	r2, [sp, #112]	; 0x70
    a636:	add.w	r9, sp, #160	; 0xa0
    a63a:	ldr	r0, [sp, #52]	; 0x34
    a63c:	str.w	r6, [r9]
    a640:	adds	r2, #1
    a642:	add	r3, r0
    a644:	cmp	r2, #7
    a646:	str	r3, [sp, #116]	; 0x74
    a648:	str	r2, [sp, #112]	; 0x70
    a64a:	str.w	r0, [r9, #4]
    a64e:	ble.w	99be <_svfprintf_r+0x55e>
    a652:	b.n	9f42 <_svfprintf_r+0xae2>
    a654:	movs	r7, #45	; 0x2d
    a656:	str	r3, [sp, #16]
    a658:	ldr.w	fp, [sp, #40]	; 0x28
    a65c:	strb.w	r7, [sp, #79]	; 0x4f
    a660:	mov.w	r8, #0
    a664:	b.w	9846 <_svfprintf_r+0x3e6>
    a668:	str	r7, [sp, #36]	; 0x24
    a66a:	mov	r7, r3
    a66c:	b.w	9b08 <_svfprintf_r+0x6a8>
    a670:	ldr	r3, [sp, #84]	; 0x54
    a672:	adds	r2, r3, #3
    a674:	blt.n	a67c <_svfprintf_r+0x121c>
    a676:	cmp	r8, r3
    a678:	bge.w	a444 <_svfprintf_r+0xfe4>
    a67c:	ldr	r2, [sp, #48]	; 0x30
    a67e:	subs	r2, #2
    a680:	str	r2, [sp, #48]	; 0x30
    a682:	subs	r3, #1
    a684:	cmp	r3, #0
    a686:	ldrb.w	r2, [sp, #48]	; 0x30
    a68a:	str	r3, [sp, #84]	; 0x54
    a68c:	it	lt
    a68e:	neglt	r3, r3
    a690:	strb.w	r2, [sp, #92]	; 0x5c
    a694:	ite	lt
    a696:	movlt	r2, #45	; 0x2d
    a698:	movge	r2, #43	; 0x2b
    a69a:	cmp	r3, #9
    a69c:	strb.w	r2, [sp, #93]	; 0x5d
    a6a0:	ble.w	a8b0 <_svfprintf_r+0x1450>
    a6a4:	add.w	r0, sp, #107	; 0x6b
    a6a8:	mov	r4, r0
    a6aa:	ldr	r2, [pc, #284]	; (a7c8 <_svfprintf_r+0x1368>)
    a6ac:	smull	r2, r1, r2, r3
    a6b0:	asrs	r2, r3, #31
    a6b2:	rsb	r2, r2, r1, asr #2
    a6b6:	add.w	r1, r2, r2, lsl #2
    a6ba:	sub.w	r3, r3, r1, lsl #1
    a6be:	add.w	r1, r3, #48	; 0x30
    a6c2:	cmp	r2, #9
    a6c4:	mov	r3, r2
    a6c6:	strb.w	r1, [r4, #-1]!
    a6ca:	bgt.n	a6aa <_svfprintf_r+0x124a>
    a6cc:	mov	r1, r4
    a6ce:	adds	r3, #48	; 0x30
    a6d0:	uxtb	r2, r3
    a6d2:	strb.w	r2, [r1, #-1]!
    a6d6:	cmp	r0, r1
    a6d8:	bls.w	a9a0 <_svfprintf_r+0x1540>
    a6dc:	add.w	r1, sp, #94	; 0x5e
    a6e0:	mov	r3, r4
    a6e2:	b.n	a6e8 <_svfprintf_r+0x1288>
    a6e4:	ldrb.w	r2, [r3], #1
    a6e8:	strb.w	r2, [r1], #1
    a6ec:	cmp	r0, r3
    a6ee:	bne.n	a6e4 <_svfprintf_r+0x1284>
    a6f0:	adds	r3, r0, #1
    a6f2:	subs	r3, r3, r4
    a6f4:	add.w	r2, sp, #94	; 0x5e
    a6f8:	add	r3, r2
    a6fa:	add	r2, sp, #92	; 0x5c
    a6fc:	subs	r3, r3, r2
    a6fe:	ldr	r2, [sp, #52]	; 0x34
    a700:	str	r3, [sp, #68]	; 0x44
    a702:	cmp	r2, #1
    a704:	add	r3, r2
    a706:	str	r3, [sp, #32]
    a708:	ble.w	a90a <_svfprintf_r+0x14aa>
    a70c:	ldr	r3, [sp, #32]
    a70e:	ldr	r2, [sp, #60]	; 0x3c
    a710:	add	r3, r2
    a712:	movs	r2, #0
    a714:	str	r3, [sp, #32]
    a716:	str	r2, [sp, #56]	; 0x38
    a718:	bic.w	r3, r3, r3, asr #31
    a71c:	b.n	a462 <_svfprintf_r+0x1002>
    a71e:	mov	r3, r1
    a720:	b.n	a428 <_svfprintf_r+0xfc8>
    a722:	add	r2, sp, #108	; 0x6c
    a724:	ldr	r1, [sp, #12]
    a726:	ldr	r0, [sp, #20]
    a728:	bl	d8cc <__ssprint_r>
    a72c:	cmp	r0, #0
    a72e:	bne.w	964c <_svfprintf_r+0x1ec>
    a732:	ldr	r3, [sp, #116]	; 0x74
    a734:	add.w	r9, sp, #160	; 0xa0
    a738:	b.n	a042 <_svfprintf_r+0xbe2>
    a73a:	add	r2, sp, #108	; 0x6c
    a73c:	ldr	r1, [sp, #12]
    a73e:	ldr	r0, [sp, #20]
    a740:	bl	d8cc <__ssprint_r>
    a744:	cmp	r0, #0
    a746:	bne.w	964c <_svfprintf_r+0x1ec>
    a74a:	ldr	r2, [sp, #84]	; 0x54
    a74c:	ldr	r3, [sp, #116]	; 0x74
    a74e:	add.w	r9, sp, #160	; 0xa0
    a752:	b.n	a248 <_svfprintf_r+0xde8>
    a754:	mov	r6, r9
    a756:	mov	r9, r1
    a758:	adds	r2, #1
    a75a:	add	r3, r4
    a75c:	cmp	r2, #7
    a75e:	str	r3, [sp, #116]	; 0x74
    a760:	str	r2, [sp, #112]	; 0x70
    a762:	str.w	r7, [r9]
    a766:	str.w	r4, [r9, #4]
    a76a:	bgt.w	a622 <_svfprintf_r+0x11c2>
    a76e:	add.w	r9, r9, #8
    a772:	b.n	a63a <_svfprintf_r+0x11da>
    a774:	add	r2, sp, #108	; 0x6c
    a776:	ldr	r1, [sp, #12]
    a778:	ldr	r0, [sp, #20]
    a77a:	bl	d8cc <__ssprint_r>
    a77e:	cmp	r0, #0
    a780:	bne.w	964c <_svfprintf_r+0x1ec>
    a784:	ldr	r2, [sp, #84]	; 0x54
    a786:	ldr	r1, [sp, #52]	; 0x34
    a788:	ldr	r3, [sp, #116]	; 0x74
    a78a:	subs	r2, r1, r2
    a78c:	add.w	r9, sp, #160	; 0xa0
    a790:	b.n	a278 <_svfprintf_r+0xe18>
    a792:	cmp	r5, #6
    a794:	mov	r3, r5
    a796:	it	cs
    a798:	movcs	r3, #6
    a79a:	str	r3, [sp, #32]
    a79c:	bic.w	r3, r3, r3, asr #31
    a7a0:	mov	r8, r6
    a7a2:	str	r7, [sp, #36]	; 0x24
    a7a4:	str	r6, [sp, #56]	; 0x38
    a7a6:	mov	r7, r6
    a7a8:	str	r3, [sp, #16]
    a7aa:	ldr	r6, [pc, #32]	; (a7cc <_svfprintf_r+0x136c>)
    a7ac:	b.w	9844 <_svfprintf_r+0x3e4>
    a7b0:	mov	fp, r3
    a7b2:	b.w	9b8a <_svfprintf_r+0x72a>
    a7b6:	movs	r7, #45	; 0x2d
    a7b8:	strb.w	r7, [sp, #79]	; 0x4f
    a7bc:	b.w	9826 <_svfprintf_r+0x3c6>
    a7c0:	.word	0x20000404
    a7c4:	.word	0x20000fc0
    a7c8:	.word	0x66666667
    a7cc:	.word	0x20001008
    a7d0:	add	r2, sp, #100	; 0x64
    a7d2:	add	r3, sp, #88	; 0x58
    a7d4:	str	r2, [sp, #4]
    a7d6:	str	r3, [sp, #0]
    a7d8:	movs	r1, #3
    a7da:	add	r3, sp, #84	; 0x54
    a7dc:	mov	r2, r8
    a7de:	vmov.f64	d0, d10
    a7e2:	ldr	r0, [sp, #20]
    a7e4:	bl	bae8 <_dtoa_r>
    a7e8:	mov	r4, r8
    a7ea:	mov	r6, r0
    a7ec:	add.w	r1, r0, r8
    a7f0:	b.n	a5d2 <_svfprintf_r+0x1172>
    a7f2:	mov.w	r8, #6
    a7f6:	b.n	a3ae <_svfprintf_r+0xf4e>
    a7f8:	vneg.f64	d10, d8
    a7fc:	movs	r7, #45	; 0x2d
    a7fe:	b.n	a3c4 <_svfprintf_r+0xf64>
    a800:	ldr	r2, [sp, #60]	; 0x3c
    a802:	ldr	r3, [sp, #52]	; 0x34
    a804:	add	r3, r2
    a806:	ldr	r2, [sp, #56]	; 0x38
    a808:	str	r3, [sp, #32]
    a80a:	cmp	r2, #0
    a80c:	ble.w	a91c <_svfprintf_r+0x14bc>
    a810:	movs	r2, #103	; 0x67
    a812:	bic.w	r3, r3, r3, asr #31
    a816:	str	r2, [sp, #48]	; 0x30
    a818:	b.n	a462 <_svfprintf_r+0x1002>
    a81a:	ldr	r3, [sp, #48]	; 0x30
    a81c:	cmp	r3, #71	; 0x47
    a81e:	bne.w	a406 <_svfprintf_r+0xfa6>
    a822:	tst.w	fp, #1
    a826:	bne.w	a5c6 <_svfprintf_r+0x1166>
    a82a:	ldr	r3, [sp, #100]	; 0x64
    a82c:	cmp	r5, #71	; 0x47
    a82e:	sub.w	r3, r3, r6
    a832:	str	r3, [sp, #52]	; 0x34
    a834:	beq.w	a670 <_svfprintf_r+0x1210>
    a838:	ldr	r3, [sp, #84]	; 0x54
    a83a:	b.n	a682 <_svfprintf_r+0x1222>
    a83c:	cmp	r3, #0
    a83e:	mov	r2, r3
    a840:	str	r3, [sp, #56]	; 0x38
    a842:	ble.n	a92c <_svfprintf_r+0x14cc>
    a844:	cmp.w	r8, #0
    a848:	bne.n	a8e2 <_svfprintf_r+0x1482>
    a84a:	tst.w	fp, #1
    a84e:	bne.n	a8e2 <_svfprintf_r+0x1482>
    a850:	bic.w	r3, r3, r3, asr #31
    a854:	str	r2, [sp, #32]
    a856:	b.n	a462 <_svfprintf_r+0x1002>
    a858:	tst.w	fp, #1
    a85c:	mov	r7, r8
    a85e:	beq.n	a86c <_svfprintf_r+0x140c>
    a860:	add	r6, sp, #224	; 0xe0
    a862:	movs	r3, #48	; 0x30
    a864:	strb.w	r3, [r6, #-65]!
    a868:	b.w	9b18 <_svfprintf_r+0x6b8>
    a86c:	str.w	r8, [sp, #32]
    a870:	add	r6, sp, #160	; 0xa0
    a872:	b.w	9b1e <_svfprintf_r+0x6be>
    a876:	bic.w	r3, r5, r5, asr #31
    a87a:	str	r7, [sp, #36]	; 0x24
    a87c:	str	r3, [sp, #16]
    a87e:	str	r5, [sp, #32]
    a880:	mov	r8, r0
    a882:	str	r0, [sp, #56]	; 0x38
    a884:	ldrb.w	r7, [sp, #79]	; 0x4f
    a888:	b.w	9844 <_svfprintf_r+0x3e4>
    a88c:	add	r2, sp, #108	; 0x6c
    a88e:	ldr	r1, [sp, #12]
    a890:	ldr	r0, [sp, #20]
    a892:	bl	d8cc <__ssprint_r>
    a896:	cmp	r0, #0
    a898:	bne.w	964c <_svfprintf_r+0x1ec>
    a89c:	ldr	r4, [sp, #84]	; 0x54
    a89e:	ldr	r3, [sp, #116]	; 0x74
    a8a0:	ldr	r2, [sp, #112]	; 0x70
    a8a2:	add.w	r9, sp, #160	; 0xa0
    a8a6:	b.n	a524 <_svfprintf_r+0x10c4>
    a8a8:	mov	sl, r4
    a8aa:	movs	r5, #0
    a8ac:	b.w	9516 <_svfprintf_r+0xb6>
    a8b0:	adds	r3, #48	; 0x30
    a8b2:	movs	r2, #48	; 0x30
    a8b4:	strb.w	r3, [sp, #95]	; 0x5f
    a8b8:	strb.w	r2, [sp, #94]	; 0x5e
    a8bc:	add	r3, sp, #96	; 0x60
    a8be:	b.n	a6fa <_svfprintf_r+0x129a>
    a8c0:	ldr	r2, [sp, #60]	; 0x3c
    a8c2:	ldr	r3, [sp, #56]	; 0x38
    a8c4:	add	r3, r2
    a8c6:	movs	r2, #103	; 0x67
    a8c8:	str	r3, [sp, #32]
    a8ca:	str	r2, [sp, #48]	; 0x30
    a8cc:	bic.w	r3, r3, r3, asr #31
    a8d0:	b.n	a462 <_svfprintf_r+0x1002>
    a8d2:	ldr	r3, [sp, #100]	; 0x64
    a8d4:	b.n	a428 <_svfprintf_r+0xfc8>
    a8d6:	ldr	r6, [pc, #240]	; (a9c8 <_svfprintf_r+0x1568>)
    a8d8:	ldr	r3, [pc, #240]	; (a9cc <_svfprintf_r+0x156c>)
    a8da:	ldrb.w	r7, [sp, #79]	; 0x4f
    a8de:	b.w	982a <_svfprintf_r+0x3ca>
    a8e2:	ldr	r3, [sp, #56]	; 0x38
    a8e4:	ldr	r2, [sp, #60]	; 0x3c
    a8e6:	adds	r5, r3, r2
    a8e8:	add.w	r3, r5, r8
    a8ec:	str	r3, [sp, #32]
    a8ee:	bic.w	r3, r3, r3, asr #31
    a8f2:	b.n	a462 <_svfprintf_r+0x1002>
    a8f4:	vcmp.f64	d10, #0.0
    a8f8:	vmrs	APSR_nzcv, fpscr
    a8fc:	beq.w	a5da <_svfprintf_r+0x117a>
    a900:	rsb	r4, r4, #1
    a904:	str	r4, [sp, #84]	; 0x54
    a906:	add	r1, r4
    a908:	b.n	a408 <_svfprintf_r+0xfa8>
    a90a:	ands.w	r3, fp, #1
    a90e:	bne.w	a70c <_svfprintf_r+0x12ac>
    a912:	str	r3, [sp, #56]	; 0x38
    a914:	ldr	r3, [sp, #32]
    a916:	bic.w	r3, r3, r3, asr #31
    a91a:	b.n	a462 <_svfprintf_r+0x1002>
    a91c:	ldr	r3, [sp, #56]	; 0x38
    a91e:	ldr	r2, [sp, #32]
    a920:	rsb	r3, r3, #1
    a924:	add	r2, r3
    a926:	mov	r3, r2
    a928:	str	r2, [sp, #32]
    a92a:	b.n	a810 <_svfprintf_r+0x13b0>
    a92c:	cmp.w	r8, #0
    a930:	bne.n	a938 <_svfprintf_r+0x14d8>
    a932:	tst.w	fp, #1
    a936:	beq.n	a948 <_svfprintf_r+0x14e8>
    a938:	ldr	r3, [sp, #60]	; 0x3c
    a93a:	adds	r5, r3, #1
    a93c:	add.w	r3, r5, r8
    a940:	str	r3, [sp, #32]
    a942:	bic.w	r3, r3, r3, asr #31
    a946:	b.n	a462 <_svfprintf_r+0x1002>
    a948:	movs	r3, #1
    a94a:	str	r3, [sp, #32]
    a94c:	b.n	a462 <_svfprintf_r+0x1002>
    a94e:	ldr	r0, [sp, #36]	; 0x24
    a950:	ldrb.w	r3, [sl, #1]
    a954:	ldr	r5, [r0, #0]
    a956:	adds	r0, #4
    a958:	cmp	r5, #0
    a95a:	str	r0, [sp, #36]	; 0x24
    a95c:	mov	sl, r4
    a95e:	bge.w	9512 <_svfprintf_r+0xb2>
    a962:	mov.w	r5, #4294967295
    a966:	b.w	9512 <_svfprintf_r+0xb2>
    a96a:	strb.w	r1, [sp, #79]	; 0x4f
    a96e:	b.w	9c8c <_svfprintf_r+0x82c>
    a972:	strb.w	r1, [sp, #79]	; 0x4f
    a976:	b.w	9d18 <_svfprintf_r+0x8b8>
    a97a:	ldr	r2, [sp, #20]
    a97c:	movs	r3, #12
    a97e:	str	r3, [r2, #0]
    a980:	mov.w	r0, #4294967295
    a984:	b.w	965e <_svfprintf_r+0x1fe>
    a988:	strb.w	r1, [sp, #79]	; 0x4f
    a98c:	b.w	9b38 <_svfprintf_r+0x6d8>
    a990:	strb.w	r1, [sp, #79]	; 0x4f
    a994:	b.w	9ade <_svfprintf_r+0x67e>
    a998:	strb.w	r1, [sp, #79]	; 0x4f
    a99c:	b.w	9c44 <_svfprintf_r+0x7e4>
    a9a0:	add.w	r3, sp, #94	; 0x5e
    a9a4:	b.n	a6fa <_svfprintf_r+0x129a>
    a9a6:	strb.w	r1, [sp, #79]	; 0x4f
    a9aa:	b.w	9672 <_svfprintf_r+0x212>
    a9ae:	strb.w	r1, [sp, #79]	; 0x4f
    a9b2:	b.w	9a7a <_svfprintf_r+0x61a>
    a9b6:	strb.w	r1, [sp, #79]	; 0x4f
    a9ba:	b.w	97ea <_svfprintf_r+0x38a>
    a9be:	strb.w	r1, [sp, #79]	; 0x4f
    a9c2:	b.w	9766 <_svfprintf_r+0x306>
    a9c6:	nop
    a9c8:	.word	0x20000fdc
    a9cc:	.word	0x20000fd8

0000a9d0 <__sprint_r.part.0>:
    a9d0:	ldr	r3, [r1, #100]	; 0x64
    a9d2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a9d6:	lsls	r4, r3, #18
    a9d8:	mov	sl, r2
    a9da:	bpl.n	aa36 <__sprint_r.part.0+0x66>
    a9dc:	ldr	r3, [r2, #8]
    a9de:	ldr	r2, [r2, #0]
    a9e0:	cbz	r3, aa32 <__sprint_r.part.0+0x62>
    a9e2:	mov	r7, r1
    a9e4:	mov	r8, r0
    a9e6:	add.w	r9, r2, #8
    a9ea:	ldmdb	r9, {r5, r6}
    a9ee:	lsrs	r6, r6, #2
    a9f0:	beq.n	aa22 <__sprint_r.part.0+0x52>
    a9f2:	subs	r5, #4
    a9f4:	movs	r4, #0
    a9f6:	b.n	a9fc <__sprint_r.part.0+0x2c>
    a9f8:	cmp	r6, r4
    a9fa:	beq.n	aa1e <__sprint_r.part.0+0x4e>
    a9fc:	mov	r2, r7
    a9fe:	ldr.w	r1, [r5, #4]!
    aa02:	mov	r0, r8
    aa04:	bl	ca88 <_fputwc_r>
    aa08:	adds	r3, r0, #1
    aa0a:	add.w	r4, r4, #1
    aa0e:	bne.n	a9f8 <__sprint_r.part.0+0x28>
    aa10:	movs	r3, #0
    aa12:	str.w	r3, [sl, #8]
    aa16:	str.w	r3, [sl, #4]
    aa1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    aa1e:	ldr.w	r3, [sl, #8]
    aa22:	sub.w	r3, r3, r6, lsl #2
    aa26:	str.w	r3, [sl, #8]
    aa2a:	add.w	r9, r9, #8
    aa2e:	cmp	r3, #0
    aa30:	bne.n	a9ea <__sprint_r.part.0+0x1a>
    aa32:	movs	r0, #0
    aa34:	b.n	aa10 <__sprint_r.part.0+0x40>
    aa36:	bl	cd1c <__sfvwrite_r>
    aa3a:	movs	r3, #0
    aa3c:	str.w	r3, [sl, #8]
    aa40:	str.w	r3, [sl, #4]
    aa44:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000aa48 <_vfiprintf_r>:
    aa48:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aa4c:	sub	sp, #172	; 0xac
    aa4e:	mov	r4, r3
    aa50:	str	r1, [sp, #0]
    aa52:	mov	r8, r2
    aa54:	str	r3, [sp, #16]
    aa56:	str	r0, [sp, #20]
    aa58:	cbz	r0, aa62 <_vfiprintf_r+0x1a>
    aa5a:	ldr	r3, [r0, #56]	; 0x38
    aa5c:	cmp	r3, #0
    aa5e:	beq.w	ac1e <_vfiprintf_r+0x1d6>
    aa62:	ldr	r0, [sp, #0]
    aa64:	ldrsh.w	r1, [r0, #12]
    aa68:	uxth	r2, r1
    aa6a:	lsls	r5, r2, #18
    aa6c:	bmi.n	aa7e <_vfiprintf_r+0x36>
    aa6e:	ldr	r3, [r0, #100]	; 0x64
    aa70:	orr.w	r2, r1, #8192	; 0x2000
    aa74:	bic.w	r3, r3, #8192	; 0x2000
    aa78:	strh	r2, [r0, #12]
    aa7a:	str	r3, [r0, #100]	; 0x64
    aa7c:	uxth	r2, r2
    aa7e:	lsls	r1, r2, #28
    aa80:	bpl.w	abe6 <_vfiprintf_r+0x19e>
    aa84:	ldr	r3, [sp, #0]
    aa86:	ldr	r3, [r3, #16]
    aa88:	cmp	r3, #0
    aa8a:	beq.w	abe6 <_vfiprintf_r+0x19e>
    aa8e:	and.w	r2, r2, #26
    aa92:	cmp	r2, #10
    aa94:	beq.w	ac02 <_vfiprintf_r+0x1ba>
    aa98:	movs	r3, #0
    aa9a:	add.w	fp, sp, #104	; 0x68
    aa9e:	str	r3, [sp, #8]
    aaa0:	str	r3, [sp, #60]	; 0x3c
    aaa2:	str	r3, [sp, #56]	; 0x38
    aaa4:	str.w	fp, [sp, #52]	; 0x34
    aaa8:	mov	sl, fp
    aaaa:	ldrb.w	r3, [r8]
    aaae:	mov	r4, r8
    aab0:	cbz	r3, aaf2 <_vfiprintf_r+0xaa>
    aab2:	cmp	r3, #37	; 0x25
    aab4:	bne.n	aabc <_vfiprintf_r+0x74>
    aab6:	b.n	aaf2 <_vfiprintf_r+0xaa>
    aab8:	cmp	r3, #37	; 0x25
    aaba:	beq.n	aac4 <_vfiprintf_r+0x7c>
    aabc:	ldrb.w	r3, [r4, #1]!
    aac0:	cmp	r3, #0
    aac2:	bne.n	aab8 <_vfiprintf_r+0x70>
    aac4:	rsb	r5, r8, r4
    aac8:	cbz	r5, aaf2 <_vfiprintf_r+0xaa>
    aaca:	ldr	r3, [sp, #56]	; 0x38
    aacc:	ldr	r2, [sp, #60]	; 0x3c
    aace:	str.w	r8, [sl]
    aad2:	adds	r3, #1
    aad4:	add	r2, r5
    aad6:	cmp	r3, #7
    aad8:	str.w	r5, [sl, #4]
    aadc:	str	r2, [sp, #60]	; 0x3c
    aade:	str	r3, [sp, #56]	; 0x38
    aae0:	ble.n	abda <_vfiprintf_r+0x192>
    aae2:	cmp	r2, #0
    aae4:	bne.w	b538 <_vfiprintf_r+0xaf0>
    aae8:	ldr	r3, [sp, #8]
    aaea:	str	r2, [sp, #56]	; 0x38
    aaec:	add	r3, r5
    aaee:	mov	sl, fp
    aaf0:	str	r3, [sp, #8]
    aaf2:	ldrb	r3, [r4, #0]
    aaf4:	cmp	r3, #0
    aaf6:	beq.w	b376 <_vfiprintf_r+0x92e>
    aafa:	movs	r1, #0
    aafc:	mov.w	r3, #0
    ab00:	mov.w	r2, #4294967295
    ab04:	strb.w	r3, [sp, #47]	; 0x2f
    ab08:	add.w	r8, r4, #1
    ab0c:	ldrb	r3, [r4, #1]
    ab0e:	str	r2, [sp, #4]
    ab10:	mov	r0, r1
    ab12:	mov	r6, r1
    ab14:	mov	r4, r1
    ab16:	add.w	r8, r8, #1
    ab1a:	sub.w	r2, r3, #32
    ab1e:	cmp	r2, #88	; 0x58
    ab20:	bhi.w	b24a <_vfiprintf_r+0x802>
    ab24:	tbh	[pc, r2, lsl #1]
    ab28:	.word	0x03910346
    ab2c:	.word	0x034e0391
    ab30:	.word	0x03910391
    ab34:	.word	0x03910391
    ab38:	.word	0x03910391
    ab3c:	.word	0x02670289
    ab40:	.word	0x00800391
    ab44:	.word	0x0391026c
    ab48:	.word	0x025901c6
    ab4c:	.word	0x02590259
    ab50:	.word	0x02590259
    ab54:	.word	0x02590259
    ab58:	.word	0x02590259
    ab5c:	.word	0x03910391
    ab60:	.word	0x03910391
    ab64:	.word	0x03910391
    ab68:	.word	0x03910391
    ab6c:	.word	0x03910391
    ab70:	.word	0x039101cb
    ab74:	.word	0x03910391
    ab78:	.word	0x03910391
    ab7c:	.word	0x03910391
    ab80:	.word	0x03910391
    ab84:	.word	0x02140391
    ab88:	.word	0x03910391
    ab8c:	.word	0x03910391
    ab90:	.word	0x02ee0391
    ab94:	.word	0x03910391
    ab98:	.word	0x03910311
    ab9c:	.word	0x03910391
    aba0:	.word	0x03910391
    aba4:	.word	0x03910391
    aba8:	.word	0x03910391
    abac:	.word	0x03340391
    abb0:	.word	0x0391038a
    abb4:	.word	0x03910391
    abb8:	.word	0x038a0367
    abbc:	.word	0x03910391
    abc0:	.word	0x0391036c
    abc4:	.word	0x02950379
    abc8:	.word	0x02e90085
    abcc:	.word	0x029b0391
    abd0:	.word	0x02ba0391
    abd4:	.word	0x03910391
    abd8:	.short	0x0353
    abda:	add.w	sl, sl, #8
    abde:	ldr	r3, [sp, #8]
    abe0:	add	r3, r5
    abe2:	str	r3, [sp, #8]
    abe4:	b.n	aaf2 <_vfiprintf_r+0xaa>
    abe6:	ldr	r1, [sp, #0]
    abe8:	ldr	r0, [sp, #20]
    abea:	bl	b8f8 <__swsetup_r>
    abee:	cmp	r0, #0
    abf0:	bne.w	b6a4 <_vfiprintf_r+0xc5c>
    abf4:	ldr	r3, [sp, #0]
    abf6:	ldrh	r2, [r3, #12]
    abf8:	and.w	r2, r2, #26
    abfc:	cmp	r2, #10
    abfe:	bne.w	aa98 <_vfiprintf_r+0x50>
    ac02:	ldr	r1, [sp, #0]
    ac04:	ldrsh.w	r3, [r1, #14]
    ac08:	cmp	r3, #0
    ac0a:	blt.w	aa98 <_vfiprintf_r+0x50>
    ac0e:	mov	r3, r4
    ac10:	mov	r2, r8
    ac12:	ldr	r0, [sp, #20]
    ac14:	bl	b844 <__sbprintf>
    ac18:	add	sp, #172	; 0xac
    ac1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ac1e:	bl	c9dc <__sinit>
    ac22:	b.n	aa62 <_vfiprintf_r+0x1a>
    ac24:	negs	r4, r4
    ac26:	str	r3, [sp, #16]
    ac28:	orr.w	r6, r6, #4
    ac2c:	ldrb.w	r3, [r8]
    ac30:	b.n	ab16 <_vfiprintf_r+0xce>
    ac32:	movs	r1, #48	; 0x30
    ac34:	ldr	r0, [sp, #16]
    ac36:	strb.w	r1, [sp, #48]	; 0x30
    ac3a:	ldr	r1, [sp, #4]
    ac3c:	str	r4, [sp, #24]
    ac3e:	mov.w	r3, #0
    ac42:	movs	r2, #120	; 0x78
    ac44:	strb.w	r3, [sp, #47]	; 0x2f
    ac48:	cmp	r1, #0
    ac4a:	mov	r3, r0
    ac4c:	strb.w	r2, [sp, #49]	; 0x31
    ac50:	ldr	r4, [r0, #0]
    ac52:	add.w	r3, r3, #4
    ac56:	mov.w	r5, #0
    ac5a:	orr.w	r2, r6, #2
    ac5e:	blt.w	b6ac <_vfiprintf_r+0xc64>
    ac62:	bic.w	r6, r6, #128	; 0x80
    ac66:	orrs.w	r2, r4, r5
    ac6a:	orr.w	r6, r6, #2
    ac6e:	str	r3, [sp, #16]
    ac70:	bne.w	b5f2 <_vfiprintf_r+0xbaa>
    ac74:	ldr	r0, [pc, #716]	; (af44 <_vfiprintf_r+0x4fc>)
    ac76:	ldr	r3, [sp, #4]
    ac78:	cmp	r3, #0
    ac7a:	bne.w	b4b6 <_vfiprintf_r+0xa6e>
    ac7e:	mov	r9, r3
    ac80:	movs	r3, #0
    ac82:	str	r3, [sp, #4]
    ac84:	str	r3, [sp, #12]
    ac86:	mov	r7, fp
    ac88:	ldr	r3, [sp, #4]
    ac8a:	ldr	r2, [sp, #12]
    ac8c:	cmp	r3, r2
    ac8e:	it	lt
    ac90:	movlt	r3, r2
    ac92:	mov	r5, r3
    ac94:	cmp.w	r9, #0
    ac98:	beq.n	ac9c <_vfiprintf_r+0x254>
    ac9a:	adds	r5, #1
    ac9c:	ands.w	r3, r6, #2
    aca0:	str	r3, [sp, #28]
    aca2:	it	ne
    aca4:	addne	r5, #2
    aca6:	ands.w	r3, r6, #132	; 0x84
    acaa:	str	r3, [sp, #32]
    acac:	bne.w	b292 <_vfiprintf_r+0x84a>
    acb0:	ldr	r3, [sp, #24]
    acb2:	subs	r4, r3, r5
    acb4:	cmp	r4, #0
    acb6:	ble.w	b292 <_vfiprintf_r+0x84a>
    acba:	cmp	r4, #16
    acbc:	ble.w	b76c <_vfiprintf_r+0xd24>
    acc0:	ldr.w	r9, [pc, #644]	; af48 <_vfiprintf_r+0x500>
    acc4:	ldr.w	lr, [sp, #56]	; 0x38
    acc8:	ldr	r2, [sp, #60]	; 0x3c
    acca:	mov	ip, sl
    accc:	movs	r3, #16
    acce:	mov	sl, r8
    acd0:	mov	r0, lr
    acd2:	mov	r8, r5
    acd4:	mov	r5, r9
    acd6:	ldr.w	r9, [sp, #20]
    acda:	b.n	acec <_vfiprintf_r+0x2a4>
    acdc:	add.w	lr, r0, #2
    ace0:	add.w	ip, ip, #8
    ace4:	mov	r0, r1
    ace6:	subs	r4, #16
    ace8:	cmp	r4, #16
    acea:	ble.n	ad14 <_vfiprintf_r+0x2cc>
    acec:	adds	r1, r0, #1
    acee:	adds	r2, #16
    acf0:	cmp	r1, #7
    acf2:	str	r2, [sp, #60]	; 0x3c
    acf4:	str.w	r5, [ip]
    acf8:	str.w	r3, [ip, #4]
    acfc:	str	r1, [sp, #56]	; 0x38
    acfe:	ble.n	acdc <_vfiprintf_r+0x294>
    ad00:	cmp	r2, #0
    ad02:	bne.w	b274 <_vfiprintf_r+0x82c>
    ad06:	subs	r4, #16
    ad08:	cmp	r4, #16
    ad0a:	mov	r0, r2
    ad0c:	mov.w	lr, #1
    ad10:	mov	ip, fp
    ad12:	bgt.n	acec <_vfiprintf_r+0x2a4>
    ad14:	mov	r9, r5
    ad16:	mov	r0, lr
    ad18:	mov	r5, r8
    ad1a:	mov	r8, sl
    ad1c:	mov	sl, ip
    ad1e:	add	r2, r4
    ad20:	cmp	r0, #7
    ad22:	str	r2, [sp, #60]	; 0x3c
    ad24:	str.w	r9, [sl]
    ad28:	str.w	r4, [sl, #4]
    ad2c:	str	r0, [sp, #56]	; 0x38
    ad2e:	bgt.w	b41c <_vfiprintf_r+0x9d4>
    ad32:	ldrb.w	r3, [sp, #47]	; 0x2f
    ad36:	add.w	sl, sl, #8
    ad3a:	add.w	lr, r0, #1
    ad3e:	cmp	r3, #0
    ad40:	bne.w	b2a4 <_vfiprintf_r+0x85c>
    ad44:	ldr	r3, [sp, #28]
    ad46:	cmp	r3, #0
    ad48:	beq.w	b2d2 <_vfiprintf_r+0x88a>
    ad4c:	adds	r2, #2
    ad4e:	add	r1, sp, #48	; 0x30
    ad50:	movs	r3, #2
    ad52:	cmp.w	lr, #7
    ad56:	str	r2, [sp, #60]	; 0x3c
    ad58:	str.w	lr, [sp, #56]	; 0x38
    ad5c:	stmia.w	sl, {r1, r3}
    ad60:	ble.w	b454 <_vfiprintf_r+0xa0c>
    ad64:	cmp	r2, #0
    ad66:	bne.w	b57e <_vfiprintf_r+0xb36>
    ad6a:	ldr	r3, [sp, #32]
    ad6c:	cmp	r3, #128	; 0x80
    ad6e:	mov.w	lr, #1
    ad72:	mov	r0, r2
    ad74:	mov	sl, fp
    ad76:	bne.w	b2da <_vfiprintf_r+0x892>
    ad7a:	ldr	r3, [sp, #24]
    ad7c:	subs	r4, r3, r5
    ad7e:	cmp	r4, #0
    ad80:	ble.w	b2da <_vfiprintf_r+0x892>
    ad84:	cmp	r4, #16
    ad86:	ldr.w	r9, [pc, #452]	; af4c <_vfiprintf_r+0x504>
    ad8a:	ble.w	b7a4 <_vfiprintf_r+0xd5c>
    ad8e:	mov	lr, sl
    ad90:	movs	r3, #16
    ad92:	mov	sl, r8
    ad94:	mov	r8, r5
    ad96:	mov	r5, r9
    ad98:	ldr.w	r9, [sp, #20]
    ad9c:	b.n	adae <_vfiprintf_r+0x366>
    ad9e:	add.w	ip, r0, #2
    ada2:	add.w	lr, lr, #8
    ada6:	mov	r0, r1
    ada8:	subs	r4, #16
    adaa:	cmp	r4, #16
    adac:	ble.n	add6 <_vfiprintf_r+0x38e>
    adae:	adds	r1, r0, #1
    adb0:	adds	r2, #16
    adb2:	cmp	r1, #7
    adb4:	str	r2, [sp, #60]	; 0x3c
    adb6:	str.w	r5, [lr]
    adba:	str.w	r3, [lr, #4]
    adbe:	str	r1, [sp, #56]	; 0x38
    adc0:	ble.n	ad9e <_vfiprintf_r+0x356>
    adc2:	cmp	r2, #0
    adc4:	bne.w	b3f2 <_vfiprintf_r+0x9aa>
    adc8:	subs	r4, #16
    adca:	cmp	r4, #16
    adcc:	mov.w	ip, #1
    add0:	mov	r0, r2
    add2:	mov	lr, fp
    add4:	bgt.n	adae <_vfiprintf_r+0x366>
    add6:	mov	r9, r5
    add8:	mov	r5, r8
    adda:	mov	r8, sl
    addc:	mov	sl, lr
    adde:	add	r2, r4
    ade0:	cmp.w	ip, #7
    ade4:	str	r2, [sp, #60]	; 0x3c
    ade6:	str.w	r9, [sl]
    adea:	str.w	r4, [sl, #4]
    adee:	str.w	ip, [sp, #56]	; 0x38
    adf2:	bgt.w	b59a <_vfiprintf_r+0xb52>
    adf6:	ldr	r3, [sp, #4]
    adf8:	ldr	r1, [sp, #12]
    adfa:	subs	r4, r3, r1
    adfc:	cmp	r4, #0
    adfe:	add.w	sl, sl, #8
    ae02:	add.w	lr, ip, #1
    ae06:	mov	r0, ip
    ae08:	bgt.w	b2e6 <_vfiprintf_r+0x89e>
    ae0c:	ldr	r1, [sp, #12]
    ae0e:	str.w	r7, [sl]
    ae12:	add	r2, r1
    ae14:	cmp.w	lr, #7
    ae18:	str	r2, [sp, #60]	; 0x3c
    ae1a:	str.w	r1, [sl, #4]
    ae1e:	str.w	lr, [sp, #56]	; 0x38
    ae22:	ble.w	b3c2 <_vfiprintf_r+0x97a>
    ae26:	cmp	r2, #0
    ae28:	bne.w	b4a0 <_vfiprintf_r+0xa58>
    ae2c:	lsls	r0, r6, #29
    ae2e:	str	r2, [sp, #56]	; 0x38
    ae30:	bpl.n	aea4 <_vfiprintf_r+0x45c>
    ae32:	ldr	r3, [sp, #24]
    ae34:	subs	r4, r3, r5
    ae36:	cmp	r4, #0
    ae38:	ble.n	aea4 <_vfiprintf_r+0x45c>
    ae3a:	mov	sl, fp
    ae3c:	cmp	r4, #16
    ae3e:	ble.w	b798 <_vfiprintf_r+0xd50>
    ae42:	ldr.w	r9, [pc, #260]	; af48 <_vfiprintf_r+0x500>
    ae46:	ldr	r1, [sp, #56]	; 0x38
    ae48:	mov	r7, r9
    ae4a:	movs	r6, #16
    ae4c:	ldr.w	r9, [sp, #20]
    ae50:	b.n	ae60 <_vfiprintf_r+0x418>
    ae52:	adds	r0, r1, #2
    ae54:	add.w	sl, sl, #8
    ae58:	mov	r1, r3
    ae5a:	subs	r4, #16
    ae5c:	cmp	r4, #16
    ae5e:	ble.n	ae88 <_vfiprintf_r+0x440>
    ae60:	adds	r3, r1, #1
    ae62:	adds	r2, #16
    ae64:	cmp	r3, #7
    ae66:	str	r2, [sp, #60]	; 0x3c
    ae68:	str.w	r7, [sl]
    ae6c:	str.w	r6, [sl, #4]
    ae70:	str	r3, [sp, #56]	; 0x38
    ae72:	ble.n	ae52 <_vfiprintf_r+0x40a>
    ae74:	cmp	r2, #0
    ae76:	bne.w	b396 <_vfiprintf_r+0x94e>
    ae7a:	subs	r4, #16
    ae7c:	cmp	r4, #16
    ae7e:	mov.w	r0, #1
    ae82:	mov	r1, r2
    ae84:	mov	sl, fp
    ae86:	bgt.n	ae60 <_vfiprintf_r+0x418>
    ae88:	mov	r9, r7
    ae8a:	add	r2, r4
    ae8c:	cmp	r0, #7
    ae8e:	str	r2, [sp, #60]	; 0x3c
    ae90:	str.w	r9, [sl]
    ae94:	str.w	r4, [sl, #4]
    ae98:	str	r0, [sp, #56]	; 0x38
    ae9a:	ble.w	b3d4 <_vfiprintf_r+0x98c>
    ae9e:	cmp	r2, #0
    aea0:	bne.w	b6ee <_vfiprintf_r+0xca6>
    aea4:	ldr	r3, [sp, #8]
    aea6:	ldr	r2, [sp, #24]
    aea8:	cmp	r2, r5
    aeaa:	ite	ge
    aeac:	addge	r3, r3, r2
    aeae:	addlt	r3, r3, r5
    aeb0:	str	r3, [sp, #8]
    aeb2:	b.n	b3e8 <_vfiprintf_r+0x9a0>
    aeb4:	orr.w	r6, r6, #128	; 0x80
    aeb8:	ldrb.w	r3, [r8]
    aebc:	b.n	ab16 <_vfiprintf_r+0xce>
    aebe:	str	r4, [sp, #24]
    aec0:	cmp	r1, #0
    aec2:	bne.w	b824 <_vfiprintf_r+0xddc>
    aec6:	orr.w	r6, r6, #16
    aeca:	lsls	r3, r6, #26
    aecc:	bpl.w	b4f4 <_vfiprintf_r+0xaac>
    aed0:	ldr	r1, [sp, #16]
    aed2:	adds	r1, #7
    aed4:	bic.w	r1, r1, #7
    aed8:	ldrd	r2, r3, [r1]
    aedc:	adds	r1, #8
    aede:	str	r1, [sp, #16]
    aee0:	mov	r4, r2
    aee2:	mov	r5, r3
    aee4:	cmp	r2, #0
    aee6:	sbcs.w	r3, r3, #0
    aeea:	blt.w	b5fa <_vfiprintf_r+0xbb2>
    aeee:	ldr	r3, [sp, #4]
    aef0:	ldrb.w	r9, [sp, #47]	; 0x2f
    aef4:	cmp	r3, #0
    aef6:	blt.w	b52e <_vfiprintf_r+0xae6>
    aefa:	orrs.w	r3, r4, r5
    aefe:	bic.w	r6, r6, #128	; 0x80
    af02:	beq.w	b0e0 <_vfiprintf_r+0x698>
    af06:	cmp	r5, #0
    af08:	it	eq
    af0a:	cmpeq	r4, #10
    af0c:	bcc.w	b0ea <_vfiprintf_r+0x6a2>
    af10:	mov	r7, fp
    af12:	mov	r0, r4
    af14:	mov	r1, r5
    af16:	movs	r2, #10
    af18:	movs	r3, #0
    af1a:	bl	dc78 <__aeabi_uldivmod>
    af1e:	adds	r2, #48	; 0x30
    af20:	strb.w	r2, [r7, #-1]!
    af24:	mov	r0, r4
    af26:	mov	r1, r5
    af28:	movs	r3, #0
    af2a:	movs	r2, #10
    af2c:	bl	dc78 <__aeabi_uldivmod>
    af30:	mov	r4, r0
    af32:	mov	r5, r1
    af34:	orrs.w	r3, r4, r5
    af38:	bne.n	af12 <_vfiprintf_r+0x4ca>
    af3a:	rsb	r3, r7, fp
    af3e:	str	r3, [sp, #12]
    af40:	b.n	ac88 <_vfiprintf_r+0x240>
    af42:	nop
    af44:	.word	0x20000ff4
    af48:	.word	0x20001030
    af4c:	.word	0x20001020
    af50:	str	r4, [sp, #24]
    af52:	cmp	r1, #0
    af54:	bne.w	b81c <_vfiprintf_r+0xdd4>
    af58:	orr.w	r6, r6, #16
    af5c:	ands.w	r3, r6, #32
    af60:	beq.w	b4c0 <_vfiprintf_r+0xa78>
    af64:	ldr	r3, [sp, #16]
    af66:	adds	r3, #7
    af68:	bic.w	r3, r3, #7
    af6c:	mov.w	r2, #0
    af70:	strb.w	r2, [sp, #47]	; 0x2f
    af74:	ldrd	r4, r5, [r3]
    af78:	add.w	r2, r3, #8
    af7c:	ldr	r3, [sp, #4]
    af7e:	str	r2, [sp, #16]
    af80:	cmp	r3, #0
    af82:	blt.w	b26e <_vfiprintf_r+0x826>
    af86:	orrs.w	r3, r4, r5
    af8a:	bic.w	r6, r6, #128	; 0x80
    af8e:	bne.w	b26e <_vfiprintf_r+0x826>
    af92:	ldr	r3, [sp, #4]
    af94:	cmp	r3, #0
    af96:	beq.w	b7fa <_vfiprintf_r+0xdb2>
    af9a:	mov.w	r9, #0
    af9e:	movs	r4, #0
    afa0:	movs	r5, #0
    afa2:	mov	r7, fp
    afa4:	lsrs	r2, r4, #3
    afa6:	orr.w	r2, r2, r5, lsl #29
    afaa:	lsrs	r1, r5, #3
    afac:	and.w	r3, r4, #7
    afb0:	mov	r5, r1
    afb2:	mov	r4, r2
    afb4:	adds	r3, #48	; 0x30
    afb6:	orrs.w	r2, r4, r5
    afba:	strb.w	r3, [r7, #-1]!
    afbe:	bne.n	afa4 <_vfiprintf_r+0x55c>
    afc0:	lsls	r4, r6, #31
    afc2:	bpl.n	af3a <_vfiprintf_r+0x4f2>
    afc4:	cmp	r3, #48	; 0x30
    afc6:	beq.n	af3a <_vfiprintf_r+0x4f2>
    afc8:	movs	r2, #48	; 0x30
    afca:	subs	r3, r7, #1
    afcc:	strb.w	r2, [r7, #-1]
    afd0:	rsb	r2, r3, fp
    afd4:	str	r2, [sp, #12]
    afd6:	mov	r7, r3
    afd8:	b.n	ac88 <_vfiprintf_r+0x240>
    afda:	sub.w	r2, r3, #48	; 0x30
    afde:	movs	r4, #0
    afe0:	ldrb.w	r3, [r8], #1
    afe4:	add.w	r4, r4, r4, lsl #2
    afe8:	add.w	r4, r2, r4, lsl #1
    afec:	sub.w	r2, r3, #48	; 0x30
    aff0:	cmp	r2, #9
    aff2:	bls.n	afe0 <_vfiprintf_r+0x598>
    aff4:	b.n	ab1a <_vfiprintf_r+0xd2>
    aff6:	ldrb.w	r3, [r8]
    affa:	movs	r1, #1
    affc:	movs	r0, #43	; 0x2b
    affe:	b.n	ab16 <_vfiprintf_r+0xce>
    b000:	ldrb.w	r3, [r8]
    b004:	cmp	r3, #42	; 0x2a
    b006:	add.w	r5, r8, #1
    b00a:	beq.w	b7c8 <_vfiprintf_r+0xd80>
    b00e:	sub.w	r2, r3, #48	; 0x30
    b012:	cmp	r2, #9
    b014:	mov	r8, r5
    b016:	it	ls
    b018:	movls	r5, #0
    b01a:	bhi.w	b7ba <_vfiprintf_r+0xd72>
    b01e:	ldrb.w	r3, [r8], #1
    b022:	add.w	r5, r5, r5, lsl #2
    b026:	add.w	r5, r2, r5, lsl #1
    b02a:	sub.w	r2, r3, #48	; 0x30
    b02e:	cmp	r2, #9
    b030:	bls.n	b01e <_vfiprintf_r+0x5d6>
    b032:	orr.w	r2, r5, r5, asr #31
    b036:	str	r2, [sp, #4]
    b038:	b.n	ab1a <_vfiprintf_r+0xd2>
    b03a:	ldr	r2, [sp, #16]
    b03c:	ldr	r4, [r2, #0]
    b03e:	mov	r3, r2
    b040:	cmp	r4, #0
    b042:	add.w	r3, r3, #4
    b046:	blt.w	ac24 <_vfiprintf_r+0x1dc>
    b04a:	str	r3, [sp, #16]
    b04c:	ldrb.w	r3, [r8]
    b050:	b.n	ab16 <_vfiprintf_r+0xce>
    b052:	str	r4, [sp, #24]
    b054:	cmp	r1, #0
    b056:	beq.n	af5c <_vfiprintf_r+0x514>
    b058:	strb.w	r0, [sp, #47]	; 0x2f
    b05c:	b.n	af5c <_vfiprintf_r+0x514>
    b05e:	ldr	r2, [sp, #16]
    b060:	str	r4, [sp, #24]
    b062:	ldr	r7, [r2, #0]
    b064:	mov.w	r3, #0
    b068:	strb.w	r3, [sp, #47]	; 0x2f
    b06c:	adds	r4, r2, #4
    b06e:	ldr	r3, [sp, #4]
    b070:	cmp	r7, #0
    b072:	beq.w	b782 <_vfiprintf_r+0xd3a>
    b076:	cmp	r3, #0
    b078:	blt.w	b73a <_vfiprintf_r+0xcf2>
    b07c:	mov	r2, r3
    b07e:	movs	r1, #0
    b080:	mov	r0, r7
    b082:	bl	d180 <memchr>
    b086:	cmp	r0, #0
    b088:	beq.w	b7aa <_vfiprintf_r+0xd62>
    b08c:	subs	r3, r0, r7
    b08e:	str	r3, [sp, #12]
    b090:	movs	r3, #0
    b092:	str	r4, [sp, #16]
    b094:	ldrb.w	r9, [sp, #47]	; 0x2f
    b098:	str	r3, [sp, #4]
    b09a:	b.n	ac88 <_vfiprintf_r+0x240>
    b09c:	str	r4, [sp, #24]
    b09e:	cmp	r1, #0
    b0a0:	bne.w	b816 <_vfiprintf_r+0xdce>
    b0a4:	ands.w	r9, r6, #32
    b0a8:	bne.n	b116 <_vfiprintf_r+0x6ce>
    b0aa:	ands.w	r3, r6, #16
    b0ae:	bne.n	b0b8 <_vfiprintf_r+0x670>
    b0b0:	ands.w	r9, r6, #64	; 0x40
    b0b4:	bne.w	b70c <_vfiprintf_r+0xcc4>
    b0b8:	ldr	r2, [sp, #16]
    b0ba:	mov	r3, r2
    b0bc:	ldr	r4, [r2, #0]
    b0be:	ldr	r2, [sp, #4]
    b0c0:	strb.w	r9, [sp, #47]	; 0x2f
    b0c4:	cmp	r2, #0
    b0c6:	add.w	r3, r3, #4
    b0ca:	mov.w	r5, #0
    b0ce:	blt.w	b736 <_vfiprintf_r+0xcee>
    b0d2:	orrs.w	r2, r4, r5
    b0d6:	bic.w	r6, r6, #128	; 0x80
    b0da:	str	r3, [sp, #16]
    b0dc:	bne.w	af06 <_vfiprintf_r+0x4be>
    b0e0:	ldr	r3, [sp, #4]
    b0e2:	cmp	r3, #0
    b0e4:	beq.w	ac80 <_vfiprintf_r+0x238>
    b0e8:	movs	r4, #0
    b0ea:	add	r7, sp, #168	; 0xa8
    b0ec:	adds	r4, #48	; 0x30
    b0ee:	strb.w	r4, [r7, #-65]!
    b0f2:	rsb	r3, r7, fp
    b0f6:	str	r3, [sp, #12]
    b0f8:	b.n	ac88 <_vfiprintf_r+0x240>
    b0fa:	orr.w	r6, r6, #32
    b0fe:	ldrb.w	r3, [r8]
    b102:	b.n	ab16 <_vfiprintf_r+0xce>
    b104:	str	r4, [sp, #24]
    b106:	cmp	r1, #0
    b108:	bne.w	b7e8 <_vfiprintf_r+0xda0>
    b10c:	orr.w	r6, r6, #16
    b110:	ands.w	r9, r6, #32
    b114:	beq.n	b0aa <_vfiprintf_r+0x662>
    b116:	ldr	r3, [sp, #16]
    b118:	adds	r3, #7
    b11a:	bic.w	r3, r3, #7
    b11e:	mov.w	r2, #0
    b122:	strb.w	r2, [sp, #47]	; 0x2f
    b126:	ldrd	r4, r5, [r3]
    b12a:	add.w	r2, r3, #8
    b12e:	ldr	r3, [sp, #4]
    b130:	str	r2, [sp, #16]
    b132:	cmp	r3, #0
    b134:	blt.w	b52a <_vfiprintf_r+0xae2>
    b138:	orrs.w	r3, r4, r5
    b13c:	bic.w	r6, r6, #128	; 0x80
    b140:	mov.w	r9, #0
    b144:	bne.w	af06 <_vfiprintf_r+0x4be>
    b148:	b.n	b0e0 <_vfiprintf_r+0x698>
    b14a:	str	r4, [sp, #24]
    b14c:	cmp	r1, #0
    b14e:	bne.w	b7f4 <_vfiprintf_r+0xdac>
    b152:	lsls	r2, r6, #26
    b154:	ldr	r0, [pc, #696]	; (b410 <_vfiprintf_r+0x9c8>)
    b156:	bpl.n	b1dc <_vfiprintf_r+0x794>
    b158:	ldr	r2, [sp, #16]
    b15a:	adds	r2, #7
    b15c:	bic.w	r2, r2, #7
    b160:	ldrd	r4, r5, [r2]
    b164:	add.w	r1, r2, #8
    b168:	str	r1, [sp, #16]
    b16a:	ands.w	r9, r6, #1
    b16e:	beq.w	b460 <_vfiprintf_r+0xa18>
    b172:	orrs.w	r2, r4, r5
    b176:	bne.w	b5c6 <_vfiprintf_r+0xb7e>
    b17a:	mov.w	r3, #0
    b17e:	strb.w	r3, [sp, #47]	; 0x2f
    b182:	ldr	r3, [sp, #4]
    b184:	cmp	r3, #0
    b186:	blt.w	b4b6 <_vfiprintf_r+0xa6e>
    b18a:	bic.w	r6, r6, #128	; 0x80
    b18e:	b.n	ac76 <_vfiprintf_r+0x22e>
    b190:	ldr	r2, [sp, #16]
    b192:	str	r4, [sp, #24]
    b194:	ldr	r3, [r2, #0]
    b196:	strb.w	r3, [sp, #64]	; 0x40
    b19a:	mov	r3, r2
    b19c:	mov.w	r1, #0
    b1a0:	movs	r5, #1
    b1a2:	adds	r3, #4
    b1a4:	strb.w	r1, [sp, #47]	; 0x2f
    b1a8:	str	r3, [sp, #16]
    b1aa:	str	r5, [sp, #12]
    b1ac:	add	r7, sp, #64	; 0x40
    b1ae:	movs	r3, #0
    b1b0:	str	r3, [sp, #4]
    b1b2:	b.n	ac9c <_vfiprintf_r+0x254>
    b1b4:	ldrb.w	r3, [r8]
    b1b8:	cmp	r0, #0
    b1ba:	bne.w	ab16 <_vfiprintf_r+0xce>
    b1be:	movs	r1, #1
    b1c0:	movs	r0, #32
    b1c2:	b.n	ab16 <_vfiprintf_r+0xce>
    b1c4:	orr.w	r6, r6, #1
    b1c8:	ldrb.w	r3, [r8]
    b1cc:	b.n	ab16 <_vfiprintf_r+0xce>
    b1ce:	str	r4, [sp, #24]
    b1d0:	cmp	r1, #0
    b1d2:	bne.w	b7ee <_vfiprintf_r+0xda6>
    b1d6:	lsls	r2, r6, #26
    b1d8:	ldr	r0, [pc, #568]	; (b414 <_vfiprintf_r+0x9cc>)
    b1da:	bmi.n	b158 <_vfiprintf_r+0x710>
    b1dc:	ldr	r1, [sp, #16]
    b1de:	lsls	r7, r6, #27
    b1e0:	mov	r2, r1
    b1e2:	bmi.w	b520 <_vfiprintf_r+0xad8>
    b1e6:	lsls	r5, r6, #25
    b1e8:	bpl.w	b520 <_vfiprintf_r+0xad8>
    b1ec:	adds	r2, #4
    b1ee:	ldrh	r4, [r1, #0]
    b1f0:	str	r2, [sp, #16]
    b1f2:	movs	r5, #0
    b1f4:	b.n	b16a <_vfiprintf_r+0x722>
    b1f6:	orr.w	r6, r6, #64	; 0x40
    b1fa:	ldrb.w	r3, [r8]
    b1fe:	b.n	ab16 <_vfiprintf_r+0xce>
    b200:	ldrb.w	r3, [r8]
    b204:	cmp	r3, #108	; 0x6c
    b206:	ittte	eq
    b208:	ldrbeq.w	r3, [r8, #1]
    b20c:	orreq.w	r6, r6, #32
    b210:	addeq.w	r8, r8, #1
    b214:	orrne.w	r6, r6, #16
    b218:	b.n	ab16 <_vfiprintf_r+0xce>
    b21a:	cmp	r1, #0
    b21c:	bne.w	b832 <_vfiprintf_r+0xdea>
    b220:	lsls	r4, r6, #26
    b222:	bpl.w	b65e <_vfiprintf_r+0xc16>
    b226:	ldr	r2, [sp, #16]
    b228:	ldr	r1, [sp, #8]
    b22a:	ldr	r3, [r2, #0]
    b22c:	asrs	r5, r1, #31
    b22e:	mov	r0, r1
    b230:	adds	r2, #4
    b232:	mov	r1, r5
    b234:	str	r2, [sp, #16]
    b236:	strd	r0, r1, [r3]
    b23a:	b.n	aaaa <_vfiprintf_r+0x62>
    b23c:	str	r4, [sp, #24]
    b23e:	cmp	r1, #0
    b240:	beq.w	aeca <_vfiprintf_r+0x482>
    b244:	strb.w	r0, [sp, #47]	; 0x2f
    b248:	b.n	aeca <_vfiprintf_r+0x482>
    b24a:	str	r4, [sp, #24]
    b24c:	cmp	r1, #0
    b24e:	bne.w	b82c <_vfiprintf_r+0xde4>
    b252:	cmp	r3, #0
    b254:	beq.w	b376 <_vfiprintf_r+0x92e>
    b258:	movs	r5, #1
    b25a:	strb.w	r3, [sp, #64]	; 0x40
    b25e:	mov.w	r3, #0
    b262:	strb.w	r3, [sp, #47]	; 0x2f
    b266:	str	r5, [sp, #12]
    b268:	add	r7, sp, #64	; 0x40
    b26a:	b.n	b1ae <_vfiprintf_r+0x766>
    b26c:	str	r3, [sp, #16]
    b26e:	mov.w	r9, #0
    b272:	b.n	afa2 <_vfiprintf_r+0x55a>
    b274:	add	r2, sp, #52	; 0x34
    b276:	ldr	r1, [sp, #0]
    b278:	str	r3, [sp, #36]	; 0x24
    b27a:	mov	r0, r9
    b27c:	bl	a9d0 <__sprint_r.part.0>
    b280:	cmp	r0, #0
    b282:	bne.n	b384 <_vfiprintf_r+0x93c>
    b284:	ldr	r0, [sp, #56]	; 0x38
    b286:	ldr	r2, [sp, #60]	; 0x3c
    b288:	ldr	r3, [sp, #36]	; 0x24
    b28a:	add.w	lr, r0, #1
    b28e:	mov	ip, fp
    b290:	b.n	ace6 <_vfiprintf_r+0x29e>
    b292:	ldr	r0, [sp, #56]	; 0x38
    b294:	ldr	r2, [sp, #60]	; 0x3c
    b296:	add.w	lr, r0, #1
    b29a:	ldrb.w	r3, [sp, #47]	; 0x2f
    b29e:	cmp	r3, #0
    b2a0:	beq.w	ad44 <_vfiprintf_r+0x2fc>
    b2a4:	adds	r2, #1
    b2a6:	add.w	r1, sp, #47	; 0x2f
    b2aa:	movs	r3, #1
    b2ac:	cmp.w	lr, #7
    b2b0:	str	r2, [sp, #60]	; 0x3c
    b2b2:	str.w	lr, [sp, #56]	; 0x38
    b2b6:	stmia.w	sl, {r1, r3}
    b2ba:	ble.w	b43c <_vfiprintf_r+0x9f4>
    b2be:	cmp	r2, #0
    b2c0:	bne.w	b560 <_vfiprintf_r+0xb18>
    b2c4:	ldr	r1, [sp, #28]
    b2c6:	cmp	r1, #0
    b2c8:	bne.w	b448 <_vfiprintf_r+0xa00>
    b2cc:	mov	lr, r3
    b2ce:	mov	r0, r2
    b2d0:	mov	sl, fp
    b2d2:	ldr	r3, [sp, #32]
    b2d4:	cmp	r3, #128	; 0x80
    b2d6:	beq.w	ad7a <_vfiprintf_r+0x332>
    b2da:	ldr	r3, [sp, #4]
    b2dc:	ldr	r1, [sp, #12]
    b2de:	subs	r4, r3, r1
    b2e0:	cmp	r4, #0
    b2e2:	ble.w	ae0c <_vfiprintf_r+0x3c4>
    b2e6:	cmp	r4, #16
    b2e8:	ldr.w	r9, [pc, #300]	; b418 <_vfiprintf_r+0x9d0>
    b2ec:	ble.n	b33a <_vfiprintf_r+0x8f2>
    b2ee:	mov	ip, sl
    b2f0:	movs	r3, #16
    b2f2:	mov	sl, r8
    b2f4:	mov	r8, r5
    b2f6:	mov	r5, r9
    b2f8:	ldr.w	r9, [sp, #20]
    b2fc:	b.n	b30e <_vfiprintf_r+0x8c6>
    b2fe:	add.w	lr, r0, #2
    b302:	add.w	ip, ip, #8
    b306:	mov	r0, r1
    b308:	subs	r4, #16
    b30a:	cmp	r4, #16
    b30c:	ble.n	b332 <_vfiprintf_r+0x8ea>
    b30e:	adds	r1, r0, #1
    b310:	adds	r2, #16
    b312:	cmp	r1, #7
    b314:	str	r2, [sp, #60]	; 0x3c
    b316:	str.w	r5, [ip]
    b31a:	str.w	r3, [ip, #4]
    b31e:	str	r1, [sp, #56]	; 0x38
    b320:	ble.n	b2fe <_vfiprintf_r+0x8b6>
    b322:	cbnz	r2, b35a <_vfiprintf_r+0x912>
    b324:	subs	r4, #16
    b326:	cmp	r4, #16
    b328:	mov.w	lr, #1
    b32c:	mov	r0, r2
    b32e:	mov	ip, fp
    b330:	bgt.n	b30e <_vfiprintf_r+0x8c6>
    b332:	mov	r9, r5
    b334:	mov	r5, r8
    b336:	mov	r8, sl
    b338:	mov	sl, ip
    b33a:	add	r2, r4
    b33c:	cmp.w	lr, #7
    b340:	str	r2, [sp, #60]	; 0x3c
    b342:	str.w	r9, [sl]
    b346:	str.w	r4, [sl, #4]
    b34a:	str.w	lr, [sp, #56]	; 0x38
    b34e:	bgt.n	b3ae <_vfiprintf_r+0x966>
    b350:	add.w	sl, sl, #8
    b354:	add.w	lr, lr, #1
    b358:	b.n	ae0c <_vfiprintf_r+0x3c4>
    b35a:	add	r2, sp, #52	; 0x34
    b35c:	ldr	r1, [sp, #0]
    b35e:	str	r3, [sp, #4]
    b360:	mov	r0, r9
    b362:	bl	a9d0 <__sprint_r.part.0>
    b366:	cbnz	r0, b384 <_vfiprintf_r+0x93c>
    b368:	ldr	r0, [sp, #56]	; 0x38
    b36a:	ldr	r2, [sp, #60]	; 0x3c
    b36c:	ldr	r3, [sp, #4]
    b36e:	add.w	lr, r0, #1
    b372:	mov	ip, fp
    b374:	b.n	b308 <_vfiprintf_r+0x8c0>
    b376:	ldr	r3, [sp, #60]	; 0x3c
    b378:	cbz	r3, b384 <_vfiprintf_r+0x93c>
    b37a:	ldr	r0, [sp, #20]
    b37c:	ldr	r1, [sp, #0]
    b37e:	add	r2, sp, #52	; 0x34
    b380:	bl	a9d0 <__sprint_r.part.0>
    b384:	ldr	r3, [sp, #0]
    b386:	ldrh	r3, [r3, #12]
    b388:	lsls	r2, r3, #25
    b38a:	bmi.w	b6a4 <_vfiprintf_r+0xc5c>
    b38e:	ldr	r0, [sp, #8]
    b390:	add	sp, #172	; 0xac
    b392:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b396:	add	r2, sp, #52	; 0x34
    b398:	ldr	r1, [sp, #0]
    b39a:	mov	r0, r9
    b39c:	bl	a9d0 <__sprint_r.part.0>
    b3a0:	cmp	r0, #0
    b3a2:	bne.n	b384 <_vfiprintf_r+0x93c>
    b3a4:	ldr	r1, [sp, #56]	; 0x38
    b3a6:	ldr	r2, [sp, #60]	; 0x3c
    b3a8:	adds	r0, r1, #1
    b3aa:	mov	sl, fp
    b3ac:	b.n	ae5a <_vfiprintf_r+0x412>
    b3ae:	cmp	r2, #0
    b3b0:	bne.w	b5aa <_vfiprintf_r+0xb62>
    b3b4:	ldr	r2, [sp, #12]
    b3b6:	str	r2, [sp, #108]	; 0x6c
    b3b8:	movs	r3, #1
    b3ba:	str	r2, [sp, #60]	; 0x3c
    b3bc:	str	r7, [sp, #104]	; 0x68
    b3be:	str	r3, [sp, #56]	; 0x38
    b3c0:	mov	sl, fp
    b3c2:	add.w	sl, sl, #8
    b3c6:	lsls	r1, r6, #29
    b3c8:	bpl.n	b3d4 <_vfiprintf_r+0x98c>
    b3ca:	ldr	r3, [sp, #24]
    b3cc:	subs	r4, r3, r5
    b3ce:	cmp	r4, #0
    b3d0:	bgt.w	ae3c <_vfiprintf_r+0x3f4>
    b3d4:	ldr	r3, [sp, #8]
    b3d6:	ldr	r1, [sp, #24]
    b3d8:	cmp	r1, r5
    b3da:	ite	ge
    b3dc:	addge	r3, r3, r1
    b3de:	addlt	r3, r3, r5
    b3e0:	str	r3, [sp, #8]
    b3e2:	cmp	r2, #0
    b3e4:	bne.w	b54e <_vfiprintf_r+0xb06>
    b3e8:	movs	r3, #0
    b3ea:	str	r3, [sp, #56]	; 0x38
    b3ec:	mov	sl, fp
    b3ee:	b.w	aaaa <_vfiprintf_r+0x62>
    b3f2:	add	r2, sp, #52	; 0x34
    b3f4:	ldr	r1, [sp, #0]
    b3f6:	str	r3, [sp, #28]
    b3f8:	mov	r0, r9
    b3fa:	bl	a9d0 <__sprint_r.part.0>
    b3fe:	cmp	r0, #0
    b400:	bne.n	b384 <_vfiprintf_r+0x93c>
    b402:	ldr	r0, [sp, #56]	; 0x38
    b404:	ldr	r2, [sp, #60]	; 0x3c
    b406:	ldr	r3, [sp, #28]
    b408:	add.w	ip, r0, #1
    b40c:	mov	lr, fp
    b40e:	b.n	ada8 <_vfiprintf_r+0x360>
    b410:	.word	0x20000fe0
    b414:	.word	0x20000ff4
    b418:	.word	0x20001020
    b41c:	cmp	r2, #0
    b41e:	bne.w	b688 <_vfiprintf_r+0xc40>
    b422:	ldrb.w	r3, [sp, #47]	; 0x2f
    b426:	cmp	r3, #0
    b428:	beq.w	b616 <_vfiprintf_r+0xbce>
    b42c:	movs	r3, #1
    b42e:	add.w	r1, sp, #47	; 0x2f
    b432:	mov	r2, r3
    b434:	str	r3, [sp, #108]	; 0x6c
    b436:	mov	lr, r3
    b438:	str	r1, [sp, #104]	; 0x68
    b43a:	mov	sl, fp
    b43c:	mov	r0, lr
    b43e:	add.w	sl, sl, #8
    b442:	add.w	lr, lr, #1
    b446:	b.n	ad44 <_vfiprintf_r+0x2fc>
    b448:	add	r1, sp, #48	; 0x30
    b44a:	movs	r2, #2
    b44c:	mov	lr, r3
    b44e:	str	r1, [sp, #104]	; 0x68
    b450:	str	r2, [sp, #108]	; 0x6c
    b452:	mov	sl, fp
    b454:	mov	r0, lr
    b456:	add.w	sl, sl, #8
    b45a:	add.w	lr, lr, #1
    b45e:	b.n	b2d2 <_vfiprintf_r+0x88a>
    b460:	ldr	r3, [sp, #4]
    b462:	strb.w	r9, [sp, #47]	; 0x2f
    b466:	cmp	r3, #0
    b468:	blt.w	b6c0 <_vfiprintf_r+0xc78>
    b46c:	orrs.w	r3, r4, r5
    b470:	bic.w	r6, r6, #128	; 0x80
    b474:	beq.w	ac76 <_vfiprintf_r+0x22e>
    b478:	mov	r7, fp
    b47a:	lsrs	r3, r4, #4
    b47c:	and.w	r1, r4, #15
    b480:	orr.w	r3, r3, r5, lsl #28
    b484:	lsrs	r2, r5, #4
    b486:	mov	r4, r3
    b488:	mov	r5, r2
    b48a:	ldrb	r3, [r0, r1]
    b48c:	strb.w	r3, [r7, #-1]!
    b490:	orrs.w	r3, r4, r5
    b494:	bne.n	b47a <_vfiprintf_r+0xa32>
    b496:	rsb	r3, r7, fp
    b49a:	str	r3, [sp, #12]
    b49c:	b.w	ac88 <_vfiprintf_r+0x240>
    b4a0:	add	r2, sp, #52	; 0x34
    b4a2:	ldr	r1, [sp, #0]
    b4a4:	ldr	r0, [sp, #20]
    b4a6:	bl	a9d0 <__sprint_r.part.0>
    b4aa:	cmp	r0, #0
    b4ac:	bne.w	b384 <_vfiprintf_r+0x93c>
    b4b0:	ldr	r2, [sp, #60]	; 0x3c
    b4b2:	mov	sl, fp
    b4b4:	b.n	b3c6 <_vfiprintf_r+0x97e>
    b4b6:	mov.w	r9, #0
    b4ba:	movs	r4, #0
    b4bc:	movs	r5, #0
    b4be:	b.n	b478 <_vfiprintf_r+0xa30>
    b4c0:	ands.w	r2, r6, #16
    b4c4:	beq.w	b62c <_vfiprintf_r+0xbe4>
    b4c8:	ldr	r1, [sp, #16]
    b4ca:	strb.w	r3, [sp, #47]	; 0x2f
    b4ce:	mov	r2, r1
    b4d0:	ldr	r4, [r1, #0]
    b4d2:	ldr	r1, [sp, #4]
    b4d4:	cmp	r1, #0
    b4d6:	add.w	r2, r2, #4
    b4da:	mov.w	r5, #0
    b4de:	blt.w	b794 <_vfiprintf_r+0xd4c>
    b4e2:	orrs.w	r1, r4, r5
    b4e6:	bic.w	r6, r6, #128	; 0x80
    b4ea:	str	r2, [sp, #16]
    b4ec:	beq.w	af92 <_vfiprintf_r+0x54a>
    b4f0:	mov	r9, r3
    b4f2:	b.n	afa2 <_vfiprintf_r+0x55a>
    b4f4:	lsls	r7, r6, #27
    b4f6:	bmi.n	b50e <_vfiprintf_r+0xac6>
    b4f8:	lsls	r5, r6, #25
    b4fa:	bpl.n	b50e <_vfiprintf_r+0xac6>
    b4fc:	ldr	r1, [sp, #16]
    b4fe:	ldrsh.w	r4, [r1]
    b502:	adds	r1, #4
    b504:	asrs	r5, r4, #31
    b506:	mov	r2, r4
    b508:	mov	r3, r5
    b50a:	str	r1, [sp, #16]
    b50c:	b.n	aee4 <_vfiprintf_r+0x49c>
    b50e:	ldr	r2, [sp, #16]
    b510:	ldr	r4, [r2, #0]
    b512:	mov	r3, r2
    b514:	adds	r3, #4
    b516:	asrs	r5, r4, #31
    b518:	str	r3, [sp, #16]
    b51a:	mov	r2, r4
    b51c:	mov	r3, r5
    b51e:	b.n	aee4 <_vfiprintf_r+0x49c>
    b520:	ldr	r4, [r2, #0]
    b522:	adds	r2, #4
    b524:	str	r2, [sp, #16]
    b526:	movs	r5, #0
    b528:	b.n	b16a <_vfiprintf_r+0x722>
    b52a:	mov.w	r9, #0
    b52e:	orrs.w	r3, r4, r5
    b532:	bne.w	af06 <_vfiprintf_r+0x4be>
    b536:	b.n	b0ea <_vfiprintf_r+0x6a2>
    b538:	add	r2, sp, #52	; 0x34
    b53a:	ldr	r1, [sp, #0]
    b53c:	ldr	r0, [sp, #20]
    b53e:	bl	a9d0 <__sprint_r.part.0>
    b542:	cmp	r0, #0
    b544:	bne.w	b384 <_vfiprintf_r+0x93c>
    b548:	mov	sl, fp
    b54a:	b.w	abde <_vfiprintf_r+0x196>
    b54e:	add	r2, sp, #52	; 0x34
    b550:	ldr	r1, [sp, #0]
    b552:	ldr	r0, [sp, #20]
    b554:	bl	a9d0 <__sprint_r.part.0>
    b558:	cmp	r0, #0
    b55a:	beq.w	b3e8 <_vfiprintf_r+0x9a0>
    b55e:	b.n	b384 <_vfiprintf_r+0x93c>
    b560:	add	r2, sp, #52	; 0x34
    b562:	ldr	r1, [sp, #0]
    b564:	ldr	r0, [sp, #20]
    b566:	bl	a9d0 <__sprint_r.part.0>
    b56a:	cmp	r0, #0
    b56c:	bne.w	b384 <_vfiprintf_r+0x93c>
    b570:	ldr	r0, [sp, #56]	; 0x38
    b572:	ldr	r2, [sp, #60]	; 0x3c
    b574:	add.w	lr, r0, #1
    b578:	mov	sl, fp
    b57a:	b.w	ad44 <_vfiprintf_r+0x2fc>
    b57e:	add	r2, sp, #52	; 0x34
    b580:	ldr	r1, [sp, #0]
    b582:	ldr	r0, [sp, #20]
    b584:	bl	a9d0 <__sprint_r.part.0>
    b588:	cmp	r0, #0
    b58a:	bne.w	b384 <_vfiprintf_r+0x93c>
    b58e:	ldr	r0, [sp, #56]	; 0x38
    b590:	ldr	r2, [sp, #60]	; 0x3c
    b592:	add.w	lr, r0, #1
    b596:	mov	sl, fp
    b598:	b.n	b2d2 <_vfiprintf_r+0x88a>
    b59a:	cmp	r2, #0
    b59c:	bne.w	b750 <_vfiprintf_r+0xd08>
    b5a0:	mov.w	lr, #1
    b5a4:	mov	r0, r2
    b5a6:	mov	sl, fp
    b5a8:	b.n	b2da <_vfiprintf_r+0x892>
    b5aa:	add	r2, sp, #52	; 0x34
    b5ac:	ldr	r1, [sp, #0]
    b5ae:	ldr	r0, [sp, #20]
    b5b0:	bl	a9d0 <__sprint_r.part.0>
    b5b4:	cmp	r0, #0
    b5b6:	bne.w	b384 <_vfiprintf_r+0x93c>
    b5ba:	ldr	r3, [sp, #56]	; 0x38
    b5bc:	ldr	r2, [sp, #60]	; 0x3c
    b5be:	add.w	lr, r3, #1
    b5c2:	mov	sl, fp
    b5c4:	b.n	ae0c <_vfiprintf_r+0x3c4>
    b5c6:	movs	r2, #48	; 0x30
    b5c8:	strb.w	r2, [sp, #48]	; 0x30
    b5cc:	ldr	r2, [sp, #4]
    b5ce:	strb.w	r3, [sp, #49]	; 0x31
    b5d2:	cmp	r2, #0
    b5d4:	mov.w	r3, #0
    b5d8:	strb.w	r3, [sp, #47]	; 0x2f
    b5dc:	orr.w	r3, r6, #2
    b5e0:	blt.w	b77a <_vfiprintf_r+0xd32>
    b5e4:	bic.w	r6, r6, #128	; 0x80
    b5e8:	orr.w	r6, r6, #2
    b5ec:	mov.w	r9, #0
    b5f0:	b.n	b478 <_vfiprintf_r+0xa30>
    b5f2:	mov.w	r9, #0
    b5f6:	ldr	r0, [pc, #576]	; (b838 <_vfiprintf_r+0xdf0>)
    b5f8:	b.n	b478 <_vfiprintf_r+0xa30>
    b5fa:	ldr	r3, [sp, #4]
    b5fc:	negs	r4, r4
    b5fe:	mov.w	r9, #45	; 0x2d
    b602:	sbc.w	r5, r5, r5, lsl #1
    b606:	cmp	r3, #0
    b608:	strb.w	r9, [sp, #47]	; 0x2f
    b60c:	blt.w	af06 <_vfiprintf_r+0x4be>
    b610:	bic.w	r6, r6, #128	; 0x80
    b614:	b.n	af06 <_vfiprintf_r+0x4be>
    b616:	ldr	r3, [sp, #28]
    b618:	cmp	r3, #0
    b61a:	beq.n	b702 <_vfiprintf_r+0xcba>
    b61c:	add	r3, sp, #48	; 0x30
    b61e:	movs	r2, #2
    b620:	str	r3, [sp, #104]	; 0x68
    b622:	str	r2, [sp, #108]	; 0x6c
    b624:	mov.w	lr, #1
    b628:	mov	sl, fp
    b62a:	b.n	b454 <_vfiprintf_r+0xa0c>
    b62c:	ands.w	r9, r6, #64	; 0x40
    b630:	beq.n	b6c4 <_vfiprintf_r+0xc7c>
    b632:	ldr	r1, [sp, #16]
    b634:	strb.w	r2, [sp, #47]	; 0x2f
    b638:	mov	r3, r1
    b63a:	ldrh	r4, [r1, #0]
    b63c:	ldr	r1, [sp, #4]
    b63e:	cmp	r1, #0
    b640:	add.w	r3, r3, #4
    b644:	mov.w	r5, #0
    b648:	blt.w	b26c <_vfiprintf_r+0x824>
    b64c:	orrs.w	r1, r4, r5
    b650:	bic.w	r6, r6, #128	; 0x80
    b654:	str	r3, [sp, #16]
    b656:	beq.w	af92 <_vfiprintf_r+0x54a>
    b65a:	mov	r9, r2
    b65c:	b.n	afa2 <_vfiprintf_r+0x55a>
    b65e:	lsls	r0, r6, #27
    b660:	bmi.n	b678 <_vfiprintf_r+0xc30>
    b662:	lsls	r1, r6, #25
    b664:	bpl.n	b678 <_vfiprintf_r+0xc30>
    b666:	ldr	r2, [sp, #16]
    b668:	ldr	r3, [r2, #0]
    b66a:	adds	r2, #4
    b66c:	str	r2, [sp, #16]
    b66e:	ldrh.w	r2, [sp, #8]
    b672:	strh	r2, [r3, #0]
    b674:	b.w	aaaa <_vfiprintf_r+0x62>
    b678:	ldr	r2, [sp, #16]
    b67a:	ldr	r3, [r2, #0]
    b67c:	adds	r2, #4
    b67e:	str	r2, [sp, #16]
    b680:	ldr	r2, [sp, #8]
    b682:	str	r2, [r3, #0]
    b684:	b.w	aaaa <_vfiprintf_r+0x62>
    b688:	add	r2, sp, #52	; 0x34
    b68a:	ldr	r1, [sp, #0]
    b68c:	ldr	r0, [sp, #20]
    b68e:	bl	a9d0 <__sprint_r.part.0>
    b692:	cmp	r0, #0
    b694:	bne.w	b384 <_vfiprintf_r+0x93c>
    b698:	ldr	r0, [sp, #56]	; 0x38
    b69a:	ldr	r2, [sp, #60]	; 0x3c
    b69c:	add.w	lr, r0, #1
    b6a0:	mov	sl, fp
    b6a2:	b.n	b29a <_vfiprintf_r+0x852>
    b6a4:	mov.w	r0, #4294967295
    b6a8:	b.w	ac18 <_vfiprintf_r+0x1d0>
    b6ac:	ldr	r0, [pc, #392]	; (b838 <_vfiprintf_r+0xdf0>)
    b6ae:	mov	r6, r2
    b6b0:	orrs.w	r2, r4, r5
    b6b4:	str	r3, [sp, #16]
    b6b6:	mov.w	r9, #0
    b6ba:	bne.w	b478 <_vfiprintf_r+0xa30>
    b6be:	b.n	b4ba <_vfiprintf_r+0xa72>
    b6c0:	ldr	r3, [sp, #16]
    b6c2:	b.n	b6b0 <_vfiprintf_r+0xc68>
    b6c4:	ldr	r2, [sp, #16]
    b6c6:	strb.w	r9, [sp, #47]	; 0x2f
    b6ca:	mov	r3, r2
    b6cc:	ldr	r4, [r2, #0]
    b6ce:	ldr	r2, [sp, #4]
    b6d0:	cmp	r2, #0
    b6d2:	add.w	r3, r3, #4
    b6d6:	mov.w	r5, #0
    b6da:	blt.w	b26c <_vfiprintf_r+0x824>
    b6de:	orrs.w	r2, r4, r5
    b6e2:	bic.w	r6, r6, #128	; 0x80
    b6e6:	str	r3, [sp, #16]
    b6e8:	bne.w	afa2 <_vfiprintf_r+0x55a>
    b6ec:	b.n	af92 <_vfiprintf_r+0x54a>
    b6ee:	add	r2, sp, #52	; 0x34
    b6f0:	ldr	r1, [sp, #0]
    b6f2:	ldr	r0, [sp, #20]
    b6f4:	bl	a9d0 <__sprint_r.part.0>
    b6f8:	cmp	r0, #0
    b6fa:	bne.w	b384 <_vfiprintf_r+0x93c>
    b6fe:	ldr	r2, [sp, #60]	; 0x3c
    b700:	b.n	b3d4 <_vfiprintf_r+0x98c>
    b702:	mov	r0, r2
    b704:	mov.w	lr, #1
    b708:	mov	sl, fp
    b70a:	b.n	b2da <_vfiprintf_r+0x892>
    b70c:	ldr	r1, [sp, #16]
    b70e:	strb.w	r3, [sp, #47]	; 0x2f
    b712:	mov	r2, r1
    b714:	ldrh	r4, [r1, #0]
    b716:	ldr	r1, [sp, #4]
    b718:	cmp	r1, #0
    b71a:	add.w	r2, r2, #4
    b71e:	mov.w	r5, #0
    b722:	blt.n	b7c2 <_vfiprintf_r+0xd7a>
    b724:	orrs.w	r1, r4, r5
    b728:	bic.w	r6, r6, #128	; 0x80
    b72c:	str	r2, [sp, #16]
    b72e:	mov	r9, r3
    b730:	bne.w	af06 <_vfiprintf_r+0x4be>
    b734:	b.n	b0e0 <_vfiprintf_r+0x698>
    b736:	str	r3, [sp, #16]
    b738:	b.n	b52e <_vfiprintf_r+0xae6>
    b73a:	mov	r0, r7
    b73c:	str	r4, [sp, #16]
    b73e:	bl	9380 <strlen>
    b742:	movs	r3, #0
    b744:	str	r0, [sp, #12]
    b746:	ldrb.w	r9, [sp, #47]	; 0x2f
    b74a:	str	r3, [sp, #4]
    b74c:	b.w	ac88 <_vfiprintf_r+0x240>
    b750:	add	r2, sp, #52	; 0x34
    b752:	ldr	r1, [sp, #0]
    b754:	ldr	r0, [sp, #20]
    b756:	bl	a9d0 <__sprint_r.part.0>
    b75a:	cmp	r0, #0
    b75c:	bne.w	b384 <_vfiprintf_r+0x93c>
    b760:	ldr	r0, [sp, #56]	; 0x38
    b762:	ldr	r2, [sp, #60]	; 0x3c
    b764:	add.w	lr, r0, #1
    b768:	mov	sl, fp
    b76a:	b.n	b2da <_vfiprintf_r+0x892>
    b76c:	ldr	r0, [sp, #56]	; 0x38
    b76e:	ldr	r2, [sp, #60]	; 0x3c
    b770:	ldr.w	r9, [pc, #204]	; b840 <_vfiprintf_r+0xdf8>
    b774:	adds	r0, #1
    b776:	b.w	ad1e <_vfiprintf_r+0x2d6>
    b77a:	mov	r6, r3
    b77c:	mov.w	r9, #0
    b780:	b.n	b478 <_vfiprintf_r+0xa30>
    b782:	cmp	r3, #6
    b784:	it	cs
    b786:	movcs	r3, #6
    b788:	str	r3, [sp, #12]
    b78a:	str	r4, [sp, #16]
    b78c:	bic.w	r5, r3, r3, asr #31
    b790:	ldr	r7, [pc, #168]	; (b83c <_vfiprintf_r+0xdf4>)
    b792:	b.n	b1ae <_vfiprintf_r+0x766>
    b794:	str	r2, [sp, #16]
    b796:	b.n	b26e <_vfiprintf_r+0x826>
    b798:	ldr	r0, [sp, #56]	; 0x38
    b79a:	ldr.w	r9, [pc, #164]	; b840 <_vfiprintf_r+0xdf8>
    b79e:	adds	r0, #1
    b7a0:	b.w	ae8a <_vfiprintf_r+0x442>
    b7a4:	mov	ip, lr
    b7a6:	b.w	adde <_vfiprintf_r+0x396>
    b7aa:	ldr	r3, [sp, #4]
    b7ac:	ldrb.w	r9, [sp, #47]	; 0x2f
    b7b0:	str	r3, [sp, #12]
    b7b2:	str	r4, [sp, #16]
    b7b4:	str	r0, [sp, #4]
    b7b6:	b.w	ac88 <_vfiprintf_r+0x240>
    b7ba:	movs	r2, #0
    b7bc:	str	r2, [sp, #4]
    b7be:	b.w	ab1a <_vfiprintf_r+0xd2>
    b7c2:	str	r2, [sp, #16]
    b7c4:	mov	r9, r3
    b7c6:	b.n	b52e <_vfiprintf_r+0xae6>
    b7c8:	ldr	r2, [sp, #16]
    b7ca:	ldr	r3, [r2, #0]
    b7cc:	str	r3, [sp, #4]
    b7ce:	adds	r2, #4
    b7d0:	cmp	r3, #0
    b7d2:	str	r2, [sp, #16]
    b7d4:	ldrb.w	r3, [r8, #1]
    b7d8:	mov	r8, r5
    b7da:	bge.w	ab16 <_vfiprintf_r+0xce>
    b7de:	mov.w	r2, #4294967295
    b7e2:	str	r2, [sp, #4]
    b7e4:	b.w	ab16 <_vfiprintf_r+0xce>
    b7e8:	strb.w	r0, [sp, #47]	; 0x2f
    b7ec:	b.n	b10c <_vfiprintf_r+0x6c4>
    b7ee:	strb.w	r0, [sp, #47]	; 0x2f
    b7f2:	b.n	b1d6 <_vfiprintf_r+0x78e>
    b7f4:	strb.w	r0, [sp, #47]	; 0x2f
    b7f8:	b.n	b152 <_vfiprintf_r+0x70a>
    b7fa:	mov	r9, r3
    b7fc:	lsls	r3, r6, #31
    b7fe:	bpl.n	b80c <_vfiprintf_r+0xdc4>
    b800:	add	r7, sp, #168	; 0xa8
    b802:	movs	r3, #48	; 0x30
    b804:	strb.w	r3, [r7, #-65]!
    b808:	b.w	af3a <_vfiprintf_r+0x4f2>
    b80c:	ldr	r3, [sp, #4]
    b80e:	str	r3, [sp, #12]
    b810:	mov	r7, fp
    b812:	b.w	ac88 <_vfiprintf_r+0x240>
    b816:	strb.w	r0, [sp, #47]	; 0x2f
    b81a:	b.n	b0a4 <_vfiprintf_r+0x65c>
    b81c:	strb.w	r0, [sp, #47]	; 0x2f
    b820:	b.w	af58 <_vfiprintf_r+0x510>
    b824:	strb.w	r0, [sp, #47]	; 0x2f
    b828:	b.w	aec6 <_vfiprintf_r+0x47e>
    b82c:	strb.w	r0, [sp, #47]	; 0x2f
    b830:	b.n	b252 <_vfiprintf_r+0x80a>
    b832:	strb.w	r0, [sp, #47]	; 0x2f
    b836:	b.n	b220 <_vfiprintf_r+0x7d8>
    b838:	.word	0x20000ff4
    b83c:	.word	0x20001008
    b840:	.word	0x20001030

0000b844 <__sbprintf>:
    b844:	push	{r4, r5, r6, r7, lr}
    b846:	mov	r4, r1
    b848:	subw	sp, sp, #1132	; 0x46c
    b84c:	ldrh	r1, [r1, #12]
    b84e:	ldr	r6, [r4, #100]	; 0x64
    b850:	ldrh	r5, [r4, #14]
    b852:	str	r6, [sp, #100]	; 0x64
    b854:	bic.w	r1, r1, #2
    b858:	ldr	r6, [r4, #36]	; 0x24
    b85a:	strh.w	r5, [sp, #14]
    b85e:	movs	r5, #0
    b860:	ldr	r7, [r4, #28]
    b862:	strh.w	r1, [sp, #12]
    b866:	str	r6, [sp, #36]	; 0x24
    b868:	str	r5, [sp, #24]
    b86a:	add	r6, sp, #104	; 0x68
    b86c:	mov.w	r5, #1024	; 0x400
    b870:	mov	r1, sp
    b872:	str	r6, [sp, #0]
    b874:	str	r6, [sp, #16]
    b876:	str	r5, [sp, #8]
    b878:	str	r5, [sp, #20]
    b87a:	str	r7, [sp, #28]
    b87c:	mov	r6, r0
    b87e:	bl	aa48 <_vfiprintf_r>
    b882:	subs	r5, r0, #0
    b884:	blt.n	b896 <__sbprintf+0x52>
    b886:	mov	r0, r6
    b888:	mov	r1, sp
    b88a:	bl	c8b4 <_fflush_r>
    b88e:	cmp	r0, #0
    b890:	it	ne
    b892:	movne.w	r5, #4294967295
    b896:	ldrh.w	r3, [sp, #12]
    b89a:	lsls	r3, r3, #25
    b89c:	bpl.n	b8a6 <__sbprintf+0x62>
    b89e:	ldrh	r3, [r4, #12]
    b8a0:	orr.w	r3, r3, #64	; 0x40
    b8a4:	strh	r3, [r4, #12]
    b8a6:	mov	r0, r5
    b8a8:	addw	sp, sp, #1132	; 0x46c
    b8ac:	pop	{r4, r5, r6, r7, pc}
    b8ae:	nop

0000b8b0 <__ascii_wctomb>:
    b8b0:	cbz	r1, b8bc <__ascii_wctomb+0xc>
    b8b2:	cmp	r2, #255	; 0xff
    b8b4:	bhi.n	b8c0 <__ascii_wctomb+0x10>
    b8b6:	strb	r2, [r1, #0]
    b8b8:	movs	r0, #1
    b8ba:	bx	lr
    b8bc:	mov	r0, r1
    b8be:	bx	lr
    b8c0:	movs	r3, #138	; 0x8a
    b8c2:	str	r3, [r0, #0]
    b8c4:	mov.w	r0, #4294967295
    b8c8:	bx	lr
    b8ca:	nop

0000b8cc <_write_r>:
    b8cc:	push	{r4, r5, r6, lr}
    b8ce:	mov	r5, r1
    b8d0:	ldr	r4, [pc, #32]	; (b8f4 <_write_r+0x28>)
    b8d2:	mov	r1, r2
    b8d4:	mov	r6, r0
    b8d6:	mov	r2, r3
    b8d8:	mov	r0, r5
    b8da:	movs	r3, #0
    b8dc:	str	r3, [r4, #0]
    b8de:	bl	4e94 <_write>
    b8e2:	adds	r3, r0, #1
    b8e4:	beq.n	b8e8 <_write_r+0x1c>
    b8e6:	pop	{r4, r5, r6, pc}
    b8e8:	ldr	r3, [r4, #0]
    b8ea:	cmp	r3, #0
    b8ec:	beq.n	b8e6 <_write_r+0x1a>
    b8ee:	str	r3, [r6, #0]
    b8f0:	pop	{r4, r5, r6, pc}
    b8f2:	nop
    b8f4:	.word	0x20004284

0000b8f8 <__swsetup_r>:
    b8f8:	push	{r3, r4, r5, lr}
    b8fa:	ldr	r3, [pc, #192]	; (b9bc <__swsetup_r+0xc4>)
    b8fc:	ldr	r3, [r3, #0]
    b8fe:	mov	r5, r0
    b900:	mov	r4, r1
    b902:	cbz	r3, b90a <__swsetup_r+0x12>
    b904:	ldr	r2, [r3, #56]	; 0x38
    b906:	cmp	r2, #0
    b908:	beq.n	b97c <__swsetup_r+0x84>
    b90a:	ldrsh.w	r2, [r4, #12]
    b90e:	uxth	r3, r2
    b910:	lsls	r0, r3, #28
    b912:	bpl.n	b92e <__swsetup_r+0x36>
    b914:	ldr	r0, [r4, #16]
    b916:	cbz	r0, b944 <__swsetup_r+0x4c>
    b918:	ands.w	r2, r3, #1
    b91c:	beq.n	b95c <__swsetup_r+0x64>
    b91e:	ldr	r3, [r4, #20]
    b920:	movs	r2, #0
    b922:	negs	r3, r3
    b924:	str	r3, [r4, #24]
    b926:	str	r2, [r4, #8]
    b928:	cbz	r0, b968 <__swsetup_r+0x70>
    b92a:	movs	r0, #0
    b92c:	pop	{r3, r4, r5, pc}
    b92e:	lsls	r1, r3, #27
    b930:	bpl.n	b9ac <__swsetup_r+0xb4>
    b932:	lsls	r0, r3, #29
    b934:	bmi.n	b984 <__swsetup_r+0x8c>
    b936:	ldr	r0, [r4, #16]
    b938:	orr.w	r3, r2, #8
    b93c:	strh	r3, [r4, #12]
    b93e:	uxth	r3, r3
    b940:	cmp	r0, #0
    b942:	bne.n	b918 <__swsetup_r+0x20>
    b944:	and.w	r2, r3, #640	; 0x280
    b948:	cmp.w	r2, #512	; 0x200
    b94c:	beq.n	b918 <__swsetup_r+0x20>
    b94e:	mov	r0, r5
    b950:	mov	r1, r4
    b952:	bl	d0f0 <__smakebuf_r>
    b956:	ldrh	r3, [r4, #12]
    b958:	ldr	r0, [r4, #16]
    b95a:	b.n	b918 <__swsetup_r+0x20>
    b95c:	lsls	r1, r3, #30
    b95e:	it	pl
    b960:	ldrpl	r2, [r4, #20]
    b962:	str	r2, [r4, #8]
    b964:	cmp	r0, #0
    b966:	bne.n	b92a <__swsetup_r+0x32>
    b968:	ldrsh.w	r3, [r4, #12]
    b96c:	lsls	r2, r3, #24
    b96e:	bpl.n	b92c <__swsetup_r+0x34>
    b970:	orr.w	r3, r3, #64	; 0x40
    b974:	strh	r3, [r4, #12]
    b976:	mov.w	r0, #4294967295
    b97a:	pop	{r3, r4, r5, pc}
    b97c:	mov	r0, r3
    b97e:	bl	c9dc <__sinit>
    b982:	b.n	b90a <__swsetup_r+0x12>
    b984:	ldr	r1, [r4, #48]	; 0x30
    b986:	cbz	r1, b99e <__swsetup_r+0xa6>
    b988:	add.w	r3, r4, #64	; 0x40
    b98c:	cmp	r1, r3
    b98e:	beq.n	b99a <__swsetup_r+0xa2>
    b990:	mov	r0, r5
    b992:	bl	cb4c <_free_r>
    b996:	ldrsh.w	r2, [r4, #12]
    b99a:	movs	r3, #0
    b99c:	str	r3, [r4, #48]	; 0x30
    b99e:	movs	r3, #0
    b9a0:	ldr	r0, [r4, #16]
    b9a2:	str	r3, [r4, #4]
    b9a4:	bic.w	r2, r2, #36	; 0x24
    b9a8:	str	r0, [r4, #0]
    b9aa:	b.n	b938 <__swsetup_r+0x40>
    b9ac:	orr.w	r2, r2, #64	; 0x40
    b9b0:	movs	r3, #9
    b9b2:	str	r3, [r5, #0]
    b9b4:	mov.w	r0, #4294967295
    b9b8:	strh	r2, [r4, #12]
    b9ba:	pop	{r3, r4, r5, pc}
    b9bc:	.word	0x200016d0

0000b9c0 <quorem>:
    b9c0:	ldr	r2, [r0, #16]
    b9c2:	ldr	r3, [r1, #16]
    b9c4:	cmp	r3, r2
    b9c6:	bgt.w	bae4 <quorem+0x124>
    b9ca:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b9ce:	add.w	r8, r3, #4294967295
    b9d2:	add.w	r7, r1, #20
    b9d6:	add.w	fp, r0, #20
    b9da:	ldr.w	r2, [r7, r8, lsl #2]
    b9de:	ldr.w	r3, [fp, r8, lsl #2]
    b9e2:	mov.w	r4, r8, lsl #2
    b9e6:	sub	sp, #12
    b9e8:	adds	r2, #1
    b9ea:	udiv	r9, r3, r2
    b9ee:	add.w	r3, fp, r4
    b9f2:	str	r4, [sp, #0]
    b9f4:	add.w	sl, r7, r4
    b9f8:	str	r3, [sp, #4]
    b9fa:	cmp.w	r9, #0
    b9fe:	beq.n	ba74 <quorem+0xb4>
    ba00:	movs	r5, #0
    ba02:	mov	ip, r7
    ba04:	mov	lr, fp
    ba06:	mov	r3, r5
    ba08:	ldr.w	r6, [ip], #4
    ba0c:	ldr.w	r2, [lr]
    ba10:	uxth	r4, r6
    ba12:	mla	r5, r9, r4, r5
    ba16:	lsrs	r6, r6, #16
    ba18:	lsrs	r4, r5, #16
    ba1a:	mla	r4, r9, r6, r4
    ba1e:	uxth	r5, r5
    ba20:	subs	r3, r3, r5
    ba22:	uxth	r6, r4
    ba24:	uxtah	r3, r3, r2
    ba28:	rsb	r6, r6, r2, lsr #16
    ba2c:	add.w	r6, r6, r3, asr #16
    ba30:	uxth	r3, r3
    ba32:	orr.w	r3, r3, r6, lsl #16
    ba36:	cmp	sl, ip
    ba38:	str.w	r3, [lr], #4
    ba3c:	mov.w	r5, r4, lsr #16
    ba40:	mov.w	r3, r6, asr #16
    ba44:	bcs.n	ba08 <quorem+0x48>
    ba46:	ldr	r3, [sp, #0]
    ba48:	ldr.w	r3, [fp, r3]
    ba4c:	cbnz	r3, ba74 <quorem+0xb4>
    ba4e:	ldr	r4, [sp, #4]
    ba50:	subs	r3, r4, #4
    ba52:	cmp	fp, r3
    ba54:	bcs.n	ba70 <quorem+0xb0>
    ba56:	ldr.w	r3, [r4, #-4]
    ba5a:	cbnz	r3, ba70 <quorem+0xb0>
    ba5c:	sub.w	r3, r4, #8
    ba60:	b.n	ba68 <quorem+0xa8>
    ba62:	ldr	r2, [r3, #0]
    ba64:	subs	r3, #4
    ba66:	cbnz	r2, ba70 <quorem+0xb0>
    ba68:	cmp	fp, r3
    ba6a:	add.w	r8, r8, #4294967295
    ba6e:	bcc.n	ba62 <quorem+0xa2>
    ba70:	str.w	r8, [r0, #16]
    ba74:	mov	r4, r0
    ba76:	bl	d630 <__mcmp>
    ba7a:	cmp	r0, #0
    ba7c:	blt.n	badc <quorem+0x11c>
    ba7e:	add.w	r9, r9, #1
    ba82:	mov	r5, fp
    ba84:	movs	r3, #0
    ba86:	ldr.w	r1, [r7], #4
    ba8a:	ldr	r0, [r5, #0]
    ba8c:	uxth	r2, r1
    ba8e:	subs	r2, r3, r2
    ba90:	lsrs	r1, r1, #16
    ba92:	uxtah	r2, r2, r0
    ba96:	rsb	r3, r1, r0, lsr #16
    ba9a:	add.w	r3, r3, r2, asr #16
    ba9e:	uxth	r1, r2
    baa0:	orr.w	r1, r1, r3, lsl #16
    baa4:	cmp	sl, r7
    baa6:	str.w	r1, [r5], #4
    baaa:	mov.w	r3, r3, asr #16
    baae:	bcs.n	ba86 <quorem+0xc6>
    bab0:	ldr.w	r2, [fp, r8, lsl #2]
    bab4:	add.w	r3, fp, r8, lsl #2
    bab8:	cbnz	r2, badc <quorem+0x11c>
    baba:	subs	r2, r3, #4
    babc:	cmp	fp, r2
    babe:	bcs.n	bad8 <quorem+0x118>
    bac0:	ldr.w	r2, [r3, #-4]
    bac4:	cbnz	r2, bad8 <quorem+0x118>
    bac6:	subs	r3, #8
    bac8:	b.n	bad0 <quorem+0x110>
    baca:	ldr	r2, [r3, #0]
    bacc:	subs	r3, #4
    bace:	cbnz	r2, bad8 <quorem+0x118>
    bad0:	cmp	fp, r3
    bad2:	add.w	r8, r8, #4294967295
    bad6:	bcc.n	baca <quorem+0x10a>
    bad8:	str.w	r8, [r4, #16]
    badc:	mov	r0, r9
    bade:	add	sp, #12
    bae0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bae4:	movs	r0, #0
    bae6:	bx	lr

0000bae8 <_dtoa_r>:
    bae8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    baec:	vmov	r6, r7, d0
    baf0:	sub	sp, #76	; 0x4c
    baf2:	ldr	r5, [r0, #64]	; 0x40
    baf4:	str	r1, [sp, #4]
    baf6:	mov	r4, r0
    baf8:	mov	r8, r2
    bafa:	str	r3, [sp, #16]
    bafc:	vmov	sl, s0
    bb00:	mov	fp, r7
    bb02:	cbz	r5, bb18 <_dtoa_r+0x30>
    bb04:	ldr	r2, [r0, #68]	; 0x44
    bb06:	str	r2, [r5, #4]
    bb08:	movs	r3, #1
    bb0a:	lsls	r3, r2
    bb0c:	str	r3, [r5, #8]
    bb0e:	mov	r1, r5
    bb10:	bl	d26c <_Bfree>
    bb14:	movs	r3, #0
    bb16:	str	r3, [r4, #64]	; 0x40
    bb18:	cmp.w	fp, #0
    bb1c:	mov	r6, fp
    bb1e:	blt.n	bb8a <_dtoa_r+0xa2>
    bb20:	ldr	r2, [sp, #112]	; 0x70
    bb22:	movs	r3, #0
    bb24:	str	r3, [r2, #0]
    bb26:	ldr	r3, [pc, #784]	; (be38 <_dtoa_r+0x350>)
    bb28:	mov	r2, r3
    bb2a:	ands	r3, r6
    bb2c:	cmp	r3, r2
    bb2e:	beq.n	bb5c <_dtoa_r+0x74>
    bb30:	vmov	d7, sl, fp
    bb34:	vcmp.f64	d7, #0.0
    bb38:	vmrs	APSR_nzcv, fpscr
    bb3c:	strd	sl, fp, [sp, #8]
    bb40:	bne.n	bb98 <_dtoa_r+0xb0>
    bb42:	ldr	r2, [sp, #16]
    bb44:	movs	r3, #1
    bb46:	str	r3, [r2, #0]
    bb48:	ldr	r3, [sp, #116]	; 0x74
    bb4a:	cmp	r3, #0
    bb4c:	beq.w	bcbe <_dtoa_r+0x1d6>
    bb50:	ldr	r0, [pc, #744]	; (be3c <_dtoa_r+0x354>)
    bb52:	str	r0, [r3, #0]
    bb54:	subs	r0, #1
    bb56:	add	sp, #76	; 0x4c
    bb58:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb5c:	ldr	r2, [sp, #16]
    bb5e:	movw	r3, #9999	; 0x270f
    bb62:	str	r3, [r2, #0]
    bb64:	cmp.w	sl, #0
    bb68:	beq.w	bc90 <_dtoa_r+0x1a8>
    bb6c:	ldr	r0, [pc, #720]	; (be40 <_dtoa_r+0x358>)
    bb6e:	ldr	r3, [sp, #116]	; 0x74
    bb70:	cmp	r3, #0
    bb72:	beq.n	bb56 <_dtoa_r+0x6e>
    bb74:	ldrb	r3, [r0, #3]
    bb76:	cmp	r3, #0
    bb78:	beq.w	bcc2 <_dtoa_r+0x1da>
    bb7c:	add.w	r3, r0, #8
    bb80:	ldr	r2, [sp, #116]	; 0x74
    bb82:	str	r3, [r2, #0]
    bb84:	add	sp, #76	; 0x4c
    bb86:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb8a:	ldr	r2, [sp, #112]	; 0x70
    bb8c:	movs	r3, #1
    bb8e:	bic.w	r6, fp, #2147483648	; 0x80000000
    bb92:	str	r3, [r2, #0]
    bb94:	mov	fp, r6
    bb96:	b.n	bb26 <_dtoa_r+0x3e>
    bb98:	add	r1, sp, #68	; 0x44
    bb9a:	add	r2, sp, #64	; 0x40
    bb9c:	vldr	d0, [sp, #8]
    bba0:	mov	r0, r4
    bba2:	bl	d788 <__d2b>
    bba6:	lsrs	r1, r6, #20
    bba8:	str	r0, [sp, #28]
    bbaa:	bne.n	bca2 <_dtoa_r+0x1ba>
    bbac:	ldr	r0, [sp, #64]	; 0x40
    bbae:	ldr	r1, [sp, #68]	; 0x44
    bbb0:	add	r1, r0
    bbb2:	addw	r3, r1, #1074	; 0x432
    bbb6:	cmp	r3, #32
    bbb8:	ble.w	c03e <_dtoa_r+0x556>
    bbbc:	rsb	r3, r3, #64	; 0x40
    bbc0:	addw	r2, r1, #1042	; 0x412
    bbc4:	lsls	r6, r3
    bbc6:	lsr.w	r3, sl, r2
    bbca:	orrs	r3, r6
    bbcc:	vmov	s15, r3
    bbd0:	vcvt.f64.u32	d7, s15
    bbd4:	movs	r5, #1
    bbd6:	vmov	r2, r3, d7
    bbda:	subs	r1, #1
    bbdc:	sub.w	r3, r3, #32505856	; 0x1f00000
    bbe0:	str	r5, [sp, #40]	; 0x28
    bbe2:	vmov	d7, r2, r3
    bbe6:	vmov.f64	d6, #120	; 0x3fc00000  1.5
    bbea:	vldr	d4, [pc, #564]	; be20 <_dtoa_r+0x338>
    bbee:	vsub.f64	d6, d7, d6
    bbf2:	vldr	d7, [pc, #564]	; be28 <_dtoa_r+0x340>
    bbf6:	vldr	d5, [pc, #568]	; be30 <_dtoa_r+0x348>
    bbfa:	vfma.f64	d7, d6, d4
    bbfe:	vmov	s13, r1
    bc02:	vcvt.f64.s32	d6, s13
    bc06:	vfma.f64	d7, d6, d5
    bc0a:	vcvt.s32.f64	s13, d7
    bc0e:	vcmpe.f64	d7, #0.0
    bc12:	vmrs	APSR_nzcv, fpscr
    bc16:	vstr	s13, [sp, #8]
    bc1a:	bmi.w	be56 <_dtoa_r+0x36e>
    bc1e:	ldr	r5, [sp, #8]
    bc20:	cmp	r5, #22
    bc22:	bhi.w	be50 <_dtoa_r+0x368>
    bc26:	ldr	r3, [pc, #540]	; (be44 <_dtoa_r+0x35c>)
    bc28:	add.w	r3, r3, r5, lsl #3
    bc2c:	vldr	d7, [r3]
    bc30:	vmov	d6, sl, fp
    bc34:	vcmpe.f64	d7, d6
    bc38:	vmrs	APSR_nzcv, fpscr
    bc3c:	ble.w	c04c <_dtoa_r+0x564>
    bc40:	subs	r3, r5, #1
    bc42:	str	r3, [sp, #8]
    bc44:	movs	r3, #0
    bc46:	str	r3, [sp, #48]	; 0x30
    bc48:	subs	r1, r0, r1
    bc4a:	subs.w	r9, r1, #1
    bc4e:	bmi.w	be80 <_dtoa_r+0x398>
    bc52:	movs	r3, #0
    bc54:	str	r3, [sp, #24]
    bc56:	ldr	r3, [sp, #8]
    bc58:	cmp	r3, #0
    bc5a:	blt.w	be6e <_dtoa_r+0x386>
    bc5e:	add	r9, r3
    bc60:	str	r3, [sp, #44]	; 0x2c
    bc62:	movs	r3, #0
    bc64:	str	r3, [sp, #20]
    bc66:	ldr	r3, [sp, #4]
    bc68:	cmp	r3, #9
    bc6a:	bhi.n	bcc6 <_dtoa_r+0x1de>
    bc6c:	cmp	r3, #5
    bc6e:	ble.w	c730 <_dtoa_r+0xc48>
    bc72:	subs	r3, #4
    bc74:	str	r3, [sp, #4]
    bc76:	movs	r3, #0
    bc78:	str	r3, [sp, #56]	; 0x38
    bc7a:	ldr	r3, [sp, #4]
    bc7c:	subs	r3, #2
    bc7e:	cmp	r3, #3
    bc80:	bhi.w	c742 <_dtoa_r+0xc5a>
    bc84:	tbh	[pc, r3, lsl #1]
    bc88:	.word	0x01e502a9
    bc8c:	.word	0x03c802b5
    bc90:	ldr	r3, [pc, #428]	; (be40 <_dtoa_r+0x358>)
    bc92:	ldr	r2, [pc, #436]	; (be48 <_dtoa_r+0x360>)
    bc94:	ubfx	r0, r6, #0, #20
    bc98:	cmp	r0, #0
    bc9a:	ite	ne
    bc9c:	movne	r0, r3
    bc9e:	moveq	r0, r2
    bca0:	b.n	bb6e <_dtoa_r+0x86>
    bca2:	ldrd	r2, r3, [sp, #8]
    bca6:	ubfx	r0, r3, #0, #20
    bcaa:	orr.w	r3, r0, #1069547520	; 0x3fc00000
    bcae:	movs	r5, #0
    bcb0:	subw	r1, r1, #1023	; 0x3ff
    bcb4:	orr.w	r3, r3, #3145728	; 0x300000
    bcb8:	ldr	r0, [sp, #64]	; 0x40
    bcba:	str	r5, [sp, #40]	; 0x28
    bcbc:	b.n	bbe2 <_dtoa_r+0xfa>
    bcbe:	ldr	r0, [pc, #396]	; (be4c <_dtoa_r+0x364>)
    bcc0:	b.n	bb56 <_dtoa_r+0x6e>
    bcc2:	adds	r3, r0, #3
    bcc4:	b.n	bb80 <_dtoa_r+0x98>
    bcc6:	movs	r1, #0
    bcc8:	str	r1, [r4, #68]	; 0x44
    bcca:	mov	r0, r4
    bccc:	mov	r8, r1
    bcce:	str	r1, [sp, #4]
    bcd0:	bl	d220 <_Balloc>
    bcd4:	mov.w	r7, #4294967295
    bcd8:	movs	r3, #1
    bcda:	str	r0, [sp, #32]
    bcdc:	str	r0, [r4, #64]	; 0x40
    bcde:	str	r7, [sp, #52]	; 0x34
    bce0:	str	r3, [sp, #36]	; 0x24
    bce2:	ldr	r3, [sp, #68]	; 0x44
    bce4:	cmp	r3, #0
    bce6:	blt.n	bdde <_dtoa_r+0x2f6>
    bce8:	ldr	r2, [sp, #8]
    bcea:	cmp	r2, #14
    bcec:	bgt.n	bdde <_dtoa_r+0x2f6>
    bcee:	ldr	r3, [pc, #340]	; (be44 <_dtoa_r+0x35c>)
    bcf0:	cmp.w	r8, #0
    bcf4:	add.w	r3, r3, r2, lsl #3
    bcf8:	vldr	d4, [r3]
    bcfc:	blt.w	c208 <_dtoa_r+0x720>
    bd00:	vneg.f64	d2, d4
    bd04:	vmov	d7, sl, fp
    bd08:	vdiv.f64	d6, d7, d4
    bd0c:	vcvt.s32.f64	s12, d6
    bd10:	ldr	r2, [sp, #32]
    bd12:	vmov	r3, s12
    bd16:	cmp	r7, #1
    bd18:	add.w	r3, r3, #48	; 0x30
    bd1c:	vcvt.f64.s32	d5, s12
    bd20:	add.w	fp, r2, #1
    bd24:	strb	r3, [r2, #0]
    bd26:	vfma.f64	d7, d2, d5
    bd2a:	beq.n	bd72 <_dtoa_r+0x28a>
    bd2c:	vmov.f64	d3, #36	; 0x41200000  10.0
    bd30:	vmul.f64	d7, d7, d3
    bd34:	vcmp.f64	d7, #0.0
    bd38:	vmrs	APSR_nzcv, fpscr
    bd3c:	beq.n	bdb4 <_dtoa_r+0x2cc>
    bd3e:	ldr	r2, [sp, #32]
    bd40:	b.n	bd50 <_dtoa_r+0x268>
    bd42:	vmul.f64	d7, d7, d3
    bd46:	vcmp.f64	d7, #0.0
    bd4a:	vmrs	APSR_nzcv, fpscr
    bd4e:	beq.n	bdb4 <_dtoa_r+0x2cc>
    bd50:	vdiv.f64	d6, d7, d4
    bd54:	vcvt.s32.f64	s12, d6
    bd58:	vmov	r3, s12
    bd5c:	adds	r3, #48	; 0x30
    bd5e:	strb.w	r3, [fp], #1
    bd62:	rsb	r3, r2, fp
    bd66:	cmp	r3, r7
    bd68:	vcvt.f64.s32	d5, s12
    bd6c:	vfma.f64	d7, d2, d5
    bd70:	bne.n	bd42 <_dtoa_r+0x25a>
    bd72:	vadd.f64	d7, d7, d7
    bd76:	vcmpe.f64	d4, d7
    bd7a:	vmrs	APSR_nzcv, fpscr
    bd7e:	bmi.n	bd92 <_dtoa_r+0x2aa>
    bd80:	vcmp.f64	d4, d7
    bd84:	vmrs	APSR_nzcv, fpscr
    bd88:	bne.n	bdb4 <_dtoa_r+0x2cc>
    bd8a:	vmov	r3, s12
    bd8e:	lsls	r3, r3, #31
    bd90:	bpl.n	bdb4 <_dtoa_r+0x2cc>
    bd92:	ldrb.w	r0, [fp, #-1]
    bd96:	ldr	r2, [sp, #32]
    bd98:	add.w	r3, fp, #4294967295
    bd9c:	b.n	bda8 <_dtoa_r+0x2c0>
    bd9e:	cmp	r2, r3
    bda0:	beq.w	c56e <_dtoa_r+0xa86>
    bda4:	ldrb.w	r0, [r3, #-1]!
    bda8:	cmp	r0, #57	; 0x39
    bdaa:	add.w	fp, r3, #1
    bdae:	beq.n	bd9e <_dtoa_r+0x2b6>
    bdb0:	adds	r0, #1
    bdb2:	strb	r0, [r3, #0]
    bdb4:	ldr	r1, [sp, #28]
    bdb6:	mov	r0, r4
    bdb8:	bl	d26c <_Bfree>
    bdbc:	movs	r2, #0
    bdbe:	ldr	r3, [sp, #8]
    bdc0:	strb.w	r2, [fp]
    bdc4:	ldr	r2, [sp, #16]
    bdc6:	adds	r3, #1
    bdc8:	str	r3, [r2, #0]
    bdca:	ldr	r3, [sp, #116]	; 0x74
    bdcc:	cmp	r3, #0
    bdce:	beq.w	c49e <_dtoa_r+0x9b6>
    bdd2:	ldr	r0, [sp, #32]
    bdd4:	str.w	fp, [r3]
    bdd8:	add	sp, #76	; 0x4c
    bdda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bdde:	ldr	r2, [sp, #36]	; 0x24
    bde0:	cmp	r2, #0
    bde2:	beq.n	be8c <_dtoa_r+0x3a4>
    bde4:	ldr	r2, [sp, #4]
    bde6:	cmp	r2, #1
    bde8:	ble.w	c248 <_dtoa_r+0x760>
    bdec:	ldr	r1, [sp, #20]
    bdee:	subs	r2, r7, #1
    bdf0:	cmp	r1, r2
    bdf2:	blt.w	c4a4 <_dtoa_r+0x9bc>
    bdf6:	subs	r3, r1, r2
    bdf8:	str	r3, [sp, #56]	; 0x38
    bdfa:	cmp	r7, #0
    bdfc:	ldr	r3, [sp, #24]
    bdfe:	blt.w	c64a <_dtoa_r+0xb62>
    be02:	str	r3, [sp, #40]	; 0x28
    be04:	mov	r3, r7
    be06:	ldr	r2, [sp, #24]
    be08:	movs	r1, #1
    be0a:	add	r2, r3
    be0c:	mov	r0, r4
    be0e:	str	r2, [sp, #24]
    be10:	add	r9, r3
    be12:	bl	d39c <__i2b>
    be16:	mov	r6, r0
    be18:	b.n	be96 <_dtoa_r+0x3ae>
    be1a:	nop
    be1c:	nop.w
    be20:	.word	0x636f4361
    be24:	.word	0x3fd287a7
    be28:	.word	0x8b60c8b3
    be2c:	.word	0x3fc68a28
    be30:	.word	0x509f79fb
    be34:	.word	0x3fd34413
    be38:	.word	0x7ff00000
    be3c:	.word	0x20000405
    be40:	.word	0x20001150
    be44:	.word	0x20001158
    be48:	.word	0x20001144
    be4c:	.word	0x20000404
    be50:	movs	r3, #1
    be52:	str	r3, [sp, #48]	; 0x30
    be54:	b.n	bc48 <_dtoa_r+0x160>
    be56:	vcvt.f64.s32	d6, s13
    be5a:	vcmp.f64	d7, d6
    be5e:	vmrs	APSR_nzcv, fpscr
    be62:	beq.w	bc1e <_dtoa_r+0x136>
    be66:	ldr	r3, [sp, #8]
    be68:	subs	r3, #1
    be6a:	str	r3, [sp, #8]
    be6c:	b.n	bc1e <_dtoa_r+0x136>
    be6e:	ldr	r2, [sp, #24]
    be70:	ldr	r3, [sp, #8]
    be72:	subs	r2, r2, r3
    be74:	negs	r3, r3
    be76:	str	r3, [sp, #20]
    be78:	movs	r3, #0
    be7a:	str	r2, [sp, #24]
    be7c:	str	r3, [sp, #44]	; 0x2c
    be7e:	b.n	bc66 <_dtoa_r+0x17e>
    be80:	rsb	r3, r9, #0
    be84:	str	r3, [sp, #24]
    be86:	mov.w	r9, #0
    be8a:	b.n	bc56 <_dtoa_r+0x16e>
    be8c:	ldr	r3, [sp, #20]
    be8e:	str	r3, [sp, #56]	; 0x38
    be90:	ldr	r6, [sp, #36]	; 0x24
    be92:	ldr	r3, [sp, #24]
    be94:	str	r3, [sp, #40]	; 0x28
    be96:	ldr	r1, [sp, #40]	; 0x28
    be98:	mov	r3, r1
    be9a:	cbz	r1, beb6 <_dtoa_r+0x3ce>
    be9c:	cmp.w	r9, #0
    bea0:	ble.n	beb6 <_dtoa_r+0x3ce>
    bea2:	cmp	r1, r9
    bea4:	ldr	r2, [sp, #24]
    bea6:	it	ge
    bea8:	movge	r3, r9
    beaa:	subs	r2, r2, r3
    beac:	str	r2, [sp, #24]
    beae:	subs	r2, r1, r3
    beb0:	str	r2, [sp, #40]	; 0x28
    beb2:	rsb	r9, r3, r9
    beb6:	ldr	r3, [sp, #20]
    beb8:	cmp	r3, #0
    beba:	ble.w	c3be <_dtoa_r+0x8d6>
    bebe:	ldr	r2, [sp, #36]	; 0x24
    bec0:	cmp	r2, #0
    bec2:	beq.w	c1fa <_dtoa_r+0x712>
    bec6:	ldr	r2, [sp, #56]	; 0x38
    bec8:	cmp	r2, #0
    beca:	beq.w	c1fa <_dtoa_r+0x712>
    bece:	mov	r1, r6
    bed0:	mov	r0, r4
    bed2:	bl	d4e0 <__pow5mult>
    bed6:	ldr	r2, [sp, #28]
    bed8:	mov	r1, r0
    beda:	mov	r6, r0
    bedc:	mov	r0, r4
    bede:	bl	d3b0 <__multiply>
    bee2:	ldr	r1, [sp, #28]
    bee4:	mov	r5, r0
    bee6:	mov	r0, r4
    bee8:	bl	d26c <_Bfree>
    beec:	ldr	r3, [sp, #20]
    beee:	ldr	r2, [sp, #56]	; 0x38
    bef0:	subs	r3, r3, r2
    bef2:	str	r3, [sp, #20]
    bef4:	bne.w	c1f8 <_dtoa_r+0x710>
    bef8:	movs	r1, #1
    befa:	mov	r0, r4
    befc:	bl	d39c <__i2b>
    bf00:	ldr	r3, [sp, #44]	; 0x2c
    bf02:	str	r0, [sp, #20]
    bf04:	cmp	r3, #0
    bf06:	beq.w	c262 <_dtoa_r+0x77a>
    bf0a:	mov	r1, r0
    bf0c:	mov	r2, r3
    bf0e:	mov	r0, r4
    bf10:	bl	d4e0 <__pow5mult>
    bf14:	ldr	r3, [sp, #4]
    bf16:	str	r0, [sp, #20]
    bf18:	cmp	r3, #1
    bf1a:	ble.w	c41e <_dtoa_r+0x936>
    bf1e:	movs	r3, #0
    bf20:	str	r3, [sp, #28]
    bf22:	ldr	r2, [sp, #20]
    bf24:	ldr	r3, [r2, #16]
    bf26:	add.w	r3, r2, r3, lsl #2
    bf2a:	ldr	r0, [r3, #16]
    bf2c:	bl	d300 <__hi0bits>
    bf30:	rsb	r0, r0, #32
    bf34:	add	r0, r9
    bf36:	ands.w	r0, r0, #31
    bf3a:	beq.w	c25e <_dtoa_r+0x776>
    bf3e:	rsb	r3, r0, #32
    bf42:	cmp	r3, #4
    bf44:	ble.w	c738 <_dtoa_r+0xc50>
    bf48:	rsb	r0, r0, #28
    bf4c:	ldr	r3, [sp, #24]
    bf4e:	add	r3, r0
    bf50:	str	r3, [sp, #24]
    bf52:	ldr	r3, [sp, #40]	; 0x28
    bf54:	add	r3, r0
    bf56:	str	r3, [sp, #40]	; 0x28
    bf58:	add	r9, r0
    bf5a:	ldr	r3, [sp, #24]
    bf5c:	cmp	r3, #0
    bf5e:	ble.n	bf6c <_dtoa_r+0x484>
    bf60:	mov	r1, r5
    bf62:	mov	r2, r3
    bf64:	mov	r0, r4
    bf66:	bl	d580 <__lshift>
    bf6a:	mov	r5, r0
    bf6c:	cmp.w	r9, #0
    bf70:	ble.n	bf7e <_dtoa_r+0x496>
    bf72:	mov	r2, r9
    bf74:	ldr	r1, [sp, #20]
    bf76:	mov	r0, r4
    bf78:	bl	d580 <__lshift>
    bf7c:	str	r0, [sp, #20]
    bf7e:	ldr	r3, [sp, #48]	; 0x30
    bf80:	cmp	r3, #0
    bf82:	bne.w	c388 <_dtoa_r+0x8a0>
    bf86:	cmp	r7, #0
    bf88:	ble.w	c3cc <_dtoa_r+0x8e4>
    bf8c:	ldr	r3, [sp, #36]	; 0x24
    bf8e:	cmp	r3, #0
    bf90:	bne.w	c28a <_dtoa_r+0x7a2>
    bf94:	ldr.w	fp, [sp, #32]
    bf98:	ldr.w	sl, [sp, #20]
    bf9c:	mov	r8, fp
    bf9e:	b.n	bfa6 <_dtoa_r+0x4be>
    bfa0:	bl	d280 <__multadd>
    bfa4:	mov	r5, r0
    bfa6:	mov	r1, sl
    bfa8:	mov	r0, r5
    bfaa:	bl	b9c0 <quorem>
    bfae:	add.w	r9, r0, #48	; 0x30
    bfb2:	strb.w	r9, [r8], #1
    bfb6:	rsb	r3, fp, r8
    bfba:	cmp	r3, r7
    bfbc:	mov.w	r2, #10
    bfc0:	mov.w	r3, #0
    bfc4:	mov	r1, r5
    bfc6:	mov	r0, r4
    bfc8:	blt.n	bfa0 <_dtoa_r+0x4b8>
    bfca:	ldr	r3, [sp, #32]
    bfcc:	cmp	r7, #1
    bfce:	ite	ge
    bfd0:	addge	r3, r3, r7
    bfd2:	addlt	r3, #1
    bfd4:	mov	fp, r3
    bfd6:	mov.w	sl, #0
    bfda:	mov	r1, r5
    bfdc:	movs	r2, #1
    bfde:	mov	r0, r4
    bfe0:	bl	d580 <__lshift>
    bfe4:	ldr	r1, [sp, #20]
    bfe6:	str	r0, [sp, #28]
    bfe8:	bl	d630 <__mcmp>
    bfec:	cmp	r0, #0
    bfee:	ble.w	c50a <_dtoa_r+0xa22>
    bff2:	ldrb.w	r2, [fp, #-1]
    bff6:	ldr	r1, [sp, #32]
    bff8:	add.w	r3, fp, #4294967295
    bffc:	b.n	c008 <_dtoa_r+0x520>
    bffe:	cmp	r3, r1
    c000:	beq.w	c40a <_dtoa_r+0x922>
    c004:	ldrb.w	r2, [r3, #-1]!
    c008:	cmp	r2, #57	; 0x39
    c00a:	add.w	fp, r3, #1
    c00e:	beq.n	bffe <_dtoa_r+0x516>
    c010:	adds	r2, #1
    c012:	strb	r2, [r3, #0]
    c014:	ldr	r1, [sp, #20]
    c016:	mov	r0, r4
    c018:	bl	d26c <_Bfree>
    c01c:	cmp	r6, #0
    c01e:	beq.w	bdb4 <_dtoa_r+0x2cc>
    c022:	cmp.w	sl, #0
    c026:	beq.n	c034 <_dtoa_r+0x54c>
    c028:	cmp	sl, r6
    c02a:	beq.n	c034 <_dtoa_r+0x54c>
    c02c:	mov	r1, sl
    c02e:	mov	r0, r4
    c030:	bl	d26c <_Bfree>
    c034:	mov	r1, r6
    c036:	mov	r0, r4
    c038:	bl	d26c <_Bfree>
    c03c:	b.n	bdb4 <_dtoa_r+0x2cc>
    c03e:	rsb	r3, r3, #32
    c042:	lsl.w	r3, sl, r3
    c046:	vmov	s15, r3
    c04a:	b.n	bbd0 <_dtoa_r+0xe8>
    c04c:	movs	r3, #0
    c04e:	str	r3, [sp, #48]	; 0x30
    c050:	b.n	bc48 <_dtoa_r+0x160>
    c052:	movs	r3, #0
    c054:	str	r3, [sp, #36]	; 0x24
    c056:	ldr	r3, [sp, #8]
    c058:	add	r3, r8
    c05a:	adds	r7, r3, #1
    c05c:	cmp	r7, #0
    c05e:	str	r3, [sp, #52]	; 0x34
    c060:	ble.w	c4be <_dtoa_r+0x9d6>
    c064:	mov	r6, r7
    c066:	mov	r5, r7
    c068:	movs	r1, #0
    c06a:	cmp	r6, #23
    c06c:	str	r1, [r4, #68]	; 0x44
    c06e:	bls.n	c086 <_dtoa_r+0x59e>
    c070:	movs	r2, #1
    c072:	movs	r3, #4
    c074:	lsls	r3, r3, #1
    c076:	add.w	r0, r3, #20
    c07a:	cmp	r0, r6
    c07c:	mov	r1, r2
    c07e:	add.w	r2, r2, #1
    c082:	bls.n	c074 <_dtoa_r+0x58c>
    c084:	str	r1, [r4, #68]	; 0x44
    c086:	mov	r0, r4
    c088:	bl	d220 <_Balloc>
    c08c:	cmp	r5, #14
    c08e:	str	r0, [sp, #32]
    c090:	str	r0, [r4, #64]	; 0x40
    c092:	bhi.w	bce2 <_dtoa_r+0x1fa>
    c096:	ldr	r3, [sp, #56]	; 0x38
    c098:	cmp	r3, #0
    c09a:	beq.w	bce2 <_dtoa_r+0x1fa>
    c09e:	ldr	r1, [sp, #8]
    c0a0:	cmp	r1, #0
    c0a2:	strd	sl, fp, [sp, #56]	; 0x38
    c0a6:	ble.w	c52c <_dtoa_r+0xa44>
    c0aa:	ldr	r3, [pc, #792]	; (c3c4 <_dtoa_r+0x8dc>)
    c0ac:	and.w	r2, r1, #15
    c0b0:	add.w	r2, r3, r2, lsl #3
    c0b4:	asrs	r3, r1, #4
    c0b6:	lsls	r6, r3, #27
    c0b8:	vldr	d6, [r2]
    c0bc:	bpl.w	c4b6 <_dtoa_r+0x9ce>
    c0c0:	ldr	r2, [pc, #772]	; (c3c8 <_dtoa_r+0x8e0>)
    c0c2:	vldr	d7, [r2, #32]
    c0c6:	vmov	d4, sl, fp
    c0ca:	and.w	r3, r3, #15
    c0ce:	movs	r1, #3
    c0d0:	vdiv.f64	d5, d4, d7
    c0d4:	cbz	r3, c0ee <_dtoa_r+0x606>
    c0d6:	ldr	r2, [pc, #752]	; (c3c8 <_dtoa_r+0x8e0>)
    c0d8:	lsls	r5, r3, #31
    c0da:	bpl.n	c0e6 <_dtoa_r+0x5fe>
    c0dc:	vldr	d7, [r2]
    c0e0:	adds	r1, #1
    c0e2:	vmul.f64	d6, d6, d7
    c0e6:	asrs	r3, r3, #1
    c0e8:	add.w	r2, r2, #8
    c0ec:	bne.n	c0d8 <_dtoa_r+0x5f0>
    c0ee:	vdiv.f64	d4, d5, d6
    c0f2:	ldr	r3, [sp, #48]	; 0x30
    c0f4:	cbz	r3, c106 <_dtoa_r+0x61e>
    c0f6:	vmov.f64	d7, #112	; 0x3f800000  1.0
    c0fa:	vcmpe.f64	d4, d7
    c0fe:	vmrs	APSR_nzcv, fpscr
    c102:	bmi.w	c674 <_dtoa_r+0xb8c>
    c106:	vmov	s15, r1
    c10a:	vcvt.f64.s32	d6, s15
    c10e:	vmov.f64	d7, #28	; 0x40e00000  7.0
    c112:	vfma.f64	d7, d6, d4
    c116:	vmov	r2, r3, d7
    c11a:	sub.w	r3, r3, #54525952	; 0x3400000
    c11e:	cmp	r7, #0
    c120:	beq.w	c470 <_dtoa_r+0x988>
    c124:	ldr	r6, [sp, #8]
    c126:	mov	r1, r7
    c128:	ldr	r0, [sp, #36]	; 0x24
    c12a:	cmp	r0, #0
    c12c:	beq.w	c5ca <_dtoa_r+0xae2>
    c130:	vmov.f64	d3, #96	; 0x3f000000  0.5
    c134:	ldr	r0, [pc, #652]	; (c3c4 <_dtoa_r+0x8dc>)
    c136:	ldr	r5, [sp, #32]
    c138:	add.w	r0, r0, r1, lsl #3
    c13c:	vldr	d6, [r0, #-8]
    c140:	vcvt.s32.f64	s14, d4
    c144:	vdiv.f64	d5, d3, d6
    c148:	vmov	r0, s14
    c14c:	vmov	d6, r2, r3
    c150:	adds	r0, #48	; 0x30
    c152:	uxtb	r0, r0
    c154:	vsub.f64	d5, d5, d6
    c158:	vcvt.f64.s32	d7, s14
    c15c:	vsub.f64	d7, d4, d7
    c160:	vcmpe.f64	d5, d7
    c164:	vmrs	APSR_nzcv, fpscr
    c168:	strb	r0, [r5, #0]
    c16a:	add.w	fp, r5, #1
    c16e:	bgt.n	c1d6 <_dtoa_r+0x6ee>
    c170:	vmov.f64	d3, #112	; 0x3f800000  1.0
    c174:	vsub.f64	d6, d3, d7
    c178:	vcmpe.f64	d5, d6
    c17c:	vmrs	APSR_nzcv, fpscr
    c180:	bgt.w	c6e0 <_dtoa_r+0xbf8>
    c184:	cmp	r1, #1
    c186:	ble.w	c524 <_dtoa_r+0xa3c>
    c18a:	vmov.f64	d4, #36	; 0x41200000  10.0
    c18e:	ldr	r3, [sp, #32]
    c190:	add	r1, r3
    c192:	b.n	c1aa <_dtoa_r+0x6c2>
    c194:	vsub.f64	d6, d3, d7
    c198:	vcmpe.f64	d6, d5
    c19c:	vmrs	APSR_nzcv, fpscr
    c1a0:	bmi.w	c6e0 <_dtoa_r+0xbf8>
    c1a4:	cmp	fp, r1
    c1a6:	beq.w	c524 <_dtoa_r+0xa3c>
    c1aa:	vmul.f64	d7, d7, d4
    c1ae:	vmul.f64	d5, d5, d4
    c1b2:	vcvt.s32.f64	s12, d7
    c1b6:	vmov	r3, s12
    c1ba:	add.w	r0, r3, #48	; 0x30
    c1be:	uxtb	r0, r0
    c1c0:	vcvt.f64.s32	d6, s12
    c1c4:	vsub.f64	d7, d7, d6
    c1c8:	vcmpe.f64	d7, d5
    c1cc:	vmrs	APSR_nzcv, fpscr
    c1d0:	strb.w	r0, [fp], #1
    c1d4:	bpl.n	c194 <_dtoa_r+0x6ac>
    c1d6:	str	r6, [sp, #8]
    c1d8:	b.n	bdb4 <_dtoa_r+0x2cc>
    c1da:	movs	r3, #0
    c1dc:	str	r3, [sp, #36]	; 0x24
    c1de:	cmp.w	r8, #0
    c1e2:	ble.w	c4c6 <_dtoa_r+0x9de>
    c1e6:	mov	r6, r8
    c1e8:	mov	r5, r8
    c1ea:	str.w	r8, [sp, #52]	; 0x34
    c1ee:	mov	r7, r8
    c1f0:	b.n	c068 <_dtoa_r+0x580>
    c1f2:	movs	r3, #1
    c1f4:	str	r3, [sp, #36]	; 0x24
    c1f6:	b.n	c1de <_dtoa_r+0x6f6>
    c1f8:	str	r5, [sp, #28]
    c1fa:	ldr	r2, [sp, #20]
    c1fc:	ldr	r1, [sp, #28]
    c1fe:	mov	r0, r4
    c200:	bl	d4e0 <__pow5mult>
    c204:	mov	r5, r0
    c206:	b.n	bef8 <_dtoa_r+0x410>
    c208:	cmp	r7, #0
    c20a:	bgt.w	bd00 <_dtoa_r+0x218>
    c20e:	bne.w	c496 <_dtoa_r+0x9ae>
    c212:	vmov.f64	d7, #20	; 0x40a00000  5.0
    c216:	vmul.f64	d4, d4, d7
    c21a:	vmov	d7, sl, fp
    c21e:	vcmpe.f64	d4, d7
    c222:	vmrs	APSR_nzcv, fpscr
    c226:	mov	r6, r7
    c228:	str	r7, [sp, #20]
    c22a:	blt.w	c3f8 <_dtoa_r+0x910>
    c22e:	mvn.w	r3, r8
    c232:	ldr.w	fp, [sp, #32]
    c236:	str	r3, [sp, #8]
    c238:	ldr	r1, [sp, #20]
    c23a:	mov	r0, r4
    c23c:	bl	d26c <_Bfree>
    c240:	cmp	r6, #0
    c242:	beq.w	bdb4 <_dtoa_r+0x2cc>
    c246:	b.n	c034 <_dtoa_r+0x54c>
    c248:	ldr	r2, [sp, #40]	; 0x28
    c24a:	cmp	r2, #0
    c24c:	beq.w	c654 <_dtoa_r+0xb6c>
    c250:	ldr	r2, [sp, #20]
    c252:	str	r2, [sp, #56]	; 0x38
    c254:	ldr	r2, [sp, #24]
    c256:	str	r2, [sp, #40]	; 0x28
    c258:	addw	r3, r3, #1075	; 0x433
    c25c:	b.n	be06 <_dtoa_r+0x31e>
    c25e:	movs	r0, #28
    c260:	b.n	bf4c <_dtoa_r+0x464>
    c262:	ldr	r3, [sp, #4]
    c264:	cmp	r3, #1
    c266:	ble.w	c6ea <_dtoa_r+0xc02>
    c26a:	ldr	r3, [sp, #44]	; 0x2c
    c26c:	str	r3, [sp, #28]
    c26e:	movs	r0, #1
    c270:	b.n	bf34 <_dtoa_r+0x44c>
    c272:	mov	r1, r6
    c274:	movs	r3, #0
    c276:	movs	r2, #10
    c278:	mov	r0, r4
    c27a:	bl	d280 <__multadd>
    c27e:	ldr	r3, [sp, #52]	; 0x34
    c280:	cmp	r3, #0
    c282:	mov	r6, r0
    c284:	ble.w	c722 <_dtoa_r+0xc3a>
    c288:	mov	r7, r3
    c28a:	ldr	r3, [sp, #40]	; 0x28
    c28c:	cmp	r3, #0
    c28e:	ble.n	c29c <_dtoa_r+0x7b4>
    c290:	mov	r1, r6
    c292:	mov	r2, r3
    c294:	mov	r0, r4
    c296:	bl	d580 <__lshift>
    c29a:	mov	r6, r0
    c29c:	ldr	r3, [sp, #28]
    c29e:	cmp	r3, #0
    c2a0:	bne.w	c580 <_dtoa_r+0xa98>
    c2a4:	mov	r8, r6
    c2a6:	ldr	r3, [sp, #32]
    c2a8:	subs	r7, #1
    c2aa:	adds	r2, r3, r7
    c2ac:	str	r2, [sp, #36]	; 0x24
    c2ae:	and.w	r2, sl, #1
    c2b2:	str	r2, [sp, #40]	; 0x28
    c2b4:	mov	r7, r3
    c2b6:	ldr.w	fp, [sp, #20]
    c2ba:	mov	r0, r5
    c2bc:	mov	r1, fp
    c2be:	bl	b9c0 <quorem>
    c2c2:	mov	r1, r6
    c2c4:	mov	sl, r0
    c2c6:	mov	r0, r5
    c2c8:	bl	d630 <__mcmp>
    c2cc:	mov	r2, r8
    c2ce:	mov	r1, fp
    c2d0:	mov	r9, r0
    c2d2:	mov	r0, r4
    c2d4:	bl	d674 <__mdiff>
    c2d8:	ldr	r3, [r0, #12]
    c2da:	mov	fp, r0
    c2dc:	add.w	r2, sl, #48	; 0x30
    c2e0:	cmp	r3, #0
    c2e2:	bne.n	c378 <_dtoa_r+0x890>
    c2e4:	mov	r1, r0
    c2e6:	mov	r0, r5
    c2e8:	str	r2, [sp, #28]
    c2ea:	bl	d630 <__mcmp>
    c2ee:	mov	r1, fp
    c2f0:	str	r0, [sp, #24]
    c2f2:	mov	r0, r4
    c2f4:	bl	d26c <_Bfree>
    c2f8:	ldr	r3, [sp, #24]
    c2fa:	ldr	r2, [sp, #28]
    c2fc:	cbnz	r3, c30a <_dtoa_r+0x822>
    c2fe:	ldr	r1, [sp, #4]
    c300:	cbnz	r1, c30a <_dtoa_r+0x822>
    c302:	ldr	r1, [sp, #40]	; 0x28
    c304:	cmp	r1, #0
    c306:	beq.w	c6f4 <_dtoa_r+0xc0c>
    c30a:	cmp.w	r9, #0
    c30e:	blt.w	c4d0 <_dtoa_r+0x9e8>
    c312:	bne.n	c320 <_dtoa_r+0x838>
    c314:	ldr	r1, [sp, #4]
    c316:	cbnz	r1, c320 <_dtoa_r+0x838>
    c318:	ldr	r1, [sp, #40]	; 0x28
    c31a:	cmp	r1, #0
    c31c:	beq.w	c4d0 <_dtoa_r+0x9e8>
    c320:	cmp	r3, #0
    c322:	bgt.w	c5a8 <_dtoa_r+0xac0>
    c326:	ldr	r3, [sp, #36]	; 0x24
    c328:	strb	r2, [r7, #0]
    c32a:	add.w	r9, r7, #1
    c32e:	cmp	r7, r3
    c330:	mov	fp, r9
    c332:	beq.w	c5c2 <_dtoa_r+0xada>
    c336:	mov	r1, r5
    c338:	movs	r3, #0
    c33a:	movs	r2, #10
    c33c:	mov	r0, r4
    c33e:	bl	d280 <__multadd>
    c342:	cmp	r6, r8
    c344:	mov	r5, r0
    c346:	mov	r1, r6
    c348:	mov.w	r3, #0
    c34c:	mov.w	r2, #10
    c350:	mov	r0, r4
    c352:	beq.n	c36c <_dtoa_r+0x884>
    c354:	bl	d280 <__multadd>
    c358:	mov	r1, r8
    c35a:	mov	r6, r0
    c35c:	movs	r3, #0
    c35e:	movs	r2, #10
    c360:	mov	r0, r4
    c362:	bl	d280 <__multadd>
    c366:	mov	r7, r9
    c368:	mov	r8, r0
    c36a:	b.n	c2b6 <_dtoa_r+0x7ce>
    c36c:	bl	d280 <__multadd>
    c370:	mov	r7, r9
    c372:	mov	r6, r0
    c374:	mov	r8, r0
    c376:	b.n	c2b6 <_dtoa_r+0x7ce>
    c378:	mov	r1, r0
    c37a:	mov	r0, r4
    c37c:	str	r2, [sp, #24]
    c37e:	bl	d26c <_Bfree>
    c382:	movs	r3, #1
    c384:	ldr	r2, [sp, #24]
    c386:	b.n	c30a <_dtoa_r+0x822>
    c388:	ldr	r1, [sp, #20]
    c38a:	mov	r0, r5
    c38c:	bl	d630 <__mcmp>
    c390:	cmp	r0, #0
    c392:	bge.w	bf86 <_dtoa_r+0x49e>
    c396:	mov	r1, r5
    c398:	ldr	r5, [sp, #8]
    c39a:	movs	r3, #0
    c39c:	subs	r5, #1
    c39e:	movs	r2, #10
    c3a0:	mov	r0, r4
    c3a2:	str	r5, [sp, #8]
    c3a4:	bl	d280 <__multadd>
    c3a8:	ldr	r3, [sp, #36]	; 0x24
    c3aa:	mov	r5, r0
    c3ac:	cmp	r3, #0
    c3ae:	bne.w	c272 <_dtoa_r+0x78a>
    c3b2:	ldr	r3, [sp, #52]	; 0x34
    c3b4:	cmp	r3, #0
    c3b6:	ble.w	c714 <_dtoa_r+0xc2c>
    c3ba:	mov	r7, r3
    c3bc:	b.n	bf94 <_dtoa_r+0x4ac>
    c3be:	ldr	r5, [sp, #28]
    c3c0:	b.n	bef8 <_dtoa_r+0x410>
    c3c2:	nop
    c3c4:	.word	0x20001158
    c3c8:	.word	0x20001220
    c3cc:	ldr	r3, [sp, #4]
    c3ce:	cmp	r3, #2
    c3d0:	ble.w	bf8c <_dtoa_r+0x4a4>
    c3d4:	cmp	r7, #0
    c3d6:	bne.w	c6ac <_dtoa_r+0xbc4>
    c3da:	mov	r3, r7
    c3dc:	ldr	r1, [sp, #20]
    c3de:	movs	r2, #5
    c3e0:	mov	r0, r4
    c3e2:	bl	d280 <__multadd>
    c3e6:	mov	r1, r0
    c3e8:	str	r0, [sp, #20]
    c3ea:	mov	r0, r5
    c3ec:	bl	d630 <__mcmp>
    c3f0:	cmp	r0, #0
    c3f2:	str	r5, [sp, #28]
    c3f4:	ble.w	c22e <_dtoa_r+0x746>
    c3f8:	ldr	r2, [sp, #8]
    c3fa:	ldr	r1, [sp, #32]
    c3fc:	movs	r3, #49	; 0x31
    c3fe:	adds	r2, #1
    c400:	str	r2, [sp, #8]
    c402:	strb	r3, [r1, #0]
    c404:	add.w	fp, r1, #1
    c408:	b.n	c238 <_dtoa_r+0x750>
    c40a:	ldr	r2, [sp, #8]
    c40c:	adds	r2, #1
    c40e:	str	r2, [sp, #8]
    c410:	ldr	r2, [sp, #32]
    c412:	movs	r3, #49	; 0x31
    c414:	strb	r3, [r2, #0]
    c416:	b.n	c014 <_dtoa_r+0x52c>
    c418:	movs	r3, #1
    c41a:	str	r3, [sp, #36]	; 0x24
    c41c:	b.n	c056 <_dtoa_r+0x56e>
    c41e:	cmp.w	sl, #0
    c422:	bne.w	bf1e <_dtoa_r+0x436>
    c426:	ubfx	r3, fp, #0, #20
    c42a:	cmp	r3, #0
    c42c:	bne.w	c666 <_dtoa_r+0xb7e>
    c430:	bic.w	r3, fp, #2147483648	; 0x80000000
    c434:	lsrs	r3, r3, #20
    c436:	lsls	r3, r3, #20
    c438:	cmp	r3, #0
    c43a:	beq.w	c6e6 <_dtoa_r+0xbfe>
    c43e:	ldr	r3, [sp, #24]
    c440:	adds	r3, #1
    c442:	str	r3, [sp, #24]
    c444:	movs	r3, #1
    c446:	add.w	r9, r9, #1
    c44a:	str	r3, [sp, #28]
    c44c:	ldr	r3, [sp, #44]	; 0x2c
    c44e:	movs	r0, #1
    c450:	cmp	r3, #0
    c452:	beq.w	bf34 <_dtoa_r+0x44c>
    c456:	b.n	bf22 <_dtoa_r+0x43a>
    c458:	vmov	s15, r1
    c45c:	vcvt.f64.s32	d6, s15
    c460:	vmov.f64	d7, #28	; 0x40e00000  7.0
    c464:	vfma.f64	d7, d4, d6
    c468:	vmov	r2, r3, d7
    c46c:	sub.w	r3, r3, #54525952	; 0x3400000
    c470:	vmov	d6, r2, r3
    c474:	vmov.f64	d7, #20	; 0x40a00000  5.0
    c478:	vsub.f64	d7, d4, d7
    c47c:	vcmpe.f64	d7, d6
    c480:	vmrs	APSR_nzcv, fpscr
    c484:	bgt.w	c642 <_dtoa_r+0xb5a>
    c488:	vneg.f64	d6, d6
    c48c:	vcmpe.f64	d7, d6
    c490:	vmrs	APSR_nzcv, fpscr
    c494:	bpl.n	c524 <_dtoa_r+0xa3c>
    c496:	movs	r3, #0
    c498:	str	r3, [sp, #20]
    c49a:	mov	r6, r3
    c49c:	b.n	c22e <_dtoa_r+0x746>
    c49e:	ldr	r0, [sp, #32]
    c4a0:	b.w	bb56 <_dtoa_r+0x6e>
    c4a4:	ldr	r3, [sp, #20]
    c4a6:	ldr	r1, [sp, #44]	; 0x2c
    c4a8:	str	r2, [sp, #20]
    c4aa:	subs	r3, r2, r3
    c4ac:	add	r1, r3
    c4ae:	movs	r3, #0
    c4b0:	str	r1, [sp, #44]	; 0x2c
    c4b2:	str	r3, [sp, #56]	; 0x38
    c4b4:	b.n	bdfa <_dtoa_r+0x312>
    c4b6:	vldr	d5, [sp, #56]	; 0x38
    c4ba:	movs	r1, #2
    c4bc:	b.n	c0d4 <_dtoa_r+0x5ec>
    c4be:	mov	r5, r7
    c4c0:	movs	r1, #0
    c4c2:	str	r1, [r4, #68]	; 0x44
    c4c4:	b.n	c086 <_dtoa_r+0x59e>
    c4c6:	movs	r5, #1
    c4c8:	str	r5, [sp, #52]	; 0x34
    c4ca:	mov	r7, r5
    c4cc:	mov	r8, r5
    c4ce:	b.n	c4c0 <_dtoa_r+0x9d8>
    c4d0:	cmp	r3, #0
    c4d2:	mov	r9, r2
    c4d4:	ble.n	c4fa <_dtoa_r+0xa12>
    c4d6:	mov	r1, r5
    c4d8:	movs	r2, #1
    c4da:	mov	r0, r4
    c4dc:	bl	d580 <__lshift>
    c4e0:	ldr	r1, [sp, #20]
    c4e2:	mov	r5, r0
    c4e4:	bl	d630 <__mcmp>
    c4e8:	cmp	r0, #0
    c4ea:	ble.w	c706 <_dtoa_r+0xc1e>
    c4ee:	cmp.w	r9, #57	; 0x39
    c4f2:	beq.w	c6b0 <_dtoa_r+0xbc8>
    c4f6:	add.w	r9, sl, #49	; 0x31
    c4fa:	mov	sl, r6
    c4fc:	strb.w	r9, [r7]
    c500:	add.w	fp, r7, #1
    c504:	mov	r6, r8
    c506:	str	r5, [sp, #28]
    c508:	b.n	c014 <_dtoa_r+0x52c>
    c50a:	bne.n	c516 <_dtoa_r+0xa2e>
    c50c:	tst.w	r9, #1
    c510:	beq.n	c516 <_dtoa_r+0xa2e>
    c512:	b.n	bff2 <_dtoa_r+0x50a>
    c514:	mov	fp, r2
    c516:	ldrb.w	r3, [fp, #-1]
    c51a:	cmp	r3, #48	; 0x30
    c51c:	add.w	r2, fp, #4294967295
    c520:	beq.n	c514 <_dtoa_r+0xa2c>
    c522:	b.n	c014 <_dtoa_r+0x52c>
    c524:	ldrd	sl, fp, [sp, #56]	; 0x38
    c528:	b.w	bce2 <_dtoa_r+0x1fa>
    c52c:	ldr	r3, [sp, #8]
    c52e:	negs	r3, r3
    c530:	cmp	r3, #0
    c532:	beq.w	c66c <_dtoa_r+0xb84>
    c536:	ldr	r2, [pc, #556]	; (c764 <_dtoa_r+0xc7c>)
    c538:	and.w	r1, r3, #15
    c53c:	add.w	r2, r2, r1, lsl #3
    c540:	vldr	d7, [r2]
    c544:	vldr	d6, [sp, #56]	; 0x38
    c548:	asrs	r3, r3, #4
    c54a:	vmul.f64	d4, d6, d7
    c54e:	beq.w	c71e <_dtoa_r+0xc36>
    c552:	ldr	r2, [pc, #532]	; (c768 <_dtoa_r+0xc80>)
    c554:	movs	r1, #2
    c556:	lsls	r0, r3, #31
    c558:	bpl.n	c564 <_dtoa_r+0xa7c>
    c55a:	vldr	d7, [r2]
    c55e:	adds	r1, #1
    c560:	vmul.f64	d4, d4, d7
    c564:	asrs	r3, r3, #1
    c566:	add.w	r2, r2, #8
    c56a:	bne.n	c556 <_dtoa_r+0xa6e>
    c56c:	b.n	c0f2 <_dtoa_r+0x60a>
    c56e:	ldr	r1, [sp, #32]
    c570:	movs	r2, #48	; 0x30
    c572:	strb	r2, [r1, #0]
    c574:	ldr	r2, [sp, #8]
    c576:	ldrb.w	r0, [fp, #-1]
    c57a:	adds	r2, #1
    c57c:	str	r2, [sp, #8]
    c57e:	b.n	bdb0 <_dtoa_r+0x2c8>
    c580:	ldr	r1, [r6, #4]
    c582:	mov	r0, r4
    c584:	bl	d220 <_Balloc>
    c588:	ldr	r3, [r6, #16]
    c58a:	adds	r2, r3, #2
    c58c:	mov	r8, r0
    c58e:	lsls	r2, r2, #2
    c590:	add.w	r1, r6, #12
    c594:	adds	r0, #12
    c596:	bl	2df0 <memcpy>
    c59a:	mov	r1, r8
    c59c:	movs	r2, #1
    c59e:	mov	r0, r4
    c5a0:	bl	d580 <__lshift>
    c5a4:	mov	r8, r0
    c5a6:	b.n	c2a6 <_dtoa_r+0x7be>
    c5a8:	cmp	r2, #57	; 0x39
    c5aa:	beq.w	c6b0 <_dtoa_r+0xbc8>
    c5ae:	add.w	r9, r2, #1
    c5b2:	mov	sl, r6
    c5b4:	strb.w	r9, [r7]
    c5b8:	add.w	fp, r7, #1
    c5bc:	mov	r6, r8
    c5be:	str	r5, [sp, #28]
    c5c0:	b.n	c014 <_dtoa_r+0x52c>
    c5c2:	mov	sl, r6
    c5c4:	mov	r9, r2
    c5c6:	mov	r6, r8
    c5c8:	b.n	bfda <_dtoa_r+0x4f2>
    c5ca:	ldr	r0, [pc, #408]	; (c764 <_dtoa_r+0xc7c>)
    c5cc:	vcvt.s32.f64	s12, d4
    c5d0:	subs	r5, r1, #1
    c5d2:	add.w	r0, r0, r5, lsl #3
    c5d6:	vmov	d7, r2, r3
    c5da:	vldr	d3, [r0]
    c5de:	vmov	r3, s12
    c5e2:	vmul.f64	d3, d3, d7
    c5e6:	ldr	r0, [sp, #32]
    c5e8:	adds	r3, #48	; 0x30
    c5ea:	cmp	r1, #1
    c5ec:	vcvt.f64.s32	d6, s12
    c5f0:	strb	r3, [r0, #0]
    c5f2:	add.w	fp, r0, #1
    c5f6:	vsub.f64	d7, d4, d6
    c5fa:	beq.n	c626 <_dtoa_r+0xb3e>
    c5fc:	vmov.f64	d5, #36	; 0x41200000  10.0
    c600:	ldr	r3, [sp, #32]
    c602:	add	r1, r3
    c604:	mov	r3, fp
    c606:	vmul.f64	d7, d7, d5
    c60a:	vcvt.s32.f64	s12, d7
    c60e:	vmov	r2, s12
    c612:	adds	r2, #48	; 0x30
    c614:	strb.w	r2, [r3], #1
    c618:	cmp	r1, r3
    c61a:	vcvt.f64.s32	d6, s12
    c61e:	vsub.f64	d7, d7, d6
    c622:	bne.n	c606 <_dtoa_r+0xb1e>
    c624:	add	fp, r5
    c626:	vmov.f64	d6, #96	; 0x3f000000  0.5
    c62a:	vadd.f64	d5, d3, d6
    c62e:	vcmpe.f64	d5, d7
    c632:	vmrs	APSR_nzcv, fpscr
    c636:	bpl.n	c6c0 <_dtoa_r+0xbd8>
    c638:	str	r6, [sp, #8]
    c63a:	ldrb.w	r0, [fp, #-1]
    c63e:	b.w	bd96 <_dtoa_r+0x2ae>
    c642:	movs	r3, #0
    c644:	str	r3, [sp, #20]
    c646:	mov	r6, r3
    c648:	b.n	c3f8 <_dtoa_r+0x910>
    c64a:	subs	r3, r3, r7
    c64c:	str	r3, [sp, #40]	; 0x28
    c64e:	movs	r3, #0
    c650:	b.w	be06 <_dtoa_r+0x31e>
    c654:	ldr	r2, [sp, #20]
    c656:	ldr	r3, [sp, #64]	; 0x40
    c658:	str	r2, [sp, #56]	; 0x38
    c65a:	ldr	r2, [sp, #24]
    c65c:	str	r2, [sp, #40]	; 0x28
    c65e:	rsb	r3, r3, #54	; 0x36
    c662:	b.w	be06 <_dtoa_r+0x31e>
    c666:	movs	r3, #0
    c668:	str	r3, [sp, #28]
    c66a:	b.n	c44c <_dtoa_r+0x964>
    c66c:	vldr	d4, [sp, #56]	; 0x38
    c670:	movs	r1, #2
    c672:	b.n	c0f2 <_dtoa_r+0x60a>
    c674:	cmp	r7, #0
    c676:	beq.w	c458 <_dtoa_r+0x970>
    c67a:	ldr	r0, [sp, #52]	; 0x34
    c67c:	cmp	r0, #0
    c67e:	ble.w	c524 <_dtoa_r+0xa3c>
    c682:	vmov.f64	d5, #36	; 0x41200000  10.0
    c686:	vmov.f64	d7, #28	; 0x40e00000  7.0
    c68a:	adds	r1, #1
    c68c:	vmov	s13, r1
    c690:	vmul.f64	d4, d4, d5
    c694:	ldr	r3, [sp, #8]
    c696:	vcvt.f64.s32	d6, s13
    c69a:	subs	r6, r3, #1
    c69c:	vfma.f64	d7, d4, d6
    c6a0:	vmov	r2, r3, d7
    c6a4:	mov	r1, r0
    c6a6:	sub.w	r3, r3, #54525952	; 0x3400000
    c6aa:	b.n	c128 <_dtoa_r+0x640>
    c6ac:	str	r5, [sp, #28]
    c6ae:	b.n	c22e <_dtoa_r+0x746>
    c6b0:	movs	r2, #57	; 0x39
    c6b2:	mov	sl, r6
    c6b4:	str	r5, [sp, #28]
    c6b6:	mov	r6, r8
    c6b8:	strb	r2, [r7, #0]
    c6ba:	add.w	fp, r7, #1
    c6be:	b.n	bff6 <_dtoa_r+0x50e>
    c6c0:	vsub.f64	d6, d6, d3
    c6c4:	vcmpe.f64	d6, d7
    c6c8:	vmrs	APSR_nzcv, fpscr
    c6cc:	bgt.n	c6d2 <_dtoa_r+0xbea>
    c6ce:	b.n	c524 <_dtoa_r+0xa3c>
    c6d0:	mov	fp, r2
    c6d2:	ldrb.w	r3, [fp, #-1]
    c6d6:	cmp	r3, #48	; 0x30
    c6d8:	add.w	r2, fp, #4294967295
    c6dc:	beq.n	c6d0 <_dtoa_r+0xbe8>
    c6de:	b.n	c1d6 <_dtoa_r+0x6ee>
    c6e0:	str	r6, [sp, #8]
    c6e2:	b.w	bd96 <_dtoa_r+0x2ae>
    c6e6:	str	r3, [sp, #28]
    c6e8:	b.n	c44c <_dtoa_r+0x964>
    c6ea:	cmp.w	sl, #0
    c6ee:	bne.w	c26a <_dtoa_r+0x782>
    c6f2:	b.n	c426 <_dtoa_r+0x93e>
    c6f4:	cmp	r2, #57	; 0x39
    c6f6:	mov	fp, r9
    c6f8:	mov	r9, r2
    c6fa:	beq.n	c6b0 <_dtoa_r+0xbc8>
    c6fc:	cmp.w	fp, #0
    c700:	bgt.w	c4f6 <_dtoa_r+0xa0e>
    c704:	b.n	c4fa <_dtoa_r+0xa12>
    c706:	bne.w	c4fa <_dtoa_r+0xa12>
    c70a:	tst.w	r9, #1
    c70e:	beq.w	c4fa <_dtoa_r+0xa12>
    c712:	b.n	c4ee <_dtoa_r+0xa06>
    c714:	ldr	r3, [sp, #4]
    c716:	cmp	r3, #2
    c718:	bgt.n	c72c <_dtoa_r+0xc44>
    c71a:	ldr	r7, [sp, #52]	; 0x34
    c71c:	b.n	bf94 <_dtoa_r+0x4ac>
    c71e:	movs	r1, #2
    c720:	b.n	c0f2 <_dtoa_r+0x60a>
    c722:	ldr	r3, [sp, #4]
    c724:	cmp	r3, #2
    c726:	bgt.n	c72c <_dtoa_r+0xc44>
    c728:	ldr	r7, [sp, #52]	; 0x34
    c72a:	b.n	c28a <_dtoa_r+0x7a2>
    c72c:	ldr	r7, [sp, #52]	; 0x34
    c72e:	b.n	c3d4 <_dtoa_r+0x8ec>
    c730:	movs	r3, #1
    c732:	str	r3, [sp, #56]	; 0x38
    c734:	b.w	bc7a <_dtoa_r+0x192>
    c738:	beq.w	bf5a <_dtoa_r+0x472>
    c73c:	rsb	r0, r0, #60	; 0x3c
    c740:	b.n	bf4c <_dtoa_r+0x464>
    c742:	movs	r5, #0
    c744:	str	r5, [r4, #68]	; 0x44
    c746:	mov	r1, r5
    c748:	mov	r0, r4
    c74a:	bl	d220 <_Balloc>
    c74e:	mov.w	r7, #4294967295
    c752:	movs	r3, #1
    c754:	str	r0, [sp, #32]
    c756:	mov	r8, r5
    c758:	str	r0, [r4, #64]	; 0x40
    c75a:	str	r7, [sp, #52]	; 0x34
    c75c:	str	r3, [sp, #36]	; 0x24
    c75e:	b.w	bce2 <_dtoa_r+0x1fa>
    c762:	nop
    c764:	.word	0x20001158
    c768:	.word	0x20001220

0000c76c <__sflush_r>:
    c76c:	ldrsh.w	r3, [r1, #12]
    c770:	uxth	r2, r3
    c772:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c776:	mov	r5, r1
    c778:	lsls	r1, r2, #28
    c77a:	mov	r8, r0
    c77c:	bmi.n	c7f8 <__sflush_r+0x8c>
    c77e:	ldr	r2, [r5, #4]
    c780:	orr.w	r3, r3, #2048	; 0x800
    c784:	cmp	r2, #0
    c786:	strh	r3, [r5, #12]
    c788:	ble.n	c872 <__sflush_r+0x106>
    c78a:	ldr	r4, [r5, #40]	; 0x28
    c78c:	cmp	r4, #0
    c78e:	beq.n	c828 <__sflush_r+0xbc>
    c790:	uxth	r3, r3
    c792:	and.w	r2, r3, #4096	; 0x1000
    c796:	movs	r1, #0
    c798:	uxth	r2, r2
    c79a:	ldr.w	r6, [r8]
    c79e:	str.w	r1, [r8]
    c7a2:	cmp	r2, #0
    c7a4:	beq.n	c87a <__sflush_r+0x10e>
    c7a6:	ldr	r2, [r5, #80]	; 0x50
    c7a8:	lsls	r7, r3, #29
    c7aa:	bpl.n	c7b8 <__sflush_r+0x4c>
    c7ac:	ldr	r1, [r5, #4]
    c7ae:	ldr	r3, [r5, #48]	; 0x30
    c7b0:	subs	r2, r2, r1
    c7b2:	cbz	r3, c7b8 <__sflush_r+0x4c>
    c7b4:	ldr	r3, [r5, #60]	; 0x3c
    c7b6:	subs	r2, r2, r3
    c7b8:	movs	r3, #0
    c7ba:	ldr	r1, [r5, #28]
    c7bc:	mov	r0, r8
    c7be:	blx	r4
    c7c0:	adds	r4, r0, #1
    c7c2:	beq.n	c83e <__sflush_r+0xd2>
    c7c4:	ldrsh.w	r3, [r5, #12]
    c7c8:	ldr	r2, [r5, #16]
    c7ca:	str	r2, [r5, #0]
    c7cc:	bic.w	r3, r3, #2048	; 0x800
    c7d0:	movs	r2, #0
    c7d2:	strh	r3, [r5, #12]
    c7d4:	lsls	r3, r3, #19
    c7d6:	str	r2, [r5, #4]
    c7d8:	bmi.n	c86e <__sflush_r+0x102>
    c7da:	ldr	r1, [r5, #48]	; 0x30
    c7dc:	str.w	r6, [r8]
    c7e0:	cbz	r1, c828 <__sflush_r+0xbc>
    c7e2:	add.w	r3, r5, #64	; 0x40
    c7e6:	cmp	r1, r3
    c7e8:	beq.n	c7f0 <__sflush_r+0x84>
    c7ea:	mov	r0, r8
    c7ec:	bl	cb4c <_free_r>
    c7f0:	movs	r0, #0
    c7f2:	str	r0, [r5, #48]	; 0x30
    c7f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c7f8:	ldr	r6, [r5, #16]
    c7fa:	cbz	r6, c828 <__sflush_r+0xbc>
    c7fc:	ldr	r4, [r5, #0]
    c7fe:	str	r6, [r5, #0]
    c800:	lsls	r0, r2, #30
    c802:	ite	eq
    c804:	ldreq	r3, [r5, #20]
    c806:	movne	r3, #0
    c808:	subs	r4, r4, r6
    c80a:	str	r3, [r5, #8]
    c80c:	b.n	c824 <__sflush_r+0xb8>
    c80e:	mov	r3, r4
    c810:	mov	r2, r6
    c812:	ldr	r7, [r5, #36]	; 0x24
    c814:	ldr	r1, [r5, #28]
    c816:	mov	r0, r8
    c818:	blx	r7
    c81a:	cmp	r0, #0
    c81c:	sub.w	r4, r4, r0
    c820:	add	r6, r0
    c822:	ble.n	c82e <__sflush_r+0xc2>
    c824:	cmp	r4, #0
    c826:	bgt.n	c80e <__sflush_r+0xa2>
    c828:	movs	r0, #0
    c82a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c82e:	ldrh	r3, [r5, #12]
    c830:	orr.w	r3, r3, #64	; 0x40
    c834:	strh	r3, [r5, #12]
    c836:	mov.w	r0, #4294967295
    c83a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c83e:	ldr.w	r2, [r8]
    c842:	cmp	r2, #29
    c844:	bhi.n	c82e <__sflush_r+0xc2>
    c846:	ldr	r3, [pc, #104]	; (c8b0 <__sflush_r+0x144>)
    c848:	lsrs	r3, r2
    c84a:	and.w	r3, r3, #1
    c84e:	eor.w	r4, r3, #1
    c852:	cmp	r3, #0
    c854:	beq.n	c82e <__sflush_r+0xc2>
    c856:	ldrsh.w	r3, [r5, #12]
    c85a:	ldr	r1, [r5, #16]
    c85c:	str	r1, [r5, #0]
    c85e:	bic.w	r3, r3, #2048	; 0x800
    c862:	lsls	r1, r3, #19
    c864:	str	r4, [r5, #4]
    c866:	strh	r3, [r5, #12]
    c868:	bpl.n	c7da <__sflush_r+0x6e>
    c86a:	cmp	r2, #0
    c86c:	bne.n	c7da <__sflush_r+0x6e>
    c86e:	str	r0, [r5, #80]	; 0x50
    c870:	b.n	c7da <__sflush_r+0x6e>
    c872:	ldr	r2, [r5, #60]	; 0x3c
    c874:	cmp	r2, #0
    c876:	bgt.n	c78a <__sflush_r+0x1e>
    c878:	b.n	c828 <__sflush_r+0xbc>
    c87a:	movs	r3, #1
    c87c:	ldr	r1, [r5, #28]
    c87e:	mov	r0, r8
    c880:	blx	r4
    c882:	adds	r3, r0, #1
    c884:	mov	r2, r0
    c886:	beq.n	c88e <__sflush_r+0x122>
    c888:	ldrh	r3, [r5, #12]
    c88a:	ldr	r4, [r5, #40]	; 0x28
    c88c:	b.n	c7a8 <__sflush_r+0x3c>
    c88e:	ldr.w	r3, [r8]
    c892:	cmp	r3, #0
    c894:	beq.n	c888 <__sflush_r+0x11c>
    c896:	cmp	r3, #29
    c898:	beq.n	c89e <__sflush_r+0x132>
    c89a:	cmp	r3, #22
    c89c:	bne.n	c8a4 <__sflush_r+0x138>
    c89e:	str.w	r6, [r8]
    c8a2:	b.n	c828 <__sflush_r+0xbc>
    c8a4:	ldrh	r3, [r5, #12]
    c8a6:	orr.w	r3, r3, #64	; 0x40
    c8aa:	strh	r3, [r5, #12]
    c8ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c8b0:	.word	0x20400001

0000c8b4 <_fflush_r>:
    c8b4:	push	{r4, lr}
    c8b6:	mov	r4, r0
    c8b8:	sub	sp, #8
    c8ba:	cbz	r0, c8c0 <_fflush_r+0xc>
    c8bc:	ldr	r3, [r0, #56]	; 0x38
    c8be:	cbz	r3, c8d6 <_fflush_r+0x22>
    c8c0:	ldrsh.w	r0, [r1, #12]
    c8c4:	cbnz	r0, c8ca <_fflush_r+0x16>
    c8c6:	add	sp, #8
    c8c8:	pop	{r4, pc}
    c8ca:	mov	r0, r4
    c8cc:	add	sp, #8
    c8ce:	ldmia.w	sp!, {r4, lr}
    c8d2:	b.w	c76c <__sflush_r>
    c8d6:	str	r1, [sp, #4]
    c8d8:	bl	c9dc <__sinit>
    c8dc:	ldr	r1, [sp, #4]
    c8de:	b.n	c8c0 <_fflush_r+0xc>

0000c8e0 <_cleanup_r>:
    c8e0:	ldr	r1, [pc, #4]	; (c8e8 <_cleanup_r+0x8>)
    c8e2:	b.w	d020 <_fwalk_reent>
    c8e6:	nop
    c8e8:	.word	0x0000db51

0000c8ec <__sinit.part.1>:
    c8ec:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c8f0:	ldr	r3, [pc, #212]	; (c9c8 <__sinit.part.1+0xdc>)
    c8f2:	ldr	r5, [r0, #4]
    c8f4:	str	r3, [r0, #60]	; 0x3c
    c8f6:	movs	r4, #0
    c8f8:	mov	r7, r0
    c8fa:	add.w	r2, r0, #748	; 0x2ec
    c8fe:	movs	r3, #4
    c900:	movs	r1, #3
    c902:	str.w	r1, [r0, #740]	; 0x2e4
    c906:	str.w	r2, [r0, #744]	; 0x2e8
    c90a:	str.w	r4, [r0, #736]	; 0x2e0
    c90e:	sub	sp, #12
    c910:	str	r4, [r5, #0]
    c912:	str	r4, [r5, #4]
    c914:	str	r4, [r5, #8]
    c916:	str	r4, [r5, #100]	; 0x64
    c918:	strh	r4, [r5, #14]
    c91a:	str	r4, [r5, #16]
    c91c:	str	r4, [r5, #20]
    c91e:	str	r4, [r5, #24]
    c920:	strh	r3, [r5, #12]
    c922:	mov	r1, r4
    c924:	add.w	r0, r5, #92	; 0x5c
    c928:	movs	r2, #8
    c92a:	bl	8e58 <memset>
    c92e:	ldr	r6, [r7, #8]
    c930:	ldr.w	fp, [pc, #152]	; c9cc <__sinit.part.1+0xe0>
    c934:	ldr.w	sl, [pc, #152]	; c9d0 <__sinit.part.1+0xe4>
    c938:	ldr.w	r9, [pc, #152]	; c9d4 <__sinit.part.1+0xe8>
    c93c:	ldr.w	r8, [pc, #152]	; c9d8 <__sinit.part.1+0xec>
    c940:	str.w	fp, [r5, #32]
    c944:	movs	r3, #1
    c946:	movs	r2, #9
    c948:	str.w	sl, [r5, #36]	; 0x24
    c94c:	str.w	r9, [r5, #40]	; 0x28
    c950:	str.w	r8, [r5, #44]	; 0x2c
    c954:	str	r5, [r5, #28]
    c956:	mov	r1, r4
    c958:	strh	r3, [r6, #14]
    c95a:	strh	r2, [r6, #12]
    c95c:	add.w	r0, r6, #92	; 0x5c
    c960:	str	r4, [r6, #0]
    c962:	str	r4, [r6, #4]
    c964:	str	r4, [r6, #8]
    c966:	str	r4, [r6, #100]	; 0x64
    c968:	str	r4, [r6, #16]
    c96a:	str	r4, [r6, #20]
    c96c:	str	r4, [r6, #24]
    c96e:	movs	r2, #8
    c970:	str	r3, [sp, #4]
    c972:	bl	8e58 <memset>
    c976:	ldr	r5, [r7, #12]
    c978:	str	r6, [r6, #28]
    c97a:	movs	r0, #18
    c97c:	movs	r2, #2
    c97e:	str.w	fp, [r6, #32]
    c982:	str.w	sl, [r6, #36]	; 0x24
    c986:	str.w	r9, [r6, #40]	; 0x28
    c98a:	str.w	r8, [r6, #44]	; 0x2c
    c98e:	mov	r1, r4
    c990:	strh	r0, [r5, #12]
    c992:	strh	r2, [r5, #14]
    c994:	str	r4, [r5, #0]
    c996:	str	r4, [r5, #4]
    c998:	str	r4, [r5, #8]
    c99a:	str	r4, [r5, #100]	; 0x64
    c99c:	str	r4, [r5, #16]
    c99e:	str	r4, [r5, #20]
    c9a0:	str	r4, [r5, #24]
    c9a2:	add.w	r0, r5, #92	; 0x5c
    c9a6:	movs	r2, #8
    c9a8:	bl	8e58 <memset>
    c9ac:	ldr	r3, [sp, #4]
    c9ae:	str	r5, [r5, #28]
    c9b0:	str.w	fp, [r5, #32]
    c9b4:	str.w	sl, [r5, #36]	; 0x24
    c9b8:	str.w	r9, [r5, #40]	; 0x28
    c9bc:	str.w	r8, [r5, #44]	; 0x2c
    c9c0:	str	r3, [r7, #56]	; 0x38
    c9c2:	add	sp, #12
    c9c4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c9c8:	.word	0x0000c8e1
    c9cc:	.word	0x0000d845
    c9d0:	.word	0x0000d869
    c9d4:	.word	0x0000d8a5
    c9d8:	.word	0x0000d8c5

0000c9dc <__sinit>:
    c9dc:	ldr	r3, [r0, #56]	; 0x38
    c9de:	cbz	r3, c9e2 <__sinit+0x6>
    c9e0:	bx	lr
    c9e2:	b.w	c8ec <__sinit.part.1>
    c9e6:	nop

0000c9e8 <__sfp_lock_acquire>:
    c9e8:	bx	lr
    c9ea:	nop

0000c9ec <__sfp_lock_release>:
    c9ec:	bx	lr
    c9ee:	nop

0000c9f0 <__fputwc>:
    c9f0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c9f4:	sub	sp, #8
    c9f6:	mov	r8, r0
    c9f8:	mov	r9, r1
    c9fa:	mov	r4, r2
    c9fc:	bl	87d8 <__locale_mb_cur_max>
    ca00:	cmp	r0, #1
    ca02:	beq.n	ca6c <__fputwc+0x7c>
    ca04:	add.w	r3, r4, #92	; 0x5c
    ca08:	mov	r2, r9
    ca0a:	add	r1, sp, #4
    ca0c:	mov	r0, r8
    ca0e:	bl	da78 <_wcrtomb_r>
    ca12:	cmp.w	r0, #4294967295
    ca16:	mov	sl, r0
    ca18:	beq.n	ca5e <__fputwc+0x6e>
    ca1a:	cbz	r0, ca80 <__fputwc+0x90>
    ca1c:	ldrb.w	r6, [sp, #4]
    ca20:	movs	r5, #0
    ca22:	b.n	ca36 <__fputwc+0x46>
    ca24:	ldr	r3, [r4, #0]
    ca26:	adds	r2, r3, #1
    ca28:	str	r2, [r4, #0]
    ca2a:	strb	r6, [r3, #0]
    ca2c:	adds	r5, #1
    ca2e:	cmp	r5, sl
    ca30:	bcs.n	ca80 <__fputwc+0x90>
    ca32:	add	r3, sp, #4
    ca34:	ldrb	r6, [r3, r5]
    ca36:	ldr	r3, [r4, #8]
    ca38:	subs	r3, #1
    ca3a:	cmp	r3, #0
    ca3c:	str	r3, [r4, #8]
    ca3e:	bge.n	ca24 <__fputwc+0x34>
    ca40:	ldr	r7, [r4, #24]
    ca42:	cmp	r3, r7
    ca44:	mov	r1, r6
    ca46:	mov	r2, r4
    ca48:	mov	r0, r8
    ca4a:	blt.n	ca50 <__fputwc+0x60>
    ca4c:	cmp	r6, #10
    ca4e:	bne.n	ca24 <__fputwc+0x34>
    ca50:	bl	d9cc <__swbuf_r>
    ca54:	adds	r3, r0, #1
    ca56:	bne.n	ca2c <__fputwc+0x3c>
    ca58:	add	sp, #8
    ca5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ca5e:	ldrh	r3, [r4, #12]
    ca60:	orr.w	r3, r3, #64	; 0x40
    ca64:	strh	r3, [r4, #12]
    ca66:	add	sp, #8
    ca68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ca6c:	add.w	r3, r9, #4294967295
    ca70:	cmp	r3, #254	; 0xfe
    ca72:	bhi.n	ca04 <__fputwc+0x14>
    ca74:	uxtb.w	r6, r9
    ca78:	mov	sl, r0
    ca7a:	strb.w	r6, [sp, #4]
    ca7e:	b.n	ca20 <__fputwc+0x30>
    ca80:	mov	r0, r9
    ca82:	add	sp, #8
    ca84:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000ca88 <_fputwc_r>:
    ca88:	ldrsh.w	r3, [r2, #12]
    ca8c:	tst.w	r3, #8192	; 0x2000
    ca90:	bne.n	caaa <_fputwc_r+0x22>
    ca92:	push	{r4}
    ca94:	ldr	r4, [r2, #100]	; 0x64
    ca96:	orr.w	r3, r3, #8192	; 0x2000
    ca9a:	orr.w	r4, r4, #8192	; 0x2000
    ca9e:	str	r4, [r2, #100]	; 0x64
    caa0:	strh	r3, [r2, #12]
    caa2:	ldr.w	r4, [sp], #4
    caa6:	b.w	c9f0 <__fputwc>
    caaa:	b.w	c9f0 <__fputwc>
    caae:	nop

0000cab0 <_malloc_trim_r>:
    cab0:	push	{r3, r4, r5, r6, r7, lr}
    cab2:	ldr	r7, [pc, #140]	; (cb40 <_malloc_trim_r+0x90>)
    cab4:	mov	r4, r1
    cab6:	mov	r6, r0
    cab8:	bl	8ef4 <__malloc_lock>
    cabc:	ldr	r3, [r7, #8]
    cabe:	ldr	r5, [r3, #4]
    cac0:	bic.w	r5, r5, #3
    cac4:	subs	r1, r5, r4
    cac6:	addw	r1, r1, #4079	; 0xfef
    caca:	bic.w	r1, r1, #4080	; 0xff0
    cace:	bic.w	r1, r1, #15
    cad2:	sub.w	r4, r1, #4096	; 0x1000
    cad6:	cmp.w	r4, #4096	; 0x1000
    cada:	blt.n	caec <_malloc_trim_r+0x3c>
    cadc:	movs	r1, #0
    cade:	mov	r0, r6
    cae0:	bl	92dc <_sbrk_r>
    cae4:	ldr	r3, [r7, #8]
    cae6:	add	r3, r5
    cae8:	cmp	r0, r3
    caea:	beq.n	caf6 <_malloc_trim_r+0x46>
    caec:	mov	r0, r6
    caee:	bl	8ef8 <__malloc_unlock>
    caf2:	movs	r0, #0
    caf4:	pop	{r3, r4, r5, r6, r7, pc}
    caf6:	negs	r1, r4
    caf8:	mov	r0, r6
    cafa:	bl	92dc <_sbrk_r>
    cafe:	adds	r0, #1
    cb00:	beq.n	cb1e <_malloc_trim_r+0x6e>
    cb02:	ldr	r3, [pc, #64]	; (cb44 <_malloc_trim_r+0x94>)
    cb04:	ldr	r2, [r7, #8]
    cb06:	ldr	r1, [r3, #0]
    cb08:	subs	r5, r5, r4
    cb0a:	orr.w	r5, r5, #1
    cb0e:	mov	r0, r6
    cb10:	subs	r1, r1, r4
    cb12:	str	r5, [r2, #4]
    cb14:	str	r1, [r3, #0]
    cb16:	bl	8ef8 <__malloc_unlock>
    cb1a:	movs	r0, #1
    cb1c:	pop	{r3, r4, r5, r6, r7, pc}
    cb1e:	movs	r1, #0
    cb20:	mov	r0, r6
    cb22:	bl	92dc <_sbrk_r>
    cb26:	ldr	r2, [r7, #8]
    cb28:	subs	r3, r0, r2
    cb2a:	cmp	r3, #15
    cb2c:	ble.n	caec <_malloc_trim_r+0x3c>
    cb2e:	ldr	r4, [pc, #24]	; (cb48 <_malloc_trim_r+0x98>)
    cb30:	ldr	r1, [pc, #16]	; (cb44 <_malloc_trim_r+0x94>)
    cb32:	ldr	r4, [r4, #0]
    cb34:	orr.w	r3, r3, #1
    cb38:	subs	r0, r0, r4
    cb3a:	str	r3, [r2, #4]
    cb3c:	str	r0, [r1, #0]
    cb3e:	b.n	caec <_malloc_trim_r+0x3c>
    cb40:	.word	0x20001840
    cb44:	.word	0x20002468
    cb48:	.word	0x20001c4c

0000cb4c <_free_r>:
    cb4c:	cmp	r1, #0
    cb4e:	beq.n	cbdc <_free_r+0x90>
    cb50:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cb54:	mov	r5, r1
    cb56:	mov	r8, r0
    cb58:	bl	8ef4 <__malloc_lock>
    cb5c:	ldr.w	r7, [r5, #-4]
    cb60:	ldr	r1, [pc, #424]	; (cd0c <_free_r+0x1c0>)
    cb62:	bic.w	r3, r7, #1
    cb66:	sub.w	r4, r5, #8
    cb6a:	adds	r2, r4, r3
    cb6c:	ldr	r6, [r1, #8]
    cb6e:	ldr	r0, [r2, #4]
    cb70:	cmp	r2, r6
    cb72:	bic.w	r0, r0, #3
    cb76:	beq.n	cc3e <_free_r+0xf2>
    cb78:	lsls	r6, r7, #31
    cb7a:	str	r0, [r2, #4]
    cb7c:	bmi.n	cb96 <_free_r+0x4a>
    cb7e:	ldr.w	r7, [r5, #-8]
    cb82:	subs	r4, r4, r7
    cb84:	add.w	lr, r1, #8
    cb88:	ldr	r5, [r4, #8]
    cb8a:	cmp	r5, lr
    cb8c:	add	r3, r7
    cb8e:	beq.n	cc70 <_free_r+0x124>
    cb90:	ldr	r7, [r4, #12]
    cb92:	str	r7, [r5, #12]
    cb94:	str	r5, [r7, #8]
    cb96:	adds	r5, r2, r0
    cb98:	ldr	r5, [r5, #4]
    cb9a:	lsls	r5, r5, #31
    cb9c:	bpl.n	cc24 <_free_r+0xd8>
    cb9e:	orr.w	r2, r3, #1
    cba2:	str	r2, [r4, #4]
    cba4:	str	r3, [r4, r3]
    cba6:	cmp.w	r3, #512	; 0x200
    cbaa:	bcs.n	cbde <_free_r+0x92>
    cbac:	lsrs	r3, r3, #3
    cbae:	adds	r2, r3, #1
    cbb0:	ldr	r5, [r1, #4]
    cbb2:	ldr.w	r7, [r1, r2, lsl #3]
    cbb6:	str	r7, [r4, #8]
    cbb8:	movs	r0, #1
    cbba:	asrs	r3, r3, #2
    cbbc:	lsl.w	r3, r0, r3
    cbc0:	add.w	r0, r1, r2, lsl #3
    cbc4:	orrs	r5, r3
    cbc6:	subs	r0, #8
    cbc8:	str	r0, [r4, #12]
    cbca:	str	r5, [r1, #4]
    cbcc:	str.w	r4, [r1, r2, lsl #3]
    cbd0:	str	r4, [r7, #12]
    cbd2:	mov	r0, r8
    cbd4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    cbd8:	b.w	8ef8 <__malloc_unlock>
    cbdc:	bx	lr
    cbde:	lsrs	r2, r3, #9
    cbe0:	cmp	r2, #4
    cbe2:	bhi.n	cc8c <_free_r+0x140>
    cbe4:	lsrs	r2, r3, #6
    cbe6:	add.w	r7, r2, #57	; 0x39
    cbea:	lsls	r7, r7, #1
    cbec:	add.w	r5, r2, #56	; 0x38
    cbf0:	add.w	r0, r1, r7, lsl #2
    cbf4:	ldr.w	r2, [r1, r7, lsl #2]
    cbf8:	ldr	r1, [pc, #272]	; (cd0c <_free_r+0x1c0>)
    cbfa:	subs	r0, #8
    cbfc:	cmp	r0, r2
    cbfe:	beq.n	cc9c <_free_r+0x150>
    cc00:	ldr	r1, [r2, #4]
    cc02:	bic.w	r1, r1, #3
    cc06:	cmp	r3, r1
    cc08:	bcs.n	cc10 <_free_r+0xc4>
    cc0a:	ldr	r2, [r2, #8]
    cc0c:	cmp	r0, r2
    cc0e:	bne.n	cc00 <_free_r+0xb4>
    cc10:	ldr	r0, [r2, #12]
    cc12:	str	r0, [r4, #12]
    cc14:	str	r2, [r4, #8]
    cc16:	str	r4, [r0, #8]
    cc18:	str	r4, [r2, #12]
    cc1a:	mov	r0, r8
    cc1c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    cc20:	b.w	8ef8 <__malloc_unlock>
    cc24:	ldr	r5, [r2, #8]
    cc26:	ldr	r7, [pc, #232]	; (cd10 <_free_r+0x1c4>)
    cc28:	cmp	r5, r7
    cc2a:	add	r3, r0
    cc2c:	beq.n	ccae <_free_r+0x162>
    cc2e:	ldr	r0, [r2, #12]
    cc30:	str	r0, [r5, #12]
    cc32:	orr.w	r2, r3, #1
    cc36:	str	r5, [r0, #8]
    cc38:	str	r2, [r4, #4]
    cc3a:	str	r3, [r4, r3]
    cc3c:	b.n	cba6 <_free_r+0x5a>
    cc3e:	lsls	r7, r7, #31
    cc40:	add	r3, r0
    cc42:	bmi.n	cc54 <_free_r+0x108>
    cc44:	ldr.w	r2, [r5, #-8]
    cc48:	subs	r4, r4, r2
    cc4a:	add	r3, r2
    cc4c:	ldr	r0, [r4, #8]
    cc4e:	ldr	r2, [r4, #12]
    cc50:	str	r2, [r0, #12]
    cc52:	str	r0, [r2, #8]
    cc54:	ldr	r2, [pc, #188]	; (cd14 <_free_r+0x1c8>)
    cc56:	ldr	r2, [r2, #0]
    cc58:	orr.w	r0, r3, #1
    cc5c:	cmp	r3, r2
    cc5e:	str	r0, [r4, #4]
    cc60:	str	r4, [r1, #8]
    cc62:	bcc.n	cbd2 <_free_r+0x86>
    cc64:	ldr	r3, [pc, #176]	; (cd18 <_free_r+0x1cc>)
    cc66:	mov	r0, r8
    cc68:	ldr	r1, [r3, #0]
    cc6a:	bl	cab0 <_malloc_trim_r>
    cc6e:	b.n	cbd2 <_free_r+0x86>
    cc70:	adds	r1, r2, r0
    cc72:	ldr	r1, [r1, #4]
    cc74:	lsls	r1, r1, #31
    cc76:	bmi.n	cd02 <_free_r+0x1b6>
    cc78:	ldr	r1, [r2, #8]
    cc7a:	ldr	r2, [r2, #12]
    cc7c:	str	r2, [r1, #12]
    cc7e:	add	r3, r0
    cc80:	orr.w	r0, r3, #1
    cc84:	str	r1, [r2, #8]
    cc86:	str	r0, [r4, #4]
    cc88:	str	r3, [r4, r3]
    cc8a:	b.n	cbd2 <_free_r+0x86>
    cc8c:	cmp	r2, #20
    cc8e:	bhi.n	ccc0 <_free_r+0x174>
    cc90:	add.w	r7, r2, #92	; 0x5c
    cc94:	lsls	r7, r7, #1
    cc96:	add.w	r5, r2, #91	; 0x5b
    cc9a:	b.n	cbf0 <_free_r+0xa4>
    cc9c:	asrs	r2, r5, #2
    cc9e:	ldr	r3, [r1, #4]
    cca0:	movs	r5, #1
    cca2:	lsl.w	r2, r5, r2
    cca6:	orrs	r3, r2
    cca8:	str	r3, [r1, #4]
    ccaa:	mov	r2, r0
    ccac:	b.n	cc12 <_free_r+0xc6>
    ccae:	orr.w	r2, r3, #1
    ccb2:	str	r4, [r1, #20]
    ccb4:	str	r4, [r1, #16]
    ccb6:	str	r5, [r4, #12]
    ccb8:	str	r5, [r4, #8]
    ccba:	str	r2, [r4, #4]
    ccbc:	str	r3, [r4, r3]
    ccbe:	b.n	cbd2 <_free_r+0x86>
    ccc0:	cmp	r2, #84	; 0x54
    ccc2:	bhi.n	ccd2 <_free_r+0x186>
    ccc4:	lsrs	r2, r3, #12
    ccc6:	add.w	r7, r2, #111	; 0x6f
    ccca:	lsls	r7, r7, #1
    cccc:	add.w	r5, r2, #110	; 0x6e
    ccd0:	b.n	cbf0 <_free_r+0xa4>
    ccd2:	cmp.w	r2, #340	; 0x154
    ccd6:	bhi.n	cce6 <_free_r+0x19a>
    ccd8:	lsrs	r2, r3, #15
    ccda:	add.w	r7, r2, #120	; 0x78
    ccde:	lsls	r7, r7, #1
    cce0:	add.w	r5, r2, #119	; 0x77
    cce4:	b.n	cbf0 <_free_r+0xa4>
    cce6:	movw	r0, #1364	; 0x554
    ccea:	cmp	r2, r0
    ccec:	bhi.n	ccfc <_free_r+0x1b0>
    ccee:	lsrs	r2, r3, #18
    ccf0:	add.w	r7, r2, #125	; 0x7d
    ccf4:	lsls	r7, r7, #1
    ccf6:	add.w	r5, r2, #124	; 0x7c
    ccfa:	b.n	cbf0 <_free_r+0xa4>
    ccfc:	movs	r7, #254	; 0xfe
    ccfe:	movs	r5, #126	; 0x7e
    cd00:	b.n	cbf0 <_free_r+0xa4>
    cd02:	orr.w	r2, r3, #1
    cd06:	str	r2, [r4, #4]
    cd08:	str	r3, [r4, r3]
    cd0a:	b.n	cbd2 <_free_r+0x86>
    cd0c:	.word	0x20001840
    cd10:	.word	0x20001848
    cd14:	.word	0x20001c48
    cd18:	.word	0x20002464

0000cd1c <__sfvwrite_r>:
    cd1c:	ldr	r3, [r2, #8]
    cd1e:	cmp	r3, #0
    cd20:	beq.n	ce10 <__sfvwrite_r+0xf4>
    cd22:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cd26:	ldrh	r3, [r1, #12]
    cd28:	sub	sp, #20
    cd2a:	mov	r4, r1
    cd2c:	lsls	r1, r3, #28
    cd2e:	str	r0, [sp, #4]
    cd30:	mov	r6, r2
    cd32:	bpl.n	cd88 <__sfvwrite_r+0x6c>
    cd34:	ldr	r2, [r4, #16]
    cd36:	cbz	r2, cd88 <__sfvwrite_r+0x6c>
    cd38:	and.w	r8, r3, #2
    cd3c:	uxth.w	r0, r8
    cd40:	ldr	r5, [r6, #0]
    cd42:	cmp	r0, #0
    cd44:	beq.n	cda6 <__sfvwrite_r+0x8a>
    cd46:	mov.w	r9, #0
    cd4a:	ldr	r7, [pc, #720]	; (d01c <__sfvwrite_r+0x300>)
    cd4c:	mov	r8, r9
    cd4e:	mov	sl, r6
    cd50:	cmp	r8, r7
    cd52:	mov	r3, r8
    cd54:	mov	r2, r9
    cd56:	it	cs
    cd58:	movcs	r3, r7
    cd5a:	ldr	r0, [sp, #4]
    cd5c:	cmp.w	r8, #0
    cd60:	beq.n	ce04 <__sfvwrite_r+0xe8>
    cd62:	ldr	r1, [r4, #28]
    cd64:	ldr	r6, [r4, #36]	; 0x24
    cd66:	blx	r6
    cd68:	cmp	r0, #0
    cd6a:	ble.n	ce50 <__sfvwrite_r+0x134>
    cd6c:	ldr.w	r3, [sl, #8]
    cd70:	subs	r3, r3, r0
    cd72:	add	r9, r0
    cd74:	rsb	r8, r0, r8
    cd78:	str.w	r3, [sl, #8]
    cd7c:	cmp	r3, #0
    cd7e:	bne.n	cd50 <__sfvwrite_r+0x34>
    cd80:	movs	r0, #0
    cd82:	add	sp, #20
    cd84:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd88:	mov	r1, r4
    cd8a:	ldr	r0, [sp, #4]
    cd8c:	bl	b8f8 <__swsetup_r>
    cd90:	cmp	r0, #0
    cd92:	bne.w	d00a <__sfvwrite_r+0x2ee>
    cd96:	ldrh	r3, [r4, #12]
    cd98:	ldr	r5, [r6, #0]
    cd9a:	and.w	r8, r3, #2
    cd9e:	uxth.w	r0, r8
    cda2:	cmp	r0, #0
    cda4:	bne.n	cd46 <__sfvwrite_r+0x2a>
    cda6:	ands.w	r9, r3, #1
    cdaa:	bne.n	ce64 <__sfvwrite_r+0x148>
    cdac:	mov	r7, r9
    cdae:	str	r6, [sp, #8]
    cdb0:	cbz	r7, cdfa <__sfvwrite_r+0xde>
    cdb2:	lsls	r2, r3, #22
    cdb4:	ldr.w	r8, [r4, #8]
    cdb8:	bpl.n	ce14 <__sfvwrite_r+0xf8>
    cdba:	cmp	r7, r8
    cdbc:	mov	sl, r8
    cdbe:	bcc.w	cf0a <__sfvwrite_r+0x1ee>
    cdc2:	tst.w	r3, #1152	; 0x480
    cdc6:	bne.w	cf2c <__sfvwrite_r+0x210>
    cdca:	ldr	r0, [r4, #0]
    cdcc:	mov	r2, sl
    cdce:	mov	r1, r9
    cdd0:	bl	8d90 <memmove>
    cdd4:	ldr	r0, [r4, #8]
    cdd6:	ldr	r3, [r4, #0]
    cdd8:	rsb	r0, r8, r0
    cddc:	add	r3, sl
    cdde:	str	r0, [r4, #8]
    cde0:	str	r3, [r4, #0]
    cde2:	mov	r0, r7
    cde4:	ldr	r2, [sp, #8]
    cde6:	ldr	r3, [r2, #8]
    cde8:	subs	r3, r3, r0
    cdea:	add	r9, r0
    cdec:	subs	r7, r7, r0
    cdee:	str	r3, [r2, #8]
    cdf0:	cmp	r3, #0
    cdf2:	beq.n	cd80 <__sfvwrite_r+0x64>
    cdf4:	ldrh	r3, [r4, #12]
    cdf6:	cmp	r7, #0
    cdf8:	bne.n	cdb2 <__sfvwrite_r+0x96>
    cdfa:	ldr.w	r9, [r5]
    cdfe:	ldr	r7, [r5, #4]
    ce00:	adds	r5, #8
    ce02:	b.n	cdb0 <__sfvwrite_r+0x94>
    ce04:	ldr.w	r9, [r5]
    ce08:	ldr.w	r8, [r5, #4]
    ce0c:	adds	r5, #8
    ce0e:	b.n	cd50 <__sfvwrite_r+0x34>
    ce10:	movs	r0, #0
    ce12:	bx	lr
    ce14:	ldr	r0, [r4, #0]
    ce16:	ldr	r3, [r4, #16]
    ce18:	cmp	r0, r3
    ce1a:	bhi.n	ce24 <__sfvwrite_r+0x108>
    ce1c:	ldr	r1, [r4, #20]
    ce1e:	cmp	r7, r1
    ce20:	bcs.w	cf92 <__sfvwrite_r+0x276>
    ce24:	cmp	r8, r7
    ce26:	it	cs
    ce28:	movcs	r8, r7
    ce2a:	mov	r2, r8
    ce2c:	mov	r1, r9
    ce2e:	bl	8d90 <memmove>
    ce32:	ldr	r3, [r4, #8]
    ce34:	ldr	r2, [r4, #0]
    ce36:	rsb	r3, r8, r3
    ce3a:	add	r2, r8
    ce3c:	str	r3, [r4, #8]
    ce3e:	str	r2, [r4, #0]
    ce40:	cmp	r3, #0
    ce42:	bne.n	ced8 <__sfvwrite_r+0x1bc>
    ce44:	mov	r1, r4
    ce46:	ldr	r0, [sp, #4]
    ce48:	bl	c8b4 <_fflush_r>
    ce4c:	cmp	r0, #0
    ce4e:	beq.n	ced8 <__sfvwrite_r+0x1bc>
    ce50:	ldrsh.w	r3, [r4, #12]
    ce54:	orr.w	r3, r3, #64	; 0x40
    ce58:	mov.w	r0, #4294967295
    ce5c:	strh	r3, [r4, #12]
    ce5e:	add	sp, #20
    ce60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ce64:	mov	r8, r0
    ce66:	str	r0, [sp, #8]
    ce68:	mov	sl, r0
    ce6a:	mov	r9, r0
    ce6c:	cmp.w	r9, #0
    ce70:	beq.n	cec8 <__sfvwrite_r+0x1ac>
    ce72:	ldr	r3, [sp, #8]
    ce74:	cmp	r3, #0
    ce76:	beq.n	cf12 <__sfvwrite_r+0x1f6>
    ce78:	ldr	r0, [r4, #0]
    ce7a:	ldr	r3, [r4, #16]
    ce7c:	ldr	r2, [r4, #20]
    ce7e:	cmp	r8, r9
    ce80:	mov	fp, r8
    ce82:	it	cs
    ce84:	movcs	fp, r9
    ce86:	cmp	r0, r3
    ce88:	mov	r7, fp
    ce8a:	bls.n	ce96 <__sfvwrite_r+0x17a>
    ce8c:	ldr	r3, [r4, #8]
    ce8e:	add	r3, r2
    ce90:	cmp	fp, r3
    ce92:	bgt.w	cfb6 <__sfvwrite_r+0x29a>
    ce96:	cmp	fp, r2
    ce98:	blt.n	cedc <__sfvwrite_r+0x1c0>
    ce9a:	mov	r3, r2
    ce9c:	ldr	r7, [r4, #36]	; 0x24
    ce9e:	ldr	r1, [r4, #28]
    cea0:	ldr	r0, [sp, #4]
    cea2:	mov	r2, sl
    cea4:	blx	r7
    cea6:	subs	r7, r0, #0
    cea8:	ble.n	ce50 <__sfvwrite_r+0x134>
    ceaa:	subs.w	r8, r8, r7
    ceae:	beq.n	cef8 <__sfvwrite_r+0x1dc>
    ceb0:	ldr	r3, [r6, #8]
    ceb2:	subs	r3, r3, r7
    ceb4:	add	sl, r7
    ceb6:	rsb	r9, r7, r9
    ceba:	str	r3, [r6, #8]
    cebc:	cmp	r3, #0
    cebe:	beq.w	cd80 <__sfvwrite_r+0x64>
    cec2:	cmp.w	r9, #0
    cec6:	bne.n	ce72 <__sfvwrite_r+0x156>
    cec8:	movs	r3, #0
    ceca:	ldr.w	sl, [r5]
    cece:	ldr.w	r9, [r5, #4]
    ced2:	str	r3, [sp, #8]
    ced4:	adds	r5, #8
    ced6:	b.n	ce6c <__sfvwrite_r+0x150>
    ced8:	mov	r0, r8
    ceda:	b.n	cde4 <__sfvwrite_r+0xc8>
    cedc:	mov	r2, fp
    cede:	mov	r1, sl
    cee0:	bl	8d90 <memmove>
    cee4:	ldr	r2, [r4, #8]
    cee6:	ldr	r3, [r4, #0]
    cee8:	rsb	r2, fp, r2
    ceec:	add	r3, fp
    ceee:	subs.w	r8, r8, r7
    cef2:	str	r2, [r4, #8]
    cef4:	str	r3, [r4, #0]
    cef6:	bne.n	ceb0 <__sfvwrite_r+0x194>
    cef8:	mov	r1, r4
    cefa:	ldr	r0, [sp, #4]
    cefc:	bl	c8b4 <_fflush_r>
    cf00:	cmp	r0, #0
    cf02:	bne.n	ce50 <__sfvwrite_r+0x134>
    cf04:	str.w	r8, [sp, #8]
    cf08:	b.n	ceb0 <__sfvwrite_r+0x194>
    cf0a:	ldr	r0, [r4, #0]
    cf0c:	mov	r8, r7
    cf0e:	mov	sl, r7
    cf10:	b.n	cdcc <__sfvwrite_r+0xb0>
    cf12:	mov	r2, r9
    cf14:	movs	r1, #10
    cf16:	mov	r0, sl
    cf18:	bl	d180 <memchr>
    cf1c:	cmp	r0, #0
    cf1e:	beq.n	d000 <__sfvwrite_r+0x2e4>
    cf20:	adds	r0, #1
    cf22:	movs	r3, #1
    cf24:	rsb	r8, sl, r0
    cf28:	str	r3, [sp, #8]
    cf2a:	b.n	ce78 <__sfvwrite_r+0x15c>
    cf2c:	ldr	r2, [r4, #20]
    cf2e:	ldr	r0, [r4, #0]
    cf30:	ldr	r1, [r4, #16]
    cf32:	add.w	r8, r2, r2, lsl #1
    cf36:	rsb	sl, r1, r0
    cf3a:	add.w	r8, r8, r8, lsr #31
    cf3e:	add.w	r0, sl, #1
    cf42:	mov.w	r8, r8, asr #1
    cf46:	add	r0, r7
    cf48:	cmp	r0, r8
    cf4a:	mov	r2, r8
    cf4c:	itt	hi
    cf4e:	movhi	r8, r0
    cf50:	movhi	r2, r8
    cf52:	lsls	r3, r3, #21
    cf54:	bpl.n	cfdc <__sfvwrite_r+0x2c0>
    cf56:	mov	r1, r2
    cf58:	ldr	r0, [sp, #4]
    cf5a:	bl	87f4 <_malloc_r>
    cf5e:	mov	fp, r0
    cf60:	cmp	r0, #0
    cf62:	beq.n	d010 <__sfvwrite_r+0x2f4>
    cf64:	mov	r2, sl
    cf66:	ldr	r1, [r4, #16]
    cf68:	bl	2df0 <memcpy>
    cf6c:	ldrh	r3, [r4, #12]
    cf6e:	bic.w	r3, r3, #1152	; 0x480
    cf72:	orr.w	r3, r3, #128	; 0x80
    cf76:	strh	r3, [r4, #12]
    cf78:	rsb	r3, sl, r8
    cf7c:	add.w	r0, fp, sl
    cf80:	str.w	r8, [r4, #20]
    cf84:	str.w	fp, [r4, #16]
    cf88:	str	r0, [r4, #0]
    cf8a:	str	r3, [r4, #8]
    cf8c:	mov	r8, r7
    cf8e:	mov	sl, r7
    cf90:	b.n	cdcc <__sfvwrite_r+0xb0>
    cf92:	mvn.w	r3, #2147483648	; 0x80000000
    cf96:	cmp	r3, r7
    cf98:	it	cs
    cf9a:	movcs	r3, r7
    cf9c:	mov	r2, r9
    cf9e:	sdiv	r3, r3, r1
    cfa2:	ldr	r0, [sp, #4]
    cfa4:	ldr	r6, [r4, #36]	; 0x24
    cfa6:	mul.w	r3, r1, r3
    cfaa:	ldr	r1, [r4, #28]
    cfac:	blx	r6
    cfae:	cmp	r0, #0
    cfb0:	bgt.w	cde4 <__sfvwrite_r+0xc8>
    cfb4:	b.n	ce50 <__sfvwrite_r+0x134>
    cfb6:	mov	r2, r3
    cfb8:	mov	r1, sl
    cfba:	str	r3, [sp, #12]
    cfbc:	bl	8d90 <memmove>
    cfc0:	ldr	r2, [r4, #0]
    cfc2:	ldr	r3, [sp, #12]
    cfc4:	ldr	r0, [sp, #4]
    cfc6:	add	r2, r3
    cfc8:	str	r2, [r4, #0]
    cfca:	mov	r1, r4
    cfcc:	bl	c8b4 <_fflush_r>
    cfd0:	ldr	r3, [sp, #12]
    cfd2:	cmp	r0, #0
    cfd4:	bne.w	ce50 <__sfvwrite_r+0x134>
    cfd8:	mov	r7, r3
    cfda:	b.n	ceaa <__sfvwrite_r+0x18e>
    cfdc:	ldr	r0, [sp, #4]
    cfde:	bl	8efc <_realloc_r>
    cfe2:	mov	fp, r0
    cfe4:	cmp	r0, #0
    cfe6:	bne.n	cf78 <__sfvwrite_r+0x25c>
    cfe8:	ldr	r5, [sp, #4]
    cfea:	ldr	r1, [r4, #16]
    cfec:	mov	r0, r5
    cfee:	bl	cb4c <_free_r>
    cff2:	ldrsh.w	r3, [r4, #12]
    cff6:	movs	r2, #12
    cff8:	bic.w	r3, r3, #128	; 0x80
    cffc:	str	r2, [r5, #0]
    cffe:	b.n	ce54 <__sfvwrite_r+0x138>
    d000:	movs	r3, #1
    d002:	add.w	r8, r9, #1
    d006:	str	r3, [sp, #8]
    d008:	b.n	ce78 <__sfvwrite_r+0x15c>
    d00a:	mov.w	r0, #4294967295
    d00e:	b.n	cd82 <__sfvwrite_r+0x66>
    d010:	ldr	r2, [sp, #4]
    d012:	movs	r3, #12
    d014:	str	r3, [r2, #0]
    d016:	ldrsh.w	r3, [r4, #12]
    d01a:	b.n	ce54 <__sfvwrite_r+0x138>
    d01c:	.word	0x7ffffc00

0000d020 <_fwalk_reent>:
    d020:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d024:	adds.w	r7, r0, #736	; 0x2e0
    d028:	beq.n	d06a <_fwalk_reent+0x4a>
    d02a:	mov	r8, r1
    d02c:	mov	r6, r0
    d02e:	mov.w	r9, #0
    d032:	ldr	r5, [r7, #4]
    d034:	ldr	r4, [r7, #8]
    d036:	subs	r5, #1
    d038:	bmi.n	d05e <_fwalk_reent+0x3e>
    d03a:	ldrh	r3, [r4, #12]
    d03c:	cmp	r3, #1
    d03e:	add.w	r5, r5, #4294967295
    d042:	bls.n	d056 <_fwalk_reent+0x36>
    d044:	ldrsh.w	r3, [r4, #14]
    d048:	adds	r3, #1
    d04a:	mov	r1, r4
    d04c:	mov	r0, r6
    d04e:	beq.n	d056 <_fwalk_reent+0x36>
    d050:	blx	r8
    d052:	orr.w	r9, r9, r0
    d056:	adds	r3, r5, #1
    d058:	add.w	r4, r4, #104	; 0x68
    d05c:	bne.n	d03a <_fwalk_reent+0x1a>
    d05e:	ldr	r7, [r7, #0]
    d060:	cmp	r7, #0
    d062:	bne.n	d032 <_fwalk_reent+0x12>
    d064:	mov	r0, r9
    d066:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d06a:	mov	r9, r7
    d06c:	mov	r0, r9
    d06e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d072:	nop

0000d074 <_localeconv_r>:
    d074:	ldr	r2, [pc, #16]	; (d088 <_localeconv_r+0x14>)
    d076:	ldr	r3, [pc, #20]	; (d08c <_localeconv_r+0x18>)
    d078:	ldr	r2, [r2, #0]
    d07a:	ldr	r0, [r2, #52]	; 0x34
    d07c:	cmp	r0, #0
    d07e:	it	eq
    d080:	moveq	r0, r3
    d082:	adds	r0, #240	; 0xf0
    d084:	bx	lr
    d086:	nop
    d088:	.word	0x200016d0
    d08c:	.word	0x200016d4

0000d090 <__swhatbuf_r>:
    d090:	push	{r4, r5, r6, lr}
    d092:	mov	r5, r1
    d094:	ldrsh.w	r1, [r1, #14]
    d098:	cmp	r1, #0
    d09a:	sub	sp, #64	; 0x40
    d09c:	mov	r4, r2
    d09e:	mov	r6, r3
    d0a0:	blt.n	d0cc <__swhatbuf_r+0x3c>
    d0a2:	add	r2, sp, #4
    d0a4:	bl	dbd4 <_fstat_r>
    d0a8:	cmp	r0, #0
    d0aa:	blt.n	d0cc <__swhatbuf_r+0x3c>
    d0ac:	ldr	r2, [sp, #8]
    d0ae:	and.w	r2, r2, #61440	; 0xf000
    d0b2:	sub.w	r2, r2, #8192	; 0x2000
    d0b6:	clz	r2, r2
    d0ba:	lsrs	r2, r2, #5
    d0bc:	mov.w	r3, #1024	; 0x400
    d0c0:	mov.w	r0, #2048	; 0x800
    d0c4:	str	r2, [r6, #0]
    d0c6:	str	r3, [r4, #0]
    d0c8:	add	sp, #64	; 0x40
    d0ca:	pop	{r4, r5, r6, pc}
    d0cc:	ldrh	r0, [r5, #12]
    d0ce:	and.w	r0, r0, #128	; 0x80
    d0d2:	uxth	r2, r0
    d0d4:	movs	r0, #0
    d0d6:	str	r0, [r6, #0]
    d0d8:	cbz	r2, d0e2 <__swhatbuf_r+0x52>
    d0da:	movs	r3, #64	; 0x40
    d0dc:	str	r3, [r4, #0]
    d0de:	add	sp, #64	; 0x40
    d0e0:	pop	{r4, r5, r6, pc}
    d0e2:	mov.w	r3, #1024	; 0x400
    d0e6:	mov	r0, r2
    d0e8:	str	r3, [r4, #0]
    d0ea:	add	sp, #64	; 0x40
    d0ec:	pop	{r4, r5, r6, pc}
    d0ee:	nop

0000d0f0 <__smakebuf_r>:
    d0f0:	ldrh	r2, [r1, #12]
    d0f2:	lsls	r2, r2, #30
    d0f4:	mov	r3, r1
    d0f6:	bpl.n	d106 <__smakebuf_r+0x16>
    d0f8:	add.w	r2, r1, #67	; 0x43
    d0fc:	movs	r1, #1
    d0fe:	str	r2, [r3, #0]
    d100:	str	r2, [r3, #16]
    d102:	str	r1, [r3, #20]
    d104:	bx	lr
    d106:	push	{r4, r5, r6, r7, lr}
    d108:	sub	sp, #12
    d10a:	add	r3, sp, #4
    d10c:	mov	r2, sp
    d10e:	mov	r4, r1
    d110:	mov	r5, r0
    d112:	bl	d090 <__swhatbuf_r>
    d116:	ldr	r1, [sp, #0]
    d118:	mov	r6, r0
    d11a:	mov	r0, r5
    d11c:	bl	87f4 <_malloc_r>
    d120:	ldrsh.w	r3, [r4, #12]
    d124:	cbz	r0, d15c <__smakebuf_r+0x6c>
    d126:	ldr	r2, [sp, #4]
    d128:	ldr	r7, [pc, #72]	; (d174 <__smakebuf_r+0x84>)
    d12a:	ldr	r1, [sp, #0]
    d12c:	str	r7, [r5, #60]	; 0x3c
    d12e:	orr.w	r3, r3, #128	; 0x80
    d132:	strh	r3, [r4, #12]
    d134:	str	r0, [r4, #0]
    d136:	str	r0, [r4, #16]
    d138:	str	r1, [r4, #20]
    d13a:	cbnz	r2, d144 <__smakebuf_r+0x54>
    d13c:	orrs	r3, r6
    d13e:	strh	r3, [r4, #12]
    d140:	add	sp, #12
    d142:	pop	{r4, r5, r6, r7, pc}
    d144:	mov	r0, r5
    d146:	ldrsh.w	r1, [r4, #14]
    d14a:	bl	dbfc <_isatty_r>
    d14e:	ldrsh.w	r3, [r4, #12]
    d152:	cmp	r0, #0
    d154:	beq.n	d13c <__smakebuf_r+0x4c>
    d156:	orr.w	r3, r3, #1
    d15a:	b.n	d13c <__smakebuf_r+0x4c>
    d15c:	lsls	r2, r3, #22
    d15e:	bmi.n	d140 <__smakebuf_r+0x50>
    d160:	add.w	r2, r4, #67	; 0x43
    d164:	orr.w	r3, r3, #2
    d168:	movs	r1, #1
    d16a:	strh	r3, [r4, #12]
    d16c:	str	r2, [r4, #0]
    d16e:	str	r2, [r4, #16]
    d170:	str	r1, [r4, #20]
    d172:	b.n	d140 <__smakebuf_r+0x50>
    d174:	.word	0x0000c8e1
	...

0000d180 <memchr>:
    d180:	and.w	r1, r1, #255	; 0xff
    d184:	cmp	r2, #16
    d186:	blt.n	d1e0 <memchr+0x60>
    d188:	tst.w	r0, #7
    d18c:	beq.n	d1a0 <memchr+0x20>
    d18e:	ldrb.w	r3, [r0], #1
    d192:	subs	r2, #1
    d194:	cmp	r3, r1
    d196:	beq.n	d1f4 <memchr+0x74>
    d198:	tst.w	r0, #7
    d19c:	cbz	r2, d1f0 <memchr+0x70>
    d19e:	bne.n	d18e <memchr+0xe>
    d1a0:	push	{r4, r5, r6, r7}
    d1a2:	orr.w	r1, r1, r1, lsl #8
    d1a6:	orr.w	r1, r1, r1, lsl #16
    d1aa:	bic.w	r4, r2, #7
    d1ae:	mvns.w	r7, #0
    d1b2:	movs	r3, #0
    d1b4:	ldrd	r5, r6, [r0], #8
    d1b8:	subs	r4, #8
    d1ba:	eor.w	r5, r5, r1
    d1be:	eor.w	r6, r6, r1
    d1c2:	uadd8	r5, r5, r7
    d1c6:	sel	r5, r3, r7
    d1ca:	uadd8	r6, r6, r7
    d1ce:	sel	r6, r5, r7
    d1d2:	cbnz	r6, d1f8 <memchr+0x78>
    d1d4:	bne.n	d1b4 <memchr+0x34>
    d1d6:	pop	{r4, r5, r6, r7}
    d1d8:	and.w	r1, r1, #255	; 0xff
    d1dc:	and.w	r2, r2, #7
    d1e0:	cbz	r2, d1f0 <memchr+0x70>
    d1e2:	ldrb.w	r3, [r0], #1
    d1e6:	subs	r2, #1
    d1e8:	eor.w	r3, r3, r1
    d1ec:	cbz	r3, d1f4 <memchr+0x74>
    d1ee:	bne.n	d1e2 <memchr+0x62>
    d1f0:	movs	r0, #0
    d1f2:	bx	lr
    d1f4:	subs	r0, #1
    d1f6:	bx	lr
    d1f8:	cmp	r5, #0
    d1fa:	itte	eq
    d1fc:	moveq	r5, r6
    d1fe:	subeq	r0, #3
    d200:	subne	r0, #7
    d202:	tst.w	r5, #1
    d206:	bne.n	d218 <memchr+0x98>
    d208:	adds	r0, #1
    d20a:	tst.w	r5, #256	; 0x100
    d20e:	ittt	eq
    d210:	addeq	r0, #1
    d212:	tsteq.w	r5, #98304	; 0x18000
    d216:	addeq	r0, #1
    d218:	pop	{r4, r5, r6, r7}
    d21a:	subs	r0, #1
    d21c:	bx	lr
    d21e:	nop

0000d220 <_Balloc>:
    d220:	ldr	r3, [r0, #76]	; 0x4c
    d222:	push	{r4, r5, r6, lr}
    d224:	mov	r5, r0
    d226:	mov	r4, r1
    d228:	cbz	r3, d23e <_Balloc+0x1e>
    d22a:	ldr.w	r0, [r3, r4, lsl #2]
    d22e:	cbz	r0, d252 <_Balloc+0x32>
    d230:	ldr	r2, [r0, #0]
    d232:	str.w	r2, [r3, r4, lsl #2]
    d236:	movs	r3, #0
    d238:	str	r3, [r0, #16]
    d23a:	str	r3, [r0, #12]
    d23c:	pop	{r4, r5, r6, pc}
    d23e:	movs	r2, #33	; 0x21
    d240:	movs	r1, #4
    d242:	bl	dacc <_calloc_r>
    d246:	str	r0, [r5, #76]	; 0x4c
    d248:	mov	r3, r0
    d24a:	cmp	r0, #0
    d24c:	bne.n	d22a <_Balloc+0xa>
    d24e:	movs	r0, #0
    d250:	pop	{r4, r5, r6, pc}
    d252:	movs	r1, #1
    d254:	lsl.w	r6, r1, r4
    d258:	adds	r2, r6, #5
    d25a:	mov	r0, r5
    d25c:	lsls	r2, r2, #2
    d25e:	bl	dacc <_calloc_r>
    d262:	cmp	r0, #0
    d264:	beq.n	d24e <_Balloc+0x2e>
    d266:	str	r4, [r0, #4]
    d268:	str	r6, [r0, #8]
    d26a:	b.n	d236 <_Balloc+0x16>

0000d26c <_Bfree>:
    d26c:	cbz	r1, d27c <_Bfree+0x10>
    d26e:	ldr	r3, [r0, #76]	; 0x4c
    d270:	ldr	r2, [r1, #4]
    d272:	ldr.w	r0, [r3, r2, lsl #2]
    d276:	str	r0, [r1, #0]
    d278:	str.w	r1, [r3, r2, lsl #2]
    d27c:	bx	lr
    d27e:	nop

0000d280 <__multadd>:
    d280:	push	{r4, r5, r6, r7, lr}
    d282:	ldr	r4, [r1, #16]
    d284:	sub	sp, #12
    d286:	mov	r5, r1
    d288:	mov	r6, r0
    d28a:	add.w	lr, r1, #20
    d28e:	movs	r7, #0
    d290:	ldr.w	r0, [lr]
    d294:	uxth	r1, r0
    d296:	mla	r1, r2, r1, r3
    d29a:	lsrs	r3, r1, #16
    d29c:	lsrs	r0, r0, #16
    d29e:	mla	r3, r2, r0, r3
    d2a2:	uxth	r1, r1
    d2a4:	adds	r7, #1
    d2a6:	add.w	r1, r1, r3, lsl #16
    d2aa:	cmp	r4, r7
    d2ac:	str.w	r1, [lr], #4
    d2b0:	mov.w	r3, r3, lsr #16
    d2b4:	bgt.n	d290 <__multadd+0x10>
    d2b6:	cbz	r3, d2c8 <__multadd+0x48>
    d2b8:	ldr	r2, [r5, #8]
    d2ba:	cmp	r4, r2
    d2bc:	bge.n	d2ce <__multadd+0x4e>
    d2be:	add.w	r2, r5, r4, lsl #2
    d2c2:	adds	r4, #1
    d2c4:	str	r3, [r2, #20]
    d2c6:	str	r4, [r5, #16]
    d2c8:	mov	r0, r5
    d2ca:	add	sp, #12
    d2cc:	pop	{r4, r5, r6, r7, pc}
    d2ce:	ldr	r1, [r5, #4]
    d2d0:	str	r3, [sp, #4]
    d2d2:	adds	r1, #1
    d2d4:	mov	r0, r6
    d2d6:	bl	d220 <_Balloc>
    d2da:	ldr	r2, [r5, #16]
    d2dc:	adds	r2, #2
    d2de:	add.w	r1, r5, #12
    d2e2:	mov	r7, r0
    d2e4:	lsls	r2, r2, #2
    d2e6:	adds	r0, #12
    d2e8:	bl	2df0 <memcpy>
    d2ec:	ldr	r2, [r6, #76]	; 0x4c
    d2ee:	ldr	r1, [r5, #4]
    d2f0:	ldr	r3, [sp, #4]
    d2f2:	ldr.w	r0, [r2, r1, lsl #2]
    d2f6:	str	r0, [r5, #0]
    d2f8:	str.w	r5, [r2, r1, lsl #2]
    d2fc:	mov	r5, r7
    d2fe:	b.n	d2be <__multadd+0x3e>

0000d300 <__hi0bits>:
    d300:	lsrs	r3, r0, #16
    d302:	lsls	r3, r3, #16
    d304:	cbnz	r3, d334 <__hi0bits+0x34>
    d306:	lsls	r0, r0, #16
    d308:	movs	r3, #16
    d30a:	tst.w	r0, #4278190080	; 0xff000000
    d30e:	itt	eq
    d310:	lsleq	r0, r0, #8
    d312:	addeq	r3, #8
    d314:	tst.w	r0, #4026531840	; 0xf0000000
    d318:	itt	eq
    d31a:	lsleq	r0, r0, #4
    d31c:	addeq	r3, #4
    d31e:	tst.w	r0, #3221225472	; 0xc0000000
    d322:	itt	eq
    d324:	lsleq	r0, r0, #2
    d326:	addeq	r3, #2
    d328:	cmp	r0, #0
    d32a:	blt.n	d33c <__hi0bits+0x3c>
    d32c:	lsls	r2, r0, #1
    d32e:	bmi.n	d338 <__hi0bits+0x38>
    d330:	movs	r0, #32
    d332:	bx	lr
    d334:	movs	r3, #0
    d336:	b.n	d30a <__hi0bits+0xa>
    d338:	adds	r0, r3, #1
    d33a:	bx	lr
    d33c:	mov	r0, r3
    d33e:	bx	lr

0000d340 <__lo0bits>:
    d340:	ldr	r3, [r0, #0]
    d342:	ands.w	r2, r3, #7
    d346:	beq.n	d358 <__lo0bits+0x18>
    d348:	lsls	r1, r3, #31
    d34a:	bmi.n	d38e <__lo0bits+0x4e>
    d34c:	lsls	r2, r3, #30
    d34e:	bmi.n	d392 <__lo0bits+0x52>
    d350:	lsrs	r3, r3, #2
    d352:	str	r3, [r0, #0]
    d354:	movs	r0, #2
    d356:	bx	lr
    d358:	uxth	r1, r3
    d35a:	cbnz	r1, d360 <__lo0bits+0x20>
    d35c:	lsrs	r3, r3, #16
    d35e:	movs	r2, #16
    d360:	tst.w	r3, #255	; 0xff
    d364:	itt	eq
    d366:	lsreq	r3, r3, #8
    d368:	addeq	r2, #8
    d36a:	lsls	r1, r3, #28
    d36c:	itt	eq
    d36e:	lsreq	r3, r3, #4
    d370:	addeq	r2, #4
    d372:	lsls	r1, r3, #30
    d374:	itt	eq
    d376:	lsreq	r3, r3, #2
    d378:	addeq	r2, #2
    d37a:	lsls	r1, r3, #31
    d37c:	bmi.n	d388 <__lo0bits+0x48>
    d37e:	lsrs	r3, r3, #1
    d380:	bne.n	d386 <__lo0bits+0x46>
    d382:	movs	r0, #32
    d384:	bx	lr
    d386:	adds	r2, #1
    d388:	str	r3, [r0, #0]
    d38a:	mov	r0, r2
    d38c:	bx	lr
    d38e:	movs	r0, #0
    d390:	bx	lr
    d392:	lsrs	r3, r3, #1
    d394:	str	r3, [r0, #0]
    d396:	movs	r0, #1
    d398:	bx	lr
    d39a:	nop

0000d39c <__i2b>:
    d39c:	push	{r4, lr}
    d39e:	mov	r4, r1
    d3a0:	movs	r1, #1
    d3a2:	bl	d220 <_Balloc>
    d3a6:	movs	r2, #1
    d3a8:	str	r4, [r0, #20]
    d3aa:	str	r2, [r0, #16]
    d3ac:	pop	{r4, pc}
    d3ae:	nop

0000d3b0 <__multiply>:
    d3b0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d3b4:	ldr	r5, [r1, #16]
    d3b6:	ldr	r7, [r2, #16]
    d3b8:	cmp	r5, r7
    d3ba:	sub	sp, #12
    d3bc:	mov	r4, r1
    d3be:	mov	r6, r2
    d3c0:	bge.n	d3cc <__multiply+0x1c>
    d3c2:	mov	r2, r5
    d3c4:	mov	r4, r6
    d3c6:	mov	r5, r7
    d3c8:	mov	r6, r1
    d3ca:	mov	r7, r2
    d3cc:	ldr	r3, [r4, #8]
    d3ce:	ldr	r1, [r4, #4]
    d3d0:	add.w	r8, r5, r7
    d3d4:	cmp	r8, r3
    d3d6:	it	gt
    d3d8:	addgt	r1, #1
    d3da:	bl	d220 <_Balloc>
    d3de:	add.w	ip, r0, #20
    d3e2:	add.w	r9, ip, r8, lsl #2
    d3e6:	cmp	ip, r9
    d3e8:	str	r0, [sp, #0]
    d3ea:	bcs.n	d3f8 <__multiply+0x48>
    d3ec:	mov	r3, ip
    d3ee:	movs	r1, #0
    d3f0:	str.w	r1, [r3], #4
    d3f4:	cmp	r9, r3
    d3f6:	bhi.n	d3f0 <__multiply+0x40>
    d3f8:	add.w	r2, r6, #20
    d3fc:	add.w	sl, r2, r7, lsl #2
    d400:	add.w	r3, r4, #20
    d404:	cmp	r2, sl
    d406:	add.w	lr, r3, r5, lsl #2
    d40a:	bcs.n	d4b6 <__multiply+0x106>
    d40c:	str.w	r9, [sp, #4]
    d410:	mov	r9, r3
    d412:	ldr.w	r3, [r2], #4
    d416:	uxth.w	fp, r3
    d41a:	cmp.w	fp, #0
    d41e:	beq.n	d462 <__multiply+0xb2>
    d420:	movs	r0, #0
    d422:	mov	r7, r9
    d424:	mov	r6, ip
    d426:	mov	r5, r0
    d428:	b.n	d42c <__multiply+0x7c>
    d42a:	mov	r6, r3
    d42c:	ldr.w	r4, [r7], #4
    d430:	ldr	r0, [r6, #0]
    d432:	uxth	r1, r4
    d434:	uxth	r3, r0
    d436:	mla	r1, fp, r1, r3
    d43a:	lsrs	r4, r4, #16
    d43c:	lsrs	r0, r0, #16
    d43e:	adds	r3, r1, r5
    d440:	mla	r0, fp, r4, r0
    d444:	add.w	r0, r0, r3, lsr #16
    d448:	uxth	r1, r3
    d44a:	mov	r3, r6
    d44c:	orr.w	r1, r1, r0, lsl #16
    d450:	cmp	lr, r7
    d452:	mov.w	r5, r0, lsr #16
    d456:	str.w	r1, [r3], #4
    d45a:	bhi.n	d42a <__multiply+0x7a>
    d45c:	str	r5, [r6, #4]
    d45e:	ldr.w	r3, [r2, #-4]
    d462:	movs.w	fp, r3, lsr #16
    d466:	beq.n	d4aa <__multiply+0xfa>
    d468:	ldr.w	r3, [ip]
    d46c:	mov	r7, ip
    d46e:	mov	r0, r3
    d470:	mov	r5, r9
    d472:	movs	r1, #0
    d474:	b.n	d478 <__multiply+0xc8>
    d476:	mov	r7, r6
    d478:	ldrh	r4, [r5, #0]
    d47a:	lsrs	r0, r0, #16
    d47c:	mla	r0, fp, r4, r0
    d480:	add	r1, r0
    d482:	uxth	r4, r3
    d484:	mov	r6, r7
    d486:	orr.w	r3, r4, r1, lsl #16
    d48a:	str.w	r3, [r6], #4
    d48e:	ldr	r0, [r7, #4]
    d490:	ldr.w	r4, [r5], #4
    d494:	uxth	r3, r0
    d496:	lsrs	r4, r4, #16
    d498:	mla	r4, fp, r4, r3
    d49c:	add.w	r3, r4, r1, lsr #16
    d4a0:	cmp	lr, r5
    d4a2:	mov.w	r1, r3, lsr #16
    d4a6:	bhi.n	d476 <__multiply+0xc6>
    d4a8:	str	r3, [r7, #4]
    d4aa:	cmp	sl, r2
    d4ac:	add.w	ip, ip, #4
    d4b0:	bhi.n	d412 <__multiply+0x62>
    d4b2:	ldr.w	r9, [sp, #4]
    d4b6:	cmp.w	r8, #0
    d4ba:	ble.n	d4d4 <__multiply+0x124>
    d4bc:	ldr.w	r3, [r9, #-4]
    d4c0:	sub.w	r9, r9, #4
    d4c4:	cbz	r3, d4ce <__multiply+0x11e>
    d4c6:	b.n	d4d4 <__multiply+0x124>
    d4c8:	ldr.w	r3, [r9, #-4]!
    d4cc:	cbnz	r3, d4d4 <__multiply+0x124>
    d4ce:	subs.w	r8, r8, #1
    d4d2:	bne.n	d4c8 <__multiply+0x118>
    d4d4:	ldr	r0, [sp, #0]
    d4d6:	str.w	r8, [r0, #16]
    d4da:	add	sp, #12
    d4dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d4e0 <__pow5mult>:
    d4e0:	ands.w	r3, r2, #3
    d4e4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d4e8:	mov	r4, r2
    d4ea:	mov	r7, r0
    d4ec:	bne.n	d54c <__pow5mult+0x6c>
    d4ee:	mov	r6, r1
    d4f0:	asrs	r4, r4, #2
    d4f2:	beq.n	d52e <__pow5mult+0x4e>
    d4f4:	ldr	r5, [r7, #72]	; 0x48
    d4f6:	cbz	r5, d55e <__pow5mult+0x7e>
    d4f8:	lsls	r3, r4, #31
    d4fa:	mov.w	r8, #0
    d4fe:	bmi.n	d50e <__pow5mult+0x2e>
    d500:	asrs	r4, r4, #1
    d502:	beq.n	d52e <__pow5mult+0x4e>
    d504:	ldr	r0, [r5, #0]
    d506:	cbz	r0, d534 <__pow5mult+0x54>
    d508:	mov	r5, r0
    d50a:	lsls	r3, r4, #31
    d50c:	bpl.n	d500 <__pow5mult+0x20>
    d50e:	mov	r2, r5
    d510:	mov	r1, r6
    d512:	mov	r0, r7
    d514:	bl	d3b0 <__multiply>
    d518:	cbz	r6, d548 <__pow5mult+0x68>
    d51a:	ldr	r2, [r6, #4]
    d51c:	ldr	r3, [r7, #76]	; 0x4c
    d51e:	asrs	r4, r4, #1
    d520:	ldr.w	r1, [r3, r2, lsl #2]
    d524:	str	r1, [r6, #0]
    d526:	str.w	r6, [r3, r2, lsl #2]
    d52a:	mov	r6, r0
    d52c:	bne.n	d504 <__pow5mult+0x24>
    d52e:	mov	r0, r6
    d530:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d534:	mov	r2, r5
    d536:	mov	r1, r5
    d538:	mov	r0, r7
    d53a:	bl	d3b0 <__multiply>
    d53e:	str	r0, [r5, #0]
    d540:	str.w	r8, [r0]
    d544:	mov	r5, r0
    d546:	b.n	d50a <__pow5mult+0x2a>
    d548:	mov	r6, r0
    d54a:	b.n	d500 <__pow5mult+0x20>
    d54c:	subs	r2, r3, #1
    d54e:	ldr	r5, [pc, #44]	; (d57c <__pow5mult+0x9c>)
    d550:	movs	r3, #0
    d552:	ldr.w	r2, [r5, r2, lsl #2]
    d556:	bl	d280 <__multadd>
    d55a:	mov	r6, r0
    d55c:	b.n	d4f0 <__pow5mult+0x10>
    d55e:	movs	r1, #1
    d560:	mov	r0, r7
    d562:	bl	d220 <_Balloc>
    d566:	movw	r1, #625	; 0x271
    d56a:	movs	r2, #1
    d56c:	movs	r3, #0
    d56e:	str	r1, [r0, #20]
    d570:	str	r2, [r0, #16]
    d572:	mov	r5, r0
    d574:	str	r0, [r7, #72]	; 0x48
    d576:	str	r3, [r0, #0]
    d578:	b.n	d4f8 <__pow5mult+0x18>
    d57a:	nop
    d57c:	.word	0x20001248

0000d580 <__lshift>:
    d580:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d584:	mov	r9, r2
    d586:	ldr	r2, [r1, #16]
    d588:	ldr	r3, [r1, #8]
    d58a:	mov.w	r4, r9, asr #5
    d58e:	add.w	r8, r4, r2
    d592:	add.w	r5, r8, #1
    d596:	cmp	r5, r3
    d598:	mov	r6, r1
    d59a:	mov	sl, r0
    d59c:	ldr	r1, [r1, #4]
    d59e:	ble.n	d5aa <__lshift+0x2a>
    d5a0:	lsls	r3, r3, #1
    d5a2:	cmp	r5, r3
    d5a4:	add.w	r1, r1, #1
    d5a8:	bgt.n	d5a0 <__lshift+0x20>
    d5aa:	mov	r0, sl
    d5ac:	bl	d220 <_Balloc>
    d5b0:	cmp	r4, #0
    d5b2:	add.w	r2, r0, #20
    d5b6:	ble.n	d62a <__lshift+0xaa>
    d5b8:	add.w	r3, r2, r4, lsl #2
    d5bc:	movs	r1, #0
    d5be:	str.w	r1, [r2], #4
    d5c2:	cmp	r3, r2
    d5c4:	bne.n	d5be <__lshift+0x3e>
    d5c6:	ldr	r4, [r6, #16]
    d5c8:	add.w	r1, r6, #20
    d5cc:	ands.w	r9, r9, #31
    d5d0:	add.w	lr, r1, r4, lsl #2
    d5d4:	beq.n	d61a <__lshift+0x9a>
    d5d6:	rsb	r2, r9, #32
    d5da:	movs	r4, #0
    d5dc:	ldr	r7, [r1, #0]
    d5de:	lsl.w	ip, r7, r9
    d5e2:	orr.w	r4, ip, r4
    d5e6:	mov	ip, r3
    d5e8:	str.w	r4, [r3], #4
    d5ec:	ldr.w	r4, [r1], #4
    d5f0:	cmp	lr, r1
    d5f2:	lsr.w	r4, r4, r2
    d5f6:	bhi.n	d5dc <__lshift+0x5c>
    d5f8:	str.w	r4, [ip, #4]
    d5fc:	cbz	r4, d602 <__lshift+0x82>
    d5fe:	add.w	r5, r8, #2
    d602:	ldr.w	r3, [sl, #76]	; 0x4c
    d606:	ldr	r2, [r6, #4]
    d608:	subs	r5, #1
    d60a:	ldr.w	r1, [r3, r2, lsl #2]
    d60e:	str	r5, [r0, #16]
    d610:	str	r1, [r6, #0]
    d612:	str.w	r6, [r3, r2, lsl #2]
    d616:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d61a:	subs	r3, #4
    d61c:	ldr.w	r2, [r1], #4
    d620:	str.w	r2, [r3, #4]!
    d624:	cmp	lr, r1
    d626:	bhi.n	d61c <__lshift+0x9c>
    d628:	b.n	d602 <__lshift+0x82>
    d62a:	mov	r3, r2
    d62c:	b.n	d5c6 <__lshift+0x46>
    d62e:	nop

0000d630 <__mcmp>:
    d630:	ldr	r2, [r0, #16]
    d632:	ldr	r3, [r1, #16]
    d634:	subs	r2, r2, r3
    d636:	bne.n	d660 <__mcmp+0x30>
    d638:	lsls	r3, r3, #2
    d63a:	adds	r0, #20
    d63c:	adds	r1, #20
    d63e:	add	r1, r3
    d640:	push	{r4}
    d642:	add	r3, r0
    d644:	b.n	d64a <__mcmp+0x1a>
    d646:	cmp	r0, r3
    d648:	bcs.n	d664 <__mcmp+0x34>
    d64a:	ldr.w	r4, [r3, #-4]!
    d64e:	ldr.w	r2, [r1, #-4]!
    d652:	cmp	r4, r2
    d654:	beq.n	d646 <__mcmp+0x16>
    d656:	bcc.n	d66c <__mcmp+0x3c>
    d658:	movs	r0, #1
    d65a:	ldr.w	r4, [sp], #4
    d65e:	bx	lr
    d660:	mov	r0, r2
    d662:	bx	lr
    d664:	movs	r0, #0
    d666:	ldr.w	r4, [sp], #4
    d66a:	bx	lr
    d66c:	mov.w	r0, #4294967295
    d670:	b.n	d65a <__mcmp+0x2a>
    d672:	nop

0000d674 <__mdiff>:
    d674:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d678:	ldr	r3, [r1, #16]
    d67a:	mov	r7, r1
    d67c:	ldr	r1, [r2, #16]
    d67e:	subs	r3, r3, r1
    d680:	cmp	r3, #0
    d682:	mov	r8, r2
    d684:	bne.n	d6b6 <__mdiff+0x42>
    d686:	lsls	r1, r1, #2
    d688:	add.w	r2, r7, #20
    d68c:	add.w	r5, r8, #20
    d690:	adds	r3, r2, r1
    d692:	add	r1, r5
    d694:	b.n	d69a <__mdiff+0x26>
    d696:	cmp	r2, r3
    d698:	bcs.n	d758 <__mdiff+0xe4>
    d69a:	ldr.w	r6, [r3, #-4]!
    d69e:	ldr.w	r4, [r1, #-4]!
    d6a2:	cmp	r6, r4
    d6a4:	beq.n	d696 <__mdiff+0x22>
    d6a6:	bcs.n	d76a <__mdiff+0xf6>
    d6a8:	mov	r3, r7
    d6aa:	mov	r4, r2
    d6ac:	mov	r7, r8
    d6ae:	mov.w	r9, #1
    d6b2:	mov	r8, r3
    d6b4:	b.n	d6c4 <__mdiff+0x50>
    d6b6:	blt.n	d774 <__mdiff+0x100>
    d6b8:	add.w	r5, r7, #20
    d6bc:	add.w	r4, r2, #20
    d6c0:	mov.w	r9, #0
    d6c4:	ldr	r1, [r7, #4]
    d6c6:	bl	d220 <_Balloc>
    d6ca:	ldr.w	r3, [r8, #16]
    d6ce:	ldr	r6, [r7, #16]
    d6d0:	str.w	r9, [r0, #12]
    d6d4:	add.w	ip, r4, r3, lsl #2
    d6d8:	mov	lr, r4
    d6da:	add.w	r7, r5, r6, lsl #2
    d6de:	add.w	r4, r0, #20
    d6e2:	movs	r3, #0
    d6e4:	ldr.w	r1, [lr], #4
    d6e8:	ldr.w	r8, [r5], #4
    d6ec:	uxth	r2, r1
    d6ee:	uxtah	r3, r3, r8
    d6f2:	lsrs	r1, r1, #16
    d6f4:	subs	r2, r3, r2
    d6f6:	rsb	r3, r1, r8, lsr #16
    d6fa:	add.w	r3, r3, r2, asr #16
    d6fe:	uxth	r2, r2
    d700:	orr.w	r2, r2, r3, lsl #16
    d704:	cmp	ip, lr
    d706:	str.w	r2, [r4], #4
    d70a:	mov.w	r3, r3, asr #16
    d70e:	bhi.n	d6e4 <__mdiff+0x70>
    d710:	cmp	r7, r5
    d712:	bls.n	d744 <__mdiff+0xd0>
    d714:	mov	ip, r4
    d716:	mov	r1, r5
    d718:	ldr.w	lr, [r1], #4
    d71c:	uxtah	r2, r3, lr
    d720:	asrs	r3, r2, #16
    d722:	add.w	r3, r3, lr, lsr #16
    d726:	uxth	r2, r2
    d728:	orr.w	r2, r2, r3, lsl #16
    d72c:	cmp	r7, r1
    d72e:	str.w	r2, [ip], #4
    d732:	mov.w	r3, r3, asr #16
    d736:	bhi.n	d718 <__mdiff+0xa4>
    d738:	mvns	r5, r5
    d73a:	add	r5, r7
    d73c:	bic.w	r5, r5, #3
    d740:	adds	r5, #4
    d742:	add	r4, r5
    d744:	subs	r4, #4
    d746:	cbnz	r2, d752 <__mdiff+0xde>
    d748:	ldr.w	r3, [r4, #-4]!
    d74c:	subs	r6, #1
    d74e:	cmp	r3, #0
    d750:	beq.n	d748 <__mdiff+0xd4>
    d752:	str	r6, [r0, #16]
    d754:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d758:	movs	r1, #0
    d75a:	bl	d220 <_Balloc>
    d75e:	movs	r2, #1
    d760:	movs	r3, #0
    d762:	str	r2, [r0, #16]
    d764:	str	r3, [r0, #20]
    d766:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d76a:	mov	r4, r5
    d76c:	mov.w	r9, #0
    d770:	mov	r5, r2
    d772:	b.n	d6c4 <__mdiff+0x50>
    d774:	mov	r3, r7
    d776:	add.w	r4, r7, #20
    d77a:	add.w	r5, r8, #20
    d77e:	mov	r7, r8
    d780:	mov.w	r9, #1
    d784:	mov	r8, r3
    d786:	b.n	d6c4 <__mdiff+0x50>

0000d788 <__d2b>:
    d788:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d78c:	vmov	r6, r7, d0
    d790:	sub	sp, #12
    d792:	mov	r8, r1
    d794:	movs	r1, #1
    d796:	mov	r4, r7
    d798:	ubfx	r5, r7, #20, #11
    d79c:	mov	r7, r2
    d79e:	bl	d220 <_Balloc>
    d7a2:	ubfx	r4, r4, #0, #20
    d7a6:	mov	r9, r0
    d7a8:	cbz	r5, d7ae <__d2b+0x26>
    d7aa:	orr.w	r4, r4, #1048576	; 0x100000
    d7ae:	str	r4, [sp, #4]
    d7b0:	cbz	r6, d7fa <__d2b+0x72>
    d7b2:	add	r0, sp, #8
    d7b4:	str.w	r6, [r0, #-8]!
    d7b8:	bl	d340 <__lo0bits>
    d7bc:	cmp	r0, #0
    d7be:	bne.n	d82a <__d2b+0xa2>
    d7c0:	ldmia.w	sp, {r2, r3}
    d7c4:	str.w	r2, [r9, #20]
    d7c8:	cmp	r3, #0
    d7ca:	ite	eq
    d7cc:	moveq	r1, #1
    d7ce:	movne	r1, #2
    d7d0:	str.w	r3, [r9, #24]
    d7d4:	str.w	r1, [r9, #16]
    d7d8:	cbnz	r5, d812 <__d2b+0x8a>
    d7da:	add.w	r3, r9, r1, lsl #2
    d7de:	subw	r0, r0, #1074	; 0x432
    d7e2:	str.w	r0, [r8]
    d7e6:	ldr	r0, [r3, #16]
    d7e8:	bl	d300 <__hi0bits>
    d7ec:	rsb	r0, r0, r1, lsl #5
    d7f0:	str	r0, [r7, #0]
    d7f2:	mov	r0, r9
    d7f4:	add	sp, #12
    d7f6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    d7fa:	add	r0, sp, #4
    d7fc:	bl	d340 <__lo0bits>
    d800:	ldr	r3, [sp, #4]
    d802:	str.w	r3, [r9, #20]
    d806:	movs	r1, #1
    d808:	adds	r0, #32
    d80a:	str.w	r1, [r9, #16]
    d80e:	cmp	r5, #0
    d810:	beq.n	d7da <__d2b+0x52>
    d812:	subw	r5, r5, #1075	; 0x433
    d816:	add	r5, r0
    d818:	rsb	r0, r0, #53	; 0x35
    d81c:	str.w	r5, [r8]
    d820:	str	r0, [r7, #0]
    d822:	mov	r0, r9
    d824:	add	sp, #12
    d826:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    d82a:	ldmia.w	sp, {r2, r3}
    d82e:	rsb	r1, r0, #32
    d832:	lsl.w	r1, r3, r1
    d836:	orrs	r2, r1
    d838:	lsrs	r3, r0
    d83a:	str	r3, [sp, #4]
    d83c:	str.w	r2, [r9, #20]
    d840:	b.n	d7c8 <__d2b+0x40>
    d842:	nop

0000d844 <__sread>:
    d844:	push	{r4, lr}
    d846:	mov	r4, r1
    d848:	ldrsh.w	r1, [r1, #14]
    d84c:	bl	dc4c <_read_r>
    d850:	cmp	r0, #0
    d852:	blt.n	d85c <__sread+0x18>
    d854:	ldr	r3, [r4, #80]	; 0x50
    d856:	add	r3, r0
    d858:	str	r3, [r4, #80]	; 0x50
    d85a:	pop	{r4, pc}
    d85c:	ldrh	r3, [r4, #12]
    d85e:	bic.w	r3, r3, #4096	; 0x1000
    d862:	strh	r3, [r4, #12]
    d864:	pop	{r4, pc}
    d866:	nop

0000d868 <__swrite>:
    d868:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d86c:	mov	r6, r2
    d86e:	ldrsh.w	r2, [r1, #12]
    d872:	mov	r7, r3
    d874:	lsls	r3, r2, #23
    d876:	mov	r4, r1
    d878:	mov	r5, r0
    d87a:	bpl.n	d88c <__swrite+0x24>
    d87c:	movs	r2, #0
    d87e:	movs	r3, #2
    d880:	ldrsh.w	r1, [r1, #14]
    d884:	bl	dc20 <_lseek_r>
    d888:	ldrsh.w	r2, [r4, #12]
    d88c:	ldrsh.w	r1, [r4, #14]
    d890:	bic.w	r2, r2, #4096	; 0x1000
    d894:	strh	r2, [r4, #12]
    d896:	mov	r3, r7
    d898:	mov	r2, r6
    d89a:	mov	r0, r5
    d89c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    d8a0:	b.w	b8cc <_write_r>

0000d8a4 <__sseek>:
    d8a4:	push	{r4, lr}
    d8a6:	mov	r4, r1
    d8a8:	ldrsh.w	r1, [r1, #14]
    d8ac:	bl	dc20 <_lseek_r>
    d8b0:	ldrh	r3, [r4, #12]
    d8b2:	adds	r2, r0, #1
    d8b4:	itee	eq
    d8b6:	biceq.w	r3, r3, #4096	; 0x1000
    d8ba:	orrne.w	r3, r3, #4096	; 0x1000
    d8be:	strne	r0, [r4, #80]	; 0x50
    d8c0:	strh	r3, [r4, #12]
    d8c2:	pop	{r4, pc}

0000d8c4 <__sclose>:
    d8c4:	ldrsh.w	r1, [r1, #14]
    d8c8:	b.w	db2c <_close_r>

0000d8cc <__ssprint_r>:
    d8cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d8d0:	ldr	r3, [r2, #8]
    d8d2:	sub	sp, #12
    d8d4:	mov	r8, r2
    d8d6:	cmp	r3, #0
    d8d8:	beq.n	d9c0 <__ssprint_r+0xf4>
    d8da:	mov	fp, r0
    d8dc:	mov.w	r9, #0
    d8e0:	ldr	r6, [r2, #0]
    d8e2:	ldr	r0, [r1, #0]
    d8e4:	ldr	r3, [r1, #8]
    d8e6:	mov	r5, r1
    d8e8:	mov	r4, r9
    d8ea:	cmp	r4, #0
    d8ec:	beq.n	d97a <__ssprint_r+0xae>
    d8ee:	cmp	r4, r3
    d8f0:	mov	r7, r3
    d8f2:	mov	sl, r3
    d8f4:	bcc.n	d984 <__ssprint_r+0xb8>
    d8f6:	ldrh	r3, [r5, #12]
    d8f8:	tst.w	r3, #1152	; 0x480
    d8fc:	beq.n	d95a <__ssprint_r+0x8e>
    d8fe:	ldr	r7, [r5, #20]
    d900:	ldr	r1, [r5, #16]
    d902:	add.w	r7, r7, r7, lsl #1
    d906:	rsb	sl, r1, r0
    d90a:	add.w	r7, r7, r7, lsr #31
    d90e:	adds	r0, r4, #1
    d910:	asrs	r7, r7, #1
    d912:	add	r0, sl
    d914:	cmp	r0, r7
    d916:	mov	r2, r7
    d918:	itt	hi
    d91a:	movhi	r7, r0
    d91c:	movhi	r2, r7
    d91e:	lsls	r3, r3, #21
    d920:	bpl.n	d98a <__ssprint_r+0xbe>
    d922:	mov	r1, r2
    d924:	mov	r0, fp
    d926:	bl	87f4 <_malloc_r>
    d92a:	cmp	r0, #0
    d92c:	beq.n	d99e <__ssprint_r+0xd2>
    d92e:	mov	r2, sl
    d930:	ldr	r1, [r5, #16]
    d932:	str	r0, [sp, #4]
    d934:	bl	2df0 <memcpy>
    d938:	ldrh	r2, [r5, #12]
    d93a:	ldr	r3, [sp, #4]
    d93c:	bic.w	r2, r2, #1152	; 0x480
    d940:	orr.w	r2, r2, #128	; 0x80
    d944:	strh	r2, [r5, #12]
    d946:	rsb	r2, sl, r7
    d94a:	add.w	r0, r3, sl
    d94e:	str	r7, [r5, #20]
    d950:	str	r3, [r5, #16]
    d952:	str	r0, [r5, #0]
    d954:	str	r2, [r5, #8]
    d956:	mov	r7, r4
    d958:	mov	sl, r4
    d95a:	mov	r2, sl
    d95c:	mov	r1, r9
    d95e:	bl	8d90 <memmove>
    d962:	ldr.w	r2, [r8, #8]
    d966:	ldr	r3, [r5, #8]
    d968:	ldr	r0, [r5, #0]
    d96a:	subs	r3, r3, r7
    d96c:	add	r0, sl
    d96e:	subs	r4, r2, r4
    d970:	str	r3, [r5, #8]
    d972:	str	r0, [r5, #0]
    d974:	str.w	r4, [r8, #8]
    d978:	cbz	r4, d9c0 <__ssprint_r+0xf4>
    d97a:	ldr.w	r9, [r6]
    d97e:	ldr	r4, [r6, #4]
    d980:	adds	r6, #8
    d982:	b.n	d8ea <__ssprint_r+0x1e>
    d984:	mov	r7, r4
    d986:	mov	sl, r4
    d988:	b.n	d95a <__ssprint_r+0x8e>
    d98a:	mov	r0, fp
    d98c:	bl	8efc <_realloc_r>
    d990:	mov	r3, r0
    d992:	cmp	r0, #0
    d994:	bne.n	d946 <__ssprint_r+0x7a>
    d996:	ldr	r1, [r5, #16]
    d998:	mov	r0, fp
    d99a:	bl	cb4c <_free_r>
    d99e:	movs	r3, #12
    d9a0:	str.w	r3, [fp]
    d9a4:	ldrh	r3, [r5, #12]
    d9a6:	movs	r2, #0
    d9a8:	orr.w	r3, r3, #64	; 0x40
    d9ac:	mov.w	r0, #4294967295
    d9b0:	strh	r3, [r5, #12]
    d9b2:	str.w	r2, [r8, #8]
    d9b6:	str.w	r2, [r8, #4]
    d9ba:	add	sp, #12
    d9bc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d9c0:	movs	r0, #0
    d9c2:	str.w	r0, [r8, #4]
    d9c6:	add	sp, #12
    d9c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d9cc <__swbuf_r>:
    d9cc:	push	{r3, r4, r5, r6, r7, lr}
    d9ce:	mov	r5, r1
    d9d0:	mov	r4, r2
    d9d2:	mov	r6, r0
    d9d4:	cbz	r0, d9dc <__swbuf_r+0x10>
    d9d6:	ldr	r3, [r0, #56]	; 0x38
    d9d8:	cmp	r3, #0
    d9da:	beq.n	da72 <__swbuf_r+0xa6>
    d9dc:	ldrsh.w	r2, [r4, #12]
    d9e0:	ldr	r3, [r4, #24]
    d9e2:	str	r3, [r4, #8]
    d9e4:	uxth	r1, r2
    d9e6:	lsls	r0, r1, #28
    d9e8:	bpl.n	da5c <__swbuf_r+0x90>
    d9ea:	ldr	r3, [r4, #16]
    d9ec:	cmp	r3, #0
    d9ee:	beq.n	da5c <__swbuf_r+0x90>
    d9f0:	lsls	r1, r1, #18
    d9f2:	uxtb	r7, r5
    d9f4:	bpl.n	da22 <__swbuf_r+0x56>
    d9f6:	ldr	r2, [r4, #0]
    d9f8:	ldr	r1, [r4, #20]
    d9fa:	subs	r3, r2, r3
    d9fc:	cmp	r3, r1
    d9fe:	bge.n	da3a <__swbuf_r+0x6e>
    da00:	adds	r3, #1
    da02:	ldr	r1, [r4, #8]
    da04:	adds	r0, r2, #1
    da06:	subs	r1, #1
    da08:	str	r1, [r4, #8]
    da0a:	str	r0, [r4, #0]
    da0c:	strb	r5, [r2, #0]
    da0e:	ldr	r2, [r4, #20]
    da10:	cmp	r2, r3
    da12:	beq.n	da4a <__swbuf_r+0x7e>
    da14:	ldrh	r3, [r4, #12]
    da16:	lsls	r3, r3, #31
    da18:	bpl.n	da1e <__swbuf_r+0x52>
    da1a:	cmp	r7, #10
    da1c:	beq.n	da4a <__swbuf_r+0x7e>
    da1e:	mov	r0, r7
    da20:	pop	{r3, r4, r5, r6, r7, pc}
    da22:	ldr	r1, [r4, #100]	; 0x64
    da24:	orr.w	r2, r2, #8192	; 0x2000
    da28:	bic.w	r1, r1, #8192	; 0x2000
    da2c:	strh	r2, [r4, #12]
    da2e:	ldr	r2, [r4, #0]
    da30:	str	r1, [r4, #100]	; 0x64
    da32:	ldr	r1, [r4, #20]
    da34:	subs	r3, r2, r3
    da36:	cmp	r3, r1
    da38:	blt.n	da00 <__swbuf_r+0x34>
    da3a:	mov	r1, r4
    da3c:	mov	r0, r6
    da3e:	bl	c8b4 <_fflush_r>
    da42:	cbnz	r0, da56 <__swbuf_r+0x8a>
    da44:	ldr	r2, [r4, #0]
    da46:	movs	r3, #1
    da48:	b.n	da02 <__swbuf_r+0x36>
    da4a:	mov	r1, r4
    da4c:	mov	r0, r6
    da4e:	bl	c8b4 <_fflush_r>
    da52:	cmp	r0, #0
    da54:	beq.n	da1e <__swbuf_r+0x52>
    da56:	mov.w	r7, #4294967295
    da5a:	b.n	da1e <__swbuf_r+0x52>
    da5c:	mov	r1, r4
    da5e:	mov	r0, r6
    da60:	bl	b8f8 <__swsetup_r>
    da64:	cmp	r0, #0
    da66:	bne.n	da56 <__swbuf_r+0x8a>
    da68:	ldrsh.w	r2, [r4, #12]
    da6c:	ldr	r3, [r4, #16]
    da6e:	uxth	r1, r2
    da70:	b.n	d9f0 <__swbuf_r+0x24>
    da72:	bl	c9dc <__sinit>
    da76:	b.n	d9dc <__swbuf_r+0x10>

0000da78 <_wcrtomb_r>:
    da78:	push	{r4, r5, r6, r7, lr}
    da7a:	mov	r6, r0
    da7c:	sub	sp, #20
    da7e:	mov	r7, r3
    da80:	cbz	r1, daa6 <_wcrtomb_r+0x2e>
    da82:	ldr	r4, [pc, #64]	; (dac4 <_wcrtomb_r+0x4c>)
    da84:	ldr	r5, [pc, #64]	; (dac8 <_wcrtomb_r+0x50>)
    da86:	ldr	r4, [r4, #0]
    da88:	ldr	r4, [r4, #52]	; 0x34
    da8a:	cmp	r4, #0
    da8c:	it	eq
    da8e:	moveq	r4, r5
    da90:	ldr.w	r4, [r4, #224]	; 0xe0
    da94:	blx	r4
    da96:	adds	r3, r0, #1
    da98:	bne.n	daa2 <_wcrtomb_r+0x2a>
    da9a:	movs	r2, #0
    da9c:	movs	r3, #138	; 0x8a
    da9e:	str	r2, [r7, #0]
    daa0:	str	r3, [r6, #0]
    daa2:	add	sp, #20
    daa4:	pop	{r4, r5, r6, r7, pc}
    daa6:	mov	r4, r1
    daa8:	ldr	r1, [pc, #24]	; (dac4 <_wcrtomb_r+0x4c>)
    daaa:	ldr	r2, [pc, #28]	; (dac8 <_wcrtomb_r+0x50>)
    daac:	ldr	r1, [r1, #0]
    daae:	ldr	r1, [r1, #52]	; 0x34
    dab0:	cmp	r1, #0
    dab2:	it	eq
    dab4:	moveq	r1, r2
    dab6:	mov	r2, r4
    dab8:	ldr.w	r4, [r1, #224]	; 0xe0
    dabc:	add	r1, sp, #4
    dabe:	blx	r4
    dac0:	b.n	da96 <_wcrtomb_r+0x1e>
    dac2:	nop
    dac4:	.word	0x200016d0
    dac8:	.word	0x200016d4

0000dacc <_calloc_r>:
    dacc:	push	{r4, lr}
    dace:	mul.w	r1, r2, r1
    dad2:	bl	87f4 <_malloc_r>
    dad6:	mov	r4, r0
    dad8:	cbz	r0, db12 <_calloc_r+0x46>
    dada:	ldr.w	r2, [r0, #-4]
    dade:	bic.w	r2, r2, #3
    dae2:	subs	r2, #4
    dae4:	cmp	r2, #36	; 0x24
    dae6:	bhi.n	db1a <_calloc_r+0x4e>
    dae8:	cmp	r2, #19
    daea:	bls.n	db16 <_calloc_r+0x4a>
    daec:	movs	r3, #0
    daee:	cmp	r2, #27
    daf0:	str	r3, [r0, #0]
    daf2:	str	r3, [r0, #4]
    daf4:	bls.n	db24 <_calloc_r+0x58>
    daf6:	cmp	r2, #36	; 0x24
    daf8:	str	r3, [r0, #8]
    dafa:	str	r3, [r0, #12]
    dafc:	iteee	ne
    dafe:	addne.w	r2, r0, #16
    db02:	streq	r3, [r0, #16]
    db04:	streq	r3, [r0, #20]
    db06:	addeq.w	r2, r0, #24
    db0a:	movs	r3, #0
    db0c:	str	r3, [r2, #0]
    db0e:	str	r3, [r2, #4]
    db10:	str	r3, [r2, #8]
    db12:	mov	r0, r4
    db14:	pop	{r4, pc}
    db16:	mov	r2, r0
    db18:	b.n	db0a <_calloc_r+0x3e>
    db1a:	movs	r1, #0
    db1c:	bl	8e58 <memset>
    db20:	mov	r0, r4
    db22:	pop	{r4, pc}
    db24:	add.w	r2, r0, #8
    db28:	b.n	db0a <_calloc_r+0x3e>
    db2a:	nop

0000db2c <_close_r>:
    db2c:	push	{r3, r4, r5, lr}
    db2e:	ldr	r4, [pc, #28]	; (db4c <_close_r+0x20>)
    db30:	movs	r3, #0
    db32:	mov	r5, r0
    db34:	mov	r0, r1
    db36:	str	r3, [r4, #0]
    db38:	bl	3004 <_close>
    db3c:	adds	r3, r0, #1
    db3e:	beq.n	db42 <_close_r+0x16>
    db40:	pop	{r3, r4, r5, pc}
    db42:	ldr	r3, [r4, #0]
    db44:	cmp	r3, #0
    db46:	beq.n	db40 <_close_r+0x14>
    db48:	str	r3, [r5, #0]
    db4a:	pop	{r3, r4, r5, pc}
    db4c:	.word	0x20004284

0000db50 <_fclose_r>:
    db50:	cmp	r1, #0
    db52:	beq.n	dbd0 <_fclose_r+0x80>
    db54:	push	{r4, r5, r6, lr}
    db56:	mov	r5, r0
    db58:	mov	r4, r1
    db5a:	cbz	r0, db60 <_fclose_r+0x10>
    db5c:	ldr	r3, [r0, #56]	; 0x38
    db5e:	cbz	r3, dbc0 <_fclose_r+0x70>
    db60:	ldrsh.w	r3, [r4, #12]
    db64:	cbnz	r3, db6a <_fclose_r+0x1a>
    db66:	movs	r0, #0
    db68:	pop	{r4, r5, r6, pc}
    db6a:	mov	r1, r4
    db6c:	mov	r0, r5
    db6e:	bl	c76c <__sflush_r>
    db72:	ldr	r3, [r4, #44]	; 0x2c
    db74:	mov	r6, r0
    db76:	cbz	r3, db86 <_fclose_r+0x36>
    db78:	ldr	r1, [r4, #28]
    db7a:	mov	r0, r5
    db7c:	blx	r3
    db7e:	cmp	r0, #0
    db80:	it	lt
    db82:	movlt.w	r6, #4294967295
    db86:	ldrh	r3, [r4, #12]
    db88:	lsls	r3, r3, #24
    db8a:	bmi.n	dbc6 <_fclose_r+0x76>
    db8c:	ldr	r1, [r4, #48]	; 0x30
    db8e:	cbz	r1, dba2 <_fclose_r+0x52>
    db90:	add.w	r3, r4, #64	; 0x40
    db94:	cmp	r1, r3
    db96:	beq.n	db9e <_fclose_r+0x4e>
    db98:	mov	r0, r5
    db9a:	bl	cb4c <_free_r>
    db9e:	movs	r3, #0
    dba0:	str	r3, [r4, #48]	; 0x30
    dba2:	ldr	r1, [r4, #68]	; 0x44
    dba4:	cbz	r1, dbb0 <_fclose_r+0x60>
    dba6:	mov	r0, r5
    dba8:	bl	cb4c <_free_r>
    dbac:	movs	r3, #0
    dbae:	str	r3, [r4, #68]	; 0x44
    dbb0:	bl	c9e8 <__sfp_lock_acquire>
    dbb4:	movs	r3, #0
    dbb6:	strh	r3, [r4, #12]
    dbb8:	bl	c9ec <__sfp_lock_release>
    dbbc:	mov	r0, r6
    dbbe:	pop	{r4, r5, r6, pc}
    dbc0:	bl	c9dc <__sinit>
    dbc4:	b.n	db60 <_fclose_r+0x10>
    dbc6:	ldr	r1, [r4, #16]
    dbc8:	mov	r0, r5
    dbca:	bl	cb4c <_free_r>
    dbce:	b.n	db8c <_fclose_r+0x3c>
    dbd0:	movs	r0, #0
    dbd2:	bx	lr

0000dbd4 <_fstat_r>:
    dbd4:	push	{r3, r4, r5, lr}
    dbd6:	mov	r3, r1
    dbd8:	ldr	r4, [pc, #28]	; (dbf8 <_fstat_r+0x24>)
    dbda:	mov	r5, r0
    dbdc:	mov	r1, r2
    dbde:	mov	r0, r3
    dbe0:	movs	r3, #0
    dbe2:	str	r3, [r4, #0]
    dbe4:	bl	300c <_fstat>
    dbe8:	adds	r3, r0, #1
    dbea:	beq.n	dbee <_fstat_r+0x1a>
    dbec:	pop	{r3, r4, r5, pc}
    dbee:	ldr	r3, [r4, #0]
    dbf0:	cmp	r3, #0
    dbf2:	beq.n	dbec <_fstat_r+0x18>
    dbf4:	str	r3, [r5, #0]
    dbf6:	pop	{r3, r4, r5, pc}
    dbf8:	.word	0x20004284

0000dbfc <_isatty_r>:
    dbfc:	push	{r3, r4, r5, lr}
    dbfe:	ldr	r4, [pc, #28]	; (dc1c <_isatty_r+0x20>)
    dc00:	movs	r3, #0
    dc02:	mov	r5, r0
    dc04:	mov	r0, r1
    dc06:	str	r3, [r4, #0]
    dc08:	bl	3018 <_isatty>
    dc0c:	adds	r3, r0, #1
    dc0e:	beq.n	dc12 <_isatty_r+0x16>
    dc10:	pop	{r3, r4, r5, pc}
    dc12:	ldr	r3, [r4, #0]
    dc14:	cmp	r3, #0
    dc16:	beq.n	dc10 <_isatty_r+0x14>
    dc18:	str	r3, [r5, #0]
    dc1a:	pop	{r3, r4, r5, pc}
    dc1c:	.word	0x20004284

0000dc20 <_lseek_r>:
    dc20:	push	{r4, r5, r6, lr}
    dc22:	mov	r5, r1
    dc24:	ldr	r4, [pc, #32]	; (dc48 <_lseek_r+0x28>)
    dc26:	mov	r1, r2
    dc28:	mov	r6, r0
    dc2a:	mov	r2, r3
    dc2c:	mov	r0, r5
    dc2e:	movs	r3, #0
    dc30:	str	r3, [r4, #0]
    dc32:	bl	301c <_lseek>
    dc36:	adds	r3, r0, #1
    dc38:	beq.n	dc3c <_lseek_r+0x1c>
    dc3a:	pop	{r4, r5, r6, pc}
    dc3c:	ldr	r3, [r4, #0]
    dc3e:	cmp	r3, #0
    dc40:	beq.n	dc3a <_lseek_r+0x1a>
    dc42:	str	r3, [r6, #0]
    dc44:	pop	{r4, r5, r6, pc}
    dc46:	nop
    dc48:	.word	0x20004284

0000dc4c <_read_r>:
    dc4c:	push	{r4, r5, r6, lr}
    dc4e:	mov	r5, r1
    dc50:	ldr	r4, [pc, #32]	; (dc74 <_read_r+0x28>)
    dc52:	mov	r1, r2
    dc54:	mov	r6, r0
    dc56:	mov	r2, r3
    dc58:	mov	r0, r5
    dc5a:	movs	r3, #0
    dc5c:	str	r3, [r4, #0]
    dc5e:	bl	3000 <_read>
    dc62:	adds	r3, r0, #1
    dc64:	beq.n	dc68 <_read_r+0x1c>
    dc66:	pop	{r4, r5, r6, pc}
    dc68:	ldr	r3, [r4, #0]
    dc6a:	cmp	r3, #0
    dc6c:	beq.n	dc66 <_read_r+0x1a>
    dc6e:	str	r3, [r6, #0]
    dc70:	pop	{r4, r5, r6, pc}
    dc72:	nop
    dc74:	.word	0x20004284

0000dc78 <__aeabi_uldivmod>:
    dc78:	cbnz	r3, dc90 <__aeabi_uldivmod+0x18>
    dc7a:	cbnz	r2, dc90 <__aeabi_uldivmod+0x18>
    dc7c:	cmp	r1, #0
    dc7e:	it	eq
    dc80:	cmpeq	r0, #0
    dc82:	itt	ne
    dc84:	movne.w	r1, #4294967295
    dc88:	movne.w	r0, #4294967295
    dc8c:	b.w	df8c <__aeabi_idiv0>
    dc90:	sub.w	ip, sp, #8
    dc94:	strd	ip, lr, [sp, #-16]!
    dc98:	bl	dca8 <__udivmoddi4>
    dc9c:	ldr.w	lr, [sp, #4]
    dca0:	ldrd	r2, r3, [sp, #8]
    dca4:	add	sp, #16
    dca6:	bx	lr

0000dca8 <__udivmoddi4>:
    dca8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    dcac:	mov	ip, r1
    dcae:	mov	r6, r1
    dcb0:	mov	r4, r0
    dcb2:	ldr	r5, [sp, #32]
    dcb4:	cmp	r3, #0
    dcb6:	bne.n	dd5a <__udivmoddi4+0xb2>
    dcb8:	cmp	r2, r1
    dcba:	mov	r7, r2
    dcbc:	bls.n	dd98 <__udivmoddi4+0xf0>
    dcbe:	clz	lr, r2
    dcc2:	cmp.w	lr, #0
    dcc6:	beq.n	dce0 <__udivmoddi4+0x38>
    dcc8:	rsb	r4, lr, #32
    dccc:	lsr.w	r4, r0, r4
    dcd0:	lsl.w	r6, r1, lr
    dcd4:	orr.w	ip, r4, r6
    dcd8:	lsl.w	r7, r2, lr
    dcdc:	lsl.w	r4, r0, lr
    dce0:	mov.w	r9, r7, lsr #16
    dce4:	lsrs	r2, r4, #16
    dce6:	udiv	r0, ip, r9
    dcea:	uxth.w	r8, r7
    dcee:	mls	r6, r9, r0, ip
    dcf2:	orr.w	r6, r2, r6, lsl #16
    dcf6:	mul.w	r3, r0, r8
    dcfa:	cmp	r3, r6
    dcfc:	bls.n	dd12 <__udivmoddi4+0x6a>
    dcfe:	adds	r6, r6, r7
    dd00:	add.w	r2, r0, #4294967295
    dd04:	bcs.w	df4c <__udivmoddi4+0x2a4>
    dd08:	cmp	r3, r6
    dd0a:	bls.w	df4c <__udivmoddi4+0x2a4>
    dd0e:	subs	r0, #2
    dd10:	add	r6, r7
    dd12:	subs	r6, r6, r3
    dd14:	uxth	r2, r4
    dd16:	udiv	r3, r6, r9
    dd1a:	mls	r6, r9, r3, r6
    dd1e:	orr.w	r4, r2, r6, lsl #16
    dd22:	mul.w	r8, r3, r8
    dd26:	cmp	r8, r4
    dd28:	bls.n	dd3e <__udivmoddi4+0x96>
    dd2a:	adds	r4, r4, r7
    dd2c:	add.w	r2, r3, #4294967295
    dd30:	bcs.w	df48 <__udivmoddi4+0x2a0>
    dd34:	cmp	r8, r4
    dd36:	bls.w	df48 <__udivmoddi4+0x2a0>
    dd3a:	subs	r3, #2
    dd3c:	add	r4, r7
    dd3e:	rsb	r4, r8, r4
    dd42:	orr.w	r0, r3, r0, lsl #16
    dd46:	movs	r1, #0
    dd48:	cmp	r5, #0
    dd4a:	beq.n	de12 <__udivmoddi4+0x16a>
    dd4c:	lsr.w	r4, r4, lr
    dd50:	movs	r3, #0
    dd52:	str	r4, [r5, #0]
    dd54:	str	r3, [r5, #4]
    dd56:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dd5a:	cmp	r3, r1
    dd5c:	bls.n	dd6e <__udivmoddi4+0xc6>
    dd5e:	cmp	r5, #0
    dd60:	beq.n	de0e <__udivmoddi4+0x166>
    dd62:	movs	r1, #0
    dd64:	stmia.w	r5, {r0, r6}
    dd68:	mov	r0, r1
    dd6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dd6e:	clz	r1, r3
    dd72:	cmp	r1, #0
    dd74:	bne.w	de98 <__udivmoddi4+0x1f0>
    dd78:	cmp	r3, r6
    dd7a:	bcc.n	dd82 <__udivmoddi4+0xda>
    dd7c:	cmp	r2, r0
    dd7e:	bhi.w	df72 <__udivmoddi4+0x2ca>
    dd82:	subs	r4, r0, r2
    dd84:	sbc.w	r6, r6, r3
    dd88:	movs	r0, #1
    dd8a:	mov	ip, r6
    dd8c:	cmp	r5, #0
    dd8e:	beq.n	de12 <__udivmoddi4+0x16a>
    dd90:	stmia.w	r5, {r4, ip}
    dd94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dd98:	cbnz	r2, dda0 <__udivmoddi4+0xf8>
    dd9a:	movs	r7, #1
    dd9c:	udiv	r7, r7, r2
    dda0:	clz	lr, r7
    dda4:	cmp.w	lr, #0
    dda8:	bne.n	de16 <__udivmoddi4+0x16e>
    ddaa:	subs	r3, r6, r7
    ddac:	mov.w	r8, r7, lsr #16
    ddb0:	uxth.w	ip, r7
    ddb4:	movs	r1, #1
    ddb6:	udiv	r0, r3, r8
    ddba:	lsrs	r2, r4, #16
    ddbc:	mls	r6, r8, r0, r3
    ddc0:	orr.w	r6, r2, r6, lsl #16
    ddc4:	mul.w	r3, ip, r0
    ddc8:	cmp	r3, r6
    ddca:	bls.n	dddc <__udivmoddi4+0x134>
    ddcc:	adds	r6, r6, r7
    ddce:	add.w	r2, r0, #4294967295
    ddd2:	bcs.n	ddda <__udivmoddi4+0x132>
    ddd4:	cmp	r3, r6
    ddd6:	bhi.w	df76 <__udivmoddi4+0x2ce>
    ddda:	mov	r0, r2
    dddc:	subs	r6, r6, r3
    ddde:	uxth	r2, r4
    dde0:	udiv	r3, r6, r8
    dde4:	mls	r6, r8, r3, r6
    dde8:	orr.w	r4, r2, r6, lsl #16
    ddec:	mul.w	ip, ip, r3
    ddf0:	cmp	ip, r4
    ddf2:	bls.n	de04 <__udivmoddi4+0x15c>
    ddf4:	adds	r4, r4, r7
    ddf6:	add.w	r2, r3, #4294967295
    ddfa:	bcs.n	de02 <__udivmoddi4+0x15a>
    ddfc:	cmp	ip, r4
    ddfe:	bhi.w	df6c <__udivmoddi4+0x2c4>
    de02:	mov	r3, r2
    de04:	rsb	r4, ip, r4
    de08:	orr.w	r0, r3, r0, lsl #16
    de0c:	b.n	dd48 <__udivmoddi4+0xa0>
    de0e:	mov	r1, r5
    de10:	mov	r0, r5
    de12:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    de16:	rsb	r1, lr, #32
    de1a:	lsl.w	r3, r6, lr
    de1e:	lsl.w	r7, r7, lr
    de22:	lsr.w	r9, r0, r1
    de26:	mov.w	r8, r7, lsr #16
    de2a:	lsrs	r6, r1
    de2c:	orr.w	r9, r9, r3
    de30:	udiv	sl, r6, r8
    de34:	mov.w	r4, r9, lsr #16
    de38:	mls	r6, r8, sl, r6
    de3c:	uxth.w	ip, r7
    de40:	orr.w	r3, r4, r6, lsl #16
    de44:	mul.w	r2, sl, ip
    de48:	cmp	r2, r3
    de4a:	lsl.w	r4, r0, lr
    de4e:	bls.n	de66 <__udivmoddi4+0x1be>
    de50:	adds	r3, r3, r7
    de52:	add.w	r1, sl, #4294967295
    de56:	bcs.w	df68 <__udivmoddi4+0x2c0>
    de5a:	cmp	r2, r3
    de5c:	bls.w	df68 <__udivmoddi4+0x2c0>
    de60:	sub.w	sl, sl, #2
    de64:	add	r3, r7
    de66:	subs	r3, r3, r2
    de68:	uxth.w	r9, r9
    de6c:	udiv	r1, r3, r8
    de70:	mls	r3, r8, r1, r3
    de74:	orr.w	r3, r9, r3, lsl #16
    de78:	mul.w	r6, r1, ip
    de7c:	cmp	r6, r3
    de7e:	bls.n	de90 <__udivmoddi4+0x1e8>
    de80:	adds	r3, r3, r7
    de82:	add.w	r2, r1, #4294967295
    de86:	bcs.n	df60 <__udivmoddi4+0x2b8>
    de88:	cmp	r6, r3
    de8a:	bls.n	df60 <__udivmoddi4+0x2b8>
    de8c:	subs	r1, #2
    de8e:	add	r3, r7
    de90:	subs	r3, r3, r6
    de92:	orr.w	r1, r1, sl, lsl #16
    de96:	b.n	ddb6 <__udivmoddi4+0x10e>
    de98:	rsb	lr, r1, #32
    de9c:	lsr.w	r4, r2, lr
    dea0:	lsls	r3, r1
    dea2:	orrs	r3, r4
    dea4:	lsr.w	r7, r0, lr
    dea8:	lsl.w	r4, r6, r1
    deac:	mov.w	ip, r3, lsr #16
    deb0:	lsr.w	r6, r6, lr
    deb4:	orrs	r4, r7
    deb6:	udiv	r9, r6, ip
    deba:	lsrs	r7, r4, #16
    debc:	mls	r6, ip, r9, r6
    dec0:	uxth.w	r8, r3
    dec4:	orr.w	r6, r7, r6, lsl #16
    dec8:	mul.w	r7, r9, r8
    decc:	cmp	r7, r6
    dece:	lsl.w	r2, r2, r1
    ded2:	lsl.w	sl, r0, r1
    ded6:	bls.n	deea <__udivmoddi4+0x242>
    ded8:	adds	r6, r6, r3
    deda:	add.w	r0, r9, #4294967295
    dede:	bcs.n	df64 <__udivmoddi4+0x2bc>
    dee0:	cmp	r7, r6
    dee2:	bls.n	df64 <__udivmoddi4+0x2bc>
    dee4:	sub.w	r9, r9, #2
    dee8:	add	r6, r3
    deea:	subs	r6, r6, r7
    deec:	uxth	r0, r4
    deee:	udiv	r4, r6, ip
    def2:	mls	r6, ip, r4, r6
    def6:	orr.w	r7, r0, r6, lsl #16
    defa:	mul.w	r8, r4, r8
    defe:	cmp	r8, r7
    df00:	bls.n	df12 <__udivmoddi4+0x26a>
    df02:	adds	r7, r7, r3
    df04:	add.w	r0, r4, #4294967295
    df08:	bcs.n	df5c <__udivmoddi4+0x2b4>
    df0a:	cmp	r8, r7
    df0c:	bls.n	df5c <__udivmoddi4+0x2b4>
    df0e:	subs	r4, #2
    df10:	add	r7, r3
    df12:	orr.w	r0, r4, r9, lsl #16
    df16:	rsb	r7, r8, r7
    df1a:	umull	r8, r9, r0, r2
    df1e:	cmp	r7, r9
    df20:	mov	r4, r8
    df22:	mov	r6, r9
    df24:	bcc.n	df50 <__udivmoddi4+0x2a8>
    df26:	beq.n	df7c <__udivmoddi4+0x2d4>
    df28:	cbz	r5, df84 <__udivmoddi4+0x2dc>
    df2a:	subs.w	r3, sl, r4
    df2e:	sbc.w	r7, r7, r6
    df32:	lsl.w	lr, r7, lr
    df36:	lsrs	r3, r1
    df38:	lsrs	r7, r1
    df3a:	orr.w	r3, lr, r3
    df3e:	stmia.w	r5, {r3, r7}
    df42:	movs	r1, #0
    df44:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    df48:	mov	r3, r2
    df4a:	b.n	dd3e <__udivmoddi4+0x96>
    df4c:	mov	r0, r2
    df4e:	b.n	dd12 <__udivmoddi4+0x6a>
    df50:	subs.w	r4, r8, r2
    df54:	sbc.w	r6, r9, r3
    df58:	subs	r0, #1
    df5a:	b.n	df28 <__udivmoddi4+0x280>
    df5c:	mov	r4, r0
    df5e:	b.n	df12 <__udivmoddi4+0x26a>
    df60:	mov	r1, r2
    df62:	b.n	de90 <__udivmoddi4+0x1e8>
    df64:	mov	r9, r0
    df66:	b.n	deea <__udivmoddi4+0x242>
    df68:	mov	sl, r1
    df6a:	b.n	de66 <__udivmoddi4+0x1be>
    df6c:	subs	r3, #2
    df6e:	add	r4, r7
    df70:	b.n	de04 <__udivmoddi4+0x15c>
    df72:	mov	r0, r1
    df74:	b.n	dd8c <__udivmoddi4+0xe4>
    df76:	subs	r0, #2
    df78:	add	r6, r7
    df7a:	b.n	dddc <__udivmoddi4+0x134>
    df7c:	cmp	sl, r8
    df7e:	bcc.n	df50 <__udivmoddi4+0x2a8>
    df80:	mov	r6, r7
    df82:	b.n	df28 <__udivmoddi4+0x280>
    df84:	mov	r1, r5
    df86:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    df8a:	nop

0000df8c <__aeabi_idiv0>:
    df8c:	bx	lr
    df8e:	nop

0000df90 <___init_veneer>:
    df90:	ldr.w	pc, [pc]	; df94 <___init_veneer+0x4>
    df94:	.word	0x600016e9
	...

Disassembly of section .fini:

0000dfa0 <_fini>:
    dfa0:	push	{r3, r4, r5, r6, r7, lr}
    dfa2:	nop
