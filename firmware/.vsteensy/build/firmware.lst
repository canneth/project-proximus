
.vsteensy/build/firmware.elf:     file format elf32-littlearm

SYMBOL TABLE:
60000000 l    d  .text.progmem	00000000 .text.progmem
00000000 l    d  .text.itcm	00000000 .text.itcm
0000a8e0 l    d  .fini	00000000 .fini
0000a8e4 l    d  .ARM.exidx	00000000 .ARM.exidx
0000a8ec l    d  .text.itcm.padding	00000000 .text.itcm.padding
20000000 l    d  .data	00000000 .data
200019d0 l    d  .bss	00000000 .bss
20200000 l    d  .bss.dma	00000000 .bss.dma
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 bootdata.c
00000000 l    df *ABS*	00000000 startup.c
00002bb8 l       .text.itcm	00000000 _MSP
00000000 l    df *ABS*	00000000 usb.c
00002f70 l     F .text.itcm	0000005c schedule_transfer
00002fcc l     F .text.itcm	00000036 run_callbacks
00003004 l     F .text.itcm	000000a4 endpoint0_transmit.constprop.1
000030a8 l     F .text.itcm	00000698 isr
20001e34 l     O .bss	00000004 endpointN_notify_mask
20001e38 l     O .bss	00000001 sof_usage
20001e44 l     O .bss	00000004 endpoint0_notify_mask
20001e48 l     O .bss	00000001 usb_reboot_timer
20001e50 l     O .bss	00000008 endpoint0_setupdata
20001e58 l     O .bss	00000008 reply_buffer
20001e60 l     O .bss	00000008 endpoint0_buffer
00000000 l    df *ABS*	00000000 analog.c
20001e78 l     O .bss	00000001 calibrating
00000000 l    df *ABS*	00000000 tempmon.c
20001e7c l     O .bss	00000004 s_hotTemp
20001e80 l     O .bss	00000004 s_hot_ROOM
20001e84 l     O .bss	00000004 s_roomC_hotC
20001e88 l     O .bss	00000004 s_hotCount
00000000 l    df *ABS*	00000000 usb_desc.c
600016dc l     O .text.progmem	0000000a qualifier_descriptor
20000ff8 l     O .data	00000012 device_descriptor
00000000 l    df *ABS*	00000000 c:/progra~2/arduino/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/fpv5-d16/crti.o
00000000 l    df *ABS*	00000000 c:/progra~2/arduino/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/fpv5-d16/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00000020 l     F .text.itcm	00000000 __do_global_dtors_aux
200019d0 l       .bss	00000000 completed.8605
00000044 l     F .text.itcm	00000000 frame_dummy
200019d4 l       .bss	00000000 object.8610
60001740 l     O .text.progmem	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
000000e4 l     F .text.itcm	00000084 _GLOBAL__sub_I_robot
00000000 l    df *ABS*	00000000 LegStanceController.cpp
00000000 l    df *ABS*	00000000 Leg.cpp
00000000 l    df *ABS*	00000000 MyMath.cpp
00000000 l    df *ABS*	00000000 MasterController.cpp
00000000 l    df *ABS*	00000000 GaitConfig.cpp
00000000 l    df *ABS*	00000000 IMU.cpp
00000000 l    df *ABS*	00000000 Robot.cpp
00000000 l    df *ABS*	00000000 LegSwingController.cpp
20000000 l     O .data	000000b7 project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 Command.cpp
00000000 l    df *ABS*	00000000 GaitController.cpp
20000118 l     O .data	0000004f project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)::__PRETTY_FUNCTION__
20000168 l     O .data	00000044 project_namespace::GaitController::calculateGaitPhaseIndex(int)::__PRETTY_FUNCTION__
2000034c l     O .data	00000053 project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 SparkFun_BNO080_Arduino_Library.cpp
00001bdc l     F .text.itcm	00000068 BNO080::printHeader() [clone .part.7]
00001c44 l     F .text.itcm	000001e4 BNO080::printPacket() [clone .part.6]
00000000 l    df *ABS*	00000000 WireIMXRT.cpp
00000000 l    df *ABS*	00000000 SPI.cpp
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 clockspeed.c
00000000 l    df *ABS*	00000000 delay.c
00000000 l    df *ABS*	00000000 pwm.c
00000000 l    df *ABS*	00000000 digital.c
00003c30 l     F .text.itcm	00000024 digitalWrite.part.0
00003c54 l     F .text.itcm	0000001c digitalRead.part.1
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 yield.cpp
20001e8c l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 usb_serial.c
000040cc l     F .text.itcm	0000006c rx_queue_transfer
00004138 l     F .text.itcm	000000b4 rx_event
000041ec l     F .text.itcm	00000098 usb_serial_flush_callback
20001eac l     O .bss	00000010 rx_index
20001ebc l     O .bss	00000002 tx_packet_size
20001ebe l     O .bss	00000001 tx_noautoflush
20001ebf l     O .bss	00000001 tx_head
20001ec0 l     O .bss	00000100 rx_transfer
20001fc0 l     O .bss	00000001 rx_tail
20001fc4 l     O .bss	00000009 rx_list
20001fce l     O .bss	00000002 rx_packet_size
20200060 l     O .bss.dma	00001000 rx_buffer
20201060 l     O .bss.dma	00002000 txbuffer
20001fd0 l     O .bss	00000010 rx_count
20001fe0 l     O .bss	00000004 rx_available
20001fe4 l     O .bss	00000001 rx_head
20001fe6 l     O .bss	00000002 tx_available
20002000 l     O .bss	00000080 tx_transfer
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 s_sin.c
00000000 l    df *ABS*	00000000 sf_cos.c
00000000 l    df *ABS*	00000000 sf_sin.c
00000000 l    df *ABS*	00000000 w_acos.c
00000000 l    df *ABS*	00000000 w_asin.c
00000000 l    df *ABS*	00000000 w_atan2.c
00000000 l    df *ABS*	00000000 w_pow.c
00000000 l    df *ABS*	00000000 w_sqrt.c
00000000 l    df *ABS*	00000000 wf_atan2.c
00000000 l    df *ABS*	00000000 wf_sqrt.c
00000000 l    df *ABS*	00000000 e_acos.c
00000000 l    df *ABS*	00000000 e_asin.c
00000000 l    df *ABS*	00000000 e_atan2.c
00000000 l    df *ABS*	00000000 e_pow.c
00000000 l    df *ABS*	00000000 e_rem_pio2.c
2000082c l     O .data	00000080 npio2_hw
200008ac l     O .data	00000108 two_over_pi
00000000 l    df *ABS*	00000000 e_sqrt.c
00000000 l    df *ABS*	00000000 ef_atan2.c
00000000 l    df *ABS*	00000000 ef_rem_pio2.c
200009b4 l     O .data	00000080 npio2_hw
20000a34 l     O .data	00000318 two_over_pi
00000000 l    df *ABS*	00000000 ef_sqrt.c
00000000 l    df *ABS*	00000000 k_cos.c
00000000 l    df *ABS*	00000000 k_rem_pio2.c
20000d4c l     O .data	00000010 init_jk
20000d60 l     O .data	00000040 PIo2
00000000 l    df *ABS*	00000000 k_sin.c
00000000 l    df *ABS*	00000000 kf_cos.c
00000000 l    df *ABS*	00000000 kf_rem_pio2.c
20000da0 l     O .data	0000000c init_jk
20000dac l     O .data	0000002c PIo2
00000000 l    df *ABS*	00000000 kf_sin.c
00000000 l    df *ABS*	00000000 s_atan.c
20000dd8 l     O .data	00000020 atanlo
20000df8 l     O .data	00000020 atanhi
00000000 l    df *ABS*	00000000 s_fabs.c
00000000 l    df *ABS*	00000000 s_finite.c
00000000 l    df *ABS*	00000000 s_floor.c
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 s_nan.c
00000000 l    df *ABS*	00000000 s_rint.c
20000e18 l     O .data	00000010 TWO52
00000000 l    df *ABS*	00000000 s_scalbn.c
00000000 l    df *ABS*	00000000 sf_atan.c
20000e28 l     O .data	00000010 atanlo
20000e38 l     O .data	00000010 atanhi
00000000 l    df *ABS*	00000000 sf_fabs.c
00000000 l    df *ABS*	00000000 sf_floor.c
00000000 l    df *ABS*	00000000 sf_scalbn.c
00000000 l    df *ABS*	00000000 s_copysign.c
00000000 l    df *ABS*	00000000 sf_copysign.c
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 fiprintf.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 vfprintf.c
0000885c l     F .text.itcm	00000078 __sprint_r.part.0
000096d0 l     F .text.itcm	0000006a __sbprintf
20000e98 l     O .data	00000010 zeroes.7252
20000ea8 l     O .data	00000010 blanks.7251
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
000099cc l     F .text.itcm	000000f0 __sinit.part.1
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 impure.c
20001028 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
00000000 l       *UND*	00000000 __fini_array_end
00000000 l       *UND*	00000000 __bss_start__
00000000 l       *UND*	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 __fini_array_start
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __libc_fini
00000000 l       *UND*	00000000 __stack
600016f8 l     F .text.progmem	00000008 __set_arm_clock_veneer
60001700 l     F .text.progmem	00000008 __memset_veneer
60001708 l     F .text.progmem	00000008 __startup_early_hook_veneer
60001710 l     F .text.progmem	00000008 ____libc_init_array_veneer
60001718 l     F .text.progmem	00000008 __usb_init_serialnumber_veneer
60001720 l     F .text.progmem	00000008 __delay_veneer
60001728 l     F .text.progmem	00000008 __startup_late_hook_veneer
60001730 l     F .text.progmem	00000008 __main_veneer
60001738 l     F .text.progmem	00000008 __pwm_init_veneer
0000a8d0 l     F .text.itcm	00000008 ___init_veneer
00000b30 g     F .text.itcm	000000e8 project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)
00004390 g     F .text.itcm	0000000c usb_serial_available
00002790 g     F .text.itcm	00000054 BNO080::dataAvailable()
0000a538 g     F .text.itcm	00000024 _isatty_r
00002bc4 g     F .text.itcm	00000002 startup_default_late_hook
0000748c g     F .text.itcm	0000000e fabs
0000a55c g     F .text.itcm	0000002c _lseek_r
00003d70  w    F .text.itcm	000000a0 yield
000049b8 g     F .text.itcm	000000a8 sqrt
000017f8 g     F .text.itcm	00000006 project_namespace::Command::getGaitYawSpeed()
20001e3c g     O .bss	00000004 usb_timer1_callback
60001638 g     O .text.progmem	00000018 usb_string_manufacturer_name_default
20002080 g     O .bss	0000001c HardwareSerial::serial_event_handler_checks
00002254 g     F .text.itcm	0000006c BNO080::waitForI2C()
000018d0 g     F .text.itcm	000000a4 project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)
0000a414 g     F .text.itcm	00000054 _wcrtomb_r
000014e8 g     F .text.itcm	00000054 project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()
0000101c g     F .text.itcm	00000006 project_namespace::Robot::setBodyPitch(float)
00004004 g     F .text.itcm	00000020 Print::println()
0000a340 g     F .text.itcm	00000020 __sseek
00009abc g     F .text.itcm	0000000a __sinit
0000a368 g     F .text.itcm	000000ac __swbuf_r
000017e8 g     F .text.itcm	0000000e project_namespace::Command::getBodyVelocity()
00008358 g     F .text.itcm	00000002 __malloc_unlock
00001974 g     F .text.itcm	0000009c project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)
600014ac g     F .text.progmem	00000058 analog_init
0000027c g     F .text.itcm	0000003a project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)
00001784 g     F .text.itcm	00000034 project_namespace::Command::Command()
20000ff4 g     O .data	00000004 F_CPU_ACTUAL
000043ec g     F .text.itcm	00000028 HardwareSerial::processSerialEvents()
000081f0 g     F .text.itcm	000000c6 memmove
00003f40 g     F .text.itcm	00000098 MillisTimer::runFromTimer()
0000069c g     F .text.itcm	00000494 project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)
00001828 g     F .text.itcm	0000002c project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)
20001ea4 g     O .bss	00000001 EventResponder::runningFromYield
00000c7c g     F .text.itcm	0000005a project_namespace::IMU::getGyro()
00007bb4 g     F .text.itcm	0000000c __errno
60001000 g     O .text.progmem	00000020 ImageVectorTable
20001e90 g     O .bss	00000004 EventResponder::firstInterrupt
00001784 g     F .text.itcm	00000034 project_namespace::Command::Command()
00000c70 g     F .text.itcm	00000006 project_namespace::GaitConfig::setSwingHeight(float)
00005f34 g     F .text.itcm	00000298 __ieee754_rem_pio2f
20001022 g     O .data	00000001 usb_enable_serial_event_processing
00001540 g     F .text.itcm	00000244 project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)
20001cc0 g     O .bss	00000040 imu
0000a510 g     F .text.itcm	00000028 _fstat_r
20000518 g     O .data	00000280 digital_pin_to_info_PGM
00001a10 g     F .text.itcm	0000004e project_namespace::GaitController::calculateContactPattern(int)
20004290 g     O .bss	00000004 errno
000074b0 g     F .text.itcm	00000118 floor
0000a8e0 g       .text.itcm	00000000 _etext
200019d0 g       .bss	00000000 _sbss
00000c68 g     F .text.itcm	00000006 project_namespace::GaitConfig::getSwingHeight()
00003c7c g     F .text.itcm	0000000c digitalRead
60001750 g       *ABS*	00000000 _stextload
00000084 g     F .text.itcm	00000060 loop
00003740 g     F .text.itcm	00000064 usb_config_rx
00004a68 g     F .text.itcm	000000b0 sqrtf
00003ed8 g     F .text.itcm	00000068 MillisTimer::addToActiveList()
000059a8 g     F .text.itcm	0000029c __ieee754_rem_pio2
20001e94 g     O .bss	00000004 EventResponder::lastInterrupt
00002a74 g     F .text.itcm	00000134 memcpy
000099c0 g     F .text.itcm	0000000c _cleanup_r
20001e74 g     O .bss	00000004 systick_millis_count
000028fc g     F .text.itcm	0000003c TwoWire::wait_idle()
000021dc g     F .text.itcm	0000003a BNO080::getGyroY()
0000a5b4 g     F .text.itcm	00000000 .hidden __aeabi_uldivmod
20001e68 g     O .bss	00000001 usb_configuration
60000000 g     O .text.progmem	00000200 FlexSPI_NOR_Config
60001638  w    O .text.progmem	00000018 usb_string_manufacturer_name
00002c90  w    F .text.itcm	0000000a _fstat
00001bbc  w    F .text.itcm	0000001e TwoWire::read()
00002a58  w    F .text.itcm	0000001c EventResponder::triggerEvent(int, void*)
00007b78 g     F .text.itcm	0000003c __assert_func
600013c0 g     F .text.progmem	000000ec usb_init
00006270 g     F .text.itcm	00000120 __kernel_cos
0000027c g     F .text.itcm	0000003a project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)
00001110 g     F .text.itcm	0000006a project_namespace::Robot::updateStancePolygon()
200020a8 g     O .bss	00000004 __malloc_top_pad
20004280 g     O .bss	00000004 systick_safe_read
000027e4 g     F .text.itcm	00000118 TwoWire::force_clock()
aaaaaaaf g       *ABS*	00000000 _flexram_bank_config
00002074 g     F .text.itcm	0000003a BNO080::getQuatI()
00001854 g     F .text.itcm	0000007c project_namespace::GaitController::calculateGaitPhaseIndex(int)
00002164 g     F .text.itcm	0000003a BNO080::getQuatRadianAccuracy()
00009dfc g     F .text.itcm	00000304 __sfvwrite_r
20000000 g       .data	00000000 _sdata
60001698 g     O .text.progmem	00000043 usb_config_descriptor_480
0000a5e4 g     F .text.itcm	000002e2 .hidden __udivmoddi4
000017c0 g     F .text.itcm	00000006 project_namespace::Command::getStancePolygonWidth()
0000873c g     F .text.itcm	00000024 _sbrk_r
00002bc0 g     F .text.itcm	00000002 startup_default_early_hook
60001034 g     F .text.progmem	00000268 ResetHandler
20004284 g     O .bss	00000008 usb_cdc_line_coding
00003c70 g     F .text.itcm	0000000a digitalWrite
000079d4 g     F .text.itcm	0000000e fabsf
20001e9c g     O .bss	00000004 EventResponder::lastYield
0000a588 g     F .text.itcm	0000002c _read_r
200019f0 g     O .bss	00000030 command
00002128 g     F .text.itcm	0000003a BNO080::getQuatReal()
0000a48c g     F .text.itcm	00000084 _fclose_r
200020a4 g     O .bss	00000004 __malloc_max_sbrked_mem
00003c88 g     F .text.itcm	00000080 pinMode
00006a10 g     F .text.itcm	000000b0 __kernel_sin
00001024 g     F .text.itcm	00000006 project_namespace::Robot::setBodyYaw(float)
000017e0 g     F .text.itcm	00000006 project_namespace::Command::getBodyYaw()
20280000 g       .bss.dma	00000000 _heap_end
000021a0 g     F .text.itcm	0000003a BNO080::getGyroX()
00002c9c  w    F .text.itcm	00000004 _isatty
20001023 g     O .data	00000001 __fdlib_version
20001ea0 g     O .bss	00000004 EventResponder::firstYield
0000835c g     F .text.itcm	000003de _realloc_r
00007be8 g     F .text.itcm	00000050 __libc_init_array
000071f4 g     F .text.itcm	00000090 __kernel_sinf
00001bb0  w    F .text.itcm	0000000c TwoWire::available()
00009b68 g     F .text.itcm	00000026 _fputwc_r
00002ca8  w    F .text.itcm	00000004 abort
00002bc8  w    F .text.itcm	0000008c HardFault_HandlerC
00002938 g     F .text.itcm	00000120 TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
00002c54 g     F .text.itcm	00000030 _sbrk
6000c03c g       *ABS*	00000000 _sdataload
20001ea8 g     O .bss	00000004 MillisTimer::listWaiting
20000fec g     O .data	00000004 __brkval
20001fe8 g     O .bss	00000001 usb_cdc_line_rtsdtr
600016e8 g     F .text.progmem	00000000 _init
00004284 g     F .text.itcm	00000002 usb_serial_reset
000044b8 g     F .text.itcm	00000090 cosf
20001c00 g     O .bss	000000c0 master_controller
00001e28 g     F .text.itcm	0000024c BNO080::parseInputReport()
60001654 g     O .text.progmem	00000043 usb_config_descriptor_12
00006390 g     F .text.itcm	0000067c __kernel_rem_pio2
200042c0 g       .bss	00000000 _ebss
00001824 g     F .text.itcm	00000004 project_namespace::Command::setMode(project_namespace::Mode)
000075e0 g     F .text.itcm	0000011c rint
000012f4 g     F .text.itcm	000001f4 project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)
20203060 g       .bss.dma	00000000 _heap_start
00006ac0 g     F .text.itcm	00000104 __kernel_cosf
00000c4c g     F .text.itcm	00000014 project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()
00005040 g     F .text.itcm	000001dc __ieee754_atan2
00000002 g       *ABS*	00000000 _itcm_block_count
20003000 g     O .bss	00000020 endpoint0_transfer_data
00003978 g     F .text.itcm	000002b8 pwm_init
000017c8 g     F .text.itcm	00000006 project_namespace::Command::getStanceHeight()
0000067c g     F .text.itcm	0000001e project_namespace::MasterController::MasterController(project_namespace::IMU&)
0000181c g     F .text.itcm	00000006 project_namespace::Command::setSwingHeight(float)
6000135c g     F .text.progmem	00000064 usb_pll_start
6000102c g     O .text.progmem	00000008 vector_table
00000000  w      *UND*	00000000 __deregister_frame_info
2000428c g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
20003020 g     O .bss	00000020 endpoint0_transfer_ack
0000383c g     F .text.itcm	00000028 usb_transmit
00003fd8 g     F .text.itcm	00000020 systick_isr
00001194 g     F .text.itcm	00000006 project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)
2000209c g     O .bss	00000001 HardwareSerial::serial_event_handlers_active
00002bc0  w    F .text.itcm	00000002 startup_early_hook
00004dd8 g     F .text.itcm	00000264 __ieee754_asin
00009ac8 g     F .text.itcm	00000002 __sfp_lock_acquire
0000a240 g     F .text.itcm	00000000 memchr
00002cac g     F .text.itcm	000002c4 set_arm_clock
20001e6c g     O .bss	00000004 systick_cycle_count
2000100c g     O .data	00000016 usb_string_serial_number_default
00009c2c g     F .text.itcm	000001d0 _free_r
00007c38 g     F .text.itcm	0000001c __locale_mb_cur_max
000017d8 g     F .text.itcm	00000006 project_namespace::Command::getBodyPitch()
00000c44 g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitSwingDurationInTicks()
0000016c g     F .text.itcm	00000110 project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)
00002218 g     F .text.itcm	0000003a BNO080::getGyroZ()
200019cc g     O .data	00000004 __malloc_sbrk_base
00004418 g     F .text.itcm	000000a0 sin
00002ca0  w    F .text.itcm	00000006 _lseek
000020b0 g     F .text.itcm	0000003a BNO080::getQuatJ()
0000380c g     F .text.itcm	0000002e usb_prepare_transfer
00004734 g     F .text.itcm	00000004 atan2
00002ba8 g     F .text.itcm	00000018 unused_interrupt_vector
20001e30 g     O .bss	00000004 usb_timer0_callback
60001504 g     F .text.progmem	0000011c tempmon_init
00003ff8  w    F .text.itcm	0000000c serialEvent()
00000478 g     F .text.itcm	0000002a project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
00005220 g     F .text.itcm	00000784 __ieee754_pow
00004738 g     F .text.itcm	00000280 pow
00000024 g       *ABS*	00000000 _teensy_model_identifier
200020ac g     O .bss	00000028 __malloc_current_mallinfo
0000118c g     F .text.itcm	00000008 project_namespace::Robot::setStanceHeight(float)
0000a468 g     F .text.itcm	00000024 _close_r
00001a60 g     F .text.itcm	00000150 project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)
20001a20 g     O .bss	000001e0 robot
20001e70 g     O .bss	00000004 scale_cpu_cycles_to_microseconds
0000067c g     F .text.itcm	0000001e project_namespace::MasterController::MasterController(project_namespace::IMU&)
000020ec g     F .text.itcm	0000003a BNO080::getQuatK()
00009784 g     F .text.itcm	000000c8 __swsetup_r
20001e98 g     O .bss	00000004 MillisTimer::listActive
0000a8c8  w    F .text.itcm	00000002 .hidden __aeabi_ldiv0
00001828 g     F .text.itcm	0000002c project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)
200015c0 g     O .data	00000408 __malloc_av_
0000a2e0 g     F .text.itcm	00000022 __sread
00000d54 g     F .text.itcm	00000280 project_namespace::Robot::Robot()
00008354 g     F .text.itcm	00000002 __malloc_lock
00007a74 g     F .text.itcm	000000d0 scalbnf
20002400 g     O .bss	000002c0 _VectorsRam
00009994 g     F .text.itcm	0000002c _fflush_r
20001e40 g     O .bss	00000001 usb_high_speed
000082b8 g     F .text.itcm	0000009a memset
000061cc g     F .text.itcm	000000a2 __ieee754_sqrtf
00000b30 g     F .text.itcm	000000e8 project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)
00003d60 g     F .text.itcm	00000010 main
200020a0 g     O .bss	00000004 __malloc_max_total_mem
00002410 g     F .text.itcm	00000380 BNO080::receivePacket()
000022c0 g     F .text.itcm	00000150 BNO080::getData(unsigned short)
20200000 g     O .bss.dma	00000043 usb_descriptor_buffer
200019ec g     O .bss	00000004 last_time
0000a360 g     F .text.itcm	00000008 __sclose
000075c8 g     F .text.itcm	00000004 matherr
00003d08 g     F .text.itcm	00000058 usb_init_serialnumber
60001748 g       .text.progmem	00000000 __init_array_end
00007c54 g     F .text.itcm	00000570 _malloc_r
0000973c g     F .text.itcm	0000001a __ascii_wctomb
200003a0  w    O .data	00000010 SPIClass::beginTransaction(SPISettings)::clk_sel
00003e10 g     F .text.itcm	00000080 EventResponder::triggerEventNotImmediate()
00000031 g       *ABS*	00000000 __rtc_localtime
00001194 g     F .text.itcm	00000006 project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)
00009b90 g     F .text.itcm	0000009c _malloc_trim_r
60001650 g     O .text.progmem	00000004 string0
0000749c g     F .text.itcm	00000010 finite
00000168 g     F .text.itcm	00000004 project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)
00002bc4  w    F .text.itcm	00000002 startup_late_hook
00000c3c g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitNumberOfPhases()
00000cd8 g     F .text.itcm	0000007a project_namespace::IMU::getHeadingQuaternion()
20004000 g     O .bss	00000280 endpoint_queue_head
60001620  w    O .text.progmem	00000016 usb_string_product_name
00000c78 g     F .text.itcm	00000004 project_namespace::IMU::IMU(BNO080&)
00007b44 g     F .text.itcm	0000001a copysign
00003888 g     F .text.itcm	000000cc delay
0000a8e0 g     F .fini	00000000 _fini
60001020 g     O .text.progmem	0000000c BootData
00007b60 g     F .text.itcm	00000018 copysignf
00007288 g     F .text.itcm	00000204 atan
000040b4 g     F .text.itcm	00000016 Print::print(long)
00003954 g     F .text.itcm	00000024 Panic_Temp_isr
00000c48 g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitCycleDurationInTicks()
00001014 g     F .text.itcm	00000006 project_namespace::Robot::setBodyRoll(float)
000017b8 g     F .text.itcm	00000006 project_namespace::Command::getStancePolygonLength()
00009758 g     F .text.itcm	0000002c _write_r
00004688 g     F .text.itcm	000000ac asin
20001450 g     O .data	00000004 _impure_ptr
0000984c g     F .text.itcm	00000148 __sflush_r
00007700 g     F .text.itcm	0000011c scalbn
00004a60 g     F .text.itcm	00000004 atan2f
60001740 g       .text.progmem	00000000 __preinit_array_end
20001d00 g     O .bss	00000130 imu_hardware
00001184 g     F .text.itcm	00000008 project_namespace::Robot::setStancePolygonWidth(float)
000081c4 g     F .text.itcm	0000002a __ascii_mbtowc
0000102c g     F .text.itcm	00000032 project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)
0000007c g     F .text.itcm	00000008 setup
20000798 g     O .data	0000006c usb_descriptor_list
00000c40 g     F .text.itcm	00000004 project_namespace::GaitConfig::getGaitStanceDurationInTicks()
0000117c g     F .text.itcm	00000008 project_namespace::Robot::setStancePolygonLength(float)
00004548 g     F .text.itcm	00000094 sinf
000075d0 g     F .text.itcm	00000010 nan
00000fd4 g     F .text.itcm	00000020 project_namespace::Robot::getFootPositionsWrtBodyAssumingNoBodyRPY()
00001808 g     F .text.itcm	00000004 project_namespace::Command::getMode()
00005c44 g     F .text.itcm	00000184 __ieee754_sqrt
00000ff4 g     F .text.itcm	00000020 project_namespace::Robot::getFootPositionsWrtBodyAtRest()
0000a154 g     F .text.itcm	0000005e __swhatbuf_r
20070000 g       .bss.dma	00000000 _estack
000002b8 g     F .text.itcm	000001c0 project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
00004288 g     F .text.itcm	00000108 usb_serial_configure
00004024  w    F .text.itcm	0000000e _write
200019d0 g       .data	00000000 _edata
00009ad0 g     F .text.itcm	00000098 __fputwc
0000107c g     F .text.itcm	00000092 project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)
0000439c g     F .text.itcm	0000004e ultoa
0000a304 g     F .text.itcm	0000003c __swrite
00003e90 g     F .text.itcm	00000044 EventResponder::runFromInterrupt()
200019c8 g     O .data	00000004 __malloc_trim_threshold
00007bc0 g     F .text.itcm	00000028 fiprintf
000088d4 g     F .text.itcm	00000dfc _vfiprintf_r
0000a100 g     F .text.itcm	00000052 _fwalk_reent
0000119c g     F .text.itcm	00000158 project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)
00009acc g     F .text.itcm	00000002 __sfp_lock_release
0000781c g     F .text.itcm	000001b8 atanf
000004a4  w    F .text.itcm	0000009e Eigen::Matrix<float, 3, 3, 0, 3, 3>& Eigen::Matrix<float, 3, 3, 0, 3, 3>::operator=<Eigen::Quaternion<float, 0> >(Eigen::RotationBase<Eigen::Quaternion<float, 0>, 3> const&)
000017d0 g     F .text.itcm	00000006 project_namespace::Command::getBodyRoll()
20000ee8 g     O .data	00000101 _ctype_
00002c84  w    F .text.itcm	00000004 _read
0000a8c8  w    F .text.itcm	00000002 .hidden __aeabi_idiv0
60001740 g       .text.progmem	00000000 __init_array_start
20000ff0 g     O .data	00000004 F_BUS_ACTUAL
00000168 g     F .text.itcm	00000004 project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)
00006bc4 g     F .text.itcm	00000630 __kernel_rem_pio2f
0000a1b4 g     F .text.itcm	00000088 __smakebuf_r
00000000 g       .text.itcm	00000000 _stext
00000c60 g     F .text.itcm	00000004 project_namespace::GaitConfig::getLegStanceDurationInTicks()
00008780 g     F .text.itcm	000000dc strlen
60001620 g     O .text.progmem	00000016 usb_string_product_name_default
00000c18 g     F .text.itcm	00000024 project_namespace::GaitConfig::getContactSchedule()
00001800 g     F .text.itcm	00000006 project_namespace::Command::getSwingHeight()
00000c78 g     F .text.itcm	00000004 project_namespace::IMU::IMU(BNO080&)
000079e4 g     F .text.itcm	00000090 floorf
6000129c g     F .text.progmem	000000c0 configure_cache
0000180c g     F .text.itcm	0000000e project_namespace::Command::setBodyVelocity(Eigen::Matrix<float, 3, 1, 0, 3, 1>)
000045dc g     F .text.itcm	000000ac acos
00000000  w      *UND*	00000000 _Jv_RegisterClasses
60001740 g       .text.progmem	00000000 __preinit_array_start
00003864 g     F .text.itcm	00000024 usb_receive
0000da00 g       *ABS*	00000000 _flashimagelen
00000544 g     F .text.itcm	00000138 project_namespace::MyMath::eulerToMatrix(float, float, float)
00000000  w      *UND*	00000000 __register_frame_info
00003ed4 g     F .text.itcm	00000004 pendablesrvreq_isr
20001454 g     O .data	0000016c __global_locale
00000d54 g     F .text.itcm	00000280 project_namespace::Robot::Robot()
00001060 g     F .text.itcm	0000001a project_namespace::Robot::setContactPattern(Eigen::Matrix<int, 4, 1, 0, 4, 1>)
00004034 g     F .text.itcm	0000007e Print::printNumber(unsigned long, unsigned char, unsigned char)
000037a4 g     F .text.itcm	00000068 usb_config_tx
00002c88  w    F .text.itcm	00000006 _close
00000c64 g     F .text.itcm	00000004 project_namespace::GaitConfig::getLegSwingDurationInTicks()
00004b18 g     F .text.itcm	000002bc __ieee754_acos
00005dc8 g     F .text.itcm	0000016c __ieee754_atan2f
2000100c  w    O .data	00000016 usb_string_serial_number



Disassembly of section .text.progmem:

60000000 <FlexSPI_NOR_Config>:
60000000:	FCFB...V........
	...
60000044:	.............. .
	...
60000080:	.....2.&........
60000090:	...$............
	...
600000b0:	................
	...
600000d0:	 ...............
	...
60000100:	................
60000110:	..... ..........
	...
60000130:	`...............
	...
600001c0:	................
600001d0:	................
	...
60000200:	................
60000210:	................
60000220:	................
60000230:	................
60000240:	................
60000250:	................
60000260:	................
60000270:	................
60000280:	................
60000290:	................
600002a0:	................
600002b0:	................
600002c0:	................
600002d0:	................
600002e0:	................
600002f0:	................
60000300:	................
60000310:	................
60000320:	................
60000330:	................
60000340:	................
60000350:	................
60000360:	................
60000370:	................
60000380:	................
60000390:	................
600003a0:	................
600003b0:	................
600003c0:	................
600003d0:	................
600003e0:	................
600003f0:	................
60000400:	................
60000410:	................
60000420:	................
60000430:	................
60000440:	................
60000450:	................
60000460:	................
60000470:	................
60000480:	................
60000490:	................
600004a0:	................
600004b0:	................
600004c0:	................
600004d0:	................
600004e0:	................
600004f0:	................
60000500:	................
60000510:	................
60000520:	................
60000530:	................
60000540:	................
60000550:	................
60000560:	................
60000570:	................
60000580:	................
60000590:	................
600005a0:	................
600005b0:	................
600005c0:	................
600005d0:	................
600005e0:	................
600005f0:	................
60000600:	................
60000610:	................
60000620:	................
60000630:	................
60000640:	................
60000650:	................
60000660:	................
60000670:	................
60000680:	................
60000690:	................
600006a0:	................
600006b0:	................
600006c0:	................
600006d0:	................
600006e0:	................
600006f0:	................
60000700:	................
60000710:	................
60000720:	................
60000730:	................
60000740:	................
60000750:	................
60000760:	................
60000770:	................
60000780:	................
60000790:	................
600007a0:	................
600007b0:	................
600007c0:	................
600007d0:	................
600007e0:	................
600007f0:	................
60000800:	................
60000810:	................
60000820:	................
60000830:	................
60000840:	................
60000850:	................
60000860:	................
60000870:	................
60000880:	................
60000890:	................
600008a0:	................
600008b0:	................
600008c0:	................
600008d0:	................
600008e0:	................
600008f0:	................
60000900:	................
60000910:	................
60000920:	................
60000930:	................
60000940:	................
60000950:	................
60000960:	................
60000970:	................
60000980:	................
60000990:	................
600009a0:	................
600009b0:	................
600009c0:	................
600009d0:	................
600009e0:	................
600009f0:	................
60000a00:	................
60000a10:	................
60000a20:	................
60000a30:	................
60000a40:	................
60000a50:	................
60000a60:	................
60000a70:	................
60000a80:	................
60000a90:	................
60000aa0:	................
60000ab0:	................
60000ac0:	................
60000ad0:	................
60000ae0:	................
60000af0:	................
60000b00:	................
60000b10:	................
60000b20:	................
60000b30:	................
60000b40:	................
60000b50:	................
60000b60:	................
60000b70:	................
60000b80:	................
60000b90:	................
60000ba0:	................
60000bb0:	................
60000bc0:	................
60000bd0:	................
60000be0:	................
60000bf0:	................
60000c00:	................
60000c10:	................
60000c20:	................
60000c30:	................
60000c40:	................
60000c50:	................
60000c60:	................
60000c70:	................
60000c80:	................
60000c90:	................
60000ca0:	................
60000cb0:	................
60000cc0:	................
60000cd0:	................
60000ce0:	................
60000cf0:	................
60000d00:	................
60000d10:	................
60000d20:	................
60000d30:	................
60000d40:	................
60000d50:	................
60000d60:	................
60000d70:	................
60000d80:	................
60000d90:	................
60000da0:	................
60000db0:	................
60000dc0:	................
60000dd0:	................
60000de0:	................
60000df0:	................
60000e00:	................
60000e10:	................
60000e20:	................
60000e30:	................
60000e40:	................
60000e50:	................
60000e60:	................
60000e70:	................
60000e80:	................
60000e90:	................
60000ea0:	................
60000eb0:	................
60000ec0:	................
60000ed0:	................
60000ee0:	................
60000ef0:	................
60000f00:	................
60000f10:	................
60000f20:	................
60000f30:	................
60000f40:	................
60000f50:	................
60000f60:	................
60000f70:	................
60000f80:	................
60000f90:	................
60000fa0:	................
60000fb0:	................
60000fc0:	................
60000fd0:	................
60000fe0:	................
60000ff0:	................

60001000 <ImageVectorTable>:
60001000:	.. @,..`........
60001010:	 ..`...`........

60001020 <BootData>:
60001020:	...`........

6000102c <vector_table>:
6000102c:	... 5..`

60001034 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001034:	ldr	r3, [pc, #464]	; (60001208 <ResetHandler+0x1d4>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001036:	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103a:	ldr	r2, [pc, #464]	; (6000120c <ResetHandler+0x1d8>)
	IOMUXC_GPR_GPR16 = 0x00200007;
6000103c:	ldr	r0, [pc, #464]	; (60001210 <ResetHandler+0x1dc>)
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103e:	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001040:	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001042:	ldr	r2, [pc, #464]	; (60001214 <ResetHandler+0x1e0>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001044:	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001046:	mov	sp, r2
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001048:	ldr	r2, [pc, #460]	; (60001218 <ResetHandler+0x1e4>)
6000104a:	ldr	r1, [pc, #464]	; (6000121c <ResetHandler+0x1e8>)
6000104c:	cmp	r2, r1
6000104e:	beq.n	60001070 <ResetHandler+0x3c>
	while (dest < dest_end) {
60001050:	ldr	r3, [pc, #460]	; (60001220 <ResetHandler+0x1ec>)
60001052:	cmp	r2, r3
60001054:	bcs.n	60001070 <ResetHandler+0x3c>
60001056:	mvns	r4, r2
60001058:	mov	r0, r1
6000105a:	add	r3, r4
6000105c:	bic.w	r3, r3, #3
60001060:	adds	r3, #4
60001062:	add	r3, r1
		*dest++ = *src++;
60001064:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001068:	cmp	r0, r3
		*dest++ = *src++;
6000106a:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000106e:	bne.n	60001064 <ResetHandler+0x30>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001070:	ldr	r2, [pc, #432]	; (60001224 <ResetHandler+0x1f0>)
60001072:	ldr	r1, [pc, #436]	; (60001228 <ResetHandler+0x1f4>)
60001074:	cmp	r2, r1
60001076:	beq.n	60001098 <ResetHandler+0x64>
	while (dest < dest_end) {
60001078:	ldr	r3, [pc, #432]	; (6000122c <ResetHandler+0x1f8>)
6000107a:	cmp	r2, r3
6000107c:	bcs.n	60001098 <ResetHandler+0x64>
6000107e:	mvns	r4, r2
60001080:	mov	r0, r1
60001082:	add	r3, r4
60001084:	bic.w	r3, r3, #3
60001088:	adds	r3, #4
6000108a:	add	r3, r1
		*dest++ = *src++;
6000108c:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001090:	cmp	r0, r3
		*dest++ = *src++;
60001092:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001096:	bne.n	6000108c <ResetHandler+0x58>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001098:	ldr	r2, [pc, #404]	; (60001230 <ResetHandler+0x1fc>)
6000109a:	ldr	r3, [pc, #408]	; (60001234 <ResetHandler+0x200>)
6000109c:	cmp	r2, r3
6000109e:	bcs.n	600010b8 <ResetHandler+0x84>
600010a0:	mvns	r0, r2
600010a2:	mov	r1, r2
		*dest++ = 0;
600010a4:	movs	r4, #0
600010a6:	add	r3, r0
600010a8:	bic.w	r3, r3, #3
600010ac:	adds	r3, #4
600010ae:	add	r3, r2
600010b0:	str.w	r4, [r1], #4
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
600010b4:	cmp	r3, r1
600010b6:	bne.n	600010b0 <ResetHandler+0x7c>
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
600010b8:	ldr	r2, [pc, #380]	; (60001238 <ResetHandler+0x204>)
600010ba:	mov.w	r1, #15728640	; 0xf00000
600010be:	ldr	r3, [pc, #380]	; (6000123c <ResetHandler+0x208>)
600010c0:	str	r1, [r2, #0]
600010c2:	add.w	r1, r3, #704	; 0x2c0
600010c6:	ldr	r2, [pc, #376]	; (60001240 <ResetHandler+0x20c>)

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
600010c8:	str.w	r2, [r3, #4]!
600010cc:	cmp	r1, r3
600010ce:	bne.n	600010c8 <ResetHandler+0x94>
600010d0:	ldr	r3, [pc, #368]	; (60001244 <ResetHandler+0x210>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600010d2:	movs	r1, #128	; 0x80
600010d4:	ldr	r2, [pc, #368]	; (60001248 <ResetHandler+0x214>)
600010d6:	strb.w	r1, [r3], #1
600010da:	cmp	r3, r2
600010dc:	bne.n	600010d6 <ResetHandler+0xa2>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600010de:	ldr	r4, [pc, #364]	; (6000124c <ResetHandler+0x218>)
600010e0:	mov.w	r7, #2155905152	; 0x80808080
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600010e4:	ldr	r6, [pc, #360]	; (60001250 <ResetHandler+0x21c>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010e6:	mov.w	r2, #4294967295
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010ea:	ldr.w	sl, [pc, #420]	; 60001290 <ResetHandler+0x25c>
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600010ee:	movs	r5, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600010f0:	ldr.w	r9, [pc, #416]	; 60001294 <ResetHandler+0x260>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600010f4:	ldr.w	r8, [pc, #416]	; 60001298 <ResetHandler+0x264>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010f8:	ldr	r3, [pc, #344]	; (60001254 <ResetHandler+0x220>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010fa:	ldr	r1, [pc, #268]	; (60001208 <ResetHandler+0x1d4>)
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010fc:	str.w	sl, [r3]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001100:	str.w	r7, [r4, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001104:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001108:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000110c:	str.w	r8, [r4, #240]	; 0xf0
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
60001110:	ldr	r3, [r6, #28]
60001112:	bic.w	r3, r3, #127	; 0x7f
60001116:	orr.w	r3, r3, #64	; 0x40
6000111a:	str	r3, [r6, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
6000111c:	ldr	r3, [r6, #36]	; 0x24
6000111e:	bic.w	r3, r3, #127	; 0x7f
60001122:	orr.w	r3, r3, #64	; 0x40
60001126:	str	r3, [r6, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001128:	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
6000112a:	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
6000112c:	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
6000112e:	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
60001130:	bl	6000129c <configure_cache>
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001134:	ldr	r2, [pc, #288]	; (60001258 <ResetHandler+0x224>)
60001136:	movs	r0, #99	; 0x63
	SYST_CVR = 0;
60001138:	ldr	r3, [pc, #288]	; (6000125c <ResetHandler+0x228>)
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
6000113a:	ldr	r1, [pc, #292]	; (60001260 <ResetHandler+0x22c>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
6000113c:	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000113e:	movs	r2, #3
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001140:	str	r5, [r3, #0]
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
60001142:	str.w	r1, [sl, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001146:	str.w	r2, [r3, #-8]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000114a:	ldr	r1, [pc, #280]	; (60001264 <ResetHandler+0x230>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
6000114c:	ldr	r2, [pc, #280]	; (60001268 <ResetHandler+0x234>)

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
6000114e:	ldr	r0, [pc, #284]	; (6000126c <ResetHandler+0x238>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001150:	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001154:	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001156:	ldr	r2, [pc, #280]	; (60001270 <ResetHandler+0x23c>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001158:	orr.w	r3, r3, #16777216	; 0x1000000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
6000115c:	str.w	r0, [sl, #60]	; 0x3c
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001160:	ldr	r0, [pc, #272]	; (60001274 <ResetHandler+0x240>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001162:	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001164:	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001166:	ldr	r1, [pc, #272]	; (60001278 <ResetHandler+0x244>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001168:	orr.w	r3, r3, #1
6000116c:	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000116e:	ldr	r3, [r0, #0]
60001170:	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001172:	bl	6000135c <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001176:	str.w	r7, [r4, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
6000117a:	ldr	r0, [pc, #256]	; (6000127c <ResetHandler+0x248>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000117c:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001180:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001184:	str.w	r8, [r4, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001188:	bl	600016f8 <__set_arm_clock_veneer>
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?
6000118c:	nop
6000118e:	nop
60001190:	nop
60001192:	nop

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001194:	ldr	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
60001196:	ldr	r2, [pc, #232]	; (60001280 <ResetHandler+0x24c>)
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001198:	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000119c:	ldr	r3, [pc, #228]	; (60001284 <ResetHandler+0x250>)
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000119e:	str	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
600011a0:	str	r5, [r2, #0]
	PIT_TCTRL0 = 0;
600011a2:	str.w	r5, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
600011a6:	str.w	r5, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
600011aa:	str.w	r5, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
600011ae:	str.w	r5, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
600011b2:	ldr	r2, [r3, #56]	; 0x38
600011b4:	lsls	r2, r2, #31
600011b6:	bmi.n	600011ca <ResetHandler+0x196>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011b8:	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
600011bc:	ldr	r1, [pc, #200]	; (60001288 <ResetHandler+0x254>)
600011be:	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011c0:	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
600011c2:	ldr	r2, [r3, #56]	; 0x38
600011c4:	orr.w	r2, r2, #1
600011c8:	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600011ca:	ldr	r2, [pc, #184]	; (60001284 <ResetHandler+0x250>)
600011cc:	ldr	r4, [pc, #188]	; (6000128c <ResetHandler+0x258>)
600011ce:	ldr	r3, [r2, #8]
600011d0:	orr.w	r3, r3, #65537	; 0x10001
600011d4:	str	r3, [r2, #8]

	startup_early_hook();
600011d6:	bl	60001708 <__startup_early_hook_veneer>
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
600011da:	ldr	r3, [r4, #0]
	while (millis() < 20) ; // wait at least 20ms before starting USB
600011dc:	cmp	r3, #19
600011de:	bls.n	600011da <ResetHandler+0x1a6>
	usb_init();
600011e0:	bl	600013c0 <usb_init>
	analog_init();
600011e4:	bl	600014ac <analog_init>
	pwm_init();
600011e8:	bl	60001738 <__pwm_init_veneer>
	tempmon_init();
600011ec:	bl	60001504 <tempmon_init>

	startup_late_hook();
600011f0:	bl	60001728 <__startup_late_hook_veneer>
600011f4:	ldr	r3, [r4, #0]
	while (millis() < 300) ; // wait at least 300ms before calling user code
600011f6:	cmp.w	r3, #300	; 0x12c
600011fa:	bcc.n	600011f4 <ResetHandler+0x1c0>
	//printf("before C++ constructors\n");
	__libc_init_array();
600011fc:	bl	60001710 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
60001200:	bl	60001730 <__main_veneer>
60001204:	b.n	60001204 <ResetHandler+0x1d0>
60001206:	nop
60001208:	.word	0x400ac000
6000120c:	.word	0xaaaaaaaf
60001210:	.word	0x00200007
60001214:	.word	0x20070000
60001218:	.word	0x00000000
6000121c:	.word	0x60001750
60001220:	.word	0x0000a8e0
60001224:	.word	0x20000000
60001228:	.word	0x6000c03c
6000122c:	.word	0x200019d0
60001230:	.word	0x200019d0
60001234:	.word	0x200042c0
60001238:	.word	0xe000ed88
6000123c:	.word	0x200023fc
60001240:	.word	0x00002ba9
60001244:	.word	0xe000e400
60001248:	.word	0xe000e4a0
6000124c:	.word	0x400d8000
60001250:	.word	0x400fc000
60001254:	.word	0xe000ed08
60001258:	.word	0xe000e014
6000125c:	.word	0xe000e018
60001260:	.word	0x00003ed5
60001264:	.word	0xe000edfc
60001268:	.word	0x20200000
6000126c:	.word	0x00003fd9
60001270:	.word	0xe0001000
60001274:	.word	0xe0001004
60001278:	.word	0x20001e6c
6000127c:	.word	0x23c34600
60001280:	.word	0x40084000
60001284:	.word	0x400d4000
60001288:	.word	0x56c00000
6000128c:	.word	0x20001e74
60001290:	.word	0x20002400
60001294:	.word	0x2018101b
60001298:	.word	0x13110d0c

6000129c <configure_cache>:
#define SIZE_64M	(SCB_MPU_RASR_SIZE(25) | SCB_MPU_RASR_ENABLE)
#define SIZE_256M	(SCB_MPU_RASR_SIZE(26) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
6000129c:	push	{r4, r5, r6, r7, lr}

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
6000129e:	ldr	r2, [pc, #116]	; (60001314 <configure_cache+0x78>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600012a0:	movs	r1, #0

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600012a2:	ldr	r3, [pc, #116]	; (60001318 <configure_cache+0x7c>)

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
600012a4:	mov.w	lr, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600012a8:	ldr	r0, [pc, #112]	; (6000131c <configure_cache+0x80>)

	// TODO: 32 byte sub-region at 0x00000000 with NOACCESS, to trap NULL pointer deref
	// TODO: protect access to power supply config
	// TODO: 32 byte sub-region at end of .bss section with NOACCESS, to trap stack overflow

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600012aa:	movs	r4, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600012ac:	ldr	r7, [pc, #112]	; (60001320 <configure_cache+0x84>)

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
600012ae:	ldr	r6, [pc, #116]	; (60001324 <configure_cache+0x88>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600012b0:	ldr	r5, [pc, #116]	; (60001328 <configure_cache+0x8c>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600012b2:	str	r1, [r0, #0]

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
600012b4:	str.w	lr, [r2]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600012b8:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
600012ba:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
600012bc:	ldr	r7, [pc, #108]	; (6000132c <configure_cache+0x90>)

	SCB_MPU_RBAR = 0x00000000 | REGION(0); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600012be:	str	r5, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600012c0:	ldr	r6, [pc, #108]	; (60001330 <configure_cache+0x94>)

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
600012c2:	ldr	r5, [pc, #112]	; (60001334 <configure_cache+0x98>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	SCB_MPU_RBAR = 0x00200000 | REGION(1); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
600012c4:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600012c6:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600012c8:	ldr	r7, [pc, #108]	; (60001338 <configure_cache+0x9c>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
600012ca:	str	r5, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
600012cc:	ldr	r6, [pc, #108]	; (6000133c <configure_cache+0xa0>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600012ce:	ldr	r5, [pc, #112]	; (60001340 <configure_cache+0xa4>)

	SCB_MPU_RBAR = 0x20000000 | REGION(2); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600012d0:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
600012d2:	str	r6, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
600012d4:	ldr	r7, [pc, #108]	; (60001344 <configure_cache+0xa8>)

	SCB_MPU_RBAR = 0x20200000 | REGION(3); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600012d6:	str	r5, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600012d8:	ldr	r6, [pc, #108]	; (60001348 <configure_cache+0xac>)

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
600012da:	ldr	r5, [pc, #112]	; (6000134c <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(4); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
600012dc:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600012de:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_256M;
600012e0:	ldr	r7, [pc, #108]	; (60001350 <configure_cache+0xb4>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
600012e2:	str	r5, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_256M;

	SCB_MPU_RBAR = 0x70000000 | REGION(7); // FlexSPI2
600012e4:	ldr	r6, [pc, #108]	; (60001354 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | SIZE_16M;
600012e6:	ldr	r5, [pc, #112]	; (60001358 <configure_cache+0xbc>)

	SCB_MPU_RBAR = 0x60000000 | REGION(5); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(6); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_256M;
600012e8:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(7); // FlexSPI2
600012ea:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | SIZE_16M;
600012ec:	str	r5, [r3, #0]

	// TODO: 32 byte sub-region at 0x00000000 with NOACCESS, to trap NULL pointer deref
	// TODO: protect access to power supply config
	// TODO: 32 byte sub-region at end of .bss section with NOACCESS, to trap stack overflow

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600012ee:	str	r4, [r0, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
600012f0:	dsb	sy
	asm("isb");
600012f4:	isb	sy
	SCB_CACHE_ICIALLU = 0;
600012f8:	str.w	r1, [r3, #432]	; 0x1b0

	asm("dsb");
600012fc:	dsb	sy
	asm("isb");
60001300:	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
60001304:	ldr.w	r3, [r2, #-136]
60001308:	orr.w	r3, r3, #196608	; 0x30000
6000130c:	str.w	r3, [r2, #-136]
60001310:	pop	{r4, r5, r6, r7, pc}
60001312:	nop
60001314:	.word	0xe000ed9c
60001318:	.word	0xe000eda0
6000131c:	.word	0xe000ed94
60001320:	.word	0x03080025
60001324:	.word	0x00200011
60001328:	.word	0x07020021
6000132c:	.word	0x20000012
60001330:	.word	0x13080025
60001334:	.word	0x20200013
60001338:	.word	0x130b0027
6000133c:	.word	0x40000014
60001340:	.word	0x13100033
60001344:	.word	0x60000015
60001348:	.word	0x070b002f
6000134c:	.word	0x70000016
60001350:	.word	0x070b0035
60001354:	.word	0x70000017
60001358:	.word	0x030b002f

6000135c <usb_pll_start>:
}


FLASHMEM void usb_pll_start()
{
6000135c:	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
6000135e:	ldr	r2, [pc, #92]	; (600013bc <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001360:	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001362:	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001366:	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000136a:	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000136e:	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001372:	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001376:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001378:	tst.w	r3, #2
6000137c:	beq.n	6000138c <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000137e:	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001380:	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001382:	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001384:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001386:	tst.w	r3, #2
6000138a:	bne.n	6000137e <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
6000138c:	tst.w	r3, #8192	; 0x2000
60001390:	bne.n	60001396 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001392:	str	r5, [r2, #20]
			continue;
60001394:	b.n	60001376 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001396:	tst.w	r3, #4096	; 0x1000
6000139a:	bne.n	600013a0 <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000139c:	str	r6, [r2, #20]
			continue;
6000139e:	b.n	60001376 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
600013a0:	cmp	r3, #0
600013a2:	bge.n	60001376 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
600013a4:	tst.w	r3, #65536	; 0x10000
600013a8:	beq.n	600013ae <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600013aa:	str	r1, [r2, #24]
			continue;
600013ac:	b.n	60001376 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
600013ae:	lsls	r3, r3, #25
600013b0:	bmi.n	600013b6 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600013b2:	str	r7, [r2, #20]
			continue;
600013b4:	b.n	60001376 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
600013b6:	pop	{r4, r5, r6, r7}
600013b8:	bx	lr
600013ba:	nop
600013bc:	.word	0x400d8000

600013c0 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600013c0:	ldr	r3, [pc, #192]	; (60001484 <usb_init+0xc4>)
600013c2:	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
600013c6:	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600013c8:	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600013cc:	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
600013d0:	bl	60001718 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013d4:	ldr	r1, [pc, #176]	; (60001488 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600013d6:	ldr	r0, [pc, #180]	; (6000148c <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013d8:	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600013dc:	ldr	r4, [pc, #176]	; (60001490 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013de:	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600013e2:	ldr	r3, [pc, #176]	; (60001494 <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600013e4:	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600013e8:	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600013ec:	ldr	r2, [r4, #0]
600013ee:	ands	r3, r2
600013f0:	cbnz	r3, 600013fa <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
600013f2:	ldr.w	r3, [r0, #424]	; 0x1a8
600013f6:	lsls	r2, r3, #30
600013f8:	beq.n	60001430 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
600013fa:	ldr	r3, [pc, #144]	; (6000148c <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
600013fc:	mov.w	r1, #2147483648	; 0x80000000
60001400:	ldr	r2, [pc, #140]	; (60001490 <usb_init+0xd0>)
60001402:	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001404:	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001406:	ldr.w	r1, [r3, #320]	; 0x140
6000140a:	orr.w	r1, r1, #2
6000140e:	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001412:	ldr.w	r3, [r2, #320]	; 0x140
60001416:	lsls	r3, r3, #30
60001418:	bmi.n	60001412 <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000141a:	mov.w	r0, #131072	; 0x20000
6000141e:	ldr	r1, [pc, #120]	; (60001498 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001420:	ldr	r3, [pc, #108]	; (60001490 <usb_init+0xd0>)
60001422:	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001426:	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001428:	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
6000142a:	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
6000142c:	bl	60001720 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001430:	ldr	r5, [pc, #104]	; (6000149c <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001432:	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001434:	ldr	r3, [pc, #88]	; (60001490 <usb_init+0xd0>)
60001436:	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000143a:	ldr	r4, [pc, #80]	; (6000148c <usb_init+0xcc>)
6000143c:	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000143e:	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001440:	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001442:	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001444:	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001446:	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000144a:	mov.w	r2, #640	; 0x280
6000144e:	bl	60001700 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001452:	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
60001456:	mov.w	r0, #4194304	; 0x400000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000145a:	movw	r3, #323	; 0x143
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
6000145e:	ldr	r2, [pc, #64]	; (600014a0 <usb_init+0xe0>)
60001460:	ldr	r1, [pc, #64]	; (600014a4 <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001462:	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001464:	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001466:	str.w	r5, [r4, #344]	; 0x158
6000146a:	str.w	r1, [r2, #516]	; 0x204
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000146e:	str.w	r3, [r4, #328]	; 0x148
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001472:	ldr	r2, [pc, #52]	; (600014a8 <usb_init+0xe8>)
60001474:	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001478:	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
6000147a:	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
6000147c:	str.w	r3, [r4, #320]	; 0x140
60001480:	pop	{r4, r5, r6, pc}
60001482:	nop
60001484:	.word	0x400d8000
60001488:	.word	0x400fc000
6000148c:	.word	0x402e0000
60001490:	.word	0x400d9000
60001494:	.word	0x001e1c00
60001498:	.word	0xe000e28c
6000149c:	.word	0x20004000
600014a0:	.word	0x20002400
600014a4:	.word	0x000030a9
600014a8:	.word	0xe000e10c

600014ac <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014ac:	ldr	r3, [pc, #68]	; (600014f4 <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014ae:	ldr	r1, [pc, #72]	; (600014f8 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014b0:	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600014b2:	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014b4:	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
600014b8:	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600014ba:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014bc:	movw	r5, #1719	; 0x6b7
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
600014c0:	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
600014c2:	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
600014c4:	orr.w	r0, r0, #768	; 0x300
600014c8:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014ca:	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
600014cc:	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600014ce:	ldr	r3, [r2, #72]	; 0x48
600014d0:	lsls	r3, r3, #24
600014d2:	bmi.n	600014ce <analog_init+0x22>
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014d4:	ldr	r3, [pc, #36]	; (600014fc <analog_init+0x50>)
600014d6:	movw	r0, #1719	; 0x6b7
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
600014da:	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
600014dc:	mov	r2, r3
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_HC_AIEN | ADC_CFG_ADHSC;
600014de:	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
600014e0:	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
600014e2:	ldr	r3, [r2, #72]	; 0x48
600014e4:	ands.w	r3, r3, #128	; 0x80
600014e8:	bne.n	600014e2 <analog_init+0x36>
	calibrating = 0;
600014ea:	ldr	r2, [pc, #20]	; (60001500 <analog_init+0x54>)
600014ec:	strb	r3, [r2, #0]
}
600014ee:	pop	{r4, r5}
600014f0:	bx	lr
600014f2:	nop
600014f4:	.word	0x400fc000
600014f8:	.word	0x400c4000
600014fc:	.word	0x400c8000
60001500:	.word	0x20001e78

60001504 <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001504:	ldr	r2, [pc, #236]	; (600015f4 <tempmon_init+0xf0>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001506:	vmov.f32	s13, #57	; 0x41c80000  25.0

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
6000150a:	ldr	r1, [pc, #236]	; (600015f8 <tempmon_init+0xf4>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
6000150c:	movs	r0, #0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
6000150e:	ldr	r3, [r2, #0]
  asm volatile ("dsb":::"memory");
  while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001510:	push	{r4, r5, r6, r7, lr}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001512:	bic.w	r3, r3, #1

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001516:	movs	r4, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001518:	ldr.w	lr, [pc, #256]	; 6000161c <tempmon_init+0x118>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
6000151c:	str	r3, [r2, #0]

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
6000151e:	str.w	r4, [r2, #144]	; 0x90
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001522:	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
60001526:	ldr	r7, [pc, #212]	; (600015fc <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001528:	uxtb	r5, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
6000152a:	ubfx	r4, r3, #8, #12
6000152e:	ldr	r6, [pc, #208]	; (60001600 <tempmon_init+0xfc>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
60001530:	rsb	r3, r4, r3, lsr #20
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001534:	vmov	s15, r5
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001538:	sub.w	r1, r5, #85	; 0x55
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
6000153c:	str.w	r5, [lr]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001540:	vcvt.f32.s32	s14, s15
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001544:	add.w	r5, r3, r3, lsl #2
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001548:	vmov	s15, r4
6000154c:	mul.w	r1, r3, r1
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
60001550:	str	r3, [r7, #0]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001552:	add.w	r3, r3, r3, lsl #6
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001556:	vcvt.f32.s32	s10, s15
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000155a:	vmov	s15, r1
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000155e:	subs	r1, r1, r5
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001560:	vsub.f32	s13, s14, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001564:	vcvt.f32.u32	s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001568:	ldr	r5, [pc, #152]	; (60001604 <tempmon_init+0x100>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000156a:	vmov	s15, r1
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000156e:	add	r3, r1
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001570:	vstr	s13, [r5]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001574:	vcvt.f32.u32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001578:	str	r4, [r6, #0]
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000157a:	vdiv.f32	s11, s14, s13
6000157e:	ldr	r6, [pc, #136]	; (60001608 <tempmon_init+0x104>)
60001580:	ldr	r5, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001582:	ldr	r1, [pc, #136]	; (6000160c <tempmon_init+0x108>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001584:	ldr	r4, [pc, #136]	; (60001610 <tempmon_init+0x10c>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001586:	vdiv.f32	s12, s15, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000158a:	vmov	s15, r3
6000158e:	ldr	r3, [pc, #132]	; (60001614 <tempmon_init+0x110>)
60001590:	str.w	r3, [r6, #320]	; 0x140
60001594:	vcvt.f32.u32	s15, s15
60001598:	vdiv.f32	s14, s15, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000159c:	vadd.f32	s11, s11, s10
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015a0:	vadd.f32	s13, s12, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015a4:	vcvt.u32.f32	s11, s11
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015a8:	vcvt.u32.f32	s13, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015ac:	vmov	r3, s11
600015b0:	orr.w	r3, r5, r3, lsl #20
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015b4:	vmov	r5, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015b8:	vadd.f32	s15, s14, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015bc:	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015be:	and.w	r1, r1, r5, lsl #16
600015c2:	ldr.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015c6:	vcvt.u32.f32	s15, s15
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600015ca:	orrs	r3, r1
600015cc:	str.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015d0:	vmov	r3, s15
600015d4:	ldr.w	r1, [r2, #272]	; 0x110
600015d8:	ubfx	r3, r3, #0, #12
600015dc:	orrs	r3, r1
600015de:	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
600015e2:	ldr	r3, [r2, #0]
600015e4:	orr.w	r3, r3, #2
600015e8:	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600015ea:	strb	r0, [r4, #0]
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600015ec:	ldr	r3, [pc, #40]	; (60001618 <tempmon_init+0x114>)
600015ee:	movs	r2, #1
600015f0:	str	r2, [r3, #0]
600015f2:	pop	{r4, r5, r6, r7, pc}
600015f4:	.word	0x400d8180
600015f8:	.word	0x401f4400
600015fc:	.word	0x20001e84
60001600:	.word	0x20001e88
60001604:	.word	0x20001e80
60001608:	.word	0x20002400
6000160c:	.word	0x0fff0000
60001610:	.word	0xe000e440
60001614:	.word	0x00003955
60001618:	.word	0xe000e108
6000161c:	.word	0x20001e7c

60001620 <usb_string_product_name_default>:
60001620:	..U.S.B. .S.e.r.
60001630:	i.a.l...

60001638 <usb_string_manufacturer_name_default>:
60001638:	..T.e.e.n.s.y.d.
60001648:	u.i.n.o.

60001650 <string0>:
60001650:	....

60001654 <usb_config_descriptor_12>:
60001654:	..C.....2.......
60001664:	...$....$....$..
60001674:	.$..............
60001684:	.........@......
60001694:	@...

60001698 <usb_config_descriptor_480>:
60001698:	..C.....2.......
600016a8:	...$....$....$..
600016b8:	.$..............
600016c8:	................
600016d8:	....

600016dc <qualifier_descriptor>:
600016dc:	.......@....

600016e8 <_init>:
600016e8:	push	{r3, r4, r5, r6, r7, lr}
600016ea:	nop
600016ec:	pop	{r3, r4, r5, r6, r7}
600016ee:	pop	{r3}
600016f0:	mov	lr, r3
600016f2:	bx	lr
600016f4:			; <UNDEFINED> instruction: 0xffffffff

600016f8 <__set_arm_clock_veneer>:
600016f8:	ldr.w	pc, [pc]	; 600016fc <__set_arm_clock_veneer+0x4>
600016fc:	.word	0x00002cad

60001700 <__memset_veneer>:
60001700:	ldr.w	pc, [pc]	; 60001704 <__memset_veneer+0x4>
60001704:	.word	0x000082b9

60001708 <__startup_early_hook_veneer>:
60001708:	ldr.w	pc, [pc]	; 6000170c <__startup_early_hook_veneer+0x4>
6000170c:	.word	0x00002bc1

60001710 <____libc_init_array_veneer>:
60001710:	ldr.w	pc, [pc]	; 60001714 <____libc_init_array_veneer+0x4>
60001714:	.word	0x00007be9

60001718 <__usb_init_serialnumber_veneer>:
60001718:	ldr.w	pc, [pc]	; 6000171c <__usb_init_serialnumber_veneer+0x4>
6000171c:	.word	0x00003d09

60001720 <__delay_veneer>:
60001720:	ldr.w	pc, [pc]	; 60001724 <__delay_veneer+0x4>
60001724:	.word	0x00003889

60001728 <__startup_late_hook_veneer>:
60001728:	ldr.w	pc, [pc]	; 6000172c <__startup_late_hook_veneer+0x4>
6000172c:	.word	0x00002bc5

60001730 <__main_veneer>:
60001730:	ldr.w	pc, [pc]	; 60001734 <__main_veneer+0x4>
60001734:	.word	0x00003d61

60001738 <__pwm_init_veneer>:
60001738:	ldr.w	pc, [pc]	; 6000173c <__pwm_init_veneer+0x4>
6000173c:	.word	0x00003979

60001740 <__init_array_start>:
60001740:	.word	0x00000045
60001744:	.word	0x000000e5

60001748 <__init_array_end>:
60001748:	.word	0xffffffff
6000174c:	.word	0xffffffff

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
      20:	.word	0x4c05b510
		USB1_USBINTR = intr | USB_USBINTR_SRE;
      24:	ldrb	r3, [r4, #0]
      26:	cbnz	r3, 36 <__rtc_localtime+0x5>
	}
	__enable_irq();
      28:	ldr	r3, [pc, #16]	; (3c <__rtc_localtime+0xb>)
      2a:	cbz	r3, 32 <__rtc_localtime+0x1>
      2c:	.word	0xf3af4804
      30:	strh	r0, [r0, #0]
      32:	.short	0x2301
    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);

    return tmeas;
      34:	strb	r3, [r4, #0]
      36:	.short	0xbd10
      38:	adds	r0, r2, r7
      3a:	.short	0x2000
      3c:	movs	r0, r0
      3e:	movs	r0, r0
}
      40:	.word	0x0000a8e4

00000044 <frame_dummy>:
      44:	ldr	r3, [pc, #32]	; (68 <frame_dummy+0x24>)
      46:	.short	0xb510
      48:	cbz	r3, 52 <frame_dummy+0xe>
      4a:	ldr	r1, [pc, #32]	; (6c <frame_dummy+0x28>)
      4c:	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	nop.w
      52:	ldr	r0, [pc, #32]	; (74 <frame_dummy+0x30>)
      54:	ldr	r3, [r0, #0]
      56:	cbnz	r3, 5a <frame_dummy+0x16>
      58:	.word	0x4b07bd10
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
  ADC2_CFG = mode1;
      5c:	cmp	r3, #0

    } else if (num >= 16) {
      mode |= ADC_CFG_AVGS(2);
      mode1 |= ADC_CFG_AVGS(2);

    } else if (num >= 8) {
      5e:	beq.n	58 <frame_dummy+0x14>
      60:	ldmia.w	sp!, {r4, lr}
      mode |= ADC_CFG_AVGS(1);
      64:	.word	0xbf004718
      mode1 |= ADC_CFG_AVGS(1);
      68:	movs	r0, r0
    } else {
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
      6a:	.short	0x0000
  ADC2_CFG = mode1;
  
  if(num >= 4){
      6c:	adds	r4, r2, r7
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
  ADC2_CFG = mode1;
      6e:	.short	0x2000
    } else {
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
      70:	add	r0, sp, #912	; 0x390
  ADC2_CFG = mode1;
      72:	movs	r0, r0
  
  if(num >= 4){
      74:	adds	r0, r2, r7
      ADC1_GC |= ADC_GC_AVGE;// turns on averaging
      ADC2_GC |= ADC_GC_AVGE;// turns on averaging
  }
}
      76:	movs	r0, #0
      78:	movs	r0, r0
	...

0000007c <setup>:

/////////////////////

void setup() {
    // while(!Serial);
    pinMode(led_pin, OUTPUT);
      7c:	movs	r1, #1
      7e:	.short	0x200d
      80:	b.w	3c88 <pinMode>

00000084 <loop>:
      84:	.word	0x4a124b11
    imu.imu_hardware.enableGyro(Config::dt*1000); // Send data update every 50ms
    */

}

void loop() {
      88:	push	{r4, lr}
      8a:	ldr	r4, [r3, #0]
      8c:	.word	0x6813b084

    long current_time = millis();
    long delta_time = current_time - last_time;
    if (delta_time < (long(Config::dt*1000))) {
      90:	subs	r3, r4, r3
      92:	.short	0x2b09
      94:	ble.n	c8 <loop+0x44>
        return;
    }
    last_time = current_time;

    command.setMode(Mode::TROT);
      96:	.short	0x2101
      98:	ldr	r0, [pc, #56]	; (d4 <loop+0x50>)
    long current_time = millis();
    long delta_time = current_time - last_time;
    if (delta_time < (long(Config::dt*1000))) {
        return;
    }
    last_time = current_time;
      9a:	str	r4, [r2, #0]

    command.setMode(Mode::TROT);
      9c:	bl	1824 <project_namespace::Command::setMode(project_namespace::Mode)>
    command.setSwingHeight(0.1);
      a0:	.word	0x0a0ded9f
      a4:	ldr	r0, [pc, #44]	; (d4 <loop+0x50>)
      a6:	.short	0xf001
      a8:			; <UNDEFINED> instruction: 0xfbb9f04f
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
      ac:	.word	0x2300527c
    command.setBodyVelocity(Eigen::Vector3f(0.5, 0, 0));
      b0:	add	r1, sp, #4
      b2:	.short	0x4808
      b4:	str	r2, [sp, #4]
      m_storage.data()[1] = y;
      b6:	str	r3, [sp, #8]
      m_storage.data()[2] = z;
      b8:	str	r3, [sp, #12]
      ba:	.short	0xf001
      bc:	umull	r4, sl, r7, r5
    master_controller.stepOnce(robot, command);
      c0:	ldr	r1, [pc, #24]	; (dc <loop+0x58>)
      c2:	.short	0x4807
      c4:	bl	69c <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)>
    //     "%.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f",
    //     FL_x, FL_y, FL_z, FR_x, FR_y, FR_z, BL_x, BL_y, BL_z, BR_x, BR_y, BR_z
    // );
    // Serial.println(sprintf_buffer);

      c8:	add	sp, #16
      ca:	pop	{r4, pc}
      cc:	subs	r4, r6, #1
      ce:	movs	r0, #0
      d0:	adds	r4, r5, r7
      d2:	.short	0x2000
      d4:	adds	r0, r6, r7
      d6:	.short	0x2000
      d8:	ldmia	r4!, {r0, r2, r3, r6, r7}
      da:	.short	0x3dcc
      dc:	subs	r0, r4, r0
      de:	.short	0x2000
      e0:	adds	r0, r0, #0
      e2:	.short	0x2000

000000e4 <_GLOBAL__sub_I_robot>:
      e4:	push	{r3, r4, r5, r6, r7, lr}

using namespace project_namespace;

const int led_pin = 13;

Robot robot;
      e6:	.short	0x4819
#define CALIBRATE_STOP 5

#define MAX_PACKET_SIZE 128 //Packets can be up to 32k but we don't have that much RAM.
#define MAX_METADATA_SIZE 9 //This is in words. There can be many but we mostly only care about the first 9 (Qs, range, etc)

class BNO080
      e8:	movs	r5, #12
      ea:	.short	0xf000
      ec:	mrc2	8, 1, r4, cr3, cr8, {0}
Command command;
      f0:	bl	1784 <project_namespace::Command::Command()>
      f4:	ldr	r3, [pc, #92]	; (154 <_GLOBAL__sub_I_robot+0x70>)
      f6:	.short	0x220e
BNO080 imu_hardware;
IMU imu(imu_hardware);
      f8:	ldr	r4, [pc, #92]	; (158 <_GLOBAL__sub_I_robot+0x74>)
      fa:	.short	0x2109
      fc:	movs	r0, #4
      fe:	strh.w	r2, [r3, #288]	; 0x120
     102:	.short	0x270a
     104:	movs	r2, #0
     106:	.short	0xf8a3
     108:	str	r2, [r4, r4]
     10a:	.short	0x2508
     10c:	strh.w	r1, [r3, #296]	; 0x128
     110:	.word	0x012af8a3
     114:	mov	r1, r3
     116:	mov	r0, r4
     118:	.word	0x2088f8a3
     11c:	str.w	r2, [r3, #132]	; 0x84
     120:	strb.w	r2, [r3, #138]	; 0x8a
     124:	strb.w	r2, [r3, #188]	; 0xbc
     128:	.word	0x712cf8a3
     12c:	strh.w	r5, [r3, #292]	; 0x124
     130:	.word	0x5126f8a3
     134:	bl	c78 <project_namespace::IMU::IMU(BNO080&)>
MasterController master_controller(imu);
     138:	.word	0x48084621
     13c:	bl	67c <project_namespace::MasterController::MasterController(project_namespace::IMU&)>
     140:	.word	0x4b084a07
     144:	ldr	r2, [r2, #0]

long last_time = millis();
     146:	.short	0x601a
     148:	pop	{r3, r4, r5, r6, r7, pc}
     14a:	.short	0xbf00
     14c:	subs	r0, r4, r0
     14e:	.short	0x2000
     150:	adds	r0, r6, r7
     152:	.short	0x2000
     154:	adds	r0, r0, #4
     156:	.short	0x2000
     158:	adds	r0, r0, #3
     15a:	.short	0x2000
     15c:	adds	r0, r0, #0
     15e:	.short	0x2000
     160:	subs	r4, r6, #1
     162:	.short	0x2000
     164:	adds	r4, r5, r7
     166:	.short	0x2000

00000168 <project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)>:
     168:	str	r1, [r0, #0]
     16a:	bx	lr

0000016c <project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)>:
     16c:	.word	0x41f0e92d
     170:	vpush	{d8-d11}
     174:	.word	0xeddfb08c
     178:	ldrh	r7, [r7, #16]
     17a:	.short	0x4611
     17c:	mov	r4, r0
     17e:	.short	0xaf00
     180:	sub	sp, #64	; 0x40
     182:	.short	0x461e
     184:	ldr.w	r8, [r7, #104]	; 0x68
     188:	.word	0x050ff10d
     18c:	vstr	s17, [r0]
     190:	.word	0x0848eb08
     194:	vstr	s17, [r0, #4]
     198:	.word	0x050ff025
     19c:	vstr	s17, [r0, #8]
     1a0:	.word	0x9a35ed9f
     1a4:	mov	r0, r5
     1a6:	.short	0xf000
     1a8:	vmin.u16	d4, d5, d17
     1ac:	.word	0x0388eb05
     1b0:	mov	r0, r7
     1b2:	vldr	s21, [r3]
     1b6:	.short	0xed93
     1b8:	rev	r1, r0
     1ba:	.short	0xed93
     1bc:	ldrh	r2, [r0, #16]
     1be:	bl	17e8 <project_namespace::Command::getBodyVelocity()>
     1c2:	.short	0x4631
     1c4:	add.w	r0, r7, #12
     1c8:	.word	0xaa00ed97
     1cc:	bl	17e8 <project_namespace::Command::getBodyVelocity()>
     1d0:	.word	0xedd74630
     1d4:	ldr	r2, [sp, #16]
     1d6:	.short	0xf001
     1d8:	mul.w	r1, pc, r7
     1dc:	.word	0xee20000c
     1e0:	subs	r1, r1, r1
     1e2:	.short	0xeef0
     1e4:	lsrs	r0, r5, #9
     1e6:	vmov.f32	s0, s17
     1ea:	.short	0xf000
     1ec:	vld2.32	{d14[]-d15[]}, [fp :64], r7
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     1f0:	.word	0xedd77a09
     1f4:	ldrb	r2, [r1, #8]
     1f6:	vneg.f32	s20, s20
     1fa:	.short	0xee28
     1fc:	ldrb	r7, [r0, #8]
     1fe:	.short	0xedd7
     200:	ldrh	r6, [r0, r0]
     202:	.short	0xee68
     204:	ldrb	r7, [r4, #8]
     206:	vldr	s12, [r7, #28]
     20a:	vldr	s13, [r7, #44]	; 0x2c
     20e:	vneg.f32	s19, s19
     212:	.short	0xeeab
     214:	ldrb	r5, [r4, #8]
     216:	.short	0xed97
     218:	ldrh	r0, [r1, r0]
     21a:	.short	0xeeeb
     21c:	ldrb	r6, [r0, #8]
     21e:	.short	0xedd7
     220:	ldrh	r3, [r0, r0]
     222:	.short	0xee28
     224:	ldrh	r6, [r4, #16]
     226:	vldr	s12, [r7, #16]
     22a:	.short	0xedd7
     22c:	ldr	r5, [r0, #32]
     22e:	.short	0x4630
     230:	vfma.f32	s16, s22, s10
     234:	.word	0x7aa5eeaa
     238:	vfma.f32	s15, s21, s12
     23c:	vfma.f32	s16, s21, s13
     240:	.word	0x7a09eeaa
     244:	vfma.f32	s15, s19, s18
     248:	.word	0x8a28ee38
     24c:	vstr	s14, [r4]
     250:	vstr	s15, [r4, #4]
     254:	vstr	s16, [r4, #8]
     258:	.word	0xfab6f001
     25c:	vneg.f32	s0, s0
     260:	.word	0x37304620
     264:	vstr	s0, [r4, #8]
     268:	.word	0xecbd46bd
     26c:	ldrh	r0, [r1, #24]
     26e:	.short	0xe8bd
     270:	strh	r0, [r6, #14]
     272:	.short	0xbf00
     274:	movs	r0, r0
     276:	.short	0x0000
     278:	bvc.n	290 <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)+0x14>
     27a:	.short	0x3c23

0000027c <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>:
     27c:	push	{r4, r5}
     27e:	mov	r3, r0
     280:	.word	0x0a00ed80
     284:	vstr	s1, [r0, #4]
     288:	.word	0xed802400
     28c:	subs	r2, r0, r0
     28e:	add.w	r5, r0, #24
     292:	.short	0xedc0
     294:	subs	r3, r0, r0
     296:	.short	0xed80
     298:	cmp	r2, #4
     29a:	.short	0xedc0
     29c:	cmp	r2, #5
     29e:	ldmia	r1, {r0, r1, r2}
     2a0:	.word	0x0007e885
     2a4:	str	r4, [r3, #36]	; 0x24
     2a6:	.short	0x4618
     2a8:	str	r4, [r3, #40]	; 0x28
     2aa:	str	r4, [r3, #44]	; 0x2c
     2ac:	str	r4, [r3, #48]	; 0x30
     2ae:	str	r4, [r3, #52]	; 0x34
     2b0:	str	r4, [r3, #56]	; 0x38
     2b2:	pop	{r4, r5}
     2b4:	bx	lr
     2b6:	.short	0xbf00

000002b8 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
     2b8:	push	{r3, r4, r5, lr}
     2ba:	.short	0xed2d
     2bc:	ldrh	r4, [r1, #24]
     2be:	vldr	s16, [r2, #8]
     2c2:	vmov.f64	d1, #96	; 0x3f000000  0.5
     2c6:	vldr	s15, [r2, #4]
     2ca:	mov	r4, r1
     2cc:	vcvt.f64.f32	d0, s16
     2d0:	.word	0x7a01ed91
     2d4:	mov	r5, r0
     2d6:	.short	0xed92
     2d8:	add	r2, sp, #0
     2da:	.short	0xee37
     2dc:	ldrb	r7, [r0, #11]
     2de:	vmul.f64	d0, d0, d0
     2e2:	.short	0xeeb7
     2e4:	ldrb	r7, [r0, #11]
     2e6:	.short	0xeea7
     2e8:	lsrs	r7, r0, #12
     2ea:	.short	0xf004
     2ec:			; <UNDEFINED> instruction: 0xfa25eeb5
     2f0:	.word	0xeeb78ac0
     2f4:	ldr	r3, [sp, #768]	; 0x300
     2f6:	vmrs	APSR_nzcv, fpscr
     2fa:	it	le
     2fc:	vnegle.f32	s16, s16
     300:	vdiv.f32	s0, s16, s18
     304:	vcvt.f64.f32	d0, s0
     308:	bl	4688 <asin>
     30c:	vldr	s15, [r4, #12]
     310:	vcvt.f32.f64	s21, d0
     314:	.word	0x7ac0eef5
     318:	vmrs	APSR_nzcv, fpscr
     31c:	.word	0xeef1bfd8
     320:	ldrb	r7, [r4, #9]
     322:	.short	0xee87
     324:	lsrs	r1, r1, #10
     326:	vcvt.f64.f32	d0, s0
     32a:	bl	45dc <acos>
     32e:	vmov.f64	d8, d0
     332:	vldr	s0, [r4, #12]
     336:	.short	0xeeb7
     338:	ldrb	r1, [r1, #11]
     33a:	.short	0xeeb7
     33c:	lsrs	r0, r0, #11
     33e:	.short	0xee20
     340:	lsrs	r0, r0, #13
     342:	vfma.f64	d0, d7, d7
     346:	vsqrt.f64	d11, d0
     34a:	vcmp.f64	d11, d11
     34e:	vmrs	APSR_nzcv, fpscr
     352:	bne.w	458 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x1a0>
     356:	vldr	s15, [r4]
     35a:	vcvt.f32.f64	s22, d11
     35e:	vldr	s0, [r4, #8]
     362:	vsub.f32	s15, s20, s15
     366:	vcvt.f64.f32	d11, s22
     36a:	vsub.f32	s0, s15, s0
     36e:	vcvt.f64.f32	d0, s0
     372:	vmul.f64	d0, d0, d0
     376:	vfma.f64	d0, d11, d11
     37a:	.short	0xeeb1
     37c:	ldr	r3, [sp, #768]	; 0x300
     37e:	.short	0xeeb4
     380:	ldr	r3, [sp, #292]	; 0x124
     382:	.short	0xeef1
     384:			; <UNDEFINED> instruction: 0xfa10d16c
     388:	.word	0x7a04ed94
     38c:	vcvt.f32.f64	s18, d9
     390:	.word	0xdb00eeb8
     394:	vldr	s12, [r4, #20]
     398:	vcvt.f64.f32	d7, s14
     39c:	vcvt.f64.f32	d9, s18
     3a0:	vcvt.f64.f32	d6, s12
     3a4:	vnmul.f64	d0, d7, d7
     3a8:	vmul.f64	d7, d7, d13
     3ac:	vfma.f64	d0, d9, d9
     3b0:	vmul.f64	d7, d7, d6
     3b4:	vfms.f64	d0, d6, d6
     3b8:	vdiv.f64	d0, d0, d7
     3bc:	bl	45dc <acos>
     3c0:	vldr	s14, [r4, #20]
     3c4:	vldr	s12, [r4, #16]
     3c8:	vcvt.f64.f32	d7, s14
     3cc:	.word	0x6ac6eeb7
     3d0:	vmov.f64	d12, d0
     3d4:	vmul.f64	d7, d7, d7
     3d8:	vmul.f64	d0, d9, d13
     3dc:	vfms.f64	d7, d9, d9
     3e0:	vmul.f64	d0, d0, d6
     3e4:	vfms.f64	d7, d6, d6
     3e8:	vdiv.f64	d0, d7, d0
     3ec:	bl	45dc <acos>
     3f0:	vldr	s15, [r4, #8]
     3f4:	vmov.f64	d9, d0
     3f8:	vldr	s0, [r4]
     3fc:	vmov.f64	d1, d11
     400:	vsub.f32	s20, s20, s0
     404:	vsub.f32	s0, s20, s15
     408:	.word	0x0ac0eeb7
     40c:	bl	4734 <atan2>
     410:	vcvt.f32.f64	s18, d9
     414:	vcvt.f32.f64	s16, d8
     418:	.word	0x0324f104
     41c:	vcvt.f64.f32	d9, s18
     420:	vsub.f32	s21, s16, s21
     424:	vldr	d7, [pc, #72]	; 470 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x1b8>
     428:	.word	0x0b49ee30
     42c:	vstr	s21, [r4, #36]	; 0x24
     430:	vsub.f64	d12, d12, d7
     434:	vadd.f64	d9, d0, d7
     438:	vcvt.f32.f64	s24, d12
     43c:	vcvt.f32.f64	s18, d9
     440:	vstr	s24, [r4, #44]	; 0x2c
     444:	vstr	s18, [r4, #40]	; 0x28
     448:	vpop	{d8-d13}
     44c:	ldmia.w	r3, {r0, r1, r2}
     450:	stmia.w	r5, {r0, r1, r2}
     454:	mov	r0, r5
     456:	pop	{r3, r4, r5, pc}
     458:	bl	49b8 <sqrt>
     45c:	vmov.f64	d11, d0
     460:	b.n	356 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0x9e>
     462:	bl	49b8 <sqrt>
     466:	vmov.f64	d9, d0
     46a:	b.n	388 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)+0xd0>
     46c:	nop.w
     470:	.word	0x54442d18
     474:	.word	0x3ff921fb

00000478 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
     478:	push	{r4, r5, lr}
     47a:	sub	sp, #36	; 0x24
     47c:	mov	r5, r0
     47e:	mov	r4, r1
     480:	add	r3, sp, #20
     482:	ldmia	r1, {r0, r1, r2}
     484:	stmia.w	r3, {r0, r1, r2}
     488:	mov	r2, r3
     48a:	mov	r1, r5
     48c:	mov	r0, sp
     48e:	bl	2b8 <project_namespace::Leg::calculateIKFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
     492:	ldr	r1, [r4, #0]
     494:	ldr	r2, [r4, #4]
     496:	ldr	r3, [r4, #8]
     498:	str	r1, [r5, #48]	; 0x30
     49a:	str	r2, [r5, #52]	; 0x34
     49c:	str	r3, [r5, #56]	; 0x38
     49e:	add	sp, #36	; 0x24
     4a0:	pop	{r4, r5, pc}
     4a2:	nop

000004a4 <Eigen::Matrix<float, 3, 3, 0, 3, 3>& Eigen::Matrix<float, 3, 3, 0, 3, 3>::operator=<Eigen::Quaternion<float, 0> >(Eigen::RotationBase<Eigen::Quaternion<float, 0>, 3> const&)>:
     4a4:	vldr	s14, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
     4a8:	vmov.f32	s10, #112	; 0x3f800000  1.0
     4ac:	vldr	s11, [r1, #8]
     4b0:	vadd.f32	s6, s14, s14
     4b4:	vldr	s15, [r1]
     4b8:	vadd.f32	s9, s11, s11
     4bc:	vldr	s12, [r1, #12]
     4c0:	vadd.f32	s7, s15, s15
     4c4:	vmul.f32	s13, s14, s6
     4c8:	vmul.f32	s11, s11, s9
     4cc:	vmul.f32	s8, s15, s6
     4d0:	vmov.f32	s5, s13
     4d4:	vmov.f32	s4, s11
     4d8:	vmul.f32	s14, s14, s9
     4dc:	vfma.f32	s5, s15, s7
     4e0:	vfma.f32	s4, s15, s7
     4e4:	vmov.f32	s3, s8
     4e8:	vmul.f32	s15, s15, s9
     4ec:	vfms.f32	s8, s9, s12
     4f0:	vfma.f32	s3, s9, s12
     4f4:	vadd.f32	s13, s13, s11
     4f8:	vmov.f32	s9, s15
     4fc:	vmov.f32	s11, s14
     500:	vfma.f32	s15, s6, s12
     504:	vfms.f32	s9, s6, s12
     508:	vstr	s8, [r0, #12]
     50c:	vfma.f32	s11, s7, s12
     510:	vstr	s3, [r0, #4]
     514:	vfms.f32	s14, s7, s12
     518:	vsub.f32	s13, s10, s13
     51c:	vsub.f32	s12, s10, s5
     520:	vsub.f32	s10, s10, s4
     524:	vstr	s15, [r0, #24]
     528:	vstr	s9, [r0, #8]
     52c:	vstr	s12, [r0, #32]
     530:	vstr	s13, [r0]
     534:	vstr	s10, [r0, #16]
     538:	vstr	s11, [r0, #20]
     53c:	vstr	s14, [r0, #28]
     540:	bx	lr
     542:	nop

00000544 <project_namespace::MyMath::eulerToMatrix(float, float, float)>:
     544:	vmov.f32	s15, #96	; 0x3f000000  0.5
     548:	push	{r4, r5, r7, lr}
     54a:	vpush	{d8-d11}
     54e:	vmul.f32	s17, s2, s15
     552:	add	r7, sp, #0
     554:	vmul.f32	s16, s1, s15
     558:	sub	sp, #32
     55a:	vmul.f32	s21, s0, s15
     55e:	mov	r5, r0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     560:	vmov.f32	s0, s17
     564:	vldr	s18, [pc, #272]	; 678 <project_namespace::MyMath::eulerToMatrix(float, float, float)+0x134>
     568:	bl	44b8 <cosf>
     56c:	vmov.f32	s23, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     570:	vmov.f32	s0, s17
     574:	add.w	r4, sp, #15
     578:	bl	4548 <sinf>
     57c:	vmov.f32	s22, s0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     580:	vmov.f32	s0, s16
     584:	bic.w	r4, r4, #15
     588:	bl	44b8 <cosf>
     58c:	vmov.f32	s20, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     590:	vmov.f32	s0, s16
     594:	bl	4548 <sinf>
     598:	vmov.f32	s12, s0
     59c:	vmul.f32	s13, s22, s18
     5a0:	vmul.f32	s17, s20, s22
     5a4:	vmul.f32	s15, s12, s18
     5a8:	vmul.f32	s16, s20, s13
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     5ac:	vmov.f32	s0, s21
     5b0:	vmul.f32	s14, s15, s13
     5b4:	vmov.f32	s19, s16
     5b8:	vfma.f32	s17, s15, s23
     5bc:	vmov.f32	s11, s14
     5c0:	vfma.f32	s19, s12, s23
     5c4:	vfma.f32	s16, s15, s23
     5c8:	vfnms.f32	s11, s20, s23
     5cc:	vfma.f32	s17, s12, s13
     5d0:	vfma.f32	s19, s15, s22
     5d4:	vadd.f32	s16, s16, s14
     5d8:	vmov.f32	s20, s11
     5dc:	vneg.f32	s11, s12
     5e0:	vsub.f32	s17, s17, s14
     5e4:	vfma.f32	s20, s11, s13
     5e8:	vfma.f32	s16, s11, s22
     5ec:	vsub.f32	s19, s19, s14
     5f0:	vfms.f32	s20, s15, s22
     5f4:	bl	44b8 <cosf>
     5f8:	vmov.f32	s22, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     5fc:	vmov.f32	s0, s21
     600:	bl	4548 <sinf>
     604:	vmul.f32	s15, s0, s18
     608:	vnmul.f32	s14, s16, s0
     60c:	mov	r1, r4
     60e:	vmul.f32	s11, s22, s16
     612:	mov	r0, r5
     614:	vmul.f32	s13, s22, s17
     618:	vfma.f32	s14, s22, s20
     61c:	vfma.f32	s11, s0, s20
     620:	vfma.f32	s13, s15, s20
     624:	vmul.f32	s12, s22, s19
     628:	vneg.f32	s10, s15
     62c:	vfma.f32	s12, s15, s20
     630:	vfma.f32	s11, s15, s19
     634:	vfma.f32	s13, s15, s16
     638:	vmov.f32	s15, s14
     63c:	vfma.f32	s12, s0, s17
     640:	vfma.f32	s15, s10, s19
     644:	vmov.f32	s14, s13
     648:	vfma.f32	s11, s10, s17
     64c:	vfms.f32	s14, s0, s19
     650:	vfma.f32	s12, s10, s16
     654:	vfma.f32	s15, s10, s17
     658:	vstr	s11, [r4]
     65c:	vstr	s14, [r4, #8]
     660:	vstr	s12, [r4, #4]
     664:	vstr	s15, [r4, #12]
     668:	bl	4a4 <Eigen::Matrix<float, 3, 3, 0, 3, 3>& Eigen::Matrix<float, 3, 3, 0, 3, 3>::operator=<Eigen::Quaternion<float, 0> >(Eigen::RotationBase<Eigen::Quaternion<float, 0>, 3> const&)>
     66c:	mov	r0, r5
     66e:	mov	sp, r7
     670:	vpop	{d8-d11}
     674:	pop	{r4, r5, r7, pc}
     676:	nop
     678:	.word	0x00000000

0000067c <project_namespace::MasterController::MasterController(project_namespace::IMU&)>:
#include "MatrixPrinter.h"

using namespace project_namespace;

// CONSTRUCTORS
MasterController::MasterController(IMU& imu_init):
     67c:	push	{r3, r4, r5, lr}
     67e:	mov	r5, r1
     680:	mov	r4, r0
    imu(imu_init),
    gait_controller(GaitController(Gait::TROT, FootTrajectory::SEMICIRCULAR, imu)),
    ticks(0)
     682:	movs	r2, #1
     684:	movs	r1, #0
     686:	mov	r3, r5
     688:	str.w	r5, [r0], #16
     68c:	bl	1828 <project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)>
     690:	movs	r3, #0
{ }
     692:	mov	r0, r4

// CONSTRUCTORS
MasterController::MasterController(IMU& imu_init):
    imu(imu_init),
    gait_controller(GaitController(Gait::TROT, FootTrajectory::SEMICIRCULAR, imu)),
    ticks(0)
     694:	str.w	r3, [r4, #176]	; 0xb0
{ }
     698:	pop	{r3, r4, r5, pc}
     69a:	nop

0000069c <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)>:

// METHODS
void MasterController::stepOnce(Robot& robot, Command& command) {
     69c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     6a0:	vpush	{d8-d11}
     6a4:	sub	sp, #52	; 0x34
     6a6:	mov	r9, r0
    ARGUMENTS:
    + robot: The robot to control and command.
    + command: It contains the input commands into the robot.
    */

    if (command.getMode() == Mode::REST) {
     6a8:	mov	r0, r2
    gait_controller(GaitController(Gait::TROT, FootTrajectory::SEMICIRCULAR, imu)),
    ticks(0)
{ }

// METHODS
void MasterController::stepOnce(Robot& robot, Command& command) {
     6aa:	mov	r6, r2
     6ac:	add	r7, sp, #8
     6ae:	sub	sp, #112	; 0x70
     6b0:	mov	r8, r1
     6b2:	add.w	r4, sp, #23
     6b6:	bic.w	r4, r4, #15
    ARGUMENTS:
    + robot: The robot to control and command.
    + command: It contains the input commands into the robot.
    */

    if (command.getMode() == Mode::REST) {
     6ba:	bl	1808 <project_namespace::Command::getMode()>
     6be:	cbz	r0, 6d8 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x3c>
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
        robot.setBodyRoll(command.getBodyRoll());
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

    } else if (command.getMode() == Mode::TROT) {
     6c0:	mov	r0, r6
     6c2:	bl	1808 <project_namespace::Command::getMode()>
     6c6:	cmp	r0, #1
     6c8:	beq.w	934 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x298>
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

        ticks += 1;
    }
     6cc:	adds	r7, #44	; 0x2c
     6ce:	mov	sp, r7
     6d0:	vpop	{d8-d11}
     6d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ticks = 0;
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     6d8:	vmov.f32	s22, #96	; 0x3f000000  0.5
    + robot: The robot to control and command.
    + command: It contains the input commands into the robot.
    */

    if (command.getMode() == Mode::REST) {
        ticks = 0;
     6dc:	str.w	r0, [r9, #176]	; 0xb0
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     6e0:	mov	r0, r6
  *
  */
template<typename DstScalar,typename SrcScalar> struct assign_op {

  EIGEN_EMPTY_STRUCT_CTOR(assign_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a = b; }
     6e2:	vmov.f64	d10, #96	; 0x3f000000  0.5
     6e6:	bl	17b8 <project_namespace::Command::getStancePolygonLength()>
                command.getStancePolygonWidth()/2.0,
     6ea:	mov	r0, r6
        ticks = 0;
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     6ec:	vmul.f32	s18, s0, s22
                command.getStancePolygonWidth()/2.0,
     6f0:	bl	17c0 <project_namespace::Command::getStancePolygonWidth()>
                -1.0*command.getStanceHeight()
     6f4:	mov	r0, r6
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        // Calculate neutral stance positions for each leg
        new_foot_positions_wrt_body.col(0) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
                command.getStancePolygonWidth()/2.0,
     6f6:	vmul.f32	s17, s0, s22
                -1.0*command.getStanceHeight()
     6fa:	bl	17c8 <project_namespace::Command::getStanceHeight()>
     6fe:	vneg.f32	s16, s0
        ).finished();
        new_foot_positions_wrt_body.col(1) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     702:	mov	r0, r6
     704:	vstr	s18, [r4, #48]	; 0x30
     708:	vstr	s17, [r4, #52]	; 0x34
    }
    EIGEN_DEVICE_FUNC
    explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
      : m_data(internal::constructor_without_unaligned_array_assert()) {}
    EIGEN_DEVICE_FUNC 
    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {
     70c:	mov	r5, r4
     70e:	vstr	s16, [r4, #56]	; 0x38
     712:	bl	17b8 <project_namespace::Command::getStancePolygonLength()>
                -1.0*command.getStancePolygonWidth()/2.0,
     716:	mov	r0, r6
                command.getStancePolygonWidth()/2.0,
                -1.0*command.getStanceHeight()
        ).finished();
        new_foot_positions_wrt_body.col(1) = (
            Eigen::Vector3f()
            <<  command.getStancePolygonLength()/2.0,
     718:	vmov.f32	s23, s0
                -1.0*command.getStancePolygonWidth()/2.0,
     71c:	bl	17c0 <project_namespace::Command::getStancePolygonWidth()>
     720:	vmov.f32	s19, s0
                -1.0*command.getStanceHeight()
     724:	mov	r0, r6
     726:	bl	17c8 <project_namespace::Command::getStanceHeight()>
     72a:	vneg.f32	s0, s0
     72e:	vmul.f32	s23, s23, s22
        ).finished();
        new_foot_positions_wrt_body.col(2) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
     732:	mov	r0, r6
     734:	vcvt.f64.f32	d7, s19
     738:	vstr	s0, [r4, #68]	; 0x44
     73c:	vstr	s23, [r4, #60]	; 0x3c
     740:	vnmul.f64	d7, d7, d10
     744:	vcvt.f32.f64	s14, d7
     748:	vstr	s14, [r4, #64]	; 0x40
     74c:	bl	17b8 <project_namespace::Command::getStancePolygonLength()>
     750:	vmov.f32	s19, s0
                command.getStancePolygonWidth()/2.0,
     754:	mov	r0, r6
     756:	bl	17c0 <project_namespace::Command::getStancePolygonWidth()>
                -1.0*command.getStanceHeight()
     75a:	mov	r0, r6
                -1.0*command.getStanceHeight()
        ).finished();
        new_foot_positions_wrt_body.col(2) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
                command.getStancePolygonWidth()/2.0,
     75c:	vmov.f32	s23, s0
                -1.0*command.getStanceHeight()
     760:	bl	17c8 <project_namespace::Command::getStanceHeight()>
     764:	vcvt.f64.f32	d7, s19
        ).finished();
        new_foot_positions_wrt_body.col(3) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
     768:	mov	r0, r6
     76a:	vneg.f32	s0, s0
     76e:	vmul.f32	s22, s23, s22
     772:	vnmul.f64	d7, d7, d10
     776:	vstr	s0, [r4, #80]	; 0x50
     77a:	vstr	s22, [r4, #76]	; 0x4c
     77e:	vcvt.f32.f64	s14, d7
     782:	vstr	s14, [r4, #72]	; 0x48
     786:	bl	17b8 <project_namespace::Command::getStancePolygonLength()>
                -1.0*command.getStancePolygonWidth()/2.0,
     78a:	mov	r0, r6
                command.getStancePolygonWidth()/2.0,
                -1.0*command.getStanceHeight()
        ).finished();
        new_foot_positions_wrt_body.col(3) = (
            Eigen::Vector3f()
            <<  -1.0*command.getStancePolygonLength()/2.0,
     78c:	vmov.f32	s22, s0
                -1.0*command.getStancePolygonWidth()/2.0,
     790:	bl	17c0 <project_namespace::Command::getStancePolygonWidth()>
     794:	vmov.f32	s19, s0
                -1.0*command.getStanceHeight()
     798:	mov	r0, r6
     79a:	bl	17c8 <project_namespace::Command::getStanceHeight()>
     79e:	vneg.f32	s0, s0
     7a2:	vcvt.f64.f32	d6, s22
     7a6:	add.w	lr, r4, #48	; 0x30
     7aa:	vcvt.f64.f32	d7, s19
     7ae:	vstr	s0, [r4, #92]	; 0x5c
     7b2:	vnmul.f64	d6, d6, d10
     7b6:	vnmul.f64	d7, d7, d10
     7ba:	vcvt.f32.f64	s12, d6
     7be:	vcvt.f32.f64	s14, d7
     7c2:	vstr	s12, [r4, #84]	; 0x54
     7c6:	vstr	s14, [r4, #88]	; 0x58
     7ca:	ldmia.w	lr!, {r0, r1, r2, r3}
     7ce:	stmia	r5!, {r0, r1, r2, r3}
     7d0:	ldmia.w	lr!, {r0, r1, r2, r3}
     7d4:	stmia	r5!, {r0, r1, r2, r3}
     7d6:	ldmia.w	lr, {r0, r1, r2, r3}
     7da:	stmia.w	r5, {r0, r1, r2, r3}
        ).finished();
        // Track foot trajectory without body rpy
        robot.setFootPositionsWrtBodyAssumingNoBodyRPY(new_foot_positions_wrt_body);
     7de:	mov	r1, r4
     7e0:	mov	r0, r8
     7e2:	bl	102c <project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Desired body orientation matrix
        Eigen::Matrix<float, 3, 3> body_rpy_matrix;
        body_rpy_matrix =
            MyMath::eulerToMatrix(
     7e6:	mov	r0, r6
     7e8:	bl	17d0 <project_namespace::Command::getBodyRoll()>
     7ec:	mov	r0, r6
     7ee:	vmov.f32	s19, s0
     7f2:	bl	17d8 <project_namespace::Command::getBodyPitch()>
     7f6:	vmov.f32	s20, s0
     7fa:	mov	r0, r6
     7fc:	add.w	r5, r4, #48	; 0x30
     800:	bl	17e0 <project_namespace::Command::getBodyYaw()>
     804:	adds	r0, r7, #4
     806:	vmov.f32	s2, s0
     80a:	vmov.f32	s1, s20
     80e:	vmov.f32	s0, s19
     812:	bl	544 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     816:	vldr	s5, [r7, #4]
     81a:	mov	r3, r4
     81c:	mov	r2, r5
     81e:	vldr	s6, [r7, #8]
     822:	add.w	r1, r4, #84	; 0x54
     826:	vldr	s7, [r7, #12]
     82a:	vldr	s8, [r7, #16]
     82e:	vldr	s9, [r7, #20]
     832:	vldr	s10, [r7, #24]
     836:	vldr	s11, [r7, #28]
     83a:	vldr	s12, [r7, #32]
     83e:	vldr	s13, [r7, #36]	; 0x24
     842:	vmul.f32	s14, s7, s16
  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
  {
    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;

    const Index outerSize = kernel.outerSize();
    for(Index outer = 0; outer < outerSize; ++outer)
     846:	cmp	r2, r1
     848:	vmul.f32	s15, s10, s16
     84c:	add.w	r3, r3, #12
     850:	vmul.f32	s16, s13, s16
     854:	vfma.f32	s14, s6, s17
     858:	vfma.f32	s15, s9, s17
     85c:	vfma.f32	s16, s12, s17
     860:	vfma.f32	s14, s5, s18
     864:	vfma.f32	s15, s8, s18
     868:	vfma.f32	s16, s11, s18
     86c:	vstr	s14, [r3, #-12]
     870:	vstr	s15, [r3, #-8]
     874:	vstr	s16, [r3, #-4]
     878:	beq.n	88a <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x1ee>
     87a:	vldr	s18, [r2, #12]
     87e:	adds	r2, #12
     880:	vldr	s17, [r2, #4]
     884:	vldr	s16, [r2, #8]
     888:	b.n	842 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x1a6>
     88a:	ldr	r2, [r4, #0]
     88c:	mov	lr, r4
     88e:	ldr	r3, [r4, #4]
     890:	ldr.w	ip, [r4, #8]
     894:	ldr	r0, [r4, #12]
     896:	ldr	r1, [r4, #16]
     898:	str	r2, [r4, #48]	; 0x30
     89a:	str	r3, [r4, #52]	; 0x34
     89c:	ldr	r2, [r4, #20]
     89e:	ldr	r3, [r4, #24]
     8a0:	str.w	ip, [r4, #56]	; 0x38
     8a4:	str	r0, [r4, #60]	; 0x3c
     8a6:	ldr.w	ip, [r4, #28]
     8aa:	ldr	r0, [r4, #32]
     8ac:	str	r1, [r4, #64]	; 0x40
     8ae:	str	r2, [r4, #68]	; 0x44
     8b0:	ldr	r1, [r4, #36]	; 0x24
     8b2:	ldr	r2, [r4, #40]	; 0x28
     8b4:	str	r3, [r4, #72]	; 0x48
     8b6:	ldr	r3, [r4, #44]	; 0x2c
     8b8:	str.w	ip, [r4, #76]	; 0x4c
     8bc:	str	r0, [r4, #80]	; 0x50
     8be:	str	r1, [r4, #84]	; 0x54
     8c0:	str	r2, [r4, #88]	; 0x58
     8c2:	str	r3, [r4, #92]	; 0x5c
     8c4:	ldmia	r5!, {r0, r1, r2, r3}
     8c6:	stmia.w	lr!, {r0, r1, r2, r3}
     8ca:	ldmia	r5!, {r0, r1, r2, r3}
     8cc:	stmia.w	lr!, {r0, r1, r2, r3}
     8d0:	ldmia.w	r5, {r0, r1, r2, r3}
     8d4:	stmia.w	lr, {r0, r1, r2, r3}
                command.getBodyYaw()
            );
        // Apply body rpy
        new_foot_positions_wrt_body = body_rpy_matrix.transpose()*new_foot_positions_wrt_body;
        // Move feet to calculated positions
        robot.moveAllFeet(new_foot_positions_wrt_body); // Foot positions, joint angles in Legs and Robot are internally updated.
     8d8:	mov	r1, r4
     8da:	mov	r0, r8
     8dc:	bl	107c <project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Update robot attributes
        robot.setStancePolygonLength(command.getStancePolygonLength()); // Resting foot locations are updated internally
     8e0:	mov	r0, r6
     8e2:	bl	17b8 <project_namespace::Command::getStancePolygonLength()>
     8e6:	mov	r0, r8
     8e8:	bl	117c <project_namespace::Robot::setStancePolygonLength(float)>
        robot.setStancePolygonWidth(command.getStancePolygonWidth()); // Resting foot locations are updated internally
     8ec:	mov	r0, r6
     8ee:	bl	17c0 <project_namespace::Command::getStancePolygonWidth()>
     8f2:	mov	r0, r8
     8f4:	bl	1184 <project_namespace::Robot::setStancePolygonWidth(float)>
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
     8f8:	mov	r0, r6
     8fa:	bl	17c8 <project_namespace::Command::getStanceHeight()>
     8fe:	mov	r0, r8
     900:	bl	118c <project_namespace::Robot::setStanceHeight(float)>
        robot.setBodyRoll(command.getBodyRoll());
     904:	mov	r0, r6
     906:	bl	17d0 <project_namespace::Command::getBodyRoll()>
     90a:	mov	r0, r8
     90c:	bl	1014 <project_namespace::Robot::setBodyRoll(float)>
        robot.setBodyPitch(command.getBodyPitch());
     910:	mov	r0, r6
     912:	bl	17d8 <project_namespace::Command::getBodyPitch()>
     916:	mov	r0, r8
     918:	bl	101c <project_namespace::Robot::setBodyPitch(float)>
        robot.setBodyYaw(command.getBodyYaw());
     91c:	mov	r0, r6
     91e:	bl	17e0 <project_namespace::Command::getBodyYaw()>
     922:	mov	r0, r8
     924:	bl	1024 <project_namespace::Robot::setBodyYaw(float)>
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

        ticks += 1;
    }
     928:	adds	r7, #44	; 0x2c
     92a:	mov	sp, r7
     92c:	vpop	{d8-d11}
     930:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

    } else if (command.getMode() == Mode::TROT) {
        Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise
        new_foot_positions_wrt_body = gait_controller.calculateAllNewFootPositions(robot, command, ticks);
     934:	add.w	r5, r9, #16
     938:	ldr.w	r0, [r9, #176]	; 0xb0
     93c:	mov	r3, r6
     93e:	mov	r2, r8
     940:	mov	r1, r5
     942:	str	r0, [sp, #0]
     944:	mov	r0, r4
     946:	bl	1a60 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)>
        // Update robot contact pattern
        robot.setContactPattern(gait_controller.calculateContactPattern(ticks));
     94a:	mov	r1, r5
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
     94c:	ldr.w	ip, [r4, #12]
     950:	mov	r0, r4
     952:	ldr.w	lr, [r4, #16]
     956:	ldr	r5, [r4, #20]
     958:	ldr	r3, [r4, #24]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     95a:	vldr	s17, [r4]
     95e:	vldr	s18, [r4, #4]
     962:	vldr	s16, [r4, #8]
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
     966:	ldr	r2, [r4, #28]
     968:	str.w	ip, [r4, #60]	; 0x3c
     96c:	str.w	lr, [r4, #64]	; 0x40
     970:	ldr.w	ip, [r4, #32]
     974:	ldr.w	lr, [r4, #36]	; 0x24
     978:	str	r5, [r4, #68]	; 0x44
     97a:	str	r3, [r4, #72]	; 0x48
     97c:	ldr	r5, [r4, #40]	; 0x28
     97e:	ldr	r3, [r4, #44]	; 0x2c
     980:	str.w	ip, [r4, #80]	; 0x50
     984:	str.w	lr, [r4, #84]	; 0x54
     988:	str	r3, [r4, #92]	; 0x5c
     98a:	str	r2, [r4, #76]	; 0x4c
     98c:	str	r5, [r4, #88]	; 0x58
     98e:	mov	r5, r4
     990:	ldr.w	r2, [r9, #176]	; 0xb0
     994:	vstr	s17, [r4, #48]	; 0x30
     998:	vstr	s18, [r4, #52]	; 0x34
     99c:	vstr	s16, [r4, #56]	; 0x38
     9a0:	bl	1a10 <project_namespace::GaitController::calculateContactPattern(int)>
     9a4:	mov	r1, r4
     9a6:	mov	r0, r8
     9a8:	bl	1060 <project_namespace::Robot::setContactPattern(Eigen::Matrix<int, 4, 1, 0, 4, 1>)>
     9ac:	add.w	lr, r4, #48	; 0x30
     9b0:	ldmia.w	lr!, {r0, r1, r2, r3}
     9b4:	stmia	r5!, {r0, r1, r2, r3}
     9b6:	ldmia.w	lr!, {r0, r1, r2, r3}
     9ba:	stmia	r5!, {r0, r1, r2, r3}
     9bc:	ldmia.w	lr, {r0, r1, r2, r3}
     9c0:	stmia.w	r5, {r0, r1, r2, r3}
        // Track foot trajectory without body rpy
        robot.setFootPositionsWrtBodyAssumingNoBodyRPY(new_foot_positions_wrt_body);
     9c4:	mov	r1, r4
     9c6:	mov	r0, r8
     9c8:	bl	102c <project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Desired body orientation matrix
        Eigen::Matrix<float, 3, 3> body_rpy_matrix;
        body_rpy_matrix =
            MyMath::eulerToMatrix(
     9cc:	mov	r0, r6
     9ce:	bl	17d0 <project_namespace::Command::getBodyRoll()>
     9d2:	mov	r0, r6
     9d4:	vmov.f32	s19, s0
     9d8:	bl	17d8 <project_namespace::Command::getBodyPitch()>
     9dc:	vmov.f32	s20, s0
     9e0:	mov	r0, r6
     9e2:	bl	17e0 <project_namespace::Command::getBodyYaw()>
     9e6:	add.w	r5, r4, #48	; 0x30
     9ea:	vmov.f32	s2, s0
     9ee:	adds	r0, r7, #4
     9f0:	vmov.f32	s1, s20
     9f4:	vmov.f32	s0, s19
     9f8:	bl	544 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
     9fc:	vmov.f32	s15, s16
     a00:	vmov.f32	s11, s18
     a04:	mov	r2, r5
     a06:	vmov.f32	s12, s17
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
     a0a:	vldr	s2, [r7, #4]
     a0e:	mov	r3, r4
     a10:	vldr	s3, [r7, #8]
     a14:	add.w	r1, r4, #84	; 0x54
     a18:	vldr	s4, [r7, #12]
     a1c:	vldr	s5, [r7, #16]
     a20:	vldr	s6, [r7, #20]
     a24:	vldr	s7, [r7, #24]
     a28:	vldr	s8, [r7, #28]
     a2c:	vldr	s9, [r7, #32]
     a30:	vldr	s10, [r7, #36]	; 0x24
     a34:	vmul.f32	s13, s4, s15
     a38:	cmp	r1, r2
     a3a:	vmul.f32	s14, s7, s15
     a3e:	add.w	r3, r3, #12
     a42:	vmul.f32	s15, s10, s15
     a46:	vfma.f32	s13, s3, s11
     a4a:	vfma.f32	s14, s6, s11
     a4e:	vfma.f32	s15, s9, s11
     a52:	vfma.f32	s13, s2, s12
     a56:	vfma.f32	s14, s5, s12
     a5a:	vfma.f32	s15, s8, s12
     a5e:	vstr	s13, [r3, #-12]
     a62:	vstr	s14, [r3, #-8]
     a66:	vstr	s15, [r3, #-4]
     a6a:	beq.n	a7c <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x3e0>
     a6c:	vldr	s12, [r2, #12]
     a70:	adds	r2, #12
     a72:	vldr	s11, [r2, #4]
     a76:	vldr	s15, [r2, #8]
     a7a:	b.n	a34 <project_namespace::MasterController::stepOnce(project_namespace::Robot&, project_namespace::Command&)+0x398>
     a7c:	ldr	r2, [r4, #0]
     a7e:	mov	lr, r4
     a80:	ldr	r3, [r4, #4]
     a82:	ldr.w	ip, [r4, #8]
     a86:	ldr	r0, [r4, #12]
     a88:	ldr	r1, [r4, #16]
     a8a:	str	r2, [r4, #48]	; 0x30
     a8c:	str	r3, [r4, #52]	; 0x34
     a8e:	ldr	r2, [r4, #20]
     a90:	ldr	r3, [r4, #24]
     a92:	str.w	ip, [r4, #56]	; 0x38
     a96:	str	r0, [r4, #60]	; 0x3c
     a98:	ldr.w	ip, [r4, #28]
     a9c:	ldr	r0, [r4, #32]
     a9e:	str	r1, [r4, #64]	; 0x40
     aa0:	str	r2, [r4, #68]	; 0x44
     aa2:	ldr	r1, [r4, #36]	; 0x24
     aa4:	ldr	r2, [r4, #40]	; 0x28
     aa6:	str	r3, [r4, #72]	; 0x48
     aa8:	ldr	r3, [r4, #44]	; 0x2c
     aaa:	str.w	ip, [r4, #76]	; 0x4c
     aae:	str	r0, [r4, #80]	; 0x50
     ab0:	str	r1, [r4, #84]	; 0x54
     ab2:	str	r2, [r4, #88]	; 0x58
     ab4:	str	r3, [r4, #92]	; 0x5c
     ab6:	ldmia	r5!, {r0, r1, r2, r3}
     ab8:	stmia.w	lr!, {r0, r1, r2, r3}
     abc:	ldmia	r5!, {r0, r1, r2, r3}
     abe:	stmia.w	lr!, {r0, r1, r2, r3}
     ac2:	ldmia.w	r5, {r0, r1, r2, r3}
     ac6:	stmia.w	lr, {r0, r1, r2, r3}
                command.getBodyYaw()
            );
        // Apply body rpy
        new_foot_positions_wrt_body = body_rpy_matrix.transpose()*new_foot_positions_wrt_body;
        // Move feet to calculated positions
        robot.moveAllFeet(new_foot_positions_wrt_body); // Foot positions (true), joint angles in Legs and Robot are internally updated.
     aca:	mov	r1, r4
     acc:	mov	r0, r8
     ace:	bl	107c <project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>
        // Update robot attributes
        robot.setStancePolygonLength(command.getStancePolygonLength()); // Resting foot locations are updated internally
     ad2:	mov	r0, r6
     ad4:	bl	17b8 <project_namespace::Command::getStancePolygonLength()>
     ad8:	mov	r0, r8
     ada:	bl	117c <project_namespace::Robot::setStancePolygonLength(float)>
        robot.setStancePolygonWidth(command.getStancePolygonWidth()); // Resting foot locations are updated internally
     ade:	mov	r0, r6
     ae0:	bl	17c0 <project_namespace::Command::getStancePolygonWidth()>
     ae4:	mov	r0, r8
     ae6:	bl	1184 <project_namespace::Robot::setStancePolygonWidth(float)>
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
     aea:	mov	r0, r6
     aec:	bl	17c8 <project_namespace::Command::getStanceHeight()>
     af0:	mov	r0, r8
     af2:	bl	118c <project_namespace::Robot::setStanceHeight(float)>
        robot.setBodyRoll(command.getBodyRoll());
     af6:	mov	r0, r6
     af8:	bl	17d0 <project_namespace::Command::getBodyRoll()>
     afc:	mov	r0, r8
     afe:	bl	1014 <project_namespace::Robot::setBodyRoll(float)>
        robot.setBodyPitch(command.getBodyPitch());
     b02:	mov	r0, r6
     b04:	bl	17d8 <project_namespace::Command::getBodyPitch()>
     b08:	mov	r0, r8
     b0a:	bl	101c <project_namespace::Robot::setBodyPitch(float)>
        robot.setBodyYaw(command.getBodyYaw());
     b0e:	mov	r0, r6
     b10:	bl	17e0 <project_namespace::Command::getBodyYaw()>
     b14:	mov	r0, r8
     b16:	bl	1024 <project_namespace::Robot::setBodyYaw(float)>

        ticks += 1;
     b1a:	ldr.w	r3, [r9, #176]	; 0xb0
    }
     b1e:	adds	r7, #44	; 0x2c
        robot.setStanceHeight(command.getStanceHeight()); // Resting foot locations are updated internally
        robot.setBodyRoll(command.getBodyRoll());
        robot.setBodyPitch(command.getBodyPitch());
        robot.setBodyYaw(command.getBodyYaw());

        ticks += 1;
     b20:	adds	r3, #1
     b22:	str.w	r3, [r9, #176]	; 0xb0
    }
     b26:	mov	sp, r7
     b28:	vpop	{d8-d11}
     b2c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00000b30 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)>:
     b30:	movs	r3, #0
     b32:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     b36:	movs	r5, #0
     b38:	add	r7, sp, #0
     b3a:	str	r3, [r0, #16]
     b3c:	sub	sp, #80	; 0x50
     b3e:	str	r5, [r0, #8]
     b40:	str	r5, [r0, #12]
     b42:	str	r5, [r0, #120]	; 0x78
     b44:	str	r3, [r0, #20]
     b46:	str	r3, [r0, #24]
     b48:	str	r3, [r0, #28]
     b4a:	str	r3, [r0, #32]
     b4c:	str	r3, [r0, #36]	; 0x24
     b4e:	str	r3, [r0, #40]	; 0x28
     b50:	str	r3, [r0, #44]	; 0x2c
     b52:	str	r3, [r0, #48]	; 0x30
     b54:	str	r3, [r0, #52]	; 0x34
     b56:	str	r3, [r0, #56]	; 0x38
     b58:	str	r3, [r0, #60]	; 0x3c
     b5a:	str	r3, [r0, #64]	; 0x40
     b5c:	str	r3, [r0, #68]	; 0x44
     b5e:	str	r3, [r0, #72]	; 0x48
     b60:	str	r3, [r0, #76]	; 0x4c
     b62:	str	r3, [r0, #80]	; 0x50
     b64:	str	r3, [r0, #84]	; 0x54
     b66:	str	r3, [r0, #88]	; 0x58
     b68:	str	r3, [r0, #92]	; 0x5c
     b6a:	str	r3, [r0, #96]	; 0x60
     b6c:	str	r3, [r0, #100]	; 0x64
     b6e:	str	r3, [r0, #104]	; 0x68
     b70:	str	r3, [r0, #108]	; 0x6c
     b72:	str	r3, [r0, #112]	; 0x70
     b74:	str	r3, [r0, #116]	; 0x74
     b76:	stmia.w	r0, {r1, r2}
     b7a:	cbz	r1, b82 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0x52>
     b7c:	mov	sp, r7
     b7e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     b82:	add.w	r4, sp, #15
     b86:	movs	r3, #1
     b88:	ldr.w	r8, [pc, #132]	; c10 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xe0>
     b8c:	mov	r5, r0
     b8e:	bic.w	r2, r4, #15
     b92:	ldr.w	ip, [pc, #128]	; c14 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xe4>
     b96:	mov	r4, r3
     b98:	add.w	lr, r0, #76	; 0x4c
     b9c:	mov	r6, r2
     b9e:	str.w	r8, [r0, #8]
     ba2:	str	r1, [r2, #48]	; 0x30
     ba4:	str	r1, [r2, #20]
     ba6:	str	r1, [r2, #24]
     ba8:	str	r1, [r2, #60]	; 0x3c
     baa:	str	r3, [r2, #0]
     bac:	str	r3, [r2, #16]
     bae:	str	r3, [r2, #32]
     bb0:	str	r3, [r2, #4]
     bb2:	str	r3, [r2, #36]	; 0x24
     bb4:	str	r3, [r2, #52]	; 0x34
     bb6:	str	r3, [r2, #8]
     bb8:	str	r3, [r2, #40]	; 0x28
     bba:	str	r3, [r2, #56]	; 0x38
     bbc:	str	r3, [r2, #12]
     bbe:	str	r3, [r2, #28]
     bc0:	str	r3, [r2, #44]	; 0x2c
     bc2:	str.w	ip, [r5, #12]!
     bc6:	mov	r1, r6
     bc8:	mov	r2, r5
     bca:	movs	r3, #0
     bcc:	b.n	bd2 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xa2>
     bce:	ldr.w	r4, [r1, #4]!
     bd2:	adds	r3, #1
     bd4:	str.w	r4, [r2, #4]!
     bd8:	cmp	r3, #4
     bda:	bne.n	bce <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0x9e>
     bdc:	adds	r5, #16
     bde:	cmp	lr, r5
     be0:	beq.n	be8 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0xb8>
     be2:	ldr.w	r4, [r6, #16]!
     be6:	b.n	bc6 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)+0x96>
     be8:	movs	r2, #15
     bea:	movs	r1, #2
     bec:	movs	r6, #34	; 0x22
     bee:	movs	r5, #19
     bf0:	movs	r4, #0
     bf2:	str	r3, [r0, #80]	; 0x50
     bf4:	str	r1, [r0, #84]	; 0x54
     bf6:	str	r1, [r0, #96]	; 0x60
     bf8:	str	r1, [r0, #104]	; 0x68
     bfa:	str	r2, [r0, #88]	; 0x58
     bfc:	str	r2, [r0, #100]	; 0x64
     bfe:	str	r2, [r0, #108]	; 0x6c
     c00:	str	r2, [r0, #116]	; 0x74
     c02:	str	r6, [r0, #92]	; 0x5c
     c04:	str	r5, [r0, #112]	; 0x70
     c06:	str	r4, [r0, #120]	; 0x78
     c08:	mov	sp, r7
     c0a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     c0e:	nop
     c10:	.word	0x3ca3d70a
     c14:	.word	0x3e19999a

00000c18 <project_namespace::GaitConfig::getContactSchedule()>:
     c18:	push	{r4, r5, r6}
     c1a:	add.w	r5, r1, #16
     c1e:	mov	r6, r0
     c20:	mov	r4, r0
     c22:	ldmia	r5!, {r0, r1, r2, r3}
     c24:	stmia	r4!, {r0, r1, r2, r3}
     c26:	ldmia	r5!, {r0, r1, r2, r3}
     c28:	stmia	r4!, {r0, r1, r2, r3}
     c2a:	ldmia	r5!, {r0, r1, r2, r3}
     c2c:	stmia	r4!, {r0, r1, r2, r3}
     c2e:	ldmia.w	r5, {r0, r1, r2, r3}
     c32:	stmia.w	r4, {r0, r1, r2, r3}
     c36:	mov	r0, r6
     c38:	pop	{r4, r5, r6}
     c3a:	bx	lr

00000c3c <project_namespace::GaitConfig::getGaitNumberOfPhases()>:
     c3c:	ldr	r0, [r0, #80]	; 0x50
     c3e:	bx	lr

00000c40 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>:
     c40:	ldr	r0, [r0, #84]	; 0x54
     c42:	bx	lr

00000c44 <project_namespace::GaitConfig::getGaitSwingDurationInTicks()>:
     c44:	ldr	r0, [r0, #88]	; 0x58
     c46:	bx	lr

00000c48 <project_namespace::GaitConfig::getGaitCycleDurationInTicks()>:
     c48:	ldr	r0, [r0, #92]	; 0x5c
     c4a:	bx	lr

00000c4c <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>:
     c4c:	adds	r1, #96	; 0x60
     c4e:	push	{r4}
     c50:	mov	r4, r0
     c52:	ldmia	r1, {r0, r1, r2, r3}
     c54:	stmia.w	r4, {r0, r1, r2, r3}
     c58:	mov	r0, r4
     c5a:	ldr.w	r4, [sp], #4
     c5e:	bx	lr

00000c60 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>:
     c60:	ldr	r0, [r0, #112]	; 0x70
     c62:	bx	lr

00000c64 <project_namespace::GaitConfig::getLegSwingDurationInTicks()>:
     c64:	ldr	r0, [r0, #116]	; 0x74
     c66:	bx	lr

00000c68 <project_namespace::GaitConfig::getSwingHeight()>:
     c68:	vldr	s0, [r0, #120]	; 0x78
     c6c:	bx	lr
     c6e:	nop

00000c70 <project_namespace::GaitConfig::setSwingHeight(float)>:
     c70:	vstr	s0, [r0, #120]	; 0x78
     c74:	bx	lr
     c76:	nop

00000c78 <project_namespace::IMU::IMU(BNO080&)>:
#include "IMU.h"

using namespace project_namespace;

IMU::IMU(BNO080& imu_hardware_init):
    imu_hardware(imu_hardware_init)
     c78:	str	r1, [r0, #48]	; 0x30
{ }
     c7a:	bx	lr

00000c7c <project_namespace::IMU::getGyro()>:
    }
    Eigen::Vector3f accel_vals(x, y, z);
    last_accel = accel_vals;
    return accel_vals;
}
Eigen::Vector3f IMU::getGyro() {
     c7c:	push	{r3, r4, r5, lr}
     c7e:	mov	r5, r0
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     c80:	ldr	r0, [r1, #48]	; 0x30
    }
    Eigen::Vector3f accel_vals(x, y, z);
    last_accel = accel_vals;
    return accel_vals;
}
Eigen::Vector3f IMU::getGyro() {
     c82:	mov	r4, r1
     c84:	vpush	{d8}
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     c88:	bl	2790 <BNO080::dataAvailable()>
     c8c:	cbnz	r0, cba <project_namespace::IMU::getGyro()+0x3e>
        x = imu_hardware.getGyroX();
        y = imu_hardware.getGyroY();
        z = imu_hardware.getGyroZ();
    } else {
        x = last_gyro(0);
     c8e:	vldr	s16, [r4, #12]
        y = last_gyro(1);
     c92:	vldr	s17, [r4, #16]
        z = last_gyro(2);
     c96:	vldr	s0, [r4, #20]
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
     c9a:	vstr	s17, [r5, #4]
    }
    Eigen::Vector3f gyro_vals(x, y, z);
    last_gyro = gyro_vals;
    return gyro_vals;
}
     c9e:	mov	r0, r5
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     ca0:	vstr	s16, [r5]
      m_storage.data()[1] = y;
      m_storage.data()[2] = z;
     ca4:	vstr	s0, [r5, #8]
     ca8:	vstr	s16, [r4, #12]
     cac:	ldr	r3, [r5, #4]
     cae:	vpop	{d8}
     cb2:	str	r3, [r4, #16]
     cb4:	ldr	r3, [r5, #8]
     cb6:	str	r3, [r4, #20]
     cb8:	pop	{r3, r4, r5, pc}
Eigen::Vector3f IMU::getGyro() {
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        x = imu_hardware.getGyroX();
     cba:	ldr	r0, [r4, #48]	; 0x30
     cbc:	bl	21a0 <BNO080::getGyroX()>
        y = imu_hardware.getGyroY();
     cc0:	ldr	r0, [r4, #48]	; 0x30
Eigen::Vector3f IMU::getGyro() {
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        x = imu_hardware.getGyroX();
     cc2:	vmov.f32	s16, s0
        y = imu_hardware.getGyroY();
     cc6:	bl	21dc <BNO080::getGyroY()>
        z = imu_hardware.getGyroZ();
     cca:	ldr	r0, [r4, #48]	; 0x30
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        x = imu_hardware.getGyroX();
        y = imu_hardware.getGyroY();
     ccc:	vmov.f32	s17, s0
        z = imu_hardware.getGyroZ();
     cd0:	bl	2218 <BNO080::getGyroZ()>
     cd4:	b.n	c9a <project_namespace::IMU::getGyro()+0x1e>
     cd6:	nop

00000cd8 <project_namespace::IMU::getHeadingQuaternion()>:
    }
    Eigen::Vector3f gyro_vals(x, y, z);
    last_gyro = gyro_vals;
    return gyro_vals;
}
Eigen::Quaternionf IMU::getHeadingQuaternion() {
     cd8:	push	{r3, r4, r5, lr}
     cda:	mov	r5, r0
    float quat_x = 0.0;
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     cdc:	ldr	r0, [r1, #48]	; 0x30
    }
    Eigen::Vector3f gyro_vals(x, y, z);
    last_gyro = gyro_vals;
    return gyro_vals;
}
Eigen::Quaternionf IMU::getHeadingQuaternion() {
     cde:	mov	r4, r1
     ce0:	vpush	{d8-d9}
    float quat_x = 0.0;
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
     ce4:	bl	2790 <BNO080::dataAvailable()>
     ce8:	cbnz	r0, cfc <project_namespace::IMU::getHeadingQuaternion()+0x24>
     cea:	adds	r4, #32
        last_quaternion = heading_quaternion;
        return heading_quaternion;
    } else {
        return last_quaternion;
    }
     cec:	vpop	{d8-d9}
     cf0:	ldmia.w	r4, {r0, r1, r2, r3}
     cf4:	stmia.w	r5, {r0, r1, r2, r3}
     cf8:	mov	r0, r5
     cfa:	pop	{r3, r4, r5, pc}
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
     cfc:	ldr	r0, [r4, #48]	; 0x30
     cfe:	bl	2128 <BNO080::getQuatReal()>
        quat_x = imu_hardware.getQuatI();
     d02:	ldr	r0, [r4, #48]	; 0x30
    float quat_y = 0.0;
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
     d04:	vmov.f32	s16, s0
        quat_x = imu_hardware.getQuatI();
     d08:	bl	2074 <BNO080::getQuatI()>
        quat_y = imu_hardware.getQuatJ();
     d0c:	ldr	r0, [r4, #48]	; 0x30
    float quat_z = 0.0;
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
        quat_x = imu_hardware.getQuatI();
     d0e:	vmov.f32	s19, s0
        quat_y = imu_hardware.getQuatJ();
     d12:	bl	20b0 <BNO080::getQuatJ()>
        quat_z = imu_hardware.getQuatK();
     d16:	ldr	r0, [r4, #48]	; 0x30
    float quat_w = 0.0;
    float quat_accuracy = 0.0;
    if (imu_hardware.dataAvailable() == true) {
        quat_w = imu_hardware.getQuatReal();
        quat_x = imu_hardware.getQuatI();
        quat_y = imu_hardware.getQuatJ();
     d18:	vmov.f32	s18, s0
        quat_z = imu_hardware.getQuatK();
     d1c:	bl	20ec <BNO080::getQuatK()>
     d20:	vmov.f32	s17, s0
        quat_accuracy = imu_hardware.getQuatRadianAccuracy();
     d24:	ldr	r0, [r4, #48]	; 0x30
     d26:	bl	2164 <BNO080::getQuatRadianAccuracy()>
     d2a:	vstr	s19, [r4, #32]
     d2e:	vstr	s18, [r4, #36]	; 0x24
        last_quaternion = heading_quaternion;
        return heading_quaternion;
    } else {
        return last_quaternion;
    }
     d32:	mov	r0, r5
     d34:	vstr	s17, [r4, #40]	; 0x28
     d38:	vstr	s16, [r4, #44]	; 0x2c
     d3c:	vstr	s19, [r5]
     d40:	vstr	s18, [r5, #4]
     d44:	vstr	s17, [r5, #8]
     d48:	vstr	s16, [r5, #12]
     d4c:	vpop	{d8-d9}
     d50:	pop	{r3, r4, r5, pc}
     d52:	nop

00000d54 <project_namespace::Robot::Robot()>:
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     d54:	movs	r3, #0
     d56:	movs	r2, #0
     d58:	ldr	r1, [pc, #588]	; (fa8 <project_namespace::Robot::Robot()+0x254>)
using namespace project_namespace;

// TODO: Update dimensions according to CAD!!!

// CONSTRUCTORS
Robot::Robot():
     d5a:	push	{r4, r5, r6, lr}
     d5c:	mov	r4, r0
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     d5e:	ldr	r6, [pc, #588]	; (fac <project_namespace::Robot::Robot()+0x258>)
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     d60:	movs	r5, #1
     d62:	adds	r0, #240	; 0xf0
using namespace project_namespace;

// TODO: Update dimensions according to CAD!!!

// CONSTRUCTORS
Robot::Robot():
     d64:	vpush	{d8-d12}
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     d68:	vldr	s16, [pc, #580]	; fb0 <project_namespace::Robot::Robot()+0x25c>
using namespace project_namespace;

// TODO: Update dimensions according to CAD!!!

// CONSTRUCTORS
Robot::Robot():
     d6c:	sub	sp, #16
    foot_positions_wrt_body_true(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_assuming_no_body_rpy(Eigen::Matrix<float, 3, 4>::Zero()),
    foot_positions_wrt_body_at_rest(Eigen::Matrix<float, 3, 4>::Zero()),

    joint_angles(Eigen::Matrix<float, 3, 4>::Zero()),
    contact_pattern(Eigen::Vector4i::Zero())
     d6e:	vldr	s22, [pc, #580]	; fb4 <project_namespace::Robot::Robot()+0x260>
     d72:	vldr	s24, [pc, #580]	; fb8 <project_namespace::Robot::Robot()+0x264>
     d76:	vmov.f32	s5, s16
     d7a:	vldr	s21, [pc, #576]	; fbc <project_namespace::Robot::Robot()+0x268>
     d7e:	vmov.f32	s4, s16
     d82:	vldr	s23, [pc, #572]	; fc0 <project_namespace::Robot::Robot()+0x26c>
     d86:	vmov.f32	s3, s22
     d8a:	vldr	s20, [pc, #568]	; fc4 <project_namespace::Robot::Robot()+0x270>
     d8e:	vmov.f32	s2, s24
     d92:	vldr	s18, [pc, #564]	; fc8 <project_namespace::Robot::Robot()+0x274>
     d96:	vmov.f32	s1, s21
     d9a:	str	r1, [r4, #4]
     d9c:	vmov.f32	s0, s23
     da0:	add	r1, sp, #4
     da2:	str	r3, [r4, #12]
     da4:	str	r3, [r4, #16]
     da6:	str	r3, [r4, #20]
     da8:	str	r3, [r4, #32]
     daa:	str	r3, [r4, #36]	; 0x24
     dac:	str	r3, [r4, #40]	; 0x28
     dae:	str	r3, [r4, #44]	; 0x2c
     db0:	str	r3, [r4, #48]	; 0x30
     db2:	str	r3, [r4, #52]	; 0x34
     db4:	str	r3, [r4, #56]	; 0x38
     db6:	str	r3, [r4, #60]	; 0x3c
     db8:	str	r3, [r4, #64]	; 0x40
     dba:	str	r3, [r4, #68]	; 0x44
     dbc:	str	r3, [r4, #72]	; 0x48
     dbe:	str	r3, [r4, #76]	; 0x4c
     dc0:	str	r3, [r4, #80]	; 0x50
     dc2:	str	r3, [r4, #84]	; 0x54
     dc4:	str	r3, [r4, #88]	; 0x58
     dc6:	str	r3, [r4, #92]	; 0x5c
     dc8:	str	r3, [r4, #96]	; 0x60
     dca:	str	r3, [r4, #100]	; 0x64
     dcc:	str	r3, [r4, #104]	; 0x68
     dce:	str	r3, [r4, #108]	; 0x6c
     dd0:	str	r3, [r4, #112]	; 0x70
     dd2:	str	r3, [r4, #116]	; 0x74
     dd4:	str	r3, [r4, #120]	; 0x78
     dd6:	str	r3, [r4, #124]	; 0x7c
     dd8:	vldr	s19, [pc, #496]	; fcc <project_namespace::Robot::Robot()+0x278>
     ddc:	vldr	s17, [pc, #496]	; fd0 <project_namespace::Robot::Robot()+0x27c>
     de0:	str	r6, [r4, #0]
     de2:	str	r6, [r4, #8]
     de4:	str.w	r3, [r4, #128]	; 0x80
     de8:	str.w	r2, [r4, #224]	; 0xe0
     dec:	str.w	r2, [r4, #228]	; 0xe4
     df0:	str.w	r2, [r4, #232]	; 0xe8
     df4:	str.w	r2, [r4, #236]	; 0xec
     df8:	str.w	r3, [r4, #132]	; 0x84
     dfc:	str.w	r3, [r4, #136]	; 0x88
     e00:	str.w	r3, [r4, #140]	; 0x8c
     e04:	str.w	r3, [r4, #144]	; 0x90
     e08:	str.w	r3, [r4, #148]	; 0x94
     e0c:	str.w	r3, [r4, #152]	; 0x98
     e10:	str.w	r3, [r4, #156]	; 0x9c
     e14:	str.w	r3, [r4, #160]	; 0xa0
     e18:	str.w	r3, [r4, #164]	; 0xa4
     e1c:	str.w	r3, [r4, #168]	; 0xa8
     e20:	str.w	r3, [r4, #172]	; 0xac
     e24:	str.w	r3, [r4, #176]	; 0xb0
     e28:	str.w	r3, [r4, #180]	; 0xb4
     e2c:	str.w	r3, [r4, #184]	; 0xb8
     e30:	str.w	r3, [r4, #188]	; 0xbc
     e34:	str.w	r3, [r4, #192]	; 0xc0
     e38:	str.w	r3, [r4, #196]	; 0xc4
     e3c:	str.w	r3, [r4, #200]	; 0xc8
     e40:	str.w	r3, [r4, #204]	; 0xcc
     e44:	str.w	r3, [r4, #208]	; 0xd0
     e48:	str.w	r3, [r4, #212]	; 0xd4
     e4c:	str.w	r3, [r4, #216]	; 0xd8
     e50:	str.w	r3, [r4, #220]	; 0xdc
     e54:	str	r5, [sp, #4]
      m_storage.data()[1] = y;
     e56:	str	r5, [sp, #8]
      m_storage.data()[2] = z;
     e58:	str	r5, [sp, #12]
     e5a:	bl	27c <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
     e5e:	vmov.f32	s2, s24
     e62:	add	r1, sp, #4
     e64:	vmov.f32	s0, s23
     e68:	add.w	r0, r4, #300	; 0x12c
     e6c:	vmov.f32	s5, s16
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     e70:	str	r5, [sp, #4]
     e72:	vmov.f32	s4, s16
      m_storage.data()[1] = y;
     e76:	str	r5, [sp, #8]
     e78:	vmov.f32	s3, s20
      m_storage.data()[2] = z;
     e7c:	str	r5, [sp, #12]
     e7e:	vmov.f32	s1, s18
     e82:	bl	27c <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
     e86:	vmov.f32	s3, s22
     e8a:	vmov.f32	s1, s21
     e8e:	add	r1, sp, #4
     e90:	vmov.f32	s5, s16
     e94:	add.w	r0, r4, #360	; 0x168
     e98:	vmov.f32	s4, s16
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     e9c:	str	r5, [sp, #4]
     e9e:	vmov.f32	s2, s19
      m_storage.data()[1] = y;
     ea2:	str	r5, [sp, #8]
     ea4:	vmov.f32	s0, s17
      m_storage.data()[2] = z;
     ea8:	str	r5, [sp, #12]
     eaa:	bl	27c <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
     eae:	add	r1, sp, #4
     eb0:	vmov.f32	s3, s20
     eb4:	add.w	r0, r4, #420	; 0x1a4
     eb8:	vmov.f32	s2, s19
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
     ebc:	str	r5, [sp, #4]
     ebe:	vmov.f32	s1, s18
      m_storage.data()[1] = y;
     ec2:	str	r5, [sp, #8]
     ec4:	vmov.f32	s0, s17
      m_storage.data()[2] = z;
     ec8:	str	r5, [sp, #12]
     eca:	vmov.f32	s5, s16
     ece:	vmov.f32	s4, s16
     ed2:	bl	27c <project_namespace::Leg::Leg(float, float, float, float, float, float, Eigen::Matrix<int, 3, 1, 0, 3, 1>)>
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
     ed6:	vldr	s9, [r4]
            stance_polygon_width/2.0,
     eda:	vldr	s14, [r4, #4]
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
     ede:	vmov.f64	d3, #96	; 0x3f000000  0.5
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
     ee2:	vcvt.f64.f32	d6, s9
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
     ee6:	vldr	s15, [r4, #8]
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
     eea:	vcvt.f64.f32	d5, s14
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
}
     eee:	mov	r0, r4
    contact_pattern(Eigen::Vector4i::Zero())
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
     ef0:	vmov.f32	s8, #96	; 0x3f000000  0.5
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
     ef4:	vnmul.f64	d6, d6, d3
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
     ef8:	vnmul.f64	d5, d5, d3
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
     efc:	vneg.f32	s15, s15
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
     f00:	vcvt.f32.f64	s12, d6
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
     f04:	vmul.f32	s14, s14, s8
    contact_pattern(Eigen::Vector4i::Zero())
{
    // Initialise foot_positions_wrt_body_true to default stance
    foot_positions_wrt_body_true.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
     f08:	vmul.f32	s13, s9, s8
     f0c:	vstr	s15, [r4, #40]	; 0x28
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_true.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
     f10:	vcvt.f32.f64	s10, d5
     f14:	vstr	s15, [r4, #52]	; 0x34
     f18:	vstr	s15, [r4, #64]	; 0x40
     f1c:	vstr	s15, [r4, #76]	; 0x4c
     f20:	vstr	s15, [r4, #88]	; 0x58
     f24:	vstr	s15, [r4, #100]	; 0x64
     f28:	vstr	s15, [r4, #112]	; 0x70
     f2c:	vstr	s12, [r4, #56]	; 0x38
     f30:	vstr	s12, [r4, #68]	; 0x44
     f34:	vstr	s12, [r4, #104]	; 0x68
     f38:	vstr	s12, [r4, #116]	; 0x74
     f3c:	vstr	s10, [r4, #48]	; 0x30
     f40:	vstr	s10, [r4, #72]	; 0x48
     f44:	vstr	s10, [r4, #96]	; 0x60
     f48:	vstr	s10, [r4, #120]	; 0x78
     f4c:	vstr	s10, [r4, #144]	; 0x90
     f50:	vstr	s15, [r4, #124]	; 0x7c
     f54:	vstr	s15, [r4, #136]	; 0x88
     f58:	vstr	s13, [r4, #32]
     f5c:	vstr	s13, [r4, #44]	; 0x2c
     f60:	vstr	s13, [r4, #80]	; 0x50
     f64:	vstr	s13, [r4, #92]	; 0x5c
     f68:	vstr	s13, [r4, #128]	; 0x80
     f6c:	vstr	s13, [r4, #140]	; 0x8c
     f70:	vstr	s14, [r4, #36]	; 0x24
     f74:	vstr	s14, [r4, #60]	; 0x3c
     f78:	vstr	s14, [r4, #84]	; 0x54
     f7c:	vstr	s14, [r4, #108]	; 0x6c
     f80:	vstr	s14, [r4, #132]	; 0x84
     f84:	vstr	s15, [r4, #148]	; 0x94
     f88:	vstr	s10, [r4, #168]	; 0xa8
     f8c:	vstr	s12, [r4, #152]	; 0x98
     f90:	vstr	s12, [r4, #164]	; 0xa4
     f94:	vstr	s14, [r4, #156]	; 0x9c
     f98:	vstr	s15, [r4, #160]	; 0xa0
     f9c:	vstr	s15, [r4, #172]	; 0xac
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
}
     fa0:	add	sp, #16
     fa2:	vpop	{d8-d12}
     fa6:	pop	{r4, r5, r6, pc}
     fa8:	.word	0x3db851ec
     fac:	.word	0x3e4ccccd
     fb0:	.word	0x3e23d70a
     fb4:	.word	0x3d916873
     fb8:	.word	0x3d1ba5e3
     fbc:	.word	0x3d23d70a
     fc0:	.word	0x3e1eb852
     fc4:	.word	0xbd916873
     fc8:	.word	0xbd23d70a
     fcc:	.word	0xbd1ba5e3
     fd0:	.word	0xbe1eb852

00000fd4 <project_namespace::Robot::getFootPositionsWrtBodyAssumingNoBodyRPY()>:
    return body_yaw;
}
Eigen::Matrix<float, 3, 4> Robot::getFootPositionsWrtBodyTrue() {
    return foot_positions_wrt_body_true;
}
Eigen::Matrix<float, 3, 4> Robot::getFootPositionsWrtBodyAssumingNoBodyRPY() {
     fd4:	push	{r4, r5, r6}
     fd6:	add.w	r5, r1, #80	; 0x50
     fda:	mov	r6, r0
     fdc:	mov	r4, r0
     fde:	ldmia	r5!, {r0, r1, r2, r3}
     fe0:	stmia	r4!, {r0, r1, r2, r3}
     fe2:	ldmia	r5!, {r0, r1, r2, r3}
     fe4:	stmia	r4!, {r0, r1, r2, r3}
     fe6:	ldmia.w	r5, {r0, r1, r2, r3}
     fea:	stmia.w	r4, {r0, r1, r2, r3}
    return foot_positions_wrt_body_assuming_no_body_rpy;
}
     fee:	mov	r0, r6
     ff0:	pop	{r4, r5, r6}
     ff2:	bx	lr

00000ff4 <project_namespace::Robot::getFootPositionsWrtBodyAtRest()>:
Eigen::Matrix<float, 3, 4> Robot::getFootPositionsWrtBodyAtRest() {
     ff4:	push	{r4, r5, r6}
     ff6:	add.w	r5, r1, #128	; 0x80
     ffa:	mov	r6, r0
     ffc:	mov	r4, r0
     ffe:	ldmia	r5!, {r0, r1, r2, r3}
    1000:	stmia	r4!, {r0, r1, r2, r3}
    1002:	ldmia	r5!, {r0, r1, r2, r3}
    1004:	stmia	r4!, {r0, r1, r2, r3}
    1006:	ldmia.w	r5, {r0, r1, r2, r3}
    100a:	stmia.w	r4, {r0, r1, r2, r3}
    return foot_positions_wrt_body_at_rest;
}
    100e:	mov	r0, r6
    1010:	pop	{r4, r5, r6}
    1012:	bx	lr

00001014 <project_namespace::Robot::setBodyRoll(float)>:
void Robot::setStanceHeight(float stance_height_arg) {
    stance_height = stance_height_arg;
    updateStancePolygon();
}
void Robot::setBodyRoll(float body_roll_arg) {
    body_roll = body_roll_arg;
    1014:	vstr	s0, [r0, #12]
    1018:	bx	lr
    101a:	nop

0000101c <project_namespace::Robot::setBodyPitch(float)>:
}
void Robot::setBodyPitch(float body_pitch_arg) {
    body_pitch = body_pitch_arg;
    101c:	vstr	s0, [r0, #16]
    1020:	bx	lr
    1022:	nop

00001024 <project_namespace::Robot::setBodyYaw(float)>:
}
void Robot::setBodyYaw(float body_yaw_arg) {
    body_yaw = body_yaw_arg;
    1024:	vstr	s0, [r0, #20]
    1028:	bx	lr
    102a:	nop

0000102c <project_namespace::Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>:
}
void Robot::setFootPositionsWrtBodyTrue(Eigen::Matrix<float, 3, 4> foot_positions_wrt_body_true_arg) {
    foot_positions_wrt_body_true = foot_positions_wrt_body_true_arg;
}
void Robot::setFootPositionsWrtBodyAssumingNoBodyRPY(Eigen::Matrix<float, 3, 4> foot_positions_wrt_body_assuming_no_body_rpy_arg) {
    102c:	ldr	r3, [r1, #0]
    102e:	str	r3, [r0, #80]	; 0x50
    1030:	ldr	r3, [r1, #4]
    1032:	str	r3, [r0, #84]	; 0x54
    1034:	ldr	r3, [r1, #8]
    1036:	str	r3, [r0, #88]	; 0x58
    1038:	ldr	r3, [r1, #12]
    103a:	str	r3, [r0, #92]	; 0x5c
    103c:	ldr	r3, [r1, #16]
    103e:	str	r3, [r0, #96]	; 0x60
    1040:	ldr	r3, [r1, #20]
    1042:	str	r3, [r0, #100]	; 0x64
    1044:	ldr	r3, [r1, #24]
    1046:	str	r3, [r0, #104]	; 0x68
    1048:	ldr	r3, [r1, #28]
    104a:	str	r3, [r0, #108]	; 0x6c
    104c:	ldr	r3, [r1, #32]
    104e:	str	r3, [r0, #112]	; 0x70
    1050:	ldr	r3, [r1, #36]	; 0x24
    1052:	str	r3, [r0, #116]	; 0x74
    1054:	ldr	r3, [r1, #40]	; 0x28
    1056:	str	r3, [r0, #120]	; 0x78
    1058:	ldr	r3, [r1, #44]	; 0x2c
    105a:	str	r3, [r0, #124]	; 0x7c
    105c:	bx	lr
    105e:	nop

00001060 <project_namespace::Robot::setContactPattern(Eigen::Matrix<int, 4, 1, 0, 4, 1>)>:
    foot_positions_wrt_body_at_rest = foot_positions_wrt_body_at_rest_arg;
}
void Robot::setJointAngles(Eigen::Matrix<float, 3, 4> joint_angles_arg) {
    joint_angles = joint_angles_arg;
}
void Robot::setContactPattern(Eigen::Vector4i contact_pattern_arg) {
    1060:	ldr	r3, [r1, #0]
    1062:	str.w	r3, [r0, #224]	; 0xe0
    1066:	ldr	r3, [r1, #4]
    1068:	str.w	r3, [r0, #228]	; 0xe4
    106c:	ldr	r3, [r1, #8]
    106e:	str.w	r3, [r0, #232]	; 0xe8
    1072:	ldr	r3, [r1, #12]
    1074:	str.w	r3, [r0, #236]	; 0xec
    1078:	bx	lr
    107a:	nop

0000107c <project_namespace::Robot::moveAllFeet(Eigen::Matrix<float, 3, 4, 0, 3, 4>)>:
    contact_pattern = contact_pattern_arg;
}

// METHODS
void Robot::moveAllFeet(Eigen::Matrix<float, 3, 4> foot_positions_wrt_body_cmd) {
    107c:	push	{r4, r5, r6, lr}
    107e:	mov	r4, r1
    1080:	sub	sp, #16
    1082:	ldr	r6, [r1, #0]
    1084:	mov	r5, r0
    1086:	ldr	r2, [r1, #4]
    ARUGMENTS:
    + foot_positions_wrt_body_cmd: The commanded foot positions.
    of the foot, [FL, FR, BL, BR].
    */

    front_left_leg.moveFoot(foot_positions_wrt_body_cmd.col(0));
    1088:	adds	r0, #240	; 0xf0
    108a:	ldr	r3, [r4, #8]
    108c:	add	r1, sp, #4
    108e:	str	r6, [sp, #4]
    1090:	str	r2, [sp, #8]
    1092:	str	r3, [sp, #12]
    1094:	bl	478 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    1098:	ldr	r6, [r4, #12]
    front_right_leg.moveFoot(foot_positions_wrt_body_cmd.col(1));
    109a:	add	r1, sp, #4
    109c:	ldr	r2, [r4, #16]
    109e:	add.w	r0, r5, #300	; 0x12c
    10a2:	ldr	r3, [r4, #20]
    10a4:	str	r6, [sp, #4]
    10a6:	str	r2, [sp, #8]
    10a8:	str	r3, [sp, #12]
    10aa:	bl	478 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    10ae:	ldr	r6, [r4, #24]
    back_left_leg.moveFoot(foot_positions_wrt_body_cmd.col(2));
    10b0:	add	r1, sp, #4
    10b2:	ldr	r2, [r4, #28]
    10b4:	add.w	r0, r5, #360	; 0x168
    10b8:	ldr	r3, [r4, #32]
    10ba:	str	r6, [sp, #4]
    10bc:	str	r2, [sp, #8]
    10be:	str	r3, [sp, #12]
    10c0:	bl	478 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    10c4:	ldr	r3, [r4, #44]	; 0x2c
    back_right_leg.moveFoot(foot_positions_wrt_body_cmd.col(3));
    10c6:	add	r1, sp, #4
    10c8:	ldr	r6, [r4, #36]	; 0x24
    10ca:	add.w	r0, r5, #420	; 0x1a4
    10ce:	ldr	r2, [r4, #40]	; 0x28
    10d0:	str	r3, [sp, #12]
    10d2:	str	r6, [sp, #4]
    10d4:	str	r2, [sp, #8]
    10d6:	bl	478 <project_namespace::Leg::moveFoot(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>
    10da:	ldr	r3, [r4, #0]
    10dc:	str	r3, [r5, #32]
    10de:	ldr	r3, [r4, #4]
    10e0:	str	r3, [r5, #36]	; 0x24
    10e2:	ldr	r3, [r4, #8]
    10e4:	str	r3, [r5, #40]	; 0x28
    10e6:	ldr	r3, [r4, #12]
    10e8:	str	r3, [r5, #44]	; 0x2c
    10ea:	ldr	r3, [r4, #16]
    10ec:	str	r3, [r5, #48]	; 0x30
    10ee:	ldr	r3, [r4, #20]
    10f0:	str	r3, [r5, #52]	; 0x34
    10f2:	ldr	r3, [r4, #24]
    10f4:	str	r3, [r5, #56]	; 0x38
    10f6:	ldr	r3, [r4, #28]
    10f8:	str	r3, [r5, #60]	; 0x3c
    10fa:	ldr	r3, [r4, #32]
    10fc:	str	r3, [r5, #64]	; 0x40
    10fe:	ldr	r3, [r4, #36]	; 0x24
    1100:	str	r3, [r5, #68]	; 0x44
    1102:	ldr	r3, [r4, #40]	; 0x28
    1104:	str	r3, [r5, #72]	; 0x48
    1106:	ldr	r3, [r4, #44]	; 0x2c
    1108:	str	r3, [r5, #76]	; 0x4c
    foot_positions_wrt_body_true = foot_positions_wrt_body_cmd;
}
    110a:	add	sp, #16
    110c:	pop	{r4, r5, r6, pc}
    110e:	nop

00001110 <project_namespace::Robot::updateStancePolygon()>:
    stance polygon length or width, or stance height.
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    1110:	vldr	s9, [r0]
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1114:	vmov.f64	d3, #96	; 0x3f000000  0.5
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
    1118:	vldr	s14, [r0, #4]
    stance polygon length or width, or stance height.
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    111c:	vmov.f32	s8, #96	; 0x3f000000  0.5
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    1120:	vcvt.f64.f32	d5, s9
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
    1124:	vldr	s15, [r0, #8]
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1128:	vcvt.f64.f32	d6, s14
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
            -1.0*stance_height
    112c:	vneg.f32	s15, s15
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    1130:	vnmul.f64	d5, d5, d3
    1134:	vstr	s15, [r0, #136]	; 0x88
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1138:	vnmul.f64	d6, d6, d3
    113c:	vstr	s15, [r0, #148]	; 0x94
    1140:	vstr	s15, [r0, #160]	; 0xa0
    1144:	vstr	s15, [r0, #172]	; 0xac
    stance polygon length or width, or stance height.
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
    1148:	vmul.f32	s9, s9, s8
            -1.0*stance_polygon_width/2.0,
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(2) = (
        Eigen::Vector3f()
        <<  -1.0*stance_polygon_length/2.0,
    114c:	vcvt.f32.f64	s10, d5
    Updates foot_positions_wrt_body_at_rest accordingly.
    */
    foot_positions_wrt_body_at_rest.col(0) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            stance_polygon_width/2.0,
    1150:	vmul.f32	s14, s14, s8
            -1.0*stance_height
    ).finished();
    foot_positions_wrt_body_at_rest.col(1) = (
        Eigen::Vector3f()
        <<  stance_polygon_length/2.0,
            -1.0*stance_polygon_width/2.0,
    1154:	vcvt.f32.f64	s12, d6
    1158:	vstr	s9, [r0, #128]	; 0x80
    115c:	vstr	s9, [r0, #140]	; 0x8c
    1160:	vstr	s10, [r0, #152]	; 0x98
    1164:	vstr	s10, [r0, #164]	; 0xa4
    1168:	vstr	s14, [r0, #132]	; 0x84
    116c:	vstr	s12, [r0, #144]	; 0x90
    1170:	vstr	s12, [r0, #168]	; 0xa8
    1174:	vstr	s14, [r0, #156]	; 0x9c
    1178:	bx	lr
    117a:	nop

0000117c <project_namespace::Robot::setStancePolygonLength(float)>:
    return contact_pattern;
}

// SETTERS
void Robot::setStancePolygonLength(float stance_polygon_length_arg) {
    stance_polygon_length = stance_polygon_length_arg;
    117c:	vstr	s0, [r0]
    updateStancePolygon();
    1180:	b.w	1110 <project_namespace::Robot::updateStancePolygon()>

00001184 <project_namespace::Robot::setStancePolygonWidth(float)>:
}
void Robot::setStancePolygonWidth(float stance_polygon_width_arg) {
    stance_polygon_width = stance_polygon_width_arg;
    1184:	vstr	s0, [r0, #4]
    updateStancePolygon();
    1188:	b.w	1110 <project_namespace::Robot::updateStancePolygon()>

0000118c <project_namespace::Robot::setStanceHeight(float)>:
}
void Robot::setStanceHeight(float stance_height_arg) {
    stance_height = stance_height_arg;
    118c:	vstr	s0, [r0, #8]
    updateStancePolygon();
    1190:	b.w	1110 <project_namespace::Robot::updateStancePolygon()>

00001194 <project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)>:

// CONSTRUCTORS

LegSwingController::LegSwingController(GaitConfig& gait_config_init, IMU& imu_init):
    gait_config(gait_config_init),
    imu(imu_init)
    1194:	stmia.w	r0, {r1, r2}
{ }
    1198:	bx	lr
    119a:	nop

0000119c <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)>:

// METHODS

Eigen::Vector3f LegSwingController::calculateRaibertTouchdownLocation(Robot& robot, Command& command, int leg_index) {
    119c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    11a0:	vpush	{d8-d14}
    11a4:	sub	sp, #40	; 0x28
    11a6:	mov	r5, r0
    11a8:	mov	r8, r3
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    11aa:	movs	r0, #0
    11ac:	add	r7, sp, #0
    11ae:	sub	sp, #64	; 0x40
    11b0:	str	r0, [r5, #0]
      m_storage.data()[1] = y;
    11b2:	str	r0, [r5, #4]
    11b4:	mov	r9, r1
    11b6:	add.w	r3, sp, #15
      m_storage.data()[2] = z;
    11ba:	str	r0, [r5, #8]
    float alpha = 0.0; // For gait translation.
    float beta = 0.0; // For gait yaw.

    // If gait translation involves both antero-posterior and lateral movement,
    // alpha will be a vector sum of respective alphas in both directions, clipped within 0 and 1.
    if (command.getBodyVelocity()(0) > 0) { // If moving forwards
    11bc:	mov	r1, r8
    11be:	adds	r0, r7, #4
    imu(imu_init)
{ }

// METHODS

Eigen::Vector3f LegSwingController::calculateRaibertTouchdownLocation(Robot& robot, Command& command, int leg_index) {
    11c0:	mov	sl, r2
    11c2:	bic.w	r4, r3, #15
    11c6:	ldr.w	r6, [r7, #128]	; 0x80
    float alpha = 0.0; // For gait translation.
    float beta = 0.0; // For gait yaw.

    // If gait translation involves both antero-posterior and lateral movement,
    // alpha will be a vector sum of respective alphas in both directions, clipped within 0 and 1.
    if (command.getBodyVelocity()(0) > 0) { // If moving forwards
    11ca:	bl	17e8 <project_namespace::Command::getBodyVelocity()>
    11ce:	vldr	s15, [r7, #4]
    11d2:	vcmpe.f32	s15, #0.0
    11d6:	vmrs	APSR_nzcv, fpscr
    11da:	ble.n	12ca <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x12e>
        alpha = constrain(sqrt(pow(Parameters::lateral_alpha, 2.0) + pow(Parameters::forwards_alpha, 2.0)), 0.0, 1.0);
    11dc:	vldr	s19, [pc, #264]	; 12e8 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x14c>
    }
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
    11e0:	ldr.w	r0, [r9]
                                || ((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && ( XprTypeIsRowMajor)) ? xpr.innerStride() : xpr.outerStride()),
             BlockRows==1 ? 1 : xpr.rows(),
             BlockCols==1 ? 1 : xpr.cols()),
        m_xpr(xpr),
        m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),
        m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0)
    11e4:	add.w	r6, r6, r6, lsl #1
    11e8:	bl	c60 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
        *Config::dt
    11ec:	vmov	s15, r0
        *command.getBodyVelocity()
    11f0:	mov	r1, r8
    11f2:	adds	r0, r7, #4
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
    11f4:	vcvt.f32.s32	s15, s15
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
        *command.getGaitYawSpeed()
    ;
    Eigen::Matrix<float, 3, 3> projected_total_gait_yaw_rotation_matrix;
    projected_total_gait_yaw_rotation_matrix = MyMath::eulerToMatrix(0, 0, projected_total_gait_yaw_during_stance_phase);
    11f8:	vldr	s20, [pc, #240]	; 12ec <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x150>
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
    11fc:	vldr	s17, [pc, #240]	; 12f0 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x154>
    1200:	vmul.f32	s19, s15, s19
        *command.getBodyVelocity()
    1204:	bl	17e8 <project_namespace::Command::getBodyVelocity()>
    ;
    touchdown_displacement_from_neutral_location(2) = 0; // z-coordinate not important for touchdown location
    // Calculate touchdown location displacement due to gait yaw
    float projected_total_gait_yaw_during_stance_phase =
        beta
        *gait_config.getLegStanceDurationInTicks()
    1208:	ldr.w	r0, [r9]
    120c:	vldr	s22, [r7, #4]
    1210:	vldr	s21, [r7, #8]
    1214:	bl	c60 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
    1218:	vmov	s16, r0
        *Config::dt
        *command.getGaitYawSpeed()
    121c:	mov	r0, r8
    121e:	bl	17f8 <project_namespace::Command::getGaitYawSpeed()>
    ;
    Eigen::Matrix<float, 3, 3> projected_total_gait_yaw_rotation_matrix;
    projected_total_gait_yaw_rotation_matrix = MyMath::eulerToMatrix(0, 0, projected_total_gait_yaw_during_stance_phase);
    1222:	vmov.f32	s1, s20
    1226:	vcvt.f32.s32	s16, s16
    122a:	adds	r0, r7, #4
    // Calculate touchdown location displacement due to linear movement
    Eigen::Vector3f touchdown_displacement_from_neutral_location(0.0, 0.0, 0.0);
    touchdown_displacement_from_neutral_location =
        alpha
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
    122c:	vmul.f32	s19, s19, s17
        *gait_config.getLegStanceDurationInTicks()
        *Config::dt
        *command.getGaitYawSpeed()
    ;
    Eigen::Matrix<float, 3, 3> projected_total_gait_yaw_rotation_matrix;
    projected_total_gait_yaw_rotation_matrix = MyMath::eulerToMatrix(0, 0, projected_total_gait_yaw_during_stance_phase);
    1230:	vmul.f32	s16, s16, s20
    1234:	vmul.f32	s2, s16, s17
    1238:	vmul.f32	s2, s2, s0
    123c:	vmov.f32	s0, s20
    1240:	bl	544 <project_namespace::MyMath::eulerToMatrix(float, float, float)>
    
    // Linear combination of effects of both linear and yaw movement
    touchdown_location =
        projected_total_gait_yaw_rotation_matrix*robot.getFootPositionsWrtBodyAtRest().col(leg_index)
    1244:	mov	r0, r4
    1246:	mov	r1, sl
    1248:	vldr	s25, [r7, #4]
    124c:	vldr	s24, [r7, #8]
    1250:	vldr	s23, [r7, #12]
    1254:	vldr	s28, [r7, #16]
    1258:	vldr	s27, [r7, #20]
    125c:	vldr	s26, [r7, #24]
    1260:	vldr	s17, [r7, #28]
    1264:	vldr	s16, [r7, #32]
    1268:	vldr	s18, [r7, #36]	; 0x24
    126c:	bl	ff4 <project_namespace::Robot::getFootPositionsWrtBodyAtRest()>
    1270:	add.w	r3, r4, r6, lsl #2
        + touchdown_displacement_from_neutral_location
    ;

    return touchdown_location;
}
    1274:	mov	r0, r5
    1276:	adds	r7, #40	; 0x28
  }

  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  CoeffReturnType coeff(Index row, Index col) const
  {
    return m_data[col * colStride() + row * rowStride()];
    1278:	vldr	s1, [r3, #8]
    127c:	vldr	s12, [r3, #4]
    1280:	vmul.f32	s14, s17, s1
    1284:	vldr	s13, [r3]
    1288:	vmul.f32	s15, s16, s1
    128c:	vmul.f32	s1, s18, s1
    1290:	vfma.f32	s14, s28, s12
    1294:	vfma.f32	s15, s27, s12
    1298:	vfma.f32	s1, s26, s12
    129c:	vfma.f32	s14, s25, s13
    12a0:	vfma.f32	s15, s24, s13
    12a4:	vfma.f32	s1, s23, s13
    12a8:	vfma.f32	s14, s19, s22
    12ac:	vfma.f32	s15, s19, s21
    12b0:	vadd.f32	s1, s1, s20
    12b4:	vstr	s1, [r5, #8]
    12b8:	vstr	s14, [r5]
    12bc:	vstr	s15, [r5, #4]
    12c0:	mov	sp, r7
    12c2:	vpop	{d8-d14}
    12c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    // If gait translation involves both antero-posterior and lateral movement,
    // alpha will be a vector sum of respective alphas in both directions, clipped within 0 and 1.
    if (command.getBodyVelocity()(0) > 0) { // If moving forwards
        alpha = constrain(sqrt(pow(Parameters::lateral_alpha, 2.0) + pow(Parameters::forwards_alpha, 2.0)), 0.0, 1.0);
    } else if (command.getBodyVelocity()(0) < 0) {
    12ca:	mov	r1, r8
    12cc:	adds	r0, r7, #4
    12ce:	bl	17e8 <project_namespace::Command::getBodyVelocity()>
    12d2:	vldr	s15, [r7, #4]
    12d6:	vcmpe.f32	s15, #0.0
    12da:	vmrs	APSR_nzcv, fpscr
    12de:	bpl.w	11dc <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x40>
        alpha = constrain(sqrt(pow(Parameters::lateral_alpha, 2.0) + pow(Parameters::backwards_alpha, 2.0)), 0.0, 1.0);
    12e2:	vmov.f32	s19, #112	; 0x3f800000  1.0
    12e6:	b.n	11e0 <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)+0x44>
    12e8:	.word	0x3eb851ec
    12ec:	.word	0x00000000
    12f0:	.word	0x3c23d70a

000012f4 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)>:
    ;

    return touchdown_location;
}

Eigen::Vector3f LegSwingController::calculateRollPitchCapturePoint(Command& command) {
    12f4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    12f8:	vpush	{d8-d11}
    12fc:	add	r7, sp, #0
    12fe:	sub	sp, #48	; 0x30
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    1300:	movs	r3, #0
    */

    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f rpy_angles;
    rpy_angles = imu.getHeadingQuaternion().normalized().toRotationMatrix().eulerAngles(0, 1, 2);
    1302:	ldr	r1, [r1, #4]
    ;

    return touchdown_location;
}

Eigen::Vector3f LegSwingController::calculateRollPitchCapturePoint(Command& command) {
    1304:	add.w	r4, sp, #15
    1308:	mov	r5, r0
    130a:	str	r3, [r0, #0]
    130c:	mov	r8, r2
    130e:	bic.w	r4, r4, #15
      m_storage.data()[1] = y;
    1312:	str	r3, [r0, #4]
      m_storage.data()[2] = z;
    1314:	str	r3, [r0, #8]
    */

    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f rpy_angles;
    rpy_angles = imu.getHeadingQuaternion().normalized().toRotationMatrix().eulerAngles(0, 1, 2);
    1316:	add.w	r6, r4, #16
    131a:	mov	r0, r6
    131c:	bl	cd8 <project_namespace::IMU::getHeadingQuaternion()>
    1320:	vldr	s10, [r4, #20]
    1324:	vldr	s11, [r4, #28]
#else
  scalar_sum_op() {
    EIGEN_SCALAR_BINARY_OP_PLUGIN
  }
#endif
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a + b; }
    1328:	vmul.f32	s14, s10, s10
    132c:	vldr	s13, [r4, #16]
    1330:	vmul.f32	s15, s11, s11
    1334:	vldr	s12, [r4, #24]
    1338:	vfma.f32	s14, s13, s13
    133c:	vfma.f32	s15, s12, s12
    1340:	vadd.f32	s15, s14, s15
{
  typedef typename internal::nested_eval<Derived,2>::type _Nested;
  _Nested n(derived());
  RealScalar z = n.squaredNorm();
  // NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent x86 CPU
  if(z>RealScalar(0))
    1344:	vcmpe.f32	s15, #0.0
    1348:	vmrs	APSR_nzcv, fpscr
    134c:	bgt.w	1488 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x194>
    1350:	ldmia.w	r6, {r0, r1, r2, r3}
    1354:	stmia.w	r4, {r0, r1, r2, r3}
    1358:	vldr	s15, [r4]
    135c:	vldr	s13, [r4, #4]
    1360:	vldr	s18, [r4, #8]
    1364:	vldr	s12, [r4, #12]
  // however, not inlining this function is an order of magnitude slower, so
  // it has to be inlined, and so the return by value is not an issue
  Matrix3 res;

  const Scalar tx  = Scalar(2)*this->x();
  const Scalar ty  = Scalar(2)*this->y();
    1368:	vadd.f32	s10, s13, s13
  const Scalar tz  = Scalar(2)*this->z();
    136c:	vadd.f32	s11, s18, s18
  // if not inlined then the cost of the return by value is huge ~ +35%,
  // however, not inlining this function is an order of magnitude slower, so
  // it has to be inlined, and so the return by value is not an issue
  Matrix3 res;

  const Scalar tx  = Scalar(2)*this->x();
    1370:	vadd.f32	s9, s15, s15
  const Scalar twy = ty*this->w();
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
  const Scalar txz = tz*this->x();
  const Scalar tyy = ty*this->y();
    1374:	vmul.f32	s14, s13, s10
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();
    1378:	vmul.f32	s18, s11, s18
  const Scalar tz  = Scalar(2)*this->z();
  const Scalar twx = tx*this->w();
  const Scalar twy = ty*this->w();
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
    137c:	vmul.f32	s7, s15, s10
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    1380:	vmov.f32	s1, s14

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
    1384:	vmov.f32	s21, s18
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
  const Scalar txz = tz*this->x();
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
    1388:	vmul.f32	s13, s13, s11
    138c:	vfma.f32	s1, s15, s9

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
    1390:	vfma.f32	s21, s15, s9
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
    1394:	vmov.f32	s20, s7
  const Scalar twx = tx*this->w();
  const Scalar twy = ty*this->w();
  const Scalar twz = tz*this->w();
  const Scalar txx = tx*this->x();
  const Scalar txy = ty*this->x();
  const Scalar txz = tz*this->x();
    1398:	vmul.f32	s15, s15, s11
    139c:	vmov.f32	s0, s13
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
    13a0:	vfms.f32	s20, s11, s12
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
  res.coeffRef(2,1) = tyz+twx;
    13a4:	vfma.f32	s13, s9, s12
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
    13a8:	vfma.f32	s7, s11, s12
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
    13ac:	vmov.f32	s23, s15
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
    13b0:	vfms.f32	s15, s10, s12
  const Scalar txz = tz*this->x();
  const Scalar tyy = ty*this->y();
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
    13b4:	vmov.f32	s8, #112	; 0x3f800000  1.0
    13b8:	vadd.f32	s18, s14, s18
    13bc:	vfms.f32	s0, s9, s12
    13c0:	vsub.f32	s1, s8, s1
    13c4:	vsub.f32	s18, s8, s18
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
    13c8:	vsub.f32	s21, s8, s21
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
  res.coeffRef(2,1) = tyz+twx;
    13cc:	vmov.f32	s19, s13
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
  res.coeffRef(1,0) = txy+twz;
    13d0:	vmov.f32	s22, s7
  const Scalar tyz = tz*this->y();
  const Scalar tzz = tz*this->z();

  res.coeffRef(0,0) = Scalar(1)-(tyy+tzz);
  res.coeffRef(0,1) = txy-twz;
  res.coeffRef(0,2) = txz+twy;
    13d4:	vfma.f32	s23, s10, s12
  res.coeffRef(1,0) = txy+twz;
  res.coeffRef(1,1) = Scalar(1)-(txx+tzz);
  res.coeffRef(1,2) = tyz-twx;
  res.coeffRef(2,0) = txz-twy;
    13d8:	vmov.f32	s17, s15
    13dc:	bl	4a60 <atan2f>
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    13e0:	vmul.f32	s20, s20, s20
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    13e4:	vmov.f32	s16, s0
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    13e8:	vmov.f32	s0, s20
    13ec:	vfma.f32	s0, s18, s18
    13f0:	vsqrt.f32	s1, s0
    13f4:	vcmp.f32	s1, s1
    13f8:	vmrs	APSR_nzcv, fpscr
    13fc:	bne.n	14b6 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1c2>
  } 
  else
  {
    res[0] = atan2(coeff(j,k), coeff(k,k));
    Scalar c2 = Vector2(coeff(i,i), coeff(i,j)).norm();
    if((odd && res[0]<Scalar(0)) || ((!odd) && res[0]>Scalar(0))) {
    13fe:	vcmpe.f32	s16, #0.0
    1402:	vmrs	APSR_nzcv, fpscr
    1406:	ble.n	14a8 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1b4>
      if(res[0] > Scalar(0)) {
        res[0] -= Scalar(EIGEN_PI);
    1408:	vldr	s15, [pc, #208]	; 14dc <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1e8>
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    140c:	vneg.f32	s1, s1
    1410:	vneg.f32	s0, s23
    1414:	vsub.f32	s16, s16, s15
    1418:	bl	4a60 <atan2f>
    141c:	vmov.f32	s18, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
    1420:	vmov.f32	s0, s16
    1424:	bl	4548 <sinf>
    1428:	vmov.f32	s20, s0
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
    142c:	vmov.f32	s0, s16
    1430:	bl	44b8 <cosf>
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    1434:	vnmul.f32	s7, s22, s0
    1438:	vnmul.f32	s1, s19, s20
    143c:	vfma.f32	s7, s20, s17
    1440:	vfma.f32	s1, s0, s21
    1444:	vmov.f32	s0, s7
    1448:	bl	4a60 <atan2f>
    float roll_error =  command.getBodyRoll() - rpy_angles(0);
    144c:	mov	r0, r8
    144e:	bl	17d0 <project_namespace::Command::getBodyRoll()>
    float pitch_error =  command.getBodyPitch() - rpy_angles(1);
    1452:	mov	r0, r8

    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0); // Initialise

    Eigen::Vector3f rpy_angles;
    rpy_angles = imu.getHeadingQuaternion().normalized().toRotationMatrix().eulerAngles(0, 1, 2);
    float roll_error =  command.getBodyRoll() - rpy_angles(0);
    1454:	vadd.f32	s16, s0, s16
    float pitch_error =  command.getBodyPitch() - rpy_angles(1);
    1458:	bl	17d8 <project_namespace::Command::getBodyPitch()>
    145c:	vadd.f32	s0, s0, s18
    1460:	vldr	s15, [pc, #124]	; 14e0 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1ec>
    1464:	vldr	s18, [pc, #124]	; 14e4 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1f0>
            Parameters::roll_gain*roll_error,
            0.0
    ).finished();

    return rp_capture_point;
}
    1468:	mov	r0, r5
    146a:	vmul.f32	s16, s16, s15
    146e:	vstr	s15, [r5, #8]
    1472:	vmul.f32	s0, s0, s18
    1476:	vstr	s16, [r5, #4]
    147a:	vstr	s0, [r5]
    147e:	mov	sp, r7
    1480:	vpop	{d8-d11}
    1484:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    1488:	vsqrt.f32	s0, s15
    148c:	vcmp.f32	s0, s0
    1490:	vmrs	APSR_nzcv, fpscr
    1494:	bne.n	14c0 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1cc>
#else
  scalar_quotient_op() {
    EIGEN_SCALAR_BINARY_OP_PLUGIN
  }
#endif
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a / b; }
    1496:	vdiv.f32	s15, s13, s0
    149a:	vdiv.f32	s18, s12, s0
    149e:	vdiv.f32	s13, s10, s0
    14a2:	vdiv.f32	s12, s11, s0
    14a6:	b.n	1368 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x74>
  using ::atan2;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
    14a8:	vneg.f32	s0, s23
    14ac:	bl	4a60 <atan2f>
    14b0:	vmov.f32	s18, s0
    14b4:	b.n	1420 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x12c>
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
    14b6:	bl	4a68 <sqrtf>
    14ba:	vmov.f32	s1, s0
    14be:	b.n	13fe <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x10a>
    14c0:	vmov.f32	s0, s15
    14c4:	bl	4a68 <sqrtf>
    14c8:	vldr	s13, [r4, #16]
    14cc:	vldr	s10, [r4, #20]
    14d0:	vldr	s12, [r4, #24]
    14d4:	vldr	s11, [r4, #28]
    14d8:	b.n	1496 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)+0x1a2>
    14da:	nop
    14dc:	.word	0x40490fdb
    14e0:	.word	0x00000000
    14e4:	.word	0x80000000

000014e8 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>:

Eigen::Vector3f LegSwingController::calculateRollPitchRateCapturePoint() {
    14e8:	push	{r4, lr}
    14ea:	mov	r4, r0
    + rp_rate_capture_point: The offsets from the touchdown location dependent on
    the roll and pitch angle rates of the robot body.
    */
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0); // Initialise
    Eigen::Vector3f gyro_vals(0.0, 0.0, 0.0);
    gyro_vals = imu.getGyro();
    14ec:	ldr	r1, [r1, #4]
    ).finished();

    return rp_capture_point;
}

Eigen::Vector3f LegSwingController::calculateRollPitchRateCapturePoint() {
    14ee:	vpush	{d8}
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    14f2:	vldr	s16, [pc, #64]	; 1534 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()+0x4c>
    14f6:	sub	sp, #16
    14f8:	vstr	s16, [r4]
    + rp_rate_capture_point: The offsets from the touchdown location dependent on
    the roll and pitch angle rates of the robot body.
    */
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0); // Initialise
    Eigen::Vector3f gyro_vals(0.0, 0.0, 0.0);
    gyro_vals = imu.getGyro();
    14fc:	add	r0, sp, #4
      m_storage.data()[1] = y;
    14fe:	vstr	s16, [r4, #4]
      m_storage.data()[2] = z;
    1502:	vstr	s16, [r4, #8]
    1506:	bl	c7c <project_namespace::IMU::getGyro()>
    150a:	vldr	s14, [sp, #8]
    150e:	vldr	s15, [sp, #4]
            -1.0*Parameters::roll_rate_gain*roll_rate,
            0.0
    ).finished();

    return rp_rate_capture_point;
}
    1512:	mov	r0, r4
    1514:	vldr	s13, [pc, #32]	; 1538 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()+0x50>
    1518:	vmul.f32	s14, s14, s16
    151c:	vstr	s16, [r4, #8]
    1520:	vmul.f32	s15, s15, s13
    1524:	vstr	s14, [r4]
    1528:	vstr	s15, [r4, #4]
    152c:	add	sp, #16
    152e:	vpop	{d8}
    1532:	pop	{r4, pc}
    1534:	.word	0x00000000
    1538:	.word	0x80000000
    153c:	.word	0x00000000

00001540 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)>:
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    1540:	vcmpe.f32	s0, #0.0
    Robot& robot,
    Command& command,
    int leg_index,
    float swing_proportion_completed,
    FootTrajectory trajectory_shape
) {
    1544:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1548:	vpush	{d8-d13}
    154c:	sub	sp, #28
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    154e:	vmrs	APSR_nzcv, fpscr
    Robot& robot,
    Command& command,
    int leg_index,
    float swing_proportion_completed,
    FootTrajectory trajectory_shape
) {
    1552:	mov	r4, r0
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
      m_storage.data()[0] = x;
    1554:	mov.w	r0, #0
    1558:	add	r7, sp, #8
    155a:	str	r0, [r4, #0]
    155c:	sub	sp, #64	; 0x40
      m_storage.data()[1] = y;
    155e:	str	r0, [r4, #4]
      m_storage.data()[2] = z;
    1560:	str	r0, [r4, #8]
    1562:	ldr.w	r8, [r7, #104]	; 0x68
    1566:	ldr.w	sl, [r7, #108]	; 0x6c
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    156a:	blt.w	175c <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x21c>
    156e:	vmov.f32	s15, #112	; 0x3f800000  1.0
    1572:	vmov.f32	s16, s0
    1576:	vcmpe.f32	s0, s15
    157a:	vmrs	APSR_nzcv, fpscr
    157e:	bhi.w	175c <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x21c>
    1582:	add.w	r5, sp, #23
    1586:	mov	r6, r1
    Eigen::Vector3f current_foot_location_assuming_no_body_rpy(0.0, 0.0, 0.0);
    current_foot_location_assuming_no_body_rpy = robot.getFootPositionsWrtBodyAssumingNoBodyRPY().col(leg_index);
    1588:	mov	r1, r2
    158a:	mov	r9, r3
    158c:	bic.w	r5, r5, #15
    1590:	mov	fp, r2
    1592:	mov	r0, r5
    1594:	bl	fd4 <project_namespace::Robot::getFootPositionsWrtBodyAssumingNoBodyRPY()>
    Eigen::Vector3f raibert_touchdown_location(0.0, 0.0, 0.0);
    raibert_touchdown_location = calculateRaibertTouchdownLocation(robot, command, leg_index);
    1598:	mov	r2, fp
    159a:	add.w	r1, r8, r8, lsl #1
    159e:	adds	r0, r7, #4
    15a0:	mov	r3, r9
    15a2:	add.w	r5, r5, r1, lsl #2
    15a6:	mov	r1, r6
    15a8:	vldr	s19, [r5]
    15ac:	vldr	s20, [r5, #4]
    15b0:	vldr	s21, [r5, #8]
    15b4:	str.w	r8, [sp]
    15b8:	bl	119c <project_namespace::LegSwingController::calculateRaibertTouchdownLocation(project_namespace::Robot&, project_namespace::Command&, int)>
    Eigen::Vector3f touchdown_location(0.0, 0.0, 0.0);
    touchdown_location = raibert_touchdown_location;

    // Applying rp_capture_point
    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0);
    rp_capture_point = calculateRollPitchCapturePoint(command);
    15bc:	adds	r0, r7, #4
    15be:	mov	r2, r9
    15c0:	mov	r1, r6
    15c2:	vldr	s18, [r7, #4]
    15c6:	vldr	s17, [r7, #8]
    15ca:	bl	12f4 <project_namespace::LegSwingController::calculateRollPitchCapturePoint(project_namespace::Command&)>
    15ce:	vldr	s15, [r7, #8]
    15d2:	vldr	s13, [r7, #4]
    touchdown_location(0) = touchdown_location(0) + rp_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
    15d6:	vcmpe.f32	s15, #0.0
    touchdown_location = raibert_touchdown_location;

    // Applying rp_capture_point
    Eigen::Vector3f rp_capture_point(0.0, 0.0, 0.0);
    rp_capture_point = calculateRollPitchCapturePoint(command);
    touchdown_location(0) = touchdown_location(0) + rp_capture_point(0); // Apply x-offset to all legs
    15da:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
    15de:	vmrs	APSR_nzcv, fpscr
    15e2:	ble.n	16b6 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x176>
    15e4:	bics.w	r3, r8, #2
    15e8:	bne.n	16b6 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x176>
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    15ea:	adds	r0, r7, #4
    15ec:	mov	r1, r6
    touchdown_location(0) = touchdown_location(0) + rp_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    15ee:	vadd.f32	s17, s17, s15
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    15f2:	bl	14e8 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>
    15f6:	vldr	s15, [r7, #8]
    15fa:	vldr	s13, [r7, #4]
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    15fe:	vcmpe.f32	s15, #0.0
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    1602:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    1606:	vmrs	APSR_nzcv, fpscr
    160a:	ble.n	1610 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    160c:	vadd.f32	s17, s17, s15
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    1610:	ldr	r0, [r6, #0]
    1612:	bl	c64 <project_namespace::GaitConfig::getLegSwingDurationInTicks()>
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    1616:	vmov	s15, r0
    161a:	vldr	s12, [pc, #340]	; 1770 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x230>
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    161e:	vcvt.f64.f32	d11, s16
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    1622:	vcvt.f32.s32	s14, s15
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
    1626:	cmp.w	sl, #1
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    162a:	vmov.f64	d0, #112	; 0x3f800000  1.0
    162e:	vsub.f32	s13, s18, s19
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    1632:	vmul.f32	s14, s14, s12
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    }

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    1636:	vsub.f64	d12, d0, d11
    163a:	vsub.f32	s17, s17, s20
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    163e:	vcvt.f64.f32	d7, s14
    1642:	vmul.f64	d7, d7, d12
    1646:	vcvt.f32.f64	s14, d7
    164a:	vdiv.f32	s15, s14, s12
    164e:	vdiv.f32	s26, s13, s15
    1652:	vdiv.f32	s18, s17, s15
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
    1656:	beq.n	1738 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1f8>
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    } else if (trajectory_shape == FootTrajectory::TRIANGULAR) {
    1658:	cmp.w	sl, #0
    165c:	bne.n	16fa <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1ba>
        if (swing_proportion_completed <= 0.5) {
            z_from_ground = gait_config.getSwingHeight()*swing_proportion_completed;
    165e:	ldr	r0, [r6, #0]
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    } else if (trajectory_shape == FootTrajectory::TRIANGULAR) {
        if (swing_proportion_completed <= 0.5) {
    1660:	vmov.f32	s15, #96	; 0x3f000000  0.5
    1664:	vcmpe.f32	s16, s15
    1668:	vmrs	APSR_nzcv, fpscr
    166c:	bls.n	1700 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1c0>
            z_from_ground = gait_config.getSwingHeight()*swing_proportion_completed;
        } else {
            z_from_ground = gait_config.getSwingHeight()*(1.0 - swing_proportion_completed);
    166e:	bl	c68 <project_namespace::GaitConfig::getSwingHeight()>
    1672:	vcvt.f64.f32	d0, s0
    1676:	vmul.f64	d0, d0, d12
    167a:	vcvt.f32.f64	s16, d0
    167e:	vldr	s15, [pc, #244]	; 1774 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x234>
    1682:	vadd.f32	s19, s19, s26
    1686:	vadd.f32	s20, s20, s18
        }
    }
    new_foot_position = current_foot_location_assuming_no_body_rpy + foot_delta_p;
    new_foot_position(2) = -command.getStanceHeight() + z_from_ground;
    168a:	mov	r0, r9
    168c:	vadd.f32	s21, s21, s15
    1690:	vstr	s19, [r4]
    1694:	vstr	s20, [r4, #4]
    1698:	vstr	s21, [r4, #8]
    169c:	bl	17c8 <project_namespace::Command::getStanceHeight()>
    16a0:	vsub.f32	s0, s16, s0

    return new_foot_position;
    16a4:	mov	r0, r4
    16a6:	adds	r7, #20
        } else {
            z_from_ground = gait_config.getSwingHeight()*(1.0 - swing_proportion_completed);
        }
    }
    new_foot_position = current_foot_location_assuming_no_body_rpy + foot_delta_p;
    new_foot_position(2) = -command.getStanceHeight() + z_from_ground;
    16a8:	vstr	s0, [r4, #8]

    return new_foot_position;
    16ac:	mov	sp, r7
    16ae:	vpop	{d8-d13}
    16b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    } else if ((rp_capture_point(1) < 0) and (leg_index == 1 or leg_index == 3)) {
    16b6:	vcmpe.f32	s15, #0.0
    16ba:	vmrs	APSR_nzcv, fpscr
    16be:	bmi.n	170a <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1ca>
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    16c0:	adds	r0, r7, #4
    16c2:	mov	r1, r6
    16c4:	bl	14e8 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>
    16c8:	vldr	s15, [r7, #8]
    16cc:	vldr	s13, [r7, #4]
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    16d0:	vcmpe.f32	s15, #0.0
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    16d4:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
    16d8:	vmrs	APSR_nzcv, fpscr
    16dc:	ble.n	16e4 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1a4>
    16de:	bics.w	r3, r8, #2
    16e2:	beq.n	160c <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xcc>
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
    16e4:	vcmpe.f32	s15, #0.0
    16e8:	vmrs	APSR_nzcv, fpscr
    16ec:	bpl.n	1610 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>
    16ee:	bic.w	r8, r8, #2
    16f2:	cmp.w	r8, #1
    16f6:	beq.n	160c <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xcc>
    16f8:	b.n	1610 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>

    float time_to_touchdown = Config::dt * gait_config.getLegSwingDurationInTicks() * (1.0 - swing_proportion_completed);
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    16fa:	vldr	s16, [pc, #120]	; 1774 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x234>
    16fe:	b.n	167e <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x13e>
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    } else if (trajectory_shape == FootTrajectory::TRIANGULAR) {
        if (swing_proportion_completed <= 0.5) {
            z_from_ground = gait_config.getSwingHeight()*swing_proportion_completed;
    1700:	bl	c68 <project_namespace::GaitConfig::getSwingHeight()>
    1704:	vmul.f32	s16, s16, s0
    1708:	b.n	167e <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x13e>
    // Apply y-offset conditionally to the legs as follows:
    if ((rp_capture_point(1) > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    } else if ((rp_capture_point(1) < 0) and (leg_index == 1 or leg_index == 3)) {
    170a:	bic.w	r3, r8, #2
    170e:	cmp	r3, #1
    1710:	bne.n	16c0 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x180>
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    1712:	adds	r0, r7, #4
    1714:	mov	r1, r6
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    } else if ((rp_capture_point(1) < 0) and (leg_index == 1 or leg_index == 3)) {
        // Robot is moving with an undesired velocity in the -ve y-direction (the robot's right)
        // Along the y-direction, move only the legs on the right of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_capture_point(1);
    1716:	vadd.f32	s17, s17, s15
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    171a:	bl	14e8 <project_namespace::LegSwingController::calculateRollPitchRateCapturePoint()>
    171e:	vldr	s15, [r7, #8]
    1722:	vldr	s13, [r7, #4]
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
    1726:	vcmpe.f32	s15, #0.0
    }

    // Using rp_rate_capture_point
    Eigen::Vector3f rp_rate_capture_point(0.0, 0.0, 0.0);
    rp_rate_capture_point = calculateRollPitchRateCapturePoint();
    touchdown_location(0) = touchdown_location(0) + rp_rate_capture_point(0); // Apply x-offset to all legs
    172a:	vadd.f32	s18, s18, s13
    // Apply y-offset conditionally to the legs as follows
    if ((rp_rate_capture_point[1] > 0) and (leg_index == 0 or leg_index == 2)) {
        // Robot is moving with an undesired velocity in the +ve y-direction (the robot's left)
        // Along the y-direction, move only the legs on the left of the robot to counteract this
        touchdown_location(1) = touchdown_location(1) + rp_rate_capture_point(1);
    } else if ((rp_rate_capture_point[1] < 0) and (leg_index == 1 or leg_index == 3)) {
    172e:	vmrs	APSR_nzcv, fpscr
    1732:	bpl.w	1610 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0xd0>
    1736:	b.n	16ee <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x1ae>
    Eigen::Vector3f foot_delta_p(0.0, 0.0, 0.0);
    foot_delta_p = (touchdown_location - current_foot_location_assuming_no_body_rpy)/(time_to_touchdown / Config::dt);
    foot_delta_p(2) = 0;
    float z_from_ground = 0.0;
    if (trajectory_shape == FootTrajectory::SEMICIRCULAR) {
        z_from_ground = gait_config.getSwingHeight()*sin(swing_proportion_completed*PI);
    1738:	ldr	r0, [r6, #0]
    173a:	bl	c68 <project_namespace::GaitConfig::getSwingHeight()>
    173e:	vmov.f32	s16, s0
    1742:	vldr	d0, [pc, #36]	; 1768 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x228>
    1746:	vcvt.f64.f32	d8, s16
    174a:	vmul.f64	d0, d11, d0
    174e:	bl	4418 <sin>
    1752:	vmul.f64	d0, d8, d0
    1756:	vcvt.f32.f64	s16, d0
    175a:	b.n	167e <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x13e>
    after a single tick.
    */

    Eigen::Vector3f new_foot_position(0.0, 0.0, 0.0); // Initialise

    assert(swing_proportion_completed >= 0 && swing_proportion_completed <= 1);
    175c:	ldr	r3, [pc, #24]	; (1778 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x238>)
    175e:	movs	r1, #166	; 0xa6
    1760:	ldr	r2, [pc, #24]	; (177c <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x23c>)
    1762:	ldr	r0, [pc, #28]	; (1780 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)+0x240>)
    1764:	bl	7b78 <__assert_func>
    1768:	.word	0x54442d18
    176c:	.word	0x400921fb
    1770:	.word	0x3c23d70a
    1774:	.word	0x00000000
    1778:	.word	0x200000b8
    177c:	.word	0x20000000
    1780:	.word	0x200000fc

00001784 <project_namespace::Command::Command()>:
    1784:	movs	r2, #0
    1786:	ldr	r1, [pc, #36]	; (17ac <project_namespace::Command::Command()+0x28>)
    1788:	push	{r4, r5, r6}
    178a:	ldr	r6, [pc, #36]	; (17b0 <project_namespace::Command::Command()+0x2c>)
    178c:	movs	r4, #0
    178e:	ldr	r5, [pc, #36]	; (17b4 <project_namespace::Command::Command()+0x30>)
    1790:	str	r6, [r0, #4]
    1792:	str	r5, [r0, #40]	; 0x28
    1794:	str	r4, [r0, #44]	; 0x2c
    1796:	str	r1, [r0, #0]
    1798:	str	r1, [r0, #8]
    179a:	str	r2, [r0, #12]
    179c:	str	r2, [r0, #16]
    179e:	str	r2, [r0, #20]
    17a0:	str	r2, [r0, #24]
    17a2:	str	r2, [r0, #28]
    17a4:	str	r2, [r0, #32]
    17a6:	str	r2, [r0, #36]	; 0x24
    17a8:	pop	{r4, r5, r6}
    17aa:	bx	lr
    17ac:	.word	0x3e4ccccd
    17b0:	.word	0x3db851ec
    17b4:	.word	0x3dcccccd

000017b8 <project_namespace::Command::getStancePolygonLength()>:
    17b8:	vldr	s0, [r0]
    17bc:	bx	lr
    17be:	nop

000017c0 <project_namespace::Command::getStancePolygonWidth()>:
    17c0:	vldr	s0, [r0, #4]
    17c4:	bx	lr
    17c6:	nop

000017c8 <project_namespace::Command::getStanceHeight()>:
    17c8:	vldr	s0, [r0, #8]
    17cc:	bx	lr
    17ce:	nop

000017d0 <project_namespace::Command::getBodyRoll()>:
    17d0:	vldr	s0, [r0, #12]
    17d4:	bx	lr
    17d6:	nop

000017d8 <project_namespace::Command::getBodyPitch()>:
    17d8:	vldr	s0, [r0, #16]
    17dc:	bx	lr
    17de:	nop

000017e0 <project_namespace::Command::getBodyYaw()>:
    17e0:	vldr	s0, [r0, #20]
    17e4:	bx	lr
    17e6:	nop

000017e8 <project_namespace::Command::getBodyVelocity()>:
    17e8:	adds	r1, #24
    17ea:	mov	r3, r0
    17ec:	ldmia	r1, {r0, r1, r2}
    17ee:	stmia.w	r3, {r0, r1, r2}
    17f2:	mov	r0, r3
    17f4:	bx	lr
    17f6:	nop

000017f8 <project_namespace::Command::getGaitYawSpeed()>:
    17f8:	vldr	s0, [r0, #36]	; 0x24
    17fc:	bx	lr
    17fe:	nop

00001800 <project_namespace::Command::getSwingHeight()>:
    1800:	vldr	s0, [r0, #40]	; 0x28
    1804:	bx	lr
    1806:	nop

00001808 <project_namespace::Command::getMode()>:
    1808:	ldr	r0, [r0, #44]	; 0x2c
    180a:	bx	lr

0000180c <project_namespace::Command::setBodyVelocity(Eigen::Matrix<float, 3, 1, 0, 3, 1>)>:
    180c:	ldr	r3, [r1, #0]
    180e:	str	r3, [r0, #24]
    1810:	ldr	r3, [r1, #4]
    1812:	str	r3, [r0, #28]
    1814:	ldr	r3, [r1, #8]
    1816:	str	r3, [r0, #32]
    1818:	bx	lr
    181a:	nop

0000181c <project_namespace::Command::setSwingHeight(float)>:
    181c:	vstr	s0, [r0, #40]	; 0x28
    1820:	bx	lr
    1822:	nop

00001824 <project_namespace::Command::setMode(project_namespace::Mode)>:
    1824:	str	r1, [r0, #44]	; 0x2c
    1826:	bx	lr

00001828 <project_namespace::GaitController::GaitController(project_namespace::Gait, project_namespace::FootTrajectory, project_namespace::IMU&)>:
#include "MatrixPrinter.h"

using namespace project_namespace;

// CONSTRUCTORS
GaitController::GaitController(Gait gait_init, FootTrajectory trajectory_shape_init, IMU& imu_init):
    1828:	push	{r3, r4, r5, lr}
    gait(gait_init),
    trajectory_shape(trajectory_shape_init),
    imu(imu_init),
    gait_config(GaitConfig(gait, trajectory_shape)),
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
    182a:	add.w	r5, r0, #16
#include "MatrixPrinter.h"

using namespace project_namespace;

// CONSTRUCTORS
GaitController::GaitController(Gait gait_init, FootTrajectory trajectory_shape_init, IMU& imu_init):
    182e:	mov	r4, r0
    gait(gait_init),
    trajectory_shape(trajectory_shape_init),
    imu(imu_init),
    gait_config(GaitConfig(gait, trajectory_shape)),
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
    1830:	stmia.w	r0, {r1, r2, r3}
    1834:	mov	r0, r5
    1836:	bl	b30 <project_namespace::GaitConfig::GaitConfig(project_namespace::Gait, project_namespace::FootTrajectory)>
    183a:	mov	r1, r5
    183c:	add.w	r0, r4, #144	; 0x90
    1840:	bl	168 <project_namespace::LegStanceController::LegStanceController(project_namespace::GaitConfig&)>
    1844:	mov	r1, r5
    1846:	ldr	r2, [r4, #8]
    1848:	add.w	r0, r4, #148	; 0x94
    184c:	bl	1194 <project_namespace::LegSwingController::LegSwingController(project_namespace::GaitConfig&, project_namespace::IMU&)>
{ }
    1850:	mov	r0, r4
    1852:	pop	{r3, r4, r5, pc}

00001854 <project_namespace::GaitController::calculateGaitPhaseIndex(int)>:

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    1854:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1858:	add.w	r6, r0, #16
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
{ }

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    185c:	mov	sl, r1
    185e:	add	r7, sp, #0
    1860:	sub	sp, #32
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1862:	mov	r0, r6
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1864:	movs	r4, #0
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1866:	bl	c48 <project_namespace::GaitConfig::getGaitCycleDurationInTicks()>
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
{ }

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    186a:	add.w	r9, sp, #15
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    186e:	mov	r5, r4
    leg_stance_controller(LegStanceController(gait_config)),
    leg_swing_controller(LegSwingController(gait_config, imu))
{ }

// METHODS
int GaitController::calculateGaitPhaseIndex(int ticks) {
    1870:	bic.w	r9, r9, #15
    
    RETURNS:
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    1874:	sdiv	r3, sl, r0
    1878:	mov	r8, r9
    187a:	mls	sl, r3, r0, sl
    187e:	b.n	1894 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x40>
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
    1880:	mov	r1, r6
    1882:	mov	r0, r9
    1884:	bl	c4c <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>
    1888:	ldr.w	r3, [r8], #4
    188c:	add	r5, r3
        if (ticks_into_current_gait_cycle < tick_sum) {
    188e:	cmp	sl, r5
    1890:	blt.n	18b2 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x5e>
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1892:	adds	r4, #1
    1894:	mov	r0, r6
    1896:	bl	c3c <project_namespace::GaitConfig::getGaitNumberOfPhases()>
    189a:	cmp	r4, r0
    189c:	blt.n	1880 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x2c>
    + gait_phase_index: The phase index of the current phase of the gait.
    */

    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    int gait_phase_index = 99; // Initialise with impossible value, caught by assert later
    189e:	movs	r4, #99	; 0x63
        if (ticks_into_current_gait_cycle < tick_sum) {
            gait_phase_index = i;
            break;
        }
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    18a0:	mov	r0, r6
    18a2:	bl	c3c <project_namespace::GaitConfig::getGaitNumberOfPhases()>
    18a6:	cmp	r0, r4
    18a8:	blt.n	18b6 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x62>
    return gait_phase_index;
}
    18aa:	mov	r0, r4
    18ac:	mov	sp, r7
    18ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (ticks_into_current_gait_cycle < tick_sum) {
            gait_phase_index = i;
            break;
        }
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    18b2:	cmp	r4, #0
    18b4:	bge.n	18a0 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x4c>
    18b6:	ldr	r3, [pc, #12]	; (18c4 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x70>)
    18b8:	movs	r1, #41	; 0x29
    18ba:	ldr	r2, [pc, #12]	; (18c8 <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x74>)
    18bc:	ldr	r0, [pc, #12]	; (18cc <project_namespace::GaitController::calculateGaitPhaseIndex(int)+0x78>)
    18be:	bl	7b78 <__assert_func>
    18c2:	nop
    18c4:	.word	0x200001ac
    18c8:	.word	0x20000168
    18cc:	.word	0x20000204

000018d0 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)>:
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    18d0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    18d4:	add.w	r6, r0, #16
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    18d8:	mov	r9, r1
    18da:	add	r7, sp, #0
    18dc:	sub	sp, #32
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    18de:	mov	r0, r6
    int tick_sum = 0;
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    18e0:	movs	r4, #0
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    18e2:	bl	c48 <project_namespace::GaitConfig::getGaitCycleDurationInTicks()>
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    18e6:	add.w	sl, sp, #15
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    18ea:	mov	r5, r4
    }
    assert ((gait_phase_index >= 0) && (gait_phase_index <= gait_config.getGaitNumberOfPhases()));
    return gait_phase_index;
}

int GaitController::calculateTicksIntoCurrentGaitPhase(int ticks) {
    18ec:	bic.w	sl, sl, #15
    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    18f0:	sdiv	r1, r9, r0
    18f4:	mov	r8, sl
    18f6:	mls	r9, r1, r0, r9
    18fa:	b.n	1914 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x44>
    int tick_sum = 0;
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
    18fc:	mov	r1, r6
    18fe:	mov	r0, sl
    1900:	bl	c4c <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>
    1904:	ldr.w	r3, [r8], #4
    1908:	mov.w	fp, r4, lsl #2
    190c:	add	r5, r3
        if (tick_sum > ticks_into_current_gait_cycle) {
    190e:	cmp	r9, r5
    1910:	blt.n	1934 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x64>
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    int ticks_into_current_gait_cycle = ticks % gait_config.getGaitCycleDurationInTicks();
    int tick_sum = 0;
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
    1912:	adds	r4, #1
    1914:	mov	r0, r6
    1916:	bl	c3c <project_namespace::GaitConfig::getGaitNumberOfPhases()>
    191a:	cmp	r4, r0
    191c:	blt.n	18fc <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x2c>

    RETURNS:
    + ticks_into_current_phase: The elapsed time, in ticks, from the start of the current phase of the gait.
    */

    int ticks_into_current_phase = 999; // Initialise with impossible value, caught by assert later
    191e:	movw	r5, #999	; 0x3e7
                + gait_config.getGaitPhaseDurationsInTicks()(i)
            ;
            break;
        }
    }
    assert (
    1922:	mov	r0, r6
    1924:	bl	c40 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>
    1928:	cmp	r0, r5
    192a:	blt.n	1954 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x84>
            (ticks_into_current_phase <= gait_config.getGaitStanceDurationInTicks())
            || (ticks_into_current_phase <= gait_config.getGaitSwingDurationInTicks())
        )
    );
    return ticks_into_current_phase;
}
    192c:	mov	r0, r5
    192e:	mov	sp, r7
    1930:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
        if (tick_sum > ticks_into_current_gait_cycle) {
            ticks_into_current_phase =
                ticks_into_current_gait_cycle
                - tick_sum
                + gait_config.getGaitPhaseDurationsInTicks()(i)
    1934:	mov	r1, r6
    1936:	mov	r0, sl
    1938:	bl	c4c <project_namespace::GaitConfig::getGaitPhaseDurationsInTicks()>
    for (int i = 0; i < gait_config.getGaitNumberOfPhases(); i++) {
        tick_sum += gait_config.getGaitPhaseDurationsInTicks()(i);
        if (tick_sum > ticks_into_current_gait_cycle) {
            ticks_into_current_phase =
                ticks_into_current_gait_cycle
                - tick_sum
    193c:	rsb	r5, r5, r9
                + gait_config.getGaitPhaseDurationsInTicks()(i)
            ;
    1940:	ldr.w	r3, [sl, fp]
        (ticks_into_current_phase >= 0)
        && (
            (ticks_into_current_phase <= gait_config.getGaitStanceDurationInTicks())
            || (ticks_into_current_phase <= gait_config.getGaitSwingDurationInTicks())
        )
    );
    1944:	adds	r5, r5, r3
    1946:	bpl.n	1922 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x52>
                + gait_config.getGaitPhaseDurationsInTicks()(i)
            ;
            break;
        }
    }
    assert (
    1948:	ldr	r3, [pc, #28]	; (1968 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x98>)
    194a:	movs	r1, #78	; 0x4e
    194c:	ldr	r2, [pc, #28]	; (196c <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x9c>)
    194e:	ldr	r0, [pc, #32]	; (1970 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0xa0>)
    1950:	bl	7b78 <__assert_func>
    1954:	mov	r0, r6
    1956:	bl	c44 <project_namespace::GaitConfig::getGaitSwingDurationInTicks()>
    195a:	cmp	r0, r5
    195c:	blt.n	1948 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)+0x78>
            (ticks_into_current_phase <= gait_config.getGaitStanceDurationInTicks())
            || (ticks_into_current_phase <= gait_config.getGaitSwingDurationInTicks())
        )
    );
    return ticks_into_current_phase;
}
    195e:	mov	r0, r5
    1960:	mov	sp, r7
    1962:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1966:	nop
    1968:	.word	0x2000021c
    196c:	.word	0x20000118
    1970:	.word	0x20000204

00001974 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)>:

int GaitController::calculateTicksIntoCurrentLegPhase(int ticks, int leg_index) {
    1974:	push	{r3, r4, r5, r6, r7, lr}
    1976:	mov	r5, r0
    1978:	mov	r4, r1
    197a:	mov	r6, r2
    RETURNS:
    + ticks_into_current_leg_phase: The number of ticks into the leg's own phase (NOT GAIT PHASE!!!).
    */
    int ticks_into_current_leg_phase = 999; // Initialise with impossible value, caught by assert later

    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    197c:	bl	1854 <project_namespace::GaitController::calculateGaitPhaseIndex(int)>
    int ticks_into_current_gait_phase = calculateTicksIntoCurrentGaitPhase(ticks);
    1980:	mov	r1, r4
    RETURNS:
    + ticks_into_current_leg_phase: The number of ticks into the leg's own phase (NOT GAIT PHASE!!!).
    */
    int ticks_into_current_leg_phase = 999; // Initialise with impossible value, caught by assert later

    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1982:	mov	r7, r0
    int ticks_into_current_gait_phase = calculateTicksIntoCurrentGaitPhase(ticks);
    1984:	mov	r0, r5
    1986:	bl	18d0 <project_namespace::GaitController::calculateTicksIntoCurrentGaitPhase(int)>
    if (gait == Gait::TROT) {
    198a:	ldr	r3, [r5, #0]
    198c:	cbz	r3, 19a2 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x2e>
    198e:	movw	r4, #999	; 0x3e7
                // BR is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            }
        }
    }
    assert(
    1992:	add.w	r0, r5, #16
    1996:	bl	c60 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
    199a:	cmp	r0, r4
    199c:	blt.n	19b8 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x44>
        (ticks_into_current_leg_phase >= 0)
        && (ticks_into_current_leg_phase <= gait_config.getLegStanceDurationInTicks())
    ); // leg stance duration is always longer than swing stance duration

    return ticks_into_current_leg_phase;
}
    199e:	mov	r0, r4
    19a0:	pop	{r3, r4, r5, r6, r7, pc}
    19a2:	mov	r4, r0
    int ticks_into_current_leg_phase = 999; // Initialise with impossible value, caught by assert later

    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    int ticks_into_current_gait_phase = calculateTicksIntoCurrentGaitPhase(ticks);
    if (gait == Gait::TROT) {
        if (leg_index == 0) {
    19a4:	cbnz	r6, 19c4 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x50>
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 3) {
            // Back-right leg
            if (current_gait_phase_index == 0) {
    19a6:	cbz	r7, 19b4 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
                // BR is just starting its leg stance phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 1) {
    19a8:	cmp	r7, #1
    19aa:	beq.n	19de <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x6a>
                // BR is in the middle of its leg stance phase
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            } else if (current_gait_phase_index == 2) {
    19ac:	cmp	r7, #2
    19ae:	beq.n	19ea <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x76>
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + gait_config.getGaitSwingDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            } else if (current_gait_phase_index == 3) {
    19b0:	cmp	r7, #3
    19b2:	bne.n	198e <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1a>
        }
    }
    assert(
        (ticks_into_current_leg_phase >= 0)
        && (ticks_into_current_leg_phase <= gait_config.getLegStanceDurationInTicks())
    ); // leg stance duration is always longer than swing stance duration
    19b4:	cmp	r4, #0
    19b6:	bge.n	1992 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1e>
                // BR is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            }
        }
    }
    assert(
    19b8:	ldr	r3, [pc, #72]	; (1a04 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x90>)
    19ba:	movs	r1, #193	; 0xc1
    19bc:	ldr	r2, [pc, #72]	; (1a08 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x94>)
    19be:	ldr	r0, [pc, #76]	; (1a0c <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x98>)
    19c0:	bl	7b78 <__assert_func>
                ;
            } else if (current_gait_phase_index == 3) {
                // FL is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            }
        } else if (leg_index == 1) {
    19c4:	cmp	r6, #1
    19c6:	beq.n	19d2 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x5e>
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 2) {
    19c8:	cmp	r6, #2
    19ca:	beq.n	19d2 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x5e>
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 3) {
    19cc:	cmp	r6, #3
    19ce:	bne.n	198e <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1a>
    19d0:	b.n	19a6 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x32>
                    + ticks_into_current_gait_phase
                ;
            }
        } else if (leg_index == 2) {
            // Back-left leg
            if (current_gait_phase_index == 0) {
    19d2:	cbz	r7, 19ea <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x76>
                    + ticks_into_current_gait_phase
                ;
            } else if (current_gait_phase_index == 1) {
                // BL is in its swing phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 2) {
    19d4:	subs	r3, r7, #1
    19d6:	cmp	r3, #1
    19d8:	bls.n	19b4 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
                // BL is just starting its leg stance phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 3) {
    19da:	cmp	r7, #3
    19dc:	bne.n	198e <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x1a>
                // BR is just starting its leg stance phase
                ticks_into_current_leg_phase = ticks_into_current_gait_phase;
            } else if (current_gait_phase_index == 1) {
                // BR is in the middle of its leg stance phase
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
    19de:	add.w	r0, r5, #16
    19e2:	bl	c40 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>
                    + ticks_into_current_gait_phase
                ;
    19e6:	add	r4, r0
    19e8:	b.n	19b4 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
            } else if (current_gait_phase_index == 2) {
                // BR is approaching end of its leg stance phase
                ticks_into_current_leg_phase =
                    gait_config.getGaitStanceDurationInTicks()
    19ea:	add.w	r7, r5, #16
    19ee:	mov	r0, r7
    19f0:	bl	c40 <project_namespace::GaitConfig::getGaitStanceDurationInTicks()>
    19f4:	mov	r6, r0
                    + gait_config.getGaitSwingDurationInTicks()
    19f6:	mov	r0, r7
    19f8:	bl	c44 <project_namespace::GaitConfig::getGaitSwingDurationInTicks()>
                    + ticks_into_current_gait_phase
                ;
    19fc:	add	r0, r6
    19fe:	add	r4, r0
    1a00:	b.n	19b4 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)+0x40>
    1a02:	nop
    1a04:	.word	0x200002d8
    1a08:	.word	0x2000034c
    1a0c:	.word	0x20000204

00001a10 <project_namespace::GaitController::calculateContactPattern(int)>:
    ); // leg stance duration is always longer than swing stance duration

    return ticks_into_current_leg_phase;
}

Eigen::Vector4i GaitController::calculateContactPattern(int ticks) {
    1a10:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1a14:	add	r7, sp, #0
    1a16:	sub	sp, #80	; 0x50
    1a18:	mov	r8, r1
    1a1a:	mov	r4, r0
    1a1c:	add.w	r5, sp, #15
    RETURNS:
    + contact_pattern: The contact pattern of the legs at the time given in ticks.
    0 = swing, 1 = stance, [FL, FR, BL, BR].
    */
    
    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1a20:	mov	r1, r2
    1a22:	mov	r0, r8
    1a24:	bl	1854 <project_namespace::GaitController::calculateGaitPhaseIndex(int)>
    ); // leg stance duration is always longer than swing stance duration

    return ticks_into_current_leg_phase;
}

Eigen::Vector4i GaitController::calculateContactPattern(int ticks) {
    1a28:	bic.w	r5, r5, #15
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
      m_storage.data()[0] = x;
    1a2c:	movs	r3, #0
    RETURNS:
    + contact_pattern: The contact pattern of the legs at the time given in ticks.
    0 = swing, 1 = stance, [FL, FR, BL, BR].
    */
    
    int current_gait_phase_index = calculateGaitPhaseIndex(ticks);
    1a2e:	mov	r6, r0
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);
    1a30:	add.w	r1, r8, #16
    1a34:	mov	r0, r5
    1a36:	str	r3, [r4, #0]
      m_storage.data()[1] = y;
    1a38:	str	r3, [r4, #4]
      m_storage.data()[2] = z;
    1a3a:	str	r3, [r4, #8]
      m_storage.data()[3] = w;
    1a3c:	str	r3, [r4, #12]
    1a3e:	bl	c18 <project_namespace::GaitConfig::getContactSchedule()>

    return contact_pattern;
}
    1a42:	mov	r0, r4
    1a44:	lsls	r3, r6, #4
    1a46:	adds	r2, r5, r3
    1a48:	ldr	r6, [r5, r3]
    1a4a:	ldr	r1, [r2, #8]
    1a4c:	ldr	r5, [r2, #4]
    1a4e:	ldr	r3, [r2, #12]
    1a50:	str	r6, [r4, #0]
    1a52:	str	r5, [r4, #4]
    1a54:	str	r1, [r4, #8]
    1a56:	str	r3, [r4, #12]
    1a58:	mov	sp, r7
    1a5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1a5e:	nop

00001a60 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)>:

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1a60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1a64:	vpush	{d8}
    1a68:	sub	sp, #52	; 0x34
    1a6a:	mov	r8, r1
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1a6c:	adds	r1, #16
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);

    return contact_pattern;
}

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1a6e:	mov	sl, r3
    1a70:	add	r7, sp, #8
    1a72:	sub	sp, #48	; 0x30
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1a74:	mov	r4, r1
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);

    return contact_pattern;
}

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1a76:	str	r0, [r7, #12]
    1a78:	mov	r5, r0
    1a7a:	add.w	r3, sp, #23
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1a7e:	mov	r0, sl
    1a80:	str	r1, [r7, #20]
    contact_pattern = gait_config.getContactSchedule().col(current_gait_phase_index);

    return contact_pattern;
}

Eigen::Matrix<float, 3, 4> GaitController::calculateAllNewFootPositions(Robot& robot, Command& command, int ticks) {
    1a82:	bic.w	fp, r3, #15
    1a86:	str	r2, [r7, #8]
    */

    Eigen::Matrix<float, 3, 4> new_foot_positions_wrt_body; // Initialise

    // Update swing_height in gait_config from command
    gait_config.setSwingHeight(command.getSwingHeight());
    1a88:	bl	1800 <project_namespace::Command::getSwingHeight()>
    1a8c:	mov	r0, r4
    1a8e:	bl	c70 <project_namespace::GaitConfig::setSwingHeight(float)>
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);
    1a92:	mov	r0, fp
    1a94:	ldr	r2, [r7, #88]	; 0x58
    1a96:	mov	r1, r8
    1a98:	bl	1a10 <project_namespace::GaitController::calculateContactPattern(int)>
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
    1a9c:	ldr.w	r2, [fp, #12]
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1aa0:	add.w	r3, r8, #144	; 0x90
    1aa4:	ldr.w	r0, [fp, #4]
    1aa8:	ldr.w	r1, [fp, #8]
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1aac:	add.w	r4, r8, #148	; 0x94
    1ab0:	str.w	r2, [fp, #28]
    EIGEN_DEVICE_FUNC
    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
    {
      Base::_check_template_params();
      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
      m_storage.data()[0] = x;
    1ab4:	movs	r2, #0
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1ab6:	str	r3, [r7, #4]
    1ab8:	add.w	r9, fp, #16
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
    1abc:	ldr.w	r3, [fp]
    1ac0:	mov	r6, fp
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1ac2:	str	r4, [r7, #16]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1ac4:	movs	r4, #0
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
    1ac6:	str.w	r0, [fp, #20]
    1aca:	str.w	r1, [fp, #24]
    1ace:	str.w	r3, [fp, #16]
    1ad2:	str.w	r2, [fp]
      m_storage.data()[1] = y;
    1ad6:	str.w	r2, [fp, #4]
      m_storage.data()[2] = z;
    1ada:	str.w	r2, [fp, #8]
      m_storage.data()[3] = w;
    1ade:	str.w	r2, [fp, #12]
    1ae2:	ldr.w	fp, [r7, #8]
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
    1ae6:	cbz	r3, 1afe <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x9e>
                    leg_swing_proportion_completed,
                    trajectory_shape
                )
            ;
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
    1ae8:	cmp	r3, #1
    1aea:	beq.n	1b6a <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x10a>
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1aec:	adds	r4, #1
    1aee:	adds	r5, #12
    1af0:	adds	r6, #4
    1af2:	cmp	r4, #4
    1af4:	beq.n	1b5c <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0xfc>
    1af6:	ldr.w	r3, [r9, #4]!
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
    1afa:	cmp	r3, #0
    1afc:	bne.n	1ae8 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x88>
            // Leg is in swing phase
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
    1afe:	mov	r2, r4
    1b00:	ldr	r1, [r7, #88]	; 0x58
    1b02:	mov	r0, r8
    1b04:	adds	r5, #12
    1b06:	bl	1974 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)>
    1b0a:	vmov	s16, r0
                / float(gait_config.getLegSwingDurationInTicks())
    1b0e:	ldr	r0, [r7, #20]
    1b10:	adds	r6, #4
    1b12:	bl	c64 <project_namespace::GaitConfig::getLegSwingDurationInTicks()>
    1b16:	vmov	s15, r0
    1b1a:	vcvt.f32.s32	s16, s16
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1b1e:	ldr.w	r2, [r8, #4]
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
            // Leg is in swing phase
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
    1b22:	vcvt.f32.s32	s15, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1b26:	str	r4, [sp, #0]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1b28:	adds	r4, #1
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1b2a:	mov	r3, sl
    1b2c:	str	r2, [sp, #4]
    1b2e:	add.w	r0, r7, #28
        int leg_phase = contact_pattern(leg_index); // 0 = swing, 1 = stance
        if (leg_phase == 0) {
            // Leg is in swing phase
            float leg_swing_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegSwingDurationInTicks())
    1b32:	vdiv.f32	s17, s16, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_swing_controller.calculateNewFootPosition(
    1b36:	mov	r2, fp
    1b38:	ldr	r1, [r7, #16]
    1b3a:	vmov.f32	s0, s17
    1b3e:	bl	1540 <project_namespace::LegSwingController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int, float, project_namespace::FootTrajectory)>
    1b42:	ldr	r1, [r7, #28]
    1b44:	ldr	r2, [r7, #32]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1b46:	cmp	r4, #4
    1b48:	ldr	r3, [r7, #36]	; 0x24
                    leg_index,
                    leg_swing_proportion_completed,
                    trajectory_shape
                )
            ;
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
    1b4a:	vstr	s17, [r6, #-4]
    1b4e:	str.w	r1, [r5, #-12]
    1b52:	str.w	r2, [r5, #-8]
    1b56:	str.w	r3, [r5, #-4]
    // Find phases of each leg (swing or stance)
    Eigen::Vector4i contact_pattern(0, 0, 0, 0);
    contact_pattern = calculateContactPattern(ticks);

    Eigen::Vector4f foot_phase_proportions_completed(0.0, 0.0, 0.0, 0.0);
    for (int leg_index = 0; leg_index < 4; leg_index++) {
    1b5a:	bne.n	1af6 <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x96>
            foot_phase_proportions_completed(leg_index) = leg_stance_proportion_completed;
        }
    }

    return new_foot_positions_wrt_body;
    1b5c:	ldr	r0, [r7, #12]
    1b5e:	adds	r7, #44	; 0x2c
    1b60:	mov	sp, r7
    1b62:	vpop	{d8}
    1b66:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ;
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
            // Leg is in stance phase
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
    1b6a:	mov	r2, r4
    1b6c:	ldr	r1, [r7, #88]	; 0x58
    1b6e:	mov	r0, r8
    1b70:	bl	1974 <project_namespace::GaitController::calculateTicksIntoCurrentLegPhase(int, int)>
    1b74:	vmov	s16, r0
                / float(gait_config.getLegStanceDurationInTicks())
    1b78:	ldr	r0, [r7, #20]
    1b7a:	bl	c60 <project_namespace::GaitConfig::getLegStanceDurationInTicks()>
    1b7e:	vmov	s15, r0
    1b82:	vcvt.f32.s32	s16, s16
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1b86:	mov	r3, sl
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
            // Leg is in stance phase
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
    1b88:	vcvt.f32.s32	s15, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1b8c:	mov	r2, fp
    1b8e:	ldr	r1, [r7, #4]
    1b90:	add.w	r0, r7, #28
    1b94:	str	r4, [sp, #0]
            foot_phase_proportions_completed(leg_index) = leg_swing_proportion_completed;
        } else if (leg_phase == 1) {
            // Leg is in stance phase
            float leg_stance_proportion_completed =
                float(calculateTicksIntoCurrentLegPhase(ticks, leg_index))
                / float(gait_config.getLegStanceDurationInTicks())
    1b96:	vdiv.f32	s17, s16, s15
            ;
            new_foot_positions_wrt_body.col(leg_index) =
                leg_stance_controller.calculateNewFootPosition(robot, command, leg_index)
    1b9a:	bl	16c <project_namespace::LegStanceController::calculateNewFootPosition(project_namespace::Robot&, project_namespace::Command&, int)>
    1b9e:	ldr	r1, [r7, #28]
    1ba0:	ldr	r2, [r7, #32]
    1ba2:	ldr	r3, [r7, #36]	; 0x24
    1ba4:	str	r1, [r5, #0]
    1ba6:	str	r2, [r5, #4]
    1ba8:	str	r3, [r5, #8]
            ;
            foot_phase_proportions_completed(leg_index) = leg_stance_proportion_completed;
    1baa:	vstr	s17, [r6]
    1bae:	b.n	1aec <project_namespace::GaitController::calculateAllNewFootPositions(project_namespace::Robot&, project_namespace::Command&, int)+0x8c>

00001bb0 <TwoWire::available()>:
    1bb0:	ldrb.w	r2, [r0, #59]	; 0x3b
    1bb4:	ldrb.w	r0, [r0, #58]	; 0x3a
    1bb8:	subs	r0, r2, r0
    1bba:	bx	lr

00001bbc <TwoWire::read()>:
    1bbc:	ldrb.w	r3, [r0, #58]	; 0x3a
    1bc0:	ldrb.w	r2, [r0, #59]	; 0x3b
    1bc4:	cmp	r2, r3
    1bc6:	bls.n	1bd4 <TwoWire::read()+0x18>
    1bc8:	adds	r2, r3, #1
    1bca:	add	r3, r0
    1bcc:	strb.w	r2, [r0, #58]	; 0x3a
    1bd0:	ldrb	r0, [r3, #26]
    1bd2:	bx	lr
    1bd4:	mov.w	r0, #4294967295
    1bd8:	bx	lr
    1bda:	nop

00001bdc <BNO080::printHeader() [clone .part.7]>:
    1bdc:	push	{r4, r5, r6, lr}
    1bde:	mov	r4, r0
    1be0:	ldr.w	r0, [r0, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1be4:	movs	r2, #7
    1be6:	ldr	r1, [pc, #80]	; (1c38 <BNO080::printHeader() [clone .part.7]+0x5c>)
    1be8:	ldr	r3, [r0, #0]
    1bea:	subs	r5, r4, #1
    1bec:	adds	r6, r4, #3
    1bee:	ldr	r3, [r3, #4]
    1bf0:	blx	r3
    1bf2:	ldr.w	r0, [r4, #184]	; 0xb8
    1bf6:	movs	r2, #1
    1bf8:	ldr	r1, [pc, #64]	; (1c3c <BNO080::printHeader() [clone .part.7]+0x60>)
    1bfa:	ldr	r3, [r0, #0]
    1bfc:	ldr	r3, [r3, #4]
    1bfe:	blx	r3
    1c00:	ldrb.w	r1, [r5, #1]!
    1c04:	cmp	r1, #15
    1c06:	bls.n	1c24 <BNO080::printHeader() [clone .part.7]+0x48>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1c08:	movs	r3, #0
    1c0a:	movs	r2, #16
    1c0c:	ldr.w	r0, [r4, #184]	; 0xb8
    1c10:	bl	4034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c14:	cmp	r5, r6
    1c16:	bne.n	1bf2 <BNO080::printHeader() [clone .part.7]+0x16>
    1c18:	ldr.w	r0, [r4, #184]	; 0xb8
    1c1c:	ldmia.w	sp!, {r4, r5, r6, lr}
    1c20:	b.w	4004 <Print::println()>
    1c24:	ldr.w	r0, [r4, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1c28:	movs	r2, #1
    1c2a:	ldr	r1, [pc, #20]	; (1c40 <BNO080::printHeader() [clone .part.7]+0x64>)
    1c2c:	ldr	r3, [r0, #0]
    1c2e:	ldr	r3, [r3, #4]
    1c30:	blx	r3
    1c32:	ldrb	r1, [r5, #0]
    1c34:	b.n	1c08 <BNO080::printHeader() [clone .part.7]+0x2c>
    1c36:	nop
    1c38:	.word	0x200003b0
    1c3c:	.word	0x200003b8
    1c40:	.word	0x200003bc

00001c44 <BNO080::printPacket() [clone .part.6]>:
    1c44:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1c48:	ldrb	r3, [r0, #0]
    1c4a:	mov	r5, r0
    1c4c:	ldrb	r7, [r0, #1]
    1c4e:	subs	r6, r0, #1
    1c50:	ldr.w	r0, [r0, #184]	; 0xb8
    1c54:	movs	r2, #7
    1c56:	orr.w	r7, r3, r7, lsl #8
    1c5a:	ldr	r1, [pc, #408]	; (1df4 <BNO080::printPacket() [clone .part.6]+0x1b0>)
    1c5c:	ldr	r3, [r0, #0]
    1c5e:	adds	r4, r5, #3
    1c60:	sxth	r7, r7
    1c62:	ldr	r3, [r3, #4]
    1c64:	uxth.w	r8, r7
    1c68:	blx	r3
    1c6a:	ldr.w	r0, [r5, #184]	; 0xb8
    1c6e:	movs	r2, #1
    1c70:	ldr	r1, [pc, #388]	; (1df8 <BNO080::printPacket() [clone .part.6]+0x1b4>)
    1c72:	ldr	r3, [r0, #0]
    1c74:	ldr	r3, [r3, #4]
    1c76:	blx	r3
    1c78:	ldrb.w	r1, [r6, #1]!
    1c7c:	cmp	r1, #15
    1c7e:	bls.n	1cec <BNO080::printPacket() [clone .part.6]+0xa8>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1c80:	movs	r3, #0
    1c82:	movs	r2, #16
    1c84:	ldr.w	r0, [r5, #184]	; 0xb8
    1c88:	bl	4034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c8c:	cmp	r4, r6
    1c8e:	bne.n	1c6a <BNO080::printPacket() [clone .part.6]+0x26>
    1c90:	subs	r6, r7, #4
    1c92:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1c96:	movs	r2, #6
    1c98:	ldr	r1, [pc, #352]	; (1dfc <BNO080::printPacket() [clone .part.6]+0x1b8>)
    1c9a:	uxtb	r6, r6
    1c9c:	ldr	r3, [r0, #0]
    1c9e:	cmp	r6, #40	; 0x28
    1ca0:	ldr	r3, [r3, #4]
    1ca2:	it	cs
    1ca4:	movcs	r6, #40	; 0x28
    1ca6:	blx	r3
    1ca8:	cbz	r6, 1cfe <BNO080::printPacket() [clone .part.6]+0xba>
    1caa:	subs	r6, #1
    1cac:	uxtb	r6, r6
    1cae:	adds	r6, #4
    1cb0:	add	r6, r5
    1cb2:	b.n	1cc4 <BNO080::printPacket() [clone .part.6]+0x80>
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1cb4:	movs	r3, #0
    1cb6:	movs	r2, #16
    1cb8:	ldr.w	r0, [r5, #184]	; 0xb8
    1cbc:	bl	4034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cc0:	cmp	r6, r4
    1cc2:	beq.n	1cfe <BNO080::printPacket() [clone .part.6]+0xba>
    1cc4:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1cc8:	movs	r2, #1
    1cca:	ldr	r1, [pc, #300]	; (1df8 <BNO080::printPacket() [clone .part.6]+0x1b4>)
    1ccc:	ldr	r3, [r0, #0]
    1cce:	ldr	r3, [r3, #4]
    1cd0:	blx	r3
    1cd2:	ldrb.w	r1, [r4, #1]!
    1cd6:	cmp	r1, #15
    1cd8:	bhi.n	1cb4 <BNO080::printPacket() [clone .part.6]+0x70>
    1cda:	ldr.w	r0, [r5, #184]	; 0xb8
    1cde:	movs	r2, #1
    1ce0:	ldr	r1, [pc, #284]	; (1e00 <BNO080::printPacket() [clone .part.6]+0x1bc>)
    1ce2:	ldr	r3, [r0, #0]
    1ce4:	ldr	r3, [r3, #4]
    1ce6:	blx	r3
    1ce8:	ldrb	r1, [r4, #0]
    1cea:	b.n	1cb4 <BNO080::printPacket() [clone .part.6]+0x70>
    1cec:	ldr.w	r0, [r5, #184]	; 0xb8
    1cf0:	movs	r2, #1
    1cf2:	ldr	r1, [pc, #268]	; (1e00 <BNO080::printPacket() [clone .part.6]+0x1bc>)
    1cf4:	ldr	r3, [r0, #0]
    1cf6:	ldr	r3, [r3, #4]
    1cf8:	blx	r3
    1cfa:	ldrb	r1, [r6, #0]
    1cfc:	b.n	1c80 <BNO080::printPacket() [clone .part.6]+0x3c>
    1cfe:	cmp	r7, #0
    1d00:	blt.n	1d82 <BNO080::printPacket() [clone .part.6]+0x13e>
    1d02:	ldr.w	r0, [r5, #184]	; 0xb8
    1d06:	movs	r2, #8
    1d08:	ldr	r1, [pc, #248]	; (1e04 <BNO080::printPacket() [clone .part.6]+0x1c0>)
    1d0a:	ldr	r3, [r0, #0]
    1d0c:	ldr	r3, [r3, #4]
    1d0e:	blx	r3
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1d10:	mov	r1, r8
    1d12:	ldr.w	r0, [r5, #184]	; 0xb8
    1d16:	bl	40b4 <Print::print(long)>
    1d1a:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1d1e:	ldr	r1, [pc, #232]	; (1e08 <BNO080::printPacket() [clone .part.6]+0x1c4>)
    1d20:	movs	r2, #9
    1d22:	ldr	r3, [r0, #0]
    1d24:	ldr	r3, [r3, #4]
    1d26:	blx	r3
    1d28:	ldrb	r1, [r5, #2]
    1d2a:	cbz	r1, 1d58 <BNO080::printPacket() [clone .part.6]+0x114>
    1d2c:	cmp	r1, #1
    1d2e:	beq.n	1db8 <BNO080::printPacket() [clone .part.6]+0x174>
    1d30:	cmp	r1, #2
    1d32:	beq.n	1dd2 <BNO080::printPacket() [clone .part.6]+0x18e>
    1d34:	cmp	r1, #3
    1d36:	beq.n	1d72 <BNO080::printPacket() [clone .part.6]+0x12e>
    1d38:	cmp	r1, #4
    1d3a:	beq.n	1de2 <BNO080::printPacket() [clone .part.6]+0x19e>
    1d3c:	cmp	r1, #5
    1d3e:	beq.n	1d9e <BNO080::printPacket() [clone .part.6]+0x15a>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d40:	movs	r3, #0
    1d42:	movs	r2, #10
    1d44:	ldr.w	r0, [r5, #184]	; 0xb8
    1d48:	bl	4034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d4c:	ldr.w	r0, [r5, #184]	; 0xb8
    1d50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    1d54:	b.w	4004 <Print::println()>
    1d58:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1d5c:	movs	r2, #7
    1d5e:	ldr	r1, [pc, #172]	; (1e0c <BNO080::printPacket() [clone .part.6]+0x1c8>)
    1d60:	ldr	r3, [r0, #0]
    1d62:	ldr	r3, [r3, #4]
    1d64:	blx	r3
    1d66:	ldr.w	r0, [r5, #184]	; 0xb8
    1d6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    1d6e:	b.w	4004 <Print::println()>
    1d72:	ldr.w	r0, [r5, #184]	; 0xb8
    1d76:	movs	r2, #13
    1d78:	ldr	r1, [pc, #148]	; (1e10 <BNO080::printPacket() [clone .part.6]+0x1cc>)
    1d7a:	ldr	r3, [r0, #0]
    1d7c:	ldr	r3, [r3, #4]
    1d7e:	blx	r3
    1d80:	b.n	1d4c <BNO080::printPacket() [clone .part.6]+0x108>
    1d82:	ldr.w	r4, [r5, #184]	; 0xb8
    1d86:	movs	r2, #20
    1d88:	ldr	r1, [pc, #136]	; (1e14 <BNO080::printPacket() [clone .part.6]+0x1d0>)
    1d8a:	ubfx	r8, r8, #0, #15
    1d8e:	ldr	r3, [r4, #0]
    1d90:	mov	r0, r4
    1d92:	ldr	r3, [r3, #4]
    1d94:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    1d96:	mov	r0, r4
    1d98:	bl	4004 <Print::println()>
    1d9c:	b.n	1d02 <BNO080::printPacket() [clone .part.6]+0xbe>
    1d9e:	ldr.w	r0, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    1da2:	movs	r2, #11
    1da4:	ldr	r1, [pc, #112]	; (1e18 <BNO080::printPacket() [clone .part.6]+0x1d4>)
    1da6:	ldr	r3, [r0, #0]
    1da8:	ldr	r3, [r3, #4]
    1daa:	blx	r3
    1dac:	ldr.w	r0, [r5, #184]	; 0xb8
    1db0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    1db4:	b.w	4004 <Print::println()>
    1db8:	ldr.w	r0, [r5, #184]	; 0xb8
    1dbc:	movs	r2, #10
    1dbe:	ldr	r1, [pc, #92]	; (1e1c <BNO080::printPacket() [clone .part.6]+0x1d8>)
    1dc0:	ldr	r3, [r0, #0]
    1dc2:	ldr	r3, [r3, #4]
    1dc4:	blx	r3
    1dc6:	ldr.w	r0, [r5, #184]	; 0xb8
    1dca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    1dce:	b.w	4004 <Print::println()>
    1dd2:	ldr.w	r0, [r5, #184]	; 0xb8
    1dd6:	movs	r2, #7
    1dd8:	ldr	r1, [pc, #68]	; (1e20 <BNO080::printPacket() [clone .part.6]+0x1dc>)
    1dda:	ldr	r3, [r0, #0]
    1ddc:	ldr	r3, [r3, #4]
    1dde:	blx	r3
    1de0:	b.n	1d4c <BNO080::printPacket() [clone .part.6]+0x108>
    1de2:	ldr.w	r0, [r5, #184]	; 0xb8
    1de6:	movs	r2, #11
    1de8:	ldr	r1, [pc, #56]	; (1e24 <BNO080::printPacket() [clone .part.6]+0x1e0>)
    1dea:	ldr	r3, [r0, #0]
    1dec:	ldr	r3, [r3, #4]
    1dee:	blx	r3
    1df0:	b.n	1d4c <BNO080::printPacket() [clone .part.6]+0x108>
    1df2:	nop
    1df4:	.word	0x200003b0
    1df8:	.word	0x200003b8
    1dfc:	.word	0x200003c0
    1e00:	.word	0x200003bc
    1e04:	.word	0x200003e0
    1e08:	.word	0x200003ec
    1e0c:	.word	0x200003f8
    1e10:	.word	0x20000414
    1e14:	.word	0x200003c8
    1e18:	.word	0x20000430
    1e1c:	.word	0x20000400
    1e20:	.word	0x2000040c
    1e24:	.word	0x20000424

00001e28 <BNO080::parseInputReport()>:
    1e28:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1e2c:	ldrb	r2, [r0, #1]
    1e2e:	ldrb	r3, [r0, #0]
    1e30:	ldr.w	r1, [r0, #5]
    1e34:	orr.w	r3, r3, r2, lsl #8
    1e38:	ldrb	r2, [r0, #2]
    1e3a:	str.w	r1, [r0, #256]	; 0x100
    1e3e:	cmp	r2, #5
    1e40:	ubfx	r3, r3, #0, #15
    1e44:	ldrb	r1, [r0, #8]
    1e46:	ldrb	r6, [r0, #7]
    1e48:	ldrb	r5, [r0, #6]
    1e4a:	ldrb	r4, [r0, #5]
    1e4c:	beq.n	1f1a <BNO080::parseInputReport()+0xf2>
    1e4e:	subs	r3, #4
    1e50:	ldrb.w	lr, [r0, #11]
    1e54:	ldrb	r6, [r0, #14]
    1e56:	sxth	r3, r3
    1e58:	ldrb	r7, [r0, #13]
    1e5a:	ldrb	r5, [r0, #15]
    1e5c:	and.w	r8, lr, #3
    1e60:	ldrb	r4, [r0, #16]
    1e62:	cmp	r3, #14
    1e64:	ldrb.w	r9, [r0, #18]
    1e68:	orr.w	ip, r7, r6, lsl #8
    1e6c:	ldrb	r2, [r0, #17]
    1e6e:	orr.w	r4, r5, r4, lsl #8
    1e72:	orr.w	r9, r2, r9, lsl #8
    1e76:	bgt.n	1ece <BNO080::parseInputReport()+0xa6>
    1e78:	movs	r2, #0
    1e7a:	mov	r1, r2
    1e7c:	ldrb	r3, [r0, #9]
    1e7e:	cmp	r3, #1
    1e80:	beq.n	1eea <BNO080::parseInputReport()+0xc2>
    1e82:	cmp	r3, #4
    1e84:	beq.n	1f6e <BNO080::parseInputReport()+0x146>
    1e86:	cmp	r3, #2
    1e88:	beq.n	1f82 <BNO080::parseInputReport()+0x15a>
    1e8a:	cmp	r3, #3
    1e8c:	beq.w	1f96 <BNO080::parseInputReport()+0x16e>
    1e90:	cmp	r3, #8
    1e92:	it	ne
    1e94:	cmpne	r3, #5
    1e96:	beq.n	1efe <BNO080::parseInputReport()+0xd6>
    1e98:	sub.w	sl, r3, #40	; 0x28
    1e9c:	cmp.w	sl, #1
    1ea0:	bls.n	1efe <BNO080::parseInputReport()+0xd6>
    1ea2:	cmp	r3, #17
    1ea4:	beq.w	1faa <BNO080::parseInputReport()+0x182>
    1ea8:	cmp	r3, #19
    1eaa:	beq.w	1fe8 <BNO080::parseInputReport()+0x1c0>
    1eae:	cmp	r3, #30
    1eb0:	beq.w	1fc2 <BNO080::parseInputReport()+0x19a>
    1eb4:	cmp	r3, #20
    1eb6:	beq.w	1ff0 <BNO080::parseInputReport()+0x1c8>
    1eba:	cmp	r3, #21
    1ebc:	beq.w	2018 <BNO080::parseInputReport()+0x1f0>
    1ec0:	cmp	r3, #22
    1ec2:	beq.n	1fb2 <BNO080::parseInputReport()+0x18a>
    1ec4:	cmp	r3, #241	; 0xf1
    1ec6:	beq.w	2000 <BNO080::parseInputReport()+0x1d8>
    1eca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1ece:	ldrb	r1, [r0, #20]
    1ed0:	cmp	r3, #16
    1ed2:	ldrb	r2, [r0, #19]
    1ed4:	orr.w	r2, r2, r1, lsl #8
    1ed8:	ble.w	2066 <BNO080::parseInputReport()+0x23e>
    1edc:	ldrb	r3, [r0, #21]
    1ede:	ldrb	r1, [r0, #22]
    1ee0:	orr.w	r1, r3, r1, lsl #8
    1ee4:	ldrb	r3, [r0, #9]
    1ee6:	cmp	r3, #1
    1ee8:	bne.n	1e82 <BNO080::parseInputReport()+0x5a>
    1eea:	strh.w	r8, [r0, #210]	; 0xd2
    1eee:	strh.w	ip, [r0, #204]	; 0xcc
    1ef2:	strh.w	r4, [r0, #206]	; 0xce
    1ef6:	strh.w	r9, [r0, #208]	; 0xd0
    1efa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1efe:	strh.w	r8, [r0, #246]	; 0xf6
    1f02:	strh.w	ip, [r0, #236]	; 0xec
    1f06:	strh.w	r4, [r0, #238]	; 0xee
    1f0a:	strh.w	r9, [r0, #240]	; 0xf0
    1f0e:	strh.w	r2, [r0, #242]	; 0xf2
    1f12:	strh.w	r1, [r0, #244]	; 0xf4
    1f16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f1a:	ldrb	r2, [r0, #4]
    1f1c:	orr.w	r5, r5, r6, lsl #8
    1f20:	ldrb	r3, [r0, #9]
    1f22:	orr.w	r4, r2, r4, lsl #8
    1f26:	ldrb	r7, [r0, #11]
    1f28:	ldrb	r2, [r0, #10]
    1f2a:	orr.w	r1, r1, r3, lsl #8
    1f2e:	ldrb	r6, [r0, #13]
    1f30:	ldrb	r3, [r0, #12]
    1f32:	orr.w	r7, r2, r7, lsl #8
    1f36:	ldrb.w	ip, [r0, #15]
    1f3a:	orr.w	r6, r3, r6, lsl #8
    1f3e:	ldrb	r2, [r0, #14]
    1f40:	ldrb.w	lr, [r0, #17]
    1f44:	ldrb	r3, [r0, #16]
    1f46:	orr.w	r2, r2, ip, lsl #8
    1f4a:	strh.w	r5, [r0, #238]	; 0xee
    1f4e:	orr.w	r3, r3, lr, lsl #8
    1f52:	strh.w	r4, [r0, #236]	; 0xec
    1f56:	strh.w	r1, [r0, #240]	; 0xf0
    1f5a:	strh.w	r7, [r0, #242]	; 0xf2
    1f5e:	strh.w	r6, [r0, #248]	; 0xf8
    1f62:	strh.w	r2, [r0, #250]	; 0xfa
    1f66:	strh.w	r3, [r0, #252]	; 0xfc
    1f6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f6e:	strh.w	r8, [r0, #218]	; 0xda
    1f72:	strh.w	ip, [r0, #212]	; 0xd4
    1f76:	strh.w	r4, [r0, #214]	; 0xd6
    1f7a:	strh.w	r9, [r0, #216]	; 0xd8
    1f7e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f82:	strh.w	r8, [r0, #226]	; 0xe2
    1f86:	strh.w	ip, [r0, #220]	; 0xdc
    1f8a:	strh.w	r4, [r0, #222]	; 0xde
    1f8e:	strh.w	r9, [r0, #224]	; 0xe0
    1f92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f96:	strh.w	r8, [r0, #234]	; 0xea
    1f9a:	strh.w	ip, [r0, #228]	; 0xe4
    1f9e:	strh.w	r4, [r0, #230]	; 0xe6
    1fa2:	strh.w	r9, [r0, #232]	; 0xe8
    1fa6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1faa:	strh.w	r9, [r0, #254]	; 0xfe
    1fae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1fb2:	strh.w	ip, [r0, #282]	; 0x11a
    1fb6:	strh.w	r4, [r0, #284]	; 0x11c
    1fba:	strh.w	r9, [r0, #286]	; 0x11e
    1fbe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1fc2:	mvn.w	r1, #14
    1fc6:	add.w	r2, r0, #15
    1fca:	add.w	r4, r0, #23
    1fce:	strb.w	r6, [r0, #261]	; 0x105
    1fd2:	subs	r1, r1, r0
    1fd4:	b.n	1fda <BNO080::parseInputReport()+0x1b2>
    1fd6:	ldrb.w	r5, [r2, #1]!
    1fda:	ldr.w	r3, [r0, #264]	; 0x108
    1fde:	cmp	r2, r4
    1fe0:	add	r3, r2
    1fe2:	strb	r5, [r3, r1]
    1fe4:	bne.n	1fd6 <BNO080::parseInputReport()+0x1ae>
    1fe6:	b.n	1eca <BNO080::parseInputReport()+0xa2>
    1fe8:	strb.w	r7, [r0, #260]	; 0x104
    1fec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1ff0:	strh.w	ip, [r0, #270]	; 0x10e
    1ff4:	strh.w	r4, [r0, #272]	; 0x110
    1ff8:	strh.w	r9, [r0, #274]	; 0x112
    1ffc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2000:	ldrb.w	r3, [r0, #188]	; 0xbc
    2004:	mov	r4, r0
    2006:	cbnz	r3, 2028 <BNO080::parseInputReport()+0x200>
    2008:	cmp.w	lr, #7
    200c:	bne.w	1eca <BNO080::parseInputReport()+0xa2>
    2010:	strb.w	r6, [r4, #268]	; 0x10c
    2014:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2018:	strh.w	ip, [r0, #276]	; 0x114
    201c:	strh.w	r4, [r0, #278]	; 0x116
    2020:	strh.w	r9, [r0, #280]	; 0x118
    2024:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2028:	ldr.w	r5, [r0, #184]	; 0xb8
    202c:	movs	r2, #1
    202e:	ldr	r1, [pc, #60]	; (206c <BNO080::parseInputReport()+0x244>)
    2030:	ldr	r3, [r5, #0]
    2032:	mov	r0, r5
    2034:	ldr	r3, [r3, #4]
    2036:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    2038:	mov	r0, r5
    203a:	bl	4004 <Print::println()>
    203e:	ldrb	r3, [r4, #11]
    2040:	cmp	r3, #7
    2042:	bne.w	1eca <BNO080::parseInputReport()+0xa2>
    2046:	ldrb.w	r3, [r4, #188]	; 0xbc
    204a:	cbz	r3, 2062 <BNO080::parseInputReport()+0x23a>
    204c:	ldr.w	r5, [r4, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2050:	movs	r2, #20
    2052:	ldr	r1, [pc, #28]	; (2070 <BNO080::parseInputReport()+0x248>)
    2054:	ldr	r3, [r5, #0]
    2056:	mov	r0, r5
    2058:	ldr	r3, [r3, #4]
    205a:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    205c:	mov	r0, r5
    205e:	bl	4004 <Print::println()>
    2062:	ldrb	r6, [r4, #14]
    2064:	b.n	2010 <BNO080::parseInputReport()+0x1e8>
    2066:	movs	r1, #0
    2068:	b.n	1e7c <BNO080::parseInputReport()+0x54>
    206a:	nop
    206c:	.word	0x2000043c
    2070:	.word	0x20000440

00002074 <BNO080::getQuatI()>:
    2074:	push	{r3, lr}
    2076:	ldrsh.w	r2, [r0, #236]	; 0xec
    207a:	vmov.f64	d0, #0	; 0x40000000  2.0
    207e:	ldrb.w	r3, [r0, #288]	; 0x120
    2082:	vmov	s14, r2
    2086:	negs	r3, r3
    2088:	vpush	{d8}
    208c:	vmov	s2, r3
    2090:	vcvt.f32.s32	s16, s14
    2094:	vcvt.f64.s32	d1, s2
    2098:	bl	4738 <pow>
    209c:	vcvt.f64.f32	d7, s16
    20a0:	vpop	{d8}
    20a4:	vmul.f64	d0, d7, d0
    20a8:	vcvt.f32.f64	s0, d0
    20ac:	pop	{r3, pc}
    20ae:	nop

000020b0 <BNO080::getQuatJ()>:
    20b0:	push	{r3, lr}
    20b2:	ldrsh.w	r2, [r0, #238]	; 0xee
    20b6:	vmov.f64	d0, #0	; 0x40000000  2.0
    20ba:	ldrb.w	r3, [r0, #288]	; 0x120
    20be:	vmov	s14, r2
    20c2:	negs	r3, r3
    20c4:	vpush	{d8}
    20c8:	vmov	s2, r3
    20cc:	vcvt.f32.s32	s16, s14
    20d0:	vcvt.f64.s32	d1, s2
    20d4:	bl	4738 <pow>
    20d8:	vcvt.f64.f32	d7, s16
    20dc:	vpop	{d8}
    20e0:	vmul.f64	d0, d7, d0
    20e4:	vcvt.f32.f64	s0, d0
    20e8:	pop	{r3, pc}
    20ea:	nop

000020ec <BNO080::getQuatK()>:
    20ec:	push	{r3, lr}
    20ee:	ldrsh.w	r2, [r0, #240]	; 0xf0
    20f2:	vmov.f64	d0, #0	; 0x40000000  2.0
    20f6:	ldrb.w	r3, [r0, #288]	; 0x120
    20fa:	vmov	s14, r2
    20fe:	negs	r3, r3
    2100:	vpush	{d8}
    2104:	vmov	s2, r3
    2108:	vcvt.f32.s32	s16, s14
    210c:	vcvt.f64.s32	d1, s2
    2110:	bl	4738 <pow>
    2114:	vcvt.f64.f32	d7, s16
    2118:	vpop	{d8}
    211c:	vmul.f64	d0, d7, d0
    2120:	vcvt.f32.f64	s0, d0
    2124:	pop	{r3, pc}
    2126:	nop

00002128 <BNO080::getQuatReal()>:
    2128:	push	{r3, lr}
    212a:	ldrsh.w	r2, [r0, #242]	; 0xf2
    212e:	vmov.f64	d0, #0	; 0x40000000  2.0
    2132:	ldrb.w	r3, [r0, #288]	; 0x120
    2136:	vmov	s14, r2
    213a:	negs	r3, r3
    213c:	vpush	{d8}
    2140:	vmov	s2, r3
    2144:	vcvt.f32.s32	s16, s14
    2148:	vcvt.f64.s32	d1, s2
    214c:	bl	4738 <pow>
    2150:	vcvt.f64.f32	d7, s16
    2154:	vpop	{d8}
    2158:	vmul.f64	d0, d7, d0
    215c:	vcvt.f32.f64	s0, d0
    2160:	pop	{r3, pc}
    2162:	nop

00002164 <BNO080::getQuatRadianAccuracy()>:
    2164:	push	{r3, lr}
    2166:	ldrsh.w	r2, [r0, #244]	; 0xf4
    216a:	vmov.f64	d0, #0	; 0x40000000  2.0
    216e:	ldrb.w	r3, [r0, #290]	; 0x122
    2172:	vmov	s14, r2
    2176:	negs	r3, r3
    2178:	vpush	{d8}
    217c:	vmov	s2, r3
    2180:	vcvt.f32.s32	s16, s14
    2184:	vcvt.f64.s32	d1, s2
    2188:	bl	4738 <pow>
    218c:	vcvt.f64.f32	d7, s16
    2190:	vpop	{d8}
    2194:	vmul.f64	d0, d7, d0
    2198:	vcvt.f32.f64	s0, d0
    219c:	pop	{r3, pc}
    219e:	nop

000021a0 <BNO080::getGyroX()>:
    21a0:	push	{r3, lr}
    21a2:	ldrsh.w	r2, [r0, #220]	; 0xdc
    21a6:	vmov.f64	d0, #0	; 0x40000000  2.0
    21aa:	ldrb.w	r3, [r0, #296]	; 0x128
    21ae:	vmov	s14, r2
    21b2:	negs	r3, r3
    21b4:	vpush	{d8}
    21b8:	vmov	s2, r3
    21bc:	vcvt.f32.s32	s16, s14
    21c0:	vcvt.f64.s32	d1, s2
    21c4:	bl	4738 <pow>
    21c8:	vcvt.f64.f32	d7, s16
    21cc:	vpop	{d8}
    21d0:	vmul.f64	d0, d7, d0
    21d4:	vcvt.f32.f64	s0, d0
    21d8:	pop	{r3, pc}
    21da:	nop

000021dc <BNO080::getGyroY()>:
    21dc:	push	{r3, lr}
    21de:	ldrsh.w	r2, [r0, #222]	; 0xde
    21e2:	vmov.f64	d0, #0	; 0x40000000  2.0
    21e6:	ldrb.w	r3, [r0, #296]	; 0x128
    21ea:	vmov	s14, r2
    21ee:	negs	r3, r3
    21f0:	vpush	{d8}
    21f4:	vmov	s2, r3
    21f8:	vcvt.f32.s32	s16, s14
    21fc:	vcvt.f64.s32	d1, s2
    2200:	bl	4738 <pow>
    2204:	vcvt.f64.f32	d7, s16
    2208:	vpop	{d8}
    220c:	vmul.f64	d0, d7, d0
    2210:	vcvt.f32.f64	s0, d0
    2214:	pop	{r3, pc}
    2216:	nop

00002218 <BNO080::getGyroZ()>:
    2218:	push	{r3, lr}
    221a:	ldrsh.w	r2, [r0, #224]	; 0xe0
    221e:	vmov.f64	d0, #0	; 0x40000000  2.0
    2222:	ldrb.w	r3, [r0, #296]	; 0x128
    2226:	vmov	s14, r2
    222a:	negs	r3, r3
    222c:	vpush	{d8}
    2230:	vmov	s2, r3
    2234:	vcvt.f32.s32	s16, s14
    2238:	vcvt.f64.s32	d1, s2
    223c:	bl	4738 <pow>
    2240:	vcvt.f64.f32	d7, s16
    2244:	vpop	{d8}
    2248:	vmul.f64	d0, d7, d0
    224c:	vcvt.f32.f64	s0, d0
    2250:	pop	{r3, pc}
    2252:	nop

00002254 <BNO080::waitForI2C()>:
    2254:	push	{r4, r5, r6, lr}
    2256:	mov	r5, r0
    2258:	movs	r4, #100	; 0x64
    225a:	ldr	r6, [pc, #92]	; (22b8 <BNO080::waitForI2C()+0x64>)
    225c:	b.n	227a <BNO080::waitForI2C()+0x26>
    225e:	ldrb.w	r3, [r0, #59]	; 0x3b
    2262:	ldrb.w	r2, [r0, #58]	; 0x3a
    2266:	movs	r0, #1
    2268:	subs	r3, r3, r2
    226a:	cmp	r3, #0
    226c:	bgt.n	2290 <BNO080::waitForI2C()+0x3c>
    226e:	bl	3888 <delay>
    2272:	subs	r3, r4, #1
    2274:	ands.w	r4, r3, #255	; 0xff
    2278:	beq.n	2294 <BNO080::waitForI2C()+0x40>
    227a:	ldr.w	r0, [r5, #176]	; 0xb0
    227e:	ldr	r3, [r0, #0]
    2280:	ldr	r3, [r3, #16]
    2282:	cmp	r3, r6
    2284:	beq.n	225e <BNO080::waitForI2C()+0xa>
    2286:	blx	r3
    2288:	mov	r3, r0
    228a:	movs	r0, #1
    228c:	cmp	r3, #0
    228e:	ble.n	226e <BNO080::waitForI2C()+0x1a>
    2290:	movs	r0, #1
    2292:	pop	{r4, r5, r6, pc}
    2294:	ldrb.w	r0, [r5, #188]	; 0xbc
    2298:	cmp	r0, #0
    229a:	beq.n	2292 <BNO080::waitForI2C()+0x3e>
    229c:	ldr.w	r5, [r5, #184]	; 0xb8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    22a0:	movs	r2, #11
    22a2:	ldr	r1, [pc, #24]	; (22bc <BNO080::waitForI2C()+0x68>)
    22a4:	ldr	r3, [r5, #0]
    22a6:	mov	r0, r5
    22a8:	ldr	r3, [r3, #4]
    22aa:	blx	r3
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    22ac:	mov	r0, r5
    22ae:	bl	4004 <Print::println()>
    22b2:	mov	r0, r4
    22b4:	pop	{r4, r5, r6, pc}
    22b6:	nop
    22b8:	.word	0x00001bb1
    22bc:	.word	0x20000458

000022c0 <BNO080::getData(unsigned short)>:
    22c0:	cmp	r1, #0
    22c2:	beq.w	2406 <BNO080::getData(unsigned short)+0x146>
    22c6:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    22ca:	mov	r6, r0
    22cc:	mov	r9, r1
    22ce:	movs	r5, #0
    22d0:	ldr	r7, [pc, #312]	; (240c <BNO080::getData(unsigned short)+0x14c>)
    22d2:	cmp.w	r9, #28
    22d6:	mov	r8, r9
    22d8:	mov.w	r3, #1
    22dc:	ldrb.w	r1, [r6, #180]	; 0xb4
    22e0:	it	cs
    22e2:	movcs.w	r8, #28
    22e6:	ldr.w	r0, [r6, #176]	; 0xb0
    22ea:	add.w	r2, r8, #4
    22ee:	uxtb	r2, r2
    22f0:	bl	2938 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
    22f4:	mov	r0, r6
    22f6:	bl	2254 <BNO080::waitForI2C()>
    22fa:	cmp	r0, #0
    22fc:	beq.w	2402 <BNO080::getData(unsigned short)+0x142>
    2300:	ldr.w	r0, [r6, #176]	; 0xb0
    2304:	ldr	r3, [r0, #0]
    2306:	ldr	r3, [r3, #20]
    2308:	cmp	r3, r7
    230a:	bne.n	23f6 <BNO080::getData(unsigned short)+0x136>
    230c:	ldrb.w	r2, [r0, #58]	; 0x3a
    2310:	ldrb.w	r1, [r0, #59]	; 0x3b
    2314:	cmp	r1, r2
    2316:	bls.n	2326 <BNO080::getData(unsigned short)+0x66>
    2318:	adds	r2, #1
    231a:	strb.w	r2, [r0, #58]	; 0x3a
    231e:	ldr.w	r0, [r6, #176]	; 0xb0
    2322:	ldr	r3, [r0, #0]
    2324:	ldr	r3, [r3, #20]
    2326:	cmp	r3, r7
    2328:	bne.n	23ea <BNO080::getData(unsigned short)+0x12a>
    232a:	ldrb.w	r2, [r0, #58]	; 0x3a
    232e:	ldrb.w	r1, [r0, #59]	; 0x3b
    2332:	cmp	r1, r2
    2334:	bls.n	23da <BNO080::getData(unsigned short)+0x11a>
    2336:	adds	r2, #1
    2338:	strb.w	r2, [r0, #58]	; 0x3a
    233c:	ldr.w	r0, [r6, #176]	; 0xb0
    2340:	ldr	r3, [r0, #0]
    2342:	ldr	r3, [r3, #20]
    2344:	cmp	r3, r7
    2346:	bne.n	23e6 <BNO080::getData(unsigned short)+0x126>
    2348:	ldrb.w	r2, [r0, #58]	; 0x3a
    234c:	ldrb.w	r1, [r0, #59]	; 0x3b
    2350:	cmp	r1, r2
    2352:	bls.n	23da <BNO080::getData(unsigned short)+0x11a>
    2354:	adds	r2, #1
    2356:	strb.w	r2, [r0, #58]	; 0x3a
    235a:	ldr.w	r0, [r6, #176]	; 0xb0
    235e:	ldr	r3, [r0, #0]
    2360:	ldr	r3, [r3, #20]
    2362:	cmp	r3, r7
    2364:	bne.n	23de <BNO080::getData(unsigned short)+0x11e>
    2366:	ldrb.w	r3, [r0, #58]	; 0x3a
    236a:	ldrb.w	r2, [r0, #59]	; 0x3b
    236e:	cmp	r2, r3
    2370:	bls.n	237c <BNO080::getData(unsigned short)+0xbc>
    2372:	adds	r3, #1
    2374:	strb.w	r3, [r0, #58]	; 0x3a
    2378:	ldr.w	r0, [r6, #176]	; 0xb0
    237c:	movs	r4, #0
    237e:	b.n	23b4 <BNO080::getData(unsigned short)+0xf4>
    2380:	ldrb.w	r3, [r0, #58]	; 0x3a
    2384:	ldrb.w	r2, [r0, #59]	; 0x3b
    2388:	add.w	lr, r3, #1
    238c:	adds	r1, r0, r3
    238e:	cmp	r2, r3
    2390:	bls.n	23d6 <BNO080::getData(unsigned short)+0x116>
    2392:	strb.w	lr, [r0, #58]	; 0x3a
    2396:	ldrb	r0, [r1, #26]
    2398:	adds	r4, #1
    239a:	cmp	r5, #127	; 0x7f
    239c:	add.w	r2, r5, #1
    23a0:	add.w	r3, r6, r5
    23a4:	uxtb	r4, r4
    23a6:	bhi.n	23ac <BNO080::getData(unsigned short)+0xec>
    23a8:	uxth	r5, r2
    23aa:	strb	r0, [r3, #4]
    23ac:	cmp	r4, r8
    23ae:	bcs.n	23c2 <BNO080::getData(unsigned short)+0x102>
    23b0:	ldr.w	r0, [r6, #176]	; 0xb0
    23b4:	ldr	r3, [r0, #0]
    23b6:	ldr	r3, [r3, #20]
    23b8:	cmp	r3, r7
    23ba:	beq.n	2380 <BNO080::getData(unsigned short)+0xc0>
    23bc:	blx	r3
    23be:	uxtb	r0, r0
    23c0:	b.n	2398 <BNO080::getData(unsigned short)+0xd8>
    23c2:	rsb	r9, r8, r9
    23c6:	uxth.w	r9, r9
    23ca:	cmp.w	r9, #0
    23ce:	bne.n	22d2 <BNO080::getData(unsigned short)+0x12>
    23d0:	movs	r0, #1
    23d2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    23d6:	movs	r0, #255	; 0xff
    23d8:	b.n	2398 <BNO080::getData(unsigned short)+0xd8>
    23da:	cmp	r3, r7
    23dc:	beq.n	237c <BNO080::getData(unsigned short)+0xbc>
    23de:	blx	r3
    23e0:	ldr.w	r0, [r6, #176]	; 0xb0
    23e4:	b.n	237c <BNO080::getData(unsigned short)+0xbc>
    23e6:	blx	r3
    23e8:	b.n	235a <BNO080::getData(unsigned short)+0x9a>
    23ea:	blx	r3
    23ec:	ldr.w	r0, [r6, #176]	; 0xb0
    23f0:	ldr	r3, [r0, #0]
    23f2:	ldr	r3, [r3, #20]
    23f4:	b.n	2344 <BNO080::getData(unsigned short)+0x84>
    23f6:	blx	r3
    23f8:	ldr.w	r0, [r6, #176]	; 0xb0
    23fc:	ldr	r3, [r0, #0]
    23fe:	ldr	r3, [r3, #20]
    2400:	b.n	2326 <BNO080::getData(unsigned short)+0x66>
    2402:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2406:	movs	r0, #1
    2408:	bx	lr
    240a:	nop
    240c:	.word	0x00001bbd

00002410 <BNO080::receivePacket()>:
    2410:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2414:	mov	r4, r0
    2416:	ldr.w	r0, [r0, #176]	; 0xb0
    241a:	cmp	r0, #0
    241c:	beq.n	2512 <BNO080::receivePacket()+0x102>
    241e:	movs	r3, #1
    2420:	movs	r2, #4
    2422:	ldrb.w	r1, [r4, #180]	; 0xb4
    2426:	bl	2938 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
    242a:	mov	r0, r4
    242c:	bl	2254 <BNO080::waitForI2C()>
    2430:	mov	r5, r0
    2432:	cbnz	r0, 243c <BNO080::receivePacket()+0x2c>
    2434:	movs	r5, #0
    2436:	mov	r0, r5
    2438:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    243c:	ldr.w	r3, [r4, #176]	; 0xb0
    2440:	ldr	r7, [pc, #592]	; (2694 <BNO080::receivePacket()+0x284>)
    2442:	ldr	r2, [r3, #0]
    2444:	ldr	r2, [r2, #20]
    2446:	cmp	r2, r7
    2448:	bne.w	2652 <BNO080::receivePacket()+0x242>
    244c:	ldrb.w	r1, [r3, #58]	; 0x3a
    2450:	ldrb.w	r0, [r3, #59]	; 0x3b
    2454:	cmp	r0, r1
    2456:	bls.w	274a <BNO080::receivePacket()+0x33a>
    245a:	adds	r2, r1, #1
    245c:	add	r1, r3
    245e:	strb.w	r2, [r3, #58]	; 0x3a
    2462:	ldr.w	r3, [r4, #176]	; 0xb0
    2466:	ldrb.w	r9, [r1, #26]
    246a:	ldr	r2, [r3, #0]
    246c:	sxth.w	sl, r9
    2470:	ldr	r2, [r2, #20]
    2472:	cmp	r2, r7
    2474:	bne.w	2668 <BNO080::receivePacket()+0x258>
    2478:	ldrb.w	r0, [r3, #58]	; 0x3a
    247c:	ldrb.w	r1, [r3, #59]	; 0x3b
    2480:	cmp	r1, r0
    2482:	bls.w	2752 <BNO080::receivePacket()+0x342>
    2486:	adds	r2, r0, #1
    2488:	add	r0, r3
    248a:	strb.w	r2, [r3, #58]	; 0x3a
    248e:	ldrb.w	fp, [r0, #26]
    2492:	ldr.w	r3, [r4, #176]	; 0xb0
    2496:	mov.w	r1, fp, lsl #8
    249a:	ldr	r2, [r3, #0]
    249c:	sxth	r6, r1
    249e:	ldr	r2, [r2, #20]
    24a0:	cmp	r2, r7
    24a2:	bne.w	268a <BNO080::receivePacket()+0x27a>
    24a6:	ldrb.w	r1, [r3, #58]	; 0x3a
    24aa:	ldrb.w	r0, [r3, #59]	; 0x3b
    24ae:	cmp	r0, r1
    24b0:	bls.w	275a <BNO080::receivePacket()+0x34a>
    24b4:	adds	r2, r1, #1
    24b6:	add	r1, r3
    24b8:	strb.w	r2, [r3, #58]	; 0x3a
    24bc:	ldrb	r0, [r1, #26]
    24be:	ldr.w	r3, [r4, #176]	; 0xb0
    24c2:	uxtb.w	r8, r0
    24c6:	ldr	r2, [r3, #0]
    24c8:	ldr	r2, [r2, #20]
    24ca:	cmp	r2, r7
    24cc:	bne.w	2682 <BNO080::receivePacket()+0x272>
    24d0:	ldrb.w	r2, [r3, #58]	; 0x3a
    24d4:	ldrb.w	r1, [r3, #59]	; 0x3b
    24d8:	cmp	r1, r2
    24da:	bls.w	2764 <BNO080::receivePacket()+0x354>
    24de:	adds	r1, r2, #1
    24e0:	add	r2, r3
    24e2:	strb.w	r1, [r3, #58]	; 0x3a
    24e6:	ldrb	r0, [r2, #26]
    24e8:	orr.w	r1, r6, sl
    24ec:	strb.w	r9, [r4]
    24f0:	strb.w	fp, [r4, #1]
    24f4:	ubfx	r1, r1, #0, #15
    24f8:	strb.w	r8, [r4, #2]
    24fc:	strb	r0, [r4, #3]
    24fe:	cmp	r1, #0
    2500:	beq.n	2434 <BNO080::receivePacket()+0x24>
    2502:	subs	r1, #4
    2504:	mov	r0, r4
    2506:	uxth	r1, r1
    2508:	bl	22c0 <BNO080::getData(unsigned short)>
    250c:	mov	r0, r5
    250e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2512:	ldrb.w	r0, [r4, #202]	; 0xca
    2516:	bl	3c7c <digitalRead>
    251a:	cmp	r0, #1
    251c:	beq.n	2434 <BNO080::receivePacket()+0x24>
    251e:	ldr.w	r3, [r4, #192]	; 0xc0
    2522:	ldr.w	r0, [r4, #196]	; 0xc4
    2526:	ldrb	r2, [r3, #19]
    2528:	cmp	r2, #0
    252a:	beq.n	258a <BNO080::receivePacket()+0x17a>
    252c:	cpsid	i
    252e:	ldrb	r2, [r3, #19]
    2530:	lsls	r7, r2, #31
    2532:	bpl.n	2542 <BNO080::receivePacket()+0x132>
    2534:	ldr	r1, [pc, #352]	; (2698 <BNO080::receivePacket()+0x288>)
    2536:	ldr	r2, [r3, #20]
    2538:	ldr	r5, [r1, #0]
    253a:	ands	r2, r5
    253c:	str	r2, [r3, #40]	; 0x28
    253e:	str	r2, [r1, #0]
    2540:	ldrb	r2, [r3, #19]
    2542:	lsls	r6, r2, #30
    2544:	bpl.n	2554 <BNO080::receivePacket()+0x144>
    2546:	ldr	r1, [pc, #340]	; (269c <BNO080::receivePacket()+0x28c>)
    2548:	ldr	r2, [r3, #24]
    254a:	ldr	r5, [r1, #0]
    254c:	ands	r2, r5
    254e:	str	r2, [r3, #44]	; 0x2c
    2550:	str	r2, [r1, #0]
    2552:	ldrb	r2, [r3, #19]
    2554:	lsls	r5, r2, #29
    2556:	bpl.n	2566 <BNO080::receivePacket()+0x156>
    2558:	ldr	r1, [pc, #324]	; (26a0 <BNO080::receivePacket()+0x290>)
    255a:	ldr	r2, [r3, #28]
    255c:	ldr	r5, [r1, #0]
    255e:	ands	r2, r5
    2560:	str	r2, [r3, #48]	; 0x30
    2562:	str	r2, [r1, #0]
    2564:	ldrb	r2, [r3, #19]
    2566:	lsls	r1, r2, #28
    2568:	bpl.n	2578 <BNO080::receivePacket()+0x168>
    256a:	ldr	r1, [pc, #312]	; (26a4 <BNO080::receivePacket()+0x294>)
    256c:	ldr	r2, [r3, #32]
    256e:	ldr	r5, [r1, #0]
    2570:	ands	r2, r5
    2572:	str	r2, [r3, #52]	; 0x34
    2574:	str	r2, [r1, #0]
    2576:	ldrb	r2, [r3, #19]
    2578:	lsls	r7, r2, #27
    257a:	bpl.n	2588 <BNO080::receivePacket()+0x178>
    257c:	ldr	r1, [pc, #296]	; (26a8 <BNO080::receivePacket()+0x298>)
    257e:	ldr	r2, [r3, #36]	; 0x24
    2580:	ldr	r5, [r1, #0]
    2582:	ands	r2, r5
    2584:	str	r2, [r3, #56]	; 0x38
    2586:	str	r2, [r1, #0]
    2588:	cpsie	i
    258a:	ldr	r2, [r3, #8]
    258c:	cmp	r0, r2
    258e:	beq.w	273e <BNO080::receivePacket()+0x32e>
    2592:	ldr	r2, [pc, #280]	; (26ac <BNO080::receivePacket()+0x29c>)
    2594:	str	r0, [r3, #8]
    2596:	ldr	r2, [r2, #24]
    2598:	ldr	r1, [pc, #276]	; (26b0 <BNO080::receivePacket()+0x2a0>)
    259a:	ubfx	r5, r2, #4, #2
    259e:	ubfx	r2, r2, #26, #3
    25a2:	ldr.w	r1, [r1, r5, lsl #2]
    25a6:	adds	r2, #1
    25a8:	udiv	r1, r1, r2
    25ac:	cmp	r0, #0
    25ae:	beq.n	2690 <BNO080::receivePacket()+0x280>
    25b0:	udiv	r2, r1, r0
    25b4:	cbz	r2, 25cc <BNO080::receivePacket()+0x1bc>
    25b6:	udiv	r1, r1, r2
    25ba:	cmp	r0, r1
    25bc:	it	cc
    25be:	addcc	r2, #1
    25c0:	cmp.w	r2, #258	; 0x102
    25c4:	bcc.w	2768 <BNO080::receivePacket()+0x358>
    25c8:	movw	r2, #32767	; 0x7fff
    25cc:	str	r2, [r3, #12]
    25ce:	ldr	r3, [r3, #0]
    25d0:	movs	r5, #0
    25d2:	movs	r1, #3
    25d4:	ldr	r6, [pc, #220]	; (26b4 <BNO080::receivePacket()+0x2a4>)
    25d6:	movs	r0, #1
    25d8:	str	r5, [r3, #16]
    25da:	str	r1, [r3, #36]	; 0x24
    25dc:	mov	r1, r5
    25de:	str	r2, [r3, #64]	; 0x40
    25e0:	str	r6, [r3, #96]	; 0x60
    25e2:	str	r0, [r3, #16]
    25e4:	ldrb.w	r0, [r4, #200]	; 0xc8
    25e8:	bl	3c70 <digitalWrite>
    25ec:	ldr.w	r6, [r4, #192]	; 0xc0
    25f0:	ldr	r3, [r6, #0]
    25f2:	str	r5, [r3, #100]	; 0x64
    25f4:	ldr	r2, [r3, #92]	; 0x5c
    25f6:	tst.w	r2, #2031616	; 0x1f0000
    25fa:	beq.n	25f4 <BNO080::receivePacket()+0x1e4>
    25fc:	ldr	r1, [r3, #116]	; 0x74
    25fe:	movs	r2, #0
    2600:	uxtb	r1, r1
    2602:	str	r2, [r3, #100]	; 0x64
    2604:	ldr	r2, [r3, #92]	; 0x5c
    2606:	tst.w	r2, #2031616	; 0x1f0000
    260a:	beq.n	2604 <BNO080::receivePacket()+0x1f4>
    260c:	ldr	r5, [r3, #116]	; 0x74
    260e:	movs	r2, #0
    2610:	uxtb	r7, r5
    2612:	str	r2, [r3, #100]	; 0x64
    2614:	ldr	r2, [r3, #92]	; 0x5c
    2616:	tst.w	r2, #2031616	; 0x1f0000
    261a:	beq.n	2614 <BNO080::receivePacket()+0x204>
    261c:	ldr	r0, [r3, #116]	; 0x74
    261e:	movs	r2, #0
    2620:	uxtb	r0, r0
    2622:	str	r2, [r3, #100]	; 0x64
    2624:	ldr	r2, [r3, #92]	; 0x5c
    2626:	tst.w	r2, #2031616	; 0x1f0000
    262a:	beq.n	2624 <BNO080::receivePacket()+0x214>
    262c:	lsls	r5, r5, #8
    262e:	ldr	r3, [r3, #116]	; 0x74
    2630:	strb	r1, [r4, #0]
    2632:	and.w	r5, r5, #32512	; 0x7f00
    2636:	strb	r3, [r4, #3]
    2638:	strb	r7, [r4, #1]
    263a:	orrs	r5, r1
    263c:	strb	r0, [r4, #2]
    263e:	bne.n	26b8 <BNO080::receivePacket()+0x2a8>
    2640:	ldrb.w	r3, [r4, #188]	; 0xbc
    2644:	cmp	r3, #0
    2646:	beq.w	2434 <BNO080::receivePacket()+0x24>
    264a:	mov	r0, r4
    264c:	bl	1bdc <BNO080::printHeader() [clone .part.7]>
    2650:	b.n	2436 <BNO080::receivePacket()+0x26>
    2652:	mov	r0, r3
    2654:	blx	r2
    2656:	ldr.w	r3, [r4, #176]	; 0xb0
    265a:	uxtb.w	r9, r0
    265e:	ldr	r2, [r3, #0]
    2660:	sxth.w	sl, r9
    2664:	ldr	r2, [r2, #20]
    2666:	b.n	2472 <BNO080::receivePacket()+0x62>
    2668:	mov	r0, r3
    266a:	blx	r2
    266c:	ldr.w	r3, [r4, #176]	; 0xb0
    2670:	lsls	r1, r0, #8
    2672:	ldr	r2, [r3, #0]
    2674:	uxtb.w	fp, r0
    2678:	sxth	r6, r1
    267a:	ldr	r2, [r2, #20]
    267c:	b.n	24a0 <BNO080::receivePacket()+0x90>
    267e:	mov.w	r8, #255	; 0xff
    2682:	mov	r0, r3
    2684:	blx	r2
    2686:	uxtb	r0, r0
    2688:	b.n	24e8 <BNO080::receivePacket()+0xd8>
    268a:	mov	r0, r3
    268c:	blx	r2
    268e:	b.n	24be <BNO080::receivePacket()+0xae>
    2690:	mov	r2, r1
    2692:	b.n	25b4 <BNO080::receivePacket()+0x1a4>
    2694:	.word	0x00001bbd
    2698:	.word	0xe000e180
    269c:	.word	0xe000e184
    26a0:	.word	0xe000e188
    26a4:	.word	0xe000e18c
    26a8:	.word	0xe000e190
    26ac:	.word	0x400fc000
    26b0:	.word	0x200003a0
    26b4:	.word	0xc0000007
    26b8:	subs	r5, #4
    26ba:	uxth	r0, r5
    26bc:	cbz	r0, 26e8 <BNO080::receivePacket()+0x2d8>
    26be:	adds	r5, r4, #4
    26c0:	movs	r1, #0
    26c2:	movs	r7, #255	; 0xff
    26c4:	ldr	r2, [r6, #0]
    26c6:	str	r7, [r2, #100]	; 0x64
    26c8:	ldr	r3, [r2, #92]	; 0x5c
    26ca:	tst.w	r3, #2031616	; 0x1f0000
    26ce:	beq.n	26c8 <BNO080::receivePacket()+0x2b8>
    26d0:	cmp	r1, #127	; 0x7f
    26d2:	ldr	r3, [r2, #116]	; 0x74
    26d4:	add.w	r1, r1, #1
    26d8:	add.w	r5, r5, #1
    26dc:	it	ls
    26de:	strbls.w	r3, [r5, #-1]
    26e2:	uxth	r3, r1
    26e4:	cmp	r0, r3
    26e6:	bhi.n	26c4 <BNO080::receivePacket()+0x2b4>
    26e8:	movs	r1, #1
    26ea:	ldrb.w	r0, [r4, #200]	; 0xc8
    26ee:	bl	3c70 <digitalWrite>
    26f2:	ldr.w	r2, [r4, #192]	; 0xc0
    26f6:	ldrb	r3, [r2, #19]
    26f8:	cbz	r3, 2734 <BNO080::receivePacket()+0x324>
    26fa:	lsls	r6, r3, #31
    26fc:	bpl.n	2706 <BNO080::receivePacket()+0x2f6>
    26fe:	ldr	r3, [pc, #124]	; (277c <BNO080::receivePacket()+0x36c>)
    2700:	ldr	r1, [r2, #40]	; 0x28
    2702:	str	r1, [r3, #0]
    2704:	ldrb	r3, [r2, #19]
    2706:	lsls	r5, r3, #30
    2708:	bpl.n	2712 <BNO080::receivePacket()+0x302>
    270a:	ldr	r3, [pc, #116]	; (2780 <BNO080::receivePacket()+0x370>)
    270c:	ldr	r1, [r2, #44]	; 0x2c
    270e:	str	r1, [r3, #0]
    2710:	ldrb	r3, [r2, #19]
    2712:	lsls	r0, r3, #29
    2714:	bpl.n	271e <BNO080::receivePacket()+0x30e>
    2716:	ldr	r3, [pc, #108]	; (2784 <BNO080::receivePacket()+0x374>)
    2718:	ldr	r1, [r2, #48]	; 0x30
    271a:	str	r1, [r3, #0]
    271c:	ldrb	r3, [r2, #19]
    271e:	lsls	r1, r3, #28
    2720:	bpl.n	272a <BNO080::receivePacket()+0x31a>
    2722:	ldr	r3, [pc, #100]	; (2788 <BNO080::receivePacket()+0x378>)
    2724:	ldr	r1, [r2, #52]	; 0x34
    2726:	str	r1, [r3, #0]
    2728:	ldrb	r3, [r2, #19]
    272a:	lsls	r3, r3, #27
    272c:	bpl.n	2734 <BNO080::receivePacket()+0x324>
    272e:	ldr	r2, [r2, #56]	; 0x38
    2730:	ldr	r3, [pc, #88]	; (278c <BNO080::receivePacket()+0x37c>)
    2732:	str	r2, [r3, #0]
    2734:	ldrb.w	r5, [r4, #188]	; 0xbc
    2738:	cbnz	r5, 2742 <BNO080::receivePacket()+0x332>
    273a:	movs	r5, #1
    273c:	b.n	2436 <BNO080::receivePacket()+0x26>
    273e:	ldr	r2, [r3, #12]
    2740:	b.n	25ce <BNO080::receivePacket()+0x1be>
    2742:	mov	r0, r4
    2744:	bl	1c44 <BNO080::printPacket() [clone .part.6]>
    2748:	b.n	2436 <BNO080::receivePacket()+0x26>
    274a:	mov.w	sl, #255	; 0xff
    274e:	mov	r9, sl
    2750:	b.n	2472 <BNO080::receivePacket()+0x62>
    2752:	mvn.w	r6, #255	; 0xff
    2756:	mov.w	fp, #255	; 0xff
    275a:	cmp	r2, r7
    275c:	bne.n	267e <BNO080::receivePacket()+0x26e>
    275e:	movs	r0, #255	; 0xff
    2760:	mov	r8, r0
    2762:	b.n	24e8 <BNO080::receivePacket()+0xd8>
    2764:	movs	r0, #255	; 0xff
    2766:	b.n	24e8 <BNO080::receivePacket()+0xd8>
    2768:	cmp	r2, #2
    276a:	bls.n	2776 <BNO080::receivePacket()+0x366>
    276c:	subs	r2, #2
    276e:	lsrs	r1, r2, #1
    2770:	orr.w	r2, r2, r1, lsl #8
    2774:	b.n	25cc <BNO080::receivePacket()+0x1bc>
    2776:	movs	r2, #0
    2778:	b.n	25cc <BNO080::receivePacket()+0x1bc>
    277a:	nop
    277c:	.word	0xe000e100
    2780:	.word	0xe000e104
    2784:	.word	0xe000e108
    2788:	.word	0xe000e10c
    278c:	.word	0xe000e110

00002790 <BNO080::dataAvailable()>:
    2790:	push	{r3, r4, r5, lr}
    2792:	mov	r4, r0
    2794:	ldrb.w	r0, [r0, #202]	; 0xca
    2798:	cmp	r0, #255	; 0xff
    279a:	beq.n	27a4 <BNO080::dataAvailable()+0x14>
    279c:	bl	3c7c <digitalRead>
    27a0:	cmp	r0, #1
    27a2:	beq.n	27bc <BNO080::dataAvailable()+0x2c>
    27a4:	mov	r0, r4
    27a6:	bl	2410 <BNO080::receivePacket()>
    27aa:	mov	r5, r0
    27ac:	cbz	r0, 27bc <BNO080::dataAvailable()+0x2c>
    27ae:	ldrb	r3, [r4, #2]
    27b0:	cmp	r3, #3
    27b2:	beq.n	27c2 <BNO080::dataAvailable()+0x32>
    27b4:	cmp	r3, #2
    27b6:	beq.n	27d0 <BNO080::dataAvailable()+0x40>
    27b8:	cmp	r3, #5
    27ba:	beq.n	27c8 <BNO080::dataAvailable()+0x38>
    27bc:	movs	r5, #0
    27be:	mov	r0, r5
    27c0:	pop	{r3, r4, r5, pc}
    27c2:	ldrb	r3, [r4, #4]
    27c4:	cmp	r3, #251	; 0xfb
    27c6:	bne.n	27bc <BNO080::dataAvailable()+0x2c>
    27c8:	mov	r0, r4
    27ca:	bl	1e28 <BNO080::parseInputReport()>
    27ce:	b.n	27be <BNO080::dataAvailable()+0x2e>
    27d0:	ldrb	r3, [r4, #4]
    27d2:	cmp	r3, #241	; 0xf1
    27d4:	bne.n	27be <BNO080::dataAvailable()+0x2e>
    27d6:	ldrb	r3, [r4, #6]
    27d8:	cmp	r3, #7
    27da:	bne.n	27be <BNO080::dataAvailable()+0x2e>
    27dc:	ldrb	r3, [r4, #9]
    27de:	strb.w	r3, [r4, #268]	; 0x10c
    27e2:	b.n	27be <BNO080::dataAvailable()+0x2e>

000027e4 <TwoWire::force_clock()>:
    27e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    27e8:	mov	fp, r0
    27ea:	ldr	r0, [pc, #256]	; (28ec <TwoWire::force_clock()+0x108>)
    27ec:	sub	sp, #12
    27ee:	movs	r5, #21
    27f0:	ldr.w	sl, [fp, #20]
    27f4:	ldrb.w	r6, [fp, #24]
    27f8:	ldrb.w	r3, [fp, #25]
    27fc:	add.w	r6, sl, r6, lsl #4
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2800:	ldr	r1, [pc, #236]	; (28f0 <TwoWire::force_clock()+0x10c>)
    2802:	add.w	r3, sl, r3, lsl #4
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2806:	ldr.w	lr, [pc, #236]	; 28f4 <TwoWire::force_clock()+0x110>
    280a:	ldrb	r6, [r6, #8]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    280c:	mov	r4, r1
    280e:	ldrb.w	r3, [r3, #40]	; 0x28
    2812:	lsls	r6, r6, #4

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2814:	ldr.w	r9, [pc, #224]	; 28f8 <TwoWire::force_clock()+0x114>
    2818:	lsls	r3, r3, #4
    281a:	adds	r7, r0, r6
    281c:	ldr.w	r8, [r0, r6]
    2820:	add.w	ip, r0, r3
    2824:	ldr	r6, [r0, r3]
    2826:	ldr	r0, [r7, #12]
    2828:	ldr	r3, [r7, #4]
    282a:	ldr.w	r7, [ip, #12]
    282e:	str	r3, [sp, #0]
    2830:	str	r5, [r3, #0]
    2832:	str.w	r0, [r8, #132]	; 0x84
    2836:	ldr.w	r3, [r8, #4]
    283a:	ldr.w	r2, [ip, #4]
    283e:	orrs	r3, r0
    2840:	str	r2, [sp, #4]
    2842:	str.w	r3, [r8, #4]
    2846:	str	r5, [r2, #0]
    2848:	str.w	r7, [r6, #132]	; 0x84
    284c:	ldr	r3, [r6, #4]
    284e:	orrs	r3, r7
    2850:	str	r3, [r6, #4]
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2852:	ldr	r1, [r1, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2854:	ldr.w	r3, [lr]
    2858:	umull	r3, r2, r9, r3
    285c:	lsrs	r2, r2, #18
    285e:	add.w	r2, r2, r2, lsl #2
    2862:	lsls	r2, r2, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2864:	ldr	r3, [r4, #0]
    2866:	subs	r3, r3, r1
    2868:	cmp	r2, r3
    286a:	bhi.n	2864 <TwoWire::force_clock()+0x80>
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    286c:	ldr	r2, [pc, #128]	; (28f0 <TwoWire::force_clock()+0x10c>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    286e:	movs	r5, #9

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2870:	ldr.w	ip, [pc, #132]	; 28f8 <TwoWire::force_clock()+0x114>
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2874:	mov	r9, r2
    2876:	ldr.w	r3, [r8, #8]
    287a:	tst	r0, r3
    287c:	beq.n	2884 <TwoWire::force_clock()+0xa0>
    287e:	ldr	r3, [r6, #8]
    2880:	tst	r7, r3
    2882:	bne.n	28e8 <TwoWire::force_clock()+0x104>
    2884:	str.w	r7, [r6, #136]	; 0x88
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2888:	ldr	r4, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    288a:	ldr.w	r1, [lr]
    288e:	umull	r3, r1, ip, r1
    2892:	lsrs	r1, r1, #18
    2894:	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2898:	ldr	r3, [r2, #0]
    289a:	subs	r3, r3, r4
    289c:	cmp	r1, r3
    289e:	bhi.n	2898 <TwoWire::force_clock()+0xb4>
    28a0:	str.w	r7, [r6, #132]	; 0x84
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    28a4:	ldr.w	r4, [r9]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    28a8:	ldr.w	r1, [lr]
    28ac:	umull	r3, r1, ip, r1
    28b0:	lsrs	r1, r1, #18
    28b2:	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    28b6:	ldr	r3, [r2, #0]
    28b8:	subs	r3, r3, r4
    28ba:	cmp	r1, r3
    28bc:	bhi.n	28b6 <TwoWire::force_clock()+0xd2>
    28be:	subs	r5, #1
    28c0:	bne.n	2876 <TwoWire::force_clock()+0x92>
    28c2:	mov	r0, r5
    28c4:	ldrb.w	r3, [fp, #24]
    28c8:	ldr	r2, [sp, #0]
    28ca:	add.w	r3, sl, r3, lsl #4
    28ce:	ldr	r3, [r3, #12]
    28d0:	str	r3, [r2, #0]
    28d2:	ldrb.w	r3, [fp, #25]
    28d6:	ldr	r2, [sp, #4]
    28d8:	add.w	sl, sl, r3, lsl #4
    28dc:	ldr.w	r3, [sl, #44]	; 0x2c
    28e0:	str	r3, [r2, #0]
    28e2:	add	sp, #12
    28e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    28e8:	movs	r0, #1
    28ea:	b.n	28c4 <TwoWire::force_clock()+0xe0>
    28ec:	.word	0x20000518
    28f0:	.word	0xe0001004
    28f4:	.word	0x20000ff4
    28f8:	.word	0x431bde83

000028fc <TwoWire::wait_idle()>:
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
    28fc:	ldr	r1, [pc, #52]	; (2934 <TwoWire::wait_idle()+0x38>)
    28fe:	ldr	r2, [r0, #16]
    2900:	push	{r4, lr}
    2902:	ldr	r4, [r1, #0]
    2904:	b.n	2912 <TwoWire::wait_idle()+0x16>
    2906:	lsls	r3, r3, #7
    2908:	bmi.n	291a <TwoWire::wait_idle()+0x1e>
    290a:	ldr	r3, [r1, #0]
    290c:	subs	r3, r3, r4
    290e:	cmp	r3, #16
    2910:	bhi.n	2924 <TwoWire::wait_idle()+0x28>
    2912:	ldr	r3, [r2, #20]
    2914:	tst.w	r3, #33554432	; 0x2000000
    2918:	bne.n	2906 <TwoWire::wait_idle()+0xa>
    291a:	mov.w	r3, #32512	; 0x7f00
    291e:	movs	r0, #1
    2920:	str	r3, [r2, #20]
    2922:	pop	{r4, pc}
    2924:	mov	r4, r0
    2926:	bl	27e4 <TwoWire::force_clock()>
    292a:	cmp	r0, #0
    292c:	beq.n	2922 <TwoWire::wait_idle()+0x26>
    292e:	ldr	r2, [r4, #16]
    2930:	b.n	291a <TwoWire::wait_idle()+0x1e>
    2932:	nop
    2934:	.word	0x20001e74

00002938 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
    2938:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    293c:	mov	r4, r1
    293e:	mov	r5, r2
    2940:	mov	r8, r3
    2942:	mov	r9, r0
    2944:	bl	28fc <TwoWire::wait_idle()>
    2948:	cbnz	r0, 2950 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18>
    294a:	movs	r0, #4
    294c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2950:	movs	r2, #0
    2952:	lsls	r3, r4, #1
    2954:	cmp	r5, #0
    2956:	movw	sl, #1025	; 0x401
    295a:	mov	r4, r2
    295c:	uxtb	r3, r3
    295e:	ldr	r6, [pc, #244]	; (2a54 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>)
    2960:	it	eq
    2962:	moveq	r5, #1
    2964:	cmp	r4, #2
    2966:	orr.w	sl, r3, sl
    296a:	ldr.w	fp, [r6]
    296e:	strb.w	r2, [r9, #58]	; 0x3a
    2972:	strb.w	r2, [r9, #59]	; 0x3b
    2976:	bls.n	2a0a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
    2978:	ldr.w	r3, [r9, #16]
    297c:	ldrb.w	r2, [r9, #59]	; 0x3b
    2980:	cmp	r2, #31
    2982:	bhi.n	29aa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    2984:	ldr	r1, [r3, #92]	; 0x5c
    2986:	ubfx	r1, r1, #16, #3
    298a:	cbnz	r1, 2992 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x5a>
    298c:	b.n	29aa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    298e:	cmp	r2, #32
    2990:	beq.n	29aa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    2992:	add.w	lr, r2, #1
    2996:	add.w	r0, r9, r2
    299a:	subs	r1, #1
    299c:	uxtb.w	r2, lr
    29a0:	strb.w	r2, [r9, #59]	; 0x3b
    29a4:	ldr	r7, [r3, #112]	; 0x70
    29a6:	strb	r7, [r0, #26]
    29a8:	bne.n	298e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x56>
    29aa:	ldr	r2, [r3, #20]
    29ac:	lsls	r0, r2, #20
    29ae:	bmi.n	2a4a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x112>
    29b0:	tst.w	r2, #9216	; 0x2400
    29b4:	bne.n	29c0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x88>
    29b6:	ldr	r1, [r6, #0]
    29b8:	rsb	r1, fp, r1
    29bc:	cmp	r1, #50	; 0x32
    29be:	bls.n	29e6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xae>
    29c0:	ldr	r2, [r3, #16]
    29c2:	mov.w	r1, #512	; 0x200
    29c6:	orr.w	r2, r2, #768	; 0x300
    29ca:	str	r2, [r3, #16]
    29cc:	str	r1, [r3, #96]	; 0x60
    29ce:	ldr	r2, [r3, #92]	; 0x5c
    29d0:	tst.w	r2, #458752	; 0x70000
    29d4:	beq.n	29de <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
    29d6:	ldr	r2, [r3, #16]
    29d8:	orr.w	r2, r2, #512	; 0x200
    29dc:	str	r2, [r3, #16]
    29de:	ldrb.w	r0, [r9, #59]	; 0x3b
    29e2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    29e6:	ldrb.w	r1, [r9, #59]	; 0x3b
    29ea:	cmp	r1, r5
    29ec:	bcc.n	2a02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    29ee:	cmp	r4, #2
    29f0:	bls.n	2a02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    29f2:	ldr	r1, [r3, #92]	; 0x5c
    29f4:	lsls	r1, r1, #29
    29f6:	bne.n	2a02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    29f8:	lsls	r2, r2, #22
    29fa:	bmi.n	29ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    29fc:	cmp.w	r8, #0
    2a00:	beq.n	29ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    2a02:	bl	3d70 <yield>
    2a06:	cmp	r4, #2
    2a08:	bhi.n	2978 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x40>
    2a0a:	ldr.w	r2, [r9, #16]
    2a0e:	ldr	r3, [r2, #92]	; 0x5c
    2a10:	and.w	r3, r3, #7
    2a14:	cmp	r3, #3
    2a16:	bhi.n	2a34 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    2a18:	subs	r1, r5, #1
    2a1a:	mov.w	r0, #512	; 0x200
    2a1e:	orr.w	r1, r1, #256	; 0x100
    2a22:	cbnz	r4, 2a38 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x100>
    2a24:	str.w	sl, [r2, #96]	; 0x60
    2a28:	subs	r3, #1
    2a2a:	adds	r4, #1
    2a2c:	cmp	r3, #3
    2a2e:	bhi.n	2a34 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    2a30:	cmp	r4, #2
    2a32:	bls.n	2a22 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
    2a34:	mov	r3, r2
    2a36:	b.n	297c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
    2a38:	cmp	r4, #1
    2a3a:	beq.n	2a46 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10e>
    2a3c:	cmp.w	r8, #0
    2a40:	beq.n	2a28 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    2a42:	str	r0, [r2, #96]	; 0x60
    2a44:	b.n	2a28 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    2a46:	str	r1, [r2, #96]	; 0x60
    2a48:	b.n	2a28 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    2a4a:	ldr	r2, [r3, #16]
    2a4c:	orr.w	r2, r2, #768	; 0x300
    2a50:	str	r2, [r3, #16]
    2a52:	b.n	29ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    2a54:	.word	0x20001e74

00002a58 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    2a58:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    2a5a:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    2a5c:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    2a5e:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    2a60:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    2a62:	beq.n	2a6c <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    2a64:	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    2a68:	b.w	3e10 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    2a6c:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    2a6e:	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    2a72:	bx	r3

00002a74 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    2a74:	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    2a76:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    2a7a:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    2a7e:	bne.n	2b5c <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    2a80:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    2a82:	bcc.n	2b08 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    2a84:	ldr.w	r3, [r1], #4
    2a88:	str.w	r3, [r0], #4
    2a8c:	ldr.w	r3, [r1], #4
    2a90:	str.w	r3, [r0], #4
    2a94:	ldr.w	r3, [r1], #4
    2a98:	str.w	r3, [r0], #4
    2a9c:	ldr.w	r3, [r1], #4
    2aa0:	str.w	r3, [r0], #4
    2aa4:	ldr.w	r3, [r1], #4
    2aa8:	str.w	r3, [r0], #4
    2aac:	ldr.w	r3, [r1], #4
    2ab0:	str.w	r3, [r0], #4
    2ab4:	ldr.w	r3, [r1], #4
    2ab8:	str.w	r3, [r0], #4
    2abc:	ldr.w	r3, [r1], #4
    2ac0:	str.w	r3, [r0], #4
    2ac4:	ldr.w	r3, [r1], #4
    2ac8:	str.w	r3, [r0], #4
    2acc:	ldr.w	r3, [r1], #4
    2ad0:	str.w	r3, [r0], #4
    2ad4:	ldr.w	r3, [r1], #4
    2ad8:	str.w	r3, [r0], #4
    2adc:	ldr.w	r3, [r1], #4
    2ae0:	str.w	r3, [r0], #4
    2ae4:	ldr.w	r3, [r1], #4
    2ae8:	str.w	r3, [r0], #4
    2aec:	ldr.w	r3, [r1], #4
    2af0:	str.w	r3, [r0], #4
    2af4:	ldr.w	r3, [r1], #4
    2af8:	str.w	r3, [r0], #4
    2afc:	ldr.w	r3, [r1], #4
    2b00:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    2b04:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    2b06:	bcs.n	2a84 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    2b08:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    2b0a:	bcc.n	2b30 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    2b0c:	ldr.w	r3, [r1], #4
    2b10:	str.w	r3, [r0], #4
    2b14:	ldr.w	r3, [r1], #4
    2b18:	str.w	r3, [r0], #4
    2b1c:	ldr.w	r3, [r1], #4
    2b20:	str.w	r3, [r0], #4
    2b24:	ldr.w	r3, [r1], #4
    2b28:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    2b2c:	subs	r2, #16
	bhs	.Lmid_block_loop
    2b2e:	bcs.n	2b0c <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    2b30:	adds	r2, #12
	blo	.Lcopy_less_than_4
    2b32:	bcc.n	2b40 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    2b34:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    2b38:	str.w	r3, [r0], #4
	subs	r2, #4
    2b3c:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    2b3e:	bcs.n	2b34 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    2b40:	adds	r2, #4
	beq	.Ldone
    2b42:	beq.n	2b56 <memcpy+0xe2>

	lsls	r2, r2, #31
    2b44:	lsls	r2, r2, #31
	itt ne
    2b46:	itt	ne
	ldrbne  r3, [r1], #1
    2b48:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    2b4c:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    2b50:	bcc.n	2b56 <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    2b52:	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    2b54:	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    2b56:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    2b58:	bx	lr
    2b5a:	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    2b5c:	cmp	r2, #8
	blo	.Lbyte_copy
    2b5e:	bcc.n	2b88 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    2b60:	lsls	r3, r1, #30
	beq	.Ldst_aligned
    2b62:	beq.n	2a80 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    2b64:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    2b68:	beq.n	2a80 <memcpy+0xc>

	rsb	r3, #4
    2b6a:	rsb	r3, r3, #4
	subs	r2, r3
    2b6e:	subs	r2, r2, r3

	lsls    r3, r3, #31
    2b70:	lsls	r3, r3, #31
	itt ne
    2b72:	itt	ne
	ldrbne  r3, [r1], #1
    2b74:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    2b78:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    2b7c:	bcc.n	2a80 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    2b7e:	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    2b82:	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    2b86:	b.n	2a80 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    2b88:	subs	r2, #4
	blo	.Lcopy_less_than_4
    2b8a:	bcc.n	2b40 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    2b8c:	subs	r2, #1
	ldrb    r3, [r1], #1
    2b8e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    2b92:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    2b96:	bcs.n	2b8c <memcpy+0x118>

	ldrb	r3, [r1]
    2b98:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    2b9a:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    2b9c:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    2b9e:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    2ba0:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    2ba2:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    2ba4:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    2ba6:	bx	lr

00002ba8 <unused_interrupt_vector>:
//  R0
// Code from :: https://community.nxp.com/thread/389002
__attribute__((naked))
void unused_interrupt_vector(void)
{
  __asm( ".syntax unified\n"
    2ba8:	movs	r0, #4
    2baa:	mov	r1, lr
    2bac:	tst	r0, r1
    2bae:	beq.n	2bb8 <_MSP>
    2bb0:	mrs	r0, PSP
    2bb4:	b.w	2bc8 <HardFault_HandlerC>

00002bb8 <_MSP>:
    2bb8:	mrs	r0, MSP
    2bbc:	b.w	2bc8 <HardFault_HandlerC>

00002bc0 <startup_default_early_hook>:
         "B HardFault_HandlerC \n"
         "_MSP: \n"
         "MRS R0, MSP \n"
         "B HardFault_HandlerC \n"
         ".syntax divided\n") ;
}
    2bc0:	bx	lr
    2bc2:	nop

00002bc4 <startup_default_late_hook>:


extern int main (void);
void startup_default_early_hook(void) {}
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
    2bc4:	bx	lr
    2bc6:	nop

00002bc8 <HardFault_HandlerC>:
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2bc8:	ldr	r3, [pc, #108]	; (2c38 <HardFault_HandlerC+0x70>)
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    2bca:	movs	r1, #5
    2bcc:	ldr	r2, [pc, #108]	; (2c3c <HardFault_HandlerC+0x74>)
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    2bce:	movs	r0, #56	; 0x38
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    2bd0:	push	{r4, r5, lr}
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    2bd2:	str.w	r1, [r2, #328]	; 0x148
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
  GPIO2_DR_SET = (1 << 3);
    2bd6:	movs	r1, #8
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    2bd8:	str.w	r0, [r2, #824]	; 0x338
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    2bdc:	sub	sp, #12
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2bde:	ldr	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
    2be0:	ldr	r4, [pc, #92]	; (2c40 <HardFault_HandlerC+0x78>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2be2:	orrs	r2, r1
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
    2be4:	ldr	r0, [pc, #92]	; (2c44 <HardFault_HandlerC+0x7c>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    2be6:	str	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
    2be8:	str.w	r1, [r3, #132]	; 0x84
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    2bec:	str.w	r1, [r3, #136]	; 0x88

  if ( F_CPU_ACTUAL >= 600000000 )
    2bf0:	ldr	r3, [r4, #0]
    2bf2:	cmp	r3, r0
    2bf4:	bls.n	2bfc <HardFault_HandlerC+0x34>
    set_arm_clock(300000000);
    2bf6:	ldr	r0, [pc, #80]	; (2c48 <HardFault_HandlerC+0x80>)
    2bf8:	bl	2cac <set_arm_clock>

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    2bfc:	ldr	r5, [pc, #56]	; (2c38 <HardFault_HandlerC+0x70>)
    2bfe:	movs	r4, #8
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    2c00:	movs	r0, #0
    2c02:	ldr	r2, [pc, #72]	; (2c4c <HardFault_HandlerC+0x84>)
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    2c04:	ldr	r1, [pc, #72]	; (2c50 <HardFault_HandlerC+0x88>)
  if ( F_CPU_ACTUAL >= 600000000 )
    set_arm_clock(300000000);

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    2c06:	str.w	r4, [r5, #132]	; 0x84
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    2c0a:	str	r0, [sp, #4]
    2c0c:	ldr	r3, [sp, #4]
    2c0e:	cmp	r3, r2
    2c10:	bhi.n	2c1e <HardFault_HandlerC+0x56>
    2c12:	ldr	r3, [sp, #4]
    2c14:	adds	r3, #1
    2c16:	str	r3, [sp, #4]
    2c18:	ldr	r3, [sp, #4]
    2c1a:	cmp	r3, r2
    2c1c:	bls.n	2c12 <HardFault_HandlerC+0x4a>
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    2c1e:	str.w	r4, [r5, #136]	; 0x88
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    2c22:	str	r0, [sp, #4]
    2c24:	ldr	r3, [sp, #4]
    2c26:	cmp	r3, r1
    2c28:	bhi.n	2c06 <HardFault_HandlerC+0x3e>
    2c2a:	ldr	r3, [sp, #4]
    2c2c:	adds	r3, #1
    2c2e:	str	r3, [sp, #4]
    2c30:	ldr	r3, [sp, #4]
    2c32:	cmp	r3, r1
    2c34:	bls.n	2c2a <HardFault_HandlerC+0x62>
    2c36:	b.n	2c06 <HardFault_HandlerC+0x3e>
    2c38:	.word	0x401bc000
    2c3c:	.word	0x401f8000
    2c40:	.word	0x20000ff4
    2c44:	.word	0x23c345ff
    2c48:	.word	0x11e1a300
    2c4c:	.word	0x000f423f
    2c50:	.word	0x0089543f

00002c54 <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    2c54:	ldr	r2, [pc, #36]	; (2c7c <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    2c56:	push	{r3, lr}
        char *prev = __brkval;
    2c58:	ldr	r3, [r2, #0]
        if (incr != 0) {
    2c5a:	cbz	r0, 2c66 <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    2c5c:	add	r0, r3
    2c5e:	ldr	r1, [pc, #32]	; (2c80 <_sbrk+0x2c>)
    2c60:	cmp	r0, r1
    2c62:	bhi.n	2c6a <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    2c64:	str	r0, [r2, #0]
        }
        return prev;
}
    2c66:	mov	r0, r3
    2c68:	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    2c6a:	bl	7bb4 <__errno>
    2c6e:	movs	r2, #12
                        return (void *)-1;
    2c70:	mov.w	r3, #4294967295
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    2c74:	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    2c76:	mov	r0, r3
    2c78:	pop	{r3, pc}
    2c7a:	nop
    2c7c:	.word	0x20000fec
    2c80:	.word	0x20280000

00002c84 <_read>:

__attribute__((weak))
int _read(int file, char *ptr, int len)
{
	return 0;
}
    2c84:	movs	r0, #0
    2c86:	bx	lr

00002c88 <_close>:

__attribute__((weak))
int _close(int fd)
{
	return -1;
}
    2c88:	mov.w	r0, #4294967295
    2c8c:	bx	lr
    2c8e:	nop

00002c90 <_fstat>:
#include <sys/stat.h>

__attribute__((weak))
int _fstat(int fd, struct stat *st)
{
	st->st_mode = S_IFCHR;
    2c90:	mov.w	r3, #8192	; 0x2000
	return 0;
}
    2c94:	movs	r0, #0
#include <sys/stat.h>

__attribute__((weak))
int _fstat(int fd, struct stat *st)
{
	st->st_mode = S_IFCHR;
    2c96:	str	r3, [r1, #4]
	return 0;
}
    2c98:	bx	lr
    2c9a:	nop

00002c9c <_isatty>:

__attribute__((weak))
int _isatty(int fd)
{
	return 1;
}
    2c9c:	movs	r0, #1
    2c9e:	bx	lr

00002ca0 <_lseek>:

__attribute__((weak))
int _lseek(int fd, long long offset, int whence)
{
	return -1;
}
    2ca0:	mov.w	r0, #4294967295
    2ca4:	bx	lr
    2ca6:	nop

00002ca8 <abort>:
}

__attribute__((weak))
void abort(void)
{
	while (1) asm ("WFI");
    2ca8:	wfi
    2caa:	b.n	2ca8 <abort>

00002cac <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    2cac:	ldr	r2, [pc, #600]	; (2f08 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    2cae:	ldr	r3, [pc, #604]	; (2f0c <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    2cb0:	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
    2cb2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
    2cb6:	ldr	r4, [pc, #600]	; (2f10 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    2cb8:	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    2cbc:	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    2cbe:	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    2cc0:	bls.n	2cfc <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    2cc2:	ldr	r3, [pc, #592]	; (2f14 <set_arm_clock+0x268>)
    2cc4:	cmp	r0, r3
    2cc6:	bls.w	2ef4 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    2cca:	ldr	r3, [pc, #588]	; (2f18 <set_arm_clock+0x26c>)
    2ccc:	movw	r5, #1575	; 0x627
    2cd0:	ldr	r7, [pc, #584]	; (2f1c <set_arm_clock+0x270>)
    2cd2:	add	r3, r0
    2cd4:	ldr	r4, [pc, #584]	; (2f20 <set_arm_clock+0x274>)
    2cd6:	lsrs	r2, r3, #8
    2cd8:	umull	r3, r2, r7, r2
    2cdc:	lsrs	r3, r2, #7
    2cde:	add.w	r3, r3, r3, lsl #2
    2ce2:	add.w	r2, r3, r3, lsl #2
    2ce6:	addw	r3, r2, #1250	; 0x4e2
    2cea:	cmp	r3, r5
    2cec:	it	cs
    2cee:	movcs	r3, r5
    2cf0:	sub.w	r3, r3, #800	; 0x320
    2cf4:	umull	r3, r5, r4, r3
    2cf8:	lsrs	r5, r5, #3
    2cfa:	b.n	2d06 <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
    2cfc:	ldr	r5, [pc, #548]	; (2f24 <set_arm_clock+0x278>)
    2cfe:	cmp	r0, r5
    2d00:	ite	ls
    2d02:	movls	r5, #6
    2d04:	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    2d06:	ldr	r2, [pc, #516]	; (2f0c <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    2d08:	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    2d0c:	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    2d10:	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    2d12:	orr.w	r3, r3, #192	; 0xc0
    2d16:	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    2d1a:	bcs.n	2d32 <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    2d1c:	ldr	r3, [pc, #496]	; (2f10 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    2d1e:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    2d22:	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    2d24:	orrs	r6, r5
		DCDC_REG3 = dcdc;
    2d26:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    2d28:	ldr	r3, [r2, #0]
    2d2a:	cmp	r3, #0
    2d2c:	bge.n	2d28 <set_arm_clock+0x7c>
    2d2e:	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    2d32:	ands.w	r3, lr, #33554432	; 0x2000000
    2d36:	bne.n	2d9c <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    2d38:	ldr	r4, [pc, #492]	; (2f28 <set_arm_clock+0x27c>)
    2d3a:	ldr	r2, [pc, #496]	; (2f2c <set_arm_clock+0x280>)
    2d3c:	ldr.w	ip, [r4, #16]
    2d40:	mov	r4, r2
    2d42:	and.w	r2, ip, r2
    2d46:	cmp	r2, r4
    2d48:	itet	eq
    2d4a:	moveq.w	r3, #402653184	; 0x18000000
    2d4e:	movne.w	r2, #4096	; 0x1000
    2d52:	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    2d54:	eor.w	r4, lr, r3
    2d58:	tst.w	r4, #939524096	; 0x38000000
    2d5c:	beq.n	2d70 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    2d5e:	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    2d62:	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
    2d66:	ldr	r4, [pc, #420]	; (2f0c <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    2d68:	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
    2d6c:	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    2d70:	eor.w	r3, r1, r2
    2d74:	tst.w	r3, #12288	; 0x3000
    2d78:	beq.n	2d8c <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    2d7a:	ldr	r3, [pc, #400]	; (2f0c <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    2d7c:	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    2d80:	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    2d82:	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    2d84:	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    2d86:	ldr	r3, [r2, #72]	; 0x48
    2d88:	lsls	r4, r3, #28
    2d8a:	bmi.n	2d86 <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    2d8c:	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    2d90:	ldr	r2, [pc, #376]	; (2f0c <set_arm_clock+0x260>)
    2d92:	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    2d96:	ldr	r3, [r2, #72]	; 0x48
    2d98:	lsls	r1, r3, #26
    2d9a:	bmi.n	2d96 <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    2d9c:	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    2d9e:	ldr	r4, [pc, #400]	; (2f30 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    2da0:	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    2da2:	mul.w	r3, r1, r2
    2da6:	mul.w	r3, r0, r3
    2daa:	cmp	r3, r4
    2dac:	bhi.n	2dc2 <set_arm_clock+0x116>
		if (div_arm < 8) {
    2dae:	cmp	r2, #7
    2db0:	bhi.w	2ede <set_arm_clock+0x232>
			div_arm = div_arm + 1;
    2db4:	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    2db6:	mul.w	r3, r1, r2
    2dba:	mul.w	r3, r0, r3
    2dbe:	cmp	r3, r4
    2dc0:	bls.n	2dae <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    2dc2:	ldr	r0, [pc, #368]	; (2f34 <set_arm_clock+0x288>)
    2dc4:	ldr	r4, [pc, #368]	; (2f38 <set_arm_clock+0x28c>)
    2dc6:	add	r0, r3
    2dc8:	umull	r0, r3, r4, r0
    2dcc:	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    2dce:	cmp	r3, #108	; 0x6c
    2dd0:	bhi.w	2eea <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
    2dd4:	cmp	r3, #53	; 0x35
    2dd6:	bhi.w	2ef8 <set_arm_clock+0x24c>
    2dda:	ldr.w	r8, [pc, #392]	; 2f64 <set_arm_clock+0x2b8>
    2dde:	movs	r3, #54	; 0x36
    2de0:	ldr	r0, [pc, #344]	; (2f3c <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    2de2:	ldr.w	ip, [pc, #324]	; 2f28 <set_arm_clock+0x27c>
    2de6:	ldr	r4, [pc, #344]	; (2f40 <set_arm_clock+0x294>)
    2de8:	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    2dec:	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    2df0:	and.w	r4, r9, r4
    2df4:	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    2df6:	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    2dfa:	beq.n	2e14 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    2dfc:	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    2e00:	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    2e04:	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    2e06:	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    2e0a:	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    2e0e:	ldr	r3, [r4, #0]
    2e10:	cmp	r3, #0
    2e12:	bge.n	2e0e <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    2e14:	ldr.w	ip, [pc, #244]	; 2f0c <set_arm_clock+0x260>
    2e18:	subs	r2, #1
    2e1a:	ldr.w	r3, [ip, #16]
    2e1e:	and.w	r3, r3, #7
    2e22:	cmp	r3, r2
    2e24:	beq.n	2e36 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    2e26:	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    2e2a:	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    2e2c:	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    2e30:	ldr	r3, [r4, #72]	; 0x48
    2e32:	lsls	r3, r3, #15
    2e34:	bmi.n	2e30 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    2e36:	subs	r1, #1
    2e38:	lsls	r1, r1, #10
    2e3a:	eor.w	r3, lr, r1
    2e3e:	tst.w	r3, #7168	; 0x1c00
    2e42:	beq.n	2e5e <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    2e44:	ldr	r3, [pc, #196]	; (2f0c <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    2e46:	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    2e4a:	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    2e4e:	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    2e50:	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    2e54:	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    2e58:	ldr	r3, [r2, #72]	; 0x48
    2e5a:	lsls	r1, r3, #30
    2e5c:	bmi.n	2e58 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    2e5e:	ldr	r3, [pc, #228]	; (2f44 <set_arm_clock+0x298>)
    2e60:	ldr	r1, [pc, #228]	; (2f48 <set_arm_clock+0x29c>)
    2e62:	add	r3, r0
    2e64:	lsrs	r3, r3, #7
    2e66:	umull	r3, r1, r1, r3
    2e6a:	lsrs	r1, r1, #12
    2e6c:	cmp	r1, #4
    2e6e:	it	cs
    2e70:	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    2e72:	subs	r3, r1, #1
    2e74:	lsls	r3, r3, #8
    2e76:	eor.w	r2, lr, r3
    2e7a:	tst.w	r2, #768	; 0x300
    2e7e:	beq.n	2e90 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    2e80:	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    2e84:	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    2e88:	ldr	r2, [pc, #128]	; (2f0c <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    2e8a:	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    2e8e:	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    2e90:	ldr	r3, [pc, #120]	; (2f0c <set_arm_clock+0x260>)
    2e92:	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    2e94:	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    2e96:	bic.w	r4, r4, #33554432	; 0x2000000
    2e9a:	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    2e9c:	ldr	r3, [r2, #72]	; 0x48
    2e9e:	lsls	r3, r3, #26
    2ea0:	bmi.n	2e9c <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    2ea2:	ldr	r3, [pc, #168]	; (2f4c <set_arm_clock+0x2a0>)
    2ea4:	mov.w	r2, #4294967295
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    2ea8:	ldr	r4, [pc, #164]	; (2f50 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    2eaa:	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    2eac:	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    2eb0:	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    2eb2:	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    2eb6:	ldr	r4, [pc, #156]	; (2f54 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    2eb8:	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    2ebc:	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    2ec0:	ldr	r2, [pc, #148]	; (2f58 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    2ec2:	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    2ec4:	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    2ec6:	bcs.n	2eda <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    2ec8:	ldr	r3, [pc, #68]	; (2f10 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    2eca:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    2ece:	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    2ed0:	orrs	r6, r5
		DCDC_REG3 = dcdc;
    2ed2:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    2ed4:	ldr	r3, [r2, #0]
    2ed6:	cmp	r3, #0
    2ed8:	bge.n	2ed4 <set_arm_clock+0x228>
	}

	return frequency;
}
    2eda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    2ede:	cmp	r1, #4
    2ee0:	bhi.w	2dc2 <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    2ee4:	adds	r1, #1
				div_arm = 1;
    2ee6:	movs	r2, #1
    2ee8:	b.n	2da2 <set_arm_clock+0xf6>
    2eea:	ldr.w	r8, [pc, #124]	; 2f68 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    2eee:	movs	r3, #108	; 0x6c
    2ef0:	ldr	r0, [pc, #104]	; (2f5c <set_arm_clock+0x2b0>)
    2ef2:	b.n	2de2 <set_arm_clock+0x136>
    2ef4:	movs	r5, #18
    2ef6:	b.n	2d06 <set_arm_clock+0x5a>
    2ef8:	ldr	r0, [pc, #100]	; (2f60 <set_arm_clock+0x2b4>)
    2efa:	ldr.w	r8, [pc, #112]	; 2f6c <set_arm_clock+0x2c0>
    2efe:	mul.w	r0, r0, r3
    2f02:	orr.w	r8, r3, r8
    2f06:	b.n	2de2 <set_arm_clock+0x136>
    2f08:	.word	0x1f78a400
    2f0c:	.word	0x400fc000
    2f10:	.word	0x40080000
    2f14:	.word	0x23c34600
    2f18:	.word	0xdc3cba00
    2f1c:	.word	0x004cb223
    2f20:	.word	0x51eb851f
    2f24:	.word	0x016e3600
    2f28:	.word	0x400d8000
    2f2c:	.word	0x80003040
    2f30:	.word	0x269fb1ff
    2f34:	.word	0x005b8d80
    2f38:	.word	0x165e9f81
    2f3c:	.word	0x269fb200
    2f40:	.word	0x8001307f
    2f44:	.word	0x08f0d17f
    2f48:	.word	0x00e5109f
    2f4c:	.word	0x431bde83
    2f50:	.word	0x20000ff4
    2f54:	.word	0x20000ff0
    2f58:	.word	0x20001e70
    2f5c:	.word	0x4d3f6400
    2f60:	.word	0x00b71b00
    2f64:	.word	0x80002036
    2f68:	.word	0x8000206c
    2f6c:	.word	0x80002000

00002f70 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    2f70:	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    2f72:	push	{r4, r5}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    2f74:	cbz	r3, 2f7e <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    2f76:	ldr	r3, [r2, #4]
    2f78:	orr.w	r3, r3, #32768	; 0x8000
    2f7c:	str	r3, [r2, #4]
	}
	__disable_irq();
    2f7e:	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    2f80:	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    2f82:	cbz	r4, 2fac <schedule_transfer+0x3c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    2f84:	ldr	r3, [pc, #64]	; (2fc8 <schedule_transfer+0x58>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    2f86:	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    2f88:	ldr.w	r4, [r3, #432]	; 0x1b0
    2f8c:	tst	r4, r1
    2f8e:	bne.n	2fc0 <schedule_transfer+0x50>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    2f90:	ldr.w	r4, [r3, #320]	; 0x140
    2f94:	orr.w	r4, r4, #16384	; 0x4000
    2f98:	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    2f9c:	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW));
    2fa0:	ldr.w	r4, [r3, #320]	; 0x140
    2fa4:	lsls	r4, r4, #17
    2fa6:	bpl.n	2f90 <schedule_transfer+0x20>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    2fa8:	tst	r1, r5
    2faa:	bne.n	2fc0 <schedule_transfer+0x50>
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
    2fac:	movs	r3, #0
	USB1_ENDPTPRIME |= epmask;
    2fae:	ldr	r4, [pc, #24]	; (2fc8 <schedule_transfer+0x58>)
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    2fb0:	str	r2, [r0, #8]
	endpoint->status = 0;
    2fb2:	str	r3, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    2fb4:	ldr.w	r3, [r4, #432]	; 0x1b0
    2fb8:	orrs	r1, r3
    2fba:	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    2fbe:	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    2fc0:	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    2fc2:	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    2fc4:	pop	{r4, r5}
    2fc6:	bx	lr
    2fc8:	.word	0x402e0000

00002fcc <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    2fcc:	push	{r4, r5, r6, lr}
    2fce:	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    2fd0:	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    2fd2:	cbz	r0, 2ffa <run_callbacks+0x2e>
    2fd4:	mov	r2, r0
    2fd6:	movs	r4, #0
    2fd8:	b.n	2fe2 <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    2fda:	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    2fdc:	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    2fde:	cmp	r2, #1
    2fe0:	beq.n	2ffc <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    2fe2:	ldr	r3, [r2, #4]
    2fe4:	ands.w	r3, r3, #128	; 0x80
    2fe8:	beq.n	2fda <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    2fea:	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    2fec:	cbz	r4, 2ffa <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    2fee:	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    2ff0:	ldr	r5, [r0, #0]
		ep->callback_function(first);
    2ff2:	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    2ff4:	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    2ff6:	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    2ff8:	bne.n	2fee <run_callbacks+0x22>
    2ffa:	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    2ffc:	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    2ffe:	str	r3, [r6, #52]	; 0x34
			break;
    3000:	b.n	2fec <run_callbacks+0x20>
    3002:	nop

00003004 <endpoint0_transmit.constprop.1>:
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    3004:	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    3006:	cbnz	r1, 3046 <endpoint0_transmit.constprop.1+0x42>
    3008:	ldr	r4, [pc, #136]	; (3094 <endpoint0_transmit.constprop.1+0x90>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    300a:	ldr	r1, [pc, #140]	; (3098 <endpoint0_transmit.constprop.1+0x94>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    300c:	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    300e:	ldr	r3, [pc, #140]	; (309c <endpoint0_transmit.constprop.1+0x98>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3010:	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3012:	movs	r5, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    3014:	str	r1, [r4, #8]
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3016:	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    3018:	mov	r2, r3
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    301a:	str	r5, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    301c:	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    301e:	ldr.w	r4, [r3, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3022:	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3024:	orr.w	r4, r4, #65537	; 0x10001
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    3028:	ldr	r5, [pc, #116]	; (30a0 <endpoint0_transmit.constprop.1+0x9c>)
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    302a:	str.w	r4, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    302e:	ldr.w	r1, [r3, #432]	; 0x1b0
    3032:	orr.w	r1, r1, #1
    3036:	str.w	r1, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    303a:	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    303c:	ldr.w	r3, [r2, #432]	; 0x1b0
    3040:	cmp	r3, #0
    3042:	bne.n	303c <endpoint0_transmit.constprop.1+0x38>
}
    3044:	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3046:	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3048:	ldr	r3, [pc, #88]	; (30a4 <endpoint0_transmit.constprop.1+0xa0>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    304a:	ldr	r5, [pc, #80]	; (309c <endpoint0_transmit.constprop.1+0x98>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    304c:	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    304e:	ldr	r4, [pc, #68]	; (3094 <endpoint0_transmit.constprop.1+0x90>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3050:	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    3054:	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3056:	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3058:	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    305a:	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    305e:	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    3060:	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    3064:	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    3066:	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    306a:	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    306e:	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    3072:	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    3074:	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    3076:	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    307a:	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    307e:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    3082:	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    3084:	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    3086:	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    308a:	ldr.w	r3, [r2, #432]	; 0x1b0
    308e:	cmp	r3, #0
    3090:	bne.n	308a <endpoint0_transmit.constprop.1+0x86>
    3092:	b.n	300a <endpoint0_transmit.constprop.1+0x6>
    3094:	.word	0x20004000
    3098:	.word	0x20003020
    309c:	.word	0x402e0000
    30a0:	.word	0x20001e44
    30a4:	.word	0x20003000

000030a8 <isr>:
	//transfer_log_count = 0;
}


static void isr(void)
{
    30a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    30ac:	ldr	r4, [pc, #752]	; (33a0 <isr+0x2f8>)
	//transfer_log_count = 0;
}


static void isr(void)
{
    30ae:	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    30b0:	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    30b4:	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    30b8:	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    30bc:	beq.n	317c <isr+0xd4>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    30be:	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    30c2:	cmp	r3, #0
    30c4:	beq.n	3172 <isr+0xca>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    30c6:	mov.w	fp, #65537	; 0x10001
    30ca:	ldr.w	r9, [pc, #764]	; 33c8 <isr+0x320>
    30ce:	ldr	r6, [pc, #724]	; (33a4 <isr+0x2fc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    30d0:	mov	r5, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    30d2:	mov	sl, fp
    30d4:	ldr	r0, [r6, #40]	; 0x28
    30d6:	ldr	r2, [r6, #44]	; 0x2c
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    30d8:	str.w	r3, [r4, #428]	; 0x1ac
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    30dc:	ldr.w	r3, [r4, #320]	; 0x140
    30e0:	orr.w	r3, r3, #8192	; 0x2000
    30e4:	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    30e8:	ldr.w	r3, [r4, #320]	; 0x140
    30ec:	lsls	r7, r3, #18
    30ee:	bpl.n	30dc <isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    30f0:	ldr.w	r3, [r5, #320]	; 0x140
    30f4:	bic.w	r3, r3, #8192	; 0x2000
    30f8:	str.w	r3, [r5, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    30fc:	str.w	sl, [r5, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    3100:	ldr.w	r3, [r4, #436]	; 0x1b4
    3104:	ands.w	r3, r3, #65537	; 0x10001
    3108:	bne.n	3100 <isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    310a:	uxth	r1, r0
    310c:	movw	r7, #1665	; 0x681
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    3110:	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3114:	cmp	r1, r7
    3116:	bhi.w	3264 <isr+0x1bc>
    311a:	cmp.w	r1, #1664	; 0x680
    311e:	bcs.w	34f8 <isr+0x450>
    3122:	cmp.w	r1, #258	; 0x102
    3126:	beq.w	33fe <isr+0x356>
    312a:	bhi.w	32f6 <isr+0x24e>
    312e:	cmp	r1, #128	; 0x80
    3130:	beq.w	33e4 <isr+0x33c>
    3134:	cmp	r1, #130	; 0x82
    3136:	bne.w	32e6 <isr+0x23e>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    313a:	uxth	r2, r2
    313c:	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    3140:	cmp	r1, #7
    3142:	bhi.w	32e6 <isr+0x23e>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    3146:	lsls	r1, r1, #2
    3148:	ldr	r0, [pc, #604]	; (33a8 <isr+0x300>)
		reply_buffer[0] = 0;
    314a:	ldr	r7, [pc, #608]	; (33ac <isr+0x304>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    314c:	add	r0, r1
    314e:	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    3150:	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    3152:	strb	r3, [r7, #0]
		reply_buffer[1] = 0;
    3154:	strb	r3, [r7, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    3156:	bpl.w	3576 <isr+0x4ce>
    315a:	lsls	r2, r1, #15
    315c:	bpl.n	3162 <isr+0xba>
			reply_buffer[0] = 1;
    315e:	movs	r3, #1
    3160:	strb	r3, [r7, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    3162:	movs	r1, #2
    3164:	ldr	r0, [pc, #580]	; (33ac <isr+0x304>)
    3166:	bl	3004 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    316a:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    316e:	cmp	r3, #0
    3170:	bne.n	30d4 <isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    3172:	ldr	r2, [pc, #556]	; (33a0 <isr+0x2f8>)
    3174:	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    3178:	cmp	r3, #0
    317a:	bne.n	321e <isr+0x176>
					}
				}
			}
		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    317c:	tst.w	r8, #64	; 0x40
    3180:	beq.n	31b4 <isr+0x10c>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    3182:	ldr	r3, [pc, #540]	; (33a0 <isr+0x2f8>)
    3184:	ldr.w	r1, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    3188:	mov	r2, r3
				}
			}
		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    318a:	str.w	r1, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    318e:	ldr.w	r1, [r3, #444]	; 0x1bc
    3192:	str.w	r1, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    3196:	ldr.w	r4, [r2, #432]	; 0x1b0
    319a:	ldr	r3, [pc, #516]	; (33a0 <isr+0x2f8>)
    319c:	cmp	r4, #0
    319e:	bne.n	3196 <isr+0xee>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    31a0:	mov.w	r2, #4294967295
    31a4:	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    31a8:	ldr.w	r3, [r3, #388]	; 0x184
			// we took too long to respond :(
			// TODO; is this ever really a problem?
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
    31ac:	bl	4284 <usb_serial_reset>
		#endif
		endpointN_notify_mask = 0;
    31b0:	ldr	r3, [pc, #508]	; (33b0 <isr+0x308>)
    31b2:	str	r4, [r3, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    31b4:	tst.w	r8, #16777216	; 0x1000000
    31b8:	beq.n	31c2 <isr+0x11a>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    31ba:	ldr	r3, [pc, #504]	; (33b4 <isr+0x30c>)
    31bc:	ldr	r3, [r3, #0]
    31be:	cbz	r3, 31c2 <isr+0x11a>
    31c0:	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    31c2:	tst.w	r8, #33554432	; 0x2000000
    31c6:	beq.n	31d0 <isr+0x128>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    31c8:	ldr	r3, [pc, #492]	; (33b8 <isr+0x310>)
    31ca:	ldr	r3, [r3, #0]
    31cc:	cbz	r3, 31d0 <isr+0x128>
    31ce:	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    31d0:	tst.w	r8, #4
    31d4:	beq.n	31e8 <isr+0x140>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    31d6:	ldr	r3, [pc, #456]	; (33a0 <isr+0x2f8>)
    31d8:	ldr.w	r3, [r3, #388]	; 0x184
    31dc:	ands.w	r3, r3, #512	; 0x200
    31e0:	beq.n	325e <isr+0x1b6>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    31e2:	ldr	r3, [pc, #472]	; (33bc <isr+0x314>)
    31e4:	movs	r2, #1
    31e6:	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    31e8:	ldr	r3, [pc, #436]	; (33a0 <isr+0x2f8>)
    31ea:	ldr.w	r2, [r3, #328]	; 0x148
    31ee:	lsls	r2, r2, #24
    31f0:	bpl.n	3218 <isr+0x170>
    31f2:	tst.w	r8, #128	; 0x80
    31f6:	beq.n	3218 <isr+0x170>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    31f8:	ldr	r1, [pc, #452]	; (33c0 <isr+0x318>)
    31fa:	ldrb	r2, [r1, #0]
    31fc:	cbz	r2, 3218 <isr+0x170>
			if (--usb_reboot_timer == 0) {
    31fe:	subs	r2, #1
    3200:	uxtb	r2, r2
    3202:	strb	r2, [r1, #0]
    3204:	cbnz	r2, 3218 <isr+0x170>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    3206:	ldr	r1, [pc, #444]	; (33c4 <isr+0x31c>)
    3208:	ldrb	r2, [r1, #0]
    320a:	and.w	r2, r2, #251	; 0xfb
    320e:	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    3210:	cmp	r2, #0
    3212:	beq.w	367a <isr+0x5d2>
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				asm("bkpt #251"); // run bootloader
    3216:	bkpt	0x00fb
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    3218:	add	sp, #12
    321a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    321e:	ldr	r1, [pc, #424]	; (33c8 <isr+0x320>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    3220:	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    3224:	ldr	r0, [r1, #0]
    3226:	tst	r3, r0
    3228:	bne.w	3602 <isr+0x55a>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    322c:	ldr	r2, [pc, #384]	; (33b0 <isr+0x308>)
    322e:	ldr	r4, [r2, #0]
			if (completestatus) {
    3230:	ands	r4, r3
    3232:	beq.n	317c <isr+0xd4>
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
    3234:	lsls	r3, r4, #29
    3236:	bmi.w	3698 <isr+0x5f0>
						run_callbacks(endpoint_queue_head + i * 2);
					}
					if (completestatus & (1 << (i + 16))) { // transmit
    323a:	lsls	r7, r4, #13
    323c:	bmi.w	3690 <isr+0x5e8>
			}
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
    3240:	lsls	r6, r4, #28
    3242:	bmi.w	36a8 <isr+0x600>
						run_callbacks(endpoint_queue_head + i * 2);
					}
					if (completestatus & (1 << (i + 16))) { // transmit
    3246:	lsls	r5, r4, #12
    3248:	bmi.w	36a0 <isr+0x5f8>
			}
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
    324c:	lsls	r0, r4, #27
    324e:	bmi.w	3688 <isr+0x5e0>
						run_callbacks(endpoint_queue_head + i * 2);
					}
					if (completestatus & (1 << (i + 16))) { // transmit
    3252:	lsls	r1, r4, #11
    3254:	bpl.n	317c <isr+0xd4>
						run_callbacks(endpoint_queue_head + i * 2 + 1);
    3256:	ldr	r0, [pc, #372]	; (33cc <isr+0x324>)
    3258:	bl	2fcc <run_callbacks>
    325c:	b.n	317c <isr+0xd4>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    325e:	ldr	r2, [pc, #348]	; (33bc <isr+0x314>)
    3260:	strb	r3, [r2, #0]
    3262:	b.n	31e8 <isr+0x140>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    3264:	movw	r7, #8225	; 0x2021
    3268:	cmp	r1, r7
    326a:	beq.n	32de <isr+0x236>
    326c:	bhi.n	334e <isr+0x2a6>
    326e:	cmp.w	r1, #2176	; 0x880
    3272:	beq.w	34dc <isr+0x434>
    3276:	cmp.w	r1, #2304	; 0x900
    327a:	bne.n	32e6 <isr+0x23e>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    327c:	ubfx	r0, r0, #16, #8
    3280:	ldr	r2, [pc, #332]	; (33d0 <isr+0x328>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    3282:	ldr	r1, [pc, #336]	; (33d4 <isr+0x32c>)
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    3284:	strb	r0, [r2, #0]
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    3286:	ldr	r7, [pc, #336]	; (33d8 <isr+0x330>)
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    3288:	ldr	r2, [pc, #336]	; (33dc <isr+0x334>)
    328a:	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    328c:	str.w	r7, [r5, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    3290:	str.w	r1, [r5, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    3294:	str.w	r2, [r5, #464]	; 0x1d0
		#endif
		#if defined(ENDPOINT7_CONFIG)
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
    3298:	bl	4288 <usb_serial_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    329c:	ldr	r2, [pc, #320]	; (33e0 <isr+0x338>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    329e:	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    32a0:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    32a2:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    32a4:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    32a6:	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    32a8:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    32aa:	ldr.w	r1, [r5, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    32ae:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    32b0:	orr.w	r1, r1, #65537	; 0x10001
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    32b4:	str	r2, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    32b6:	str.w	r1, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    32ba:	ldr.w	r2, [r5, #432]	; 0x1b0
    32be:	orr.w	r2, r2, #65536	; 0x10000
    32c2:	str.w	r2, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    32c6:	ldr	r2, [pc, #256]	; (33c8 <isr+0x320>)
    32c8:	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    32ca:	ldr.w	r3, [r4, #432]	; 0x1b0
    32ce:	cmp	r3, #0
    32d0:	bne.n	32ca <isr+0x222>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    32d2:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    32d6:	cmp	r3, #0
    32d8:	bne.w	30d4 <isr+0x2c>
    32dc:	b.n	3172 <isr+0xca>
		usb_cdc_line_rtsdtr = setup.wValue;
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
    32de:	lsrs	r1, r2, #16
    32e0:	cmp	r1, #7
    32e2:	beq.w	357e <isr+0x4d6>
			return;
		}
		break;
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    32e6:	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    32ea:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    32ee:	cmp	r3, #0
    32f0:	bne.w	30d4 <isr+0x2c>
    32f4:	b.n	3172 <isr+0xca>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    32f6:	movw	r7, #770	; 0x302
    32fa:	cmp	r1, r7
    32fc:	beq.w	3476 <isr+0x3ce>
    3300:	cmp.w	r1, #1280	; 0x500
    3304:	bne.n	32e6 <isr+0x23e>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3306:	ldr	r2, [pc, #216]	; (33e0 <isr+0x338>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3308:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    330a:	movs	r7, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    330c:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    330e:	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3310:	str	r7, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3312:	ldr.w	r1, [r5, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3316:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3318:	orr.w	r3, r1, #65537	; 0x10001
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    331c:	str	r2, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    331e:	str.w	r3, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3322:	ldr.w	r3, [r5, #432]	; 0x1b0
    3326:	orr.w	r3, r3, #65536	; 0x10000
    332a:	str.w	r3, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    332e:	ldr.w	r3, [r4, #432]	; 0x1b0
    3332:	cmp	r3, #0
    3334:	bne.n	332e <isr+0x286>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    3336:	lsrs	r3, r0, #16
    3338:	lsls	r3, r3, #25
    333a:	orr.w	r3, r3, #16777216	; 0x1000000
    333e:	str.w	r3, [r5, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3342:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3346:	cmp	r3, #0
    3348:	bne.w	30d4 <isr+0x2c>
    334c:	b.n	3172 <isr+0xca>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    334e:	movw	r3, #8737	; 0x2221
    3352:	cmp	r1, r3
    3354:	beq.w	3464 <isr+0x3bc>
    3358:	movw	r3, #8993	; 0x2321
    335c:	cmp	r1, r3
    335e:	bne.n	32e6 <isr+0x23e>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3360:	ldr	r3, [pc, #124]	; (33e0 <isr+0x338>)
    3362:	movs	r1, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3364:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3366:	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3368:	movs	r1, #0
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    336a:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    336c:	ldr.w	r2, [r4, #444]	; 0x1bc
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3370:	str	r3, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3372:	orr.w	r2, r2, #65537	; 0x10001
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    3376:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    3378:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    337a:	str.w	r2, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    337e:	ldr.w	r3, [r4, #432]	; 0x1b0
    3382:	orr.w	r3, r3, #65536	; 0x10000
    3386:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    338a:	ldr.w	r3, [r4, #432]	; 0x1b0
    338e:	cmp	r3, #0
    3390:	bne.n	338a <isr+0x2e2>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3392:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    3396:	cmp	r3, #0
    3398:	bne.w	30d4 <isr+0x2c>
    339c:	b.n	3172 <isr+0xca>
    339e:	nop
    33a0:	.word	0x402e0000
    33a4:	.word	0x20004000
    33a8:	.word	0x402e01c0
    33ac:	.word	0x20001e58
    33b0:	.word	0x20001e34
    33b4:	.word	0x20001e30
    33b8:	.word	0x20001e3c
    33bc:	.word	0x20001e40
    33c0:	.word	0x20001e48
    33c4:	.word	0x20001e38
    33c8:	.word	0x20001e44
    33cc:	.word	0x20004240
    33d0:	.word	0x20001e68
    33d4:	.word	0x000200c8
    33d8:	.word	0x00cc0002
    33dc:	.word	0x00c80002
    33e0:	.word	0x20003020
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    33e4:	ldr	r2, [pc, #744]	; (36d0 <isr+0x628>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    33e6:	movs	r1, #2
    33e8:	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    33ea:	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    33ec:	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    33ee:	bl	3004 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    33f2:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    33f6:	cmp	r3, #0
    33f8:	bne.w	30d4 <isr+0x2c>
    33fc:	b.n	3172 <isr+0xca>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    33fe:	uxth	r2, r2
    3400:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    3404:	cmp	r3, #7
    3406:	bhi.w	32e6 <isr+0x23e>
		dir = setup.wIndex & 0x80;
		if (dir) {
    340a:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    340e:	mov.w	r3, r3, lsl #2
    3412:	ldr	r2, [pc, #704]	; (36d4 <isr+0x62c>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    3414:	mov.w	r1, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    3418:	add	r2, r3
    341a:	ldr	r3, [r2, #0]
    341c:	ite	ne
    341e:	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    3422:	biceq.w	r3, r3, #1
    3426:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3428:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    342a:	ldr	r3, [pc, #684]	; (36d8 <isr+0x630>)
    342c:	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    342e:	movs	r1, #0
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    3430:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3432:	ldr.w	r2, [r4, #444]	; 0x1bc
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    3436:	str	r3, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3438:	orr.w	r2, r2, #65537	; 0x10001
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    343c:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    343e:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    3440:	str.w	r2, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    3444:	ldr.w	r3, [r4, #432]	; 0x1b0
    3448:	orr.w	r3, r3, #65536	; 0x10000
    344c:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    3450:	ldr.w	r3, [r4, #432]	; 0x1b0
    3454:	cmp	r3, #0
    3456:	bne.n	3450 <isr+0x3a8>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    3458:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    345c:	cmp	r3, #0
    345e:	bne.w	30d4 <isr+0x2c>
    3462:	b.n	3172 <isr+0xca>
			}
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    3464:	ldr	r3, [pc, #628]	; (36dc <isr+0x634>)
		usb_cdc_line_rtsdtr = setup.wValue;
    3466:	ubfx	r0, r0, #16, #8
			}
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    346a:	ldr	r2, [pc, #628]	; (36e0 <isr+0x638>)
    346c:	ldr	r1, [r3, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    346e:	ldr	r3, [pc, #628]	; (36e4 <isr+0x63c>)
			}
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    3470:	str	r1, [r2, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    3472:	strb	r0, [r3, #0]
    3474:	b.n	3360 <isr+0x2b8>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    3476:	uxth	r2, r2
    3478:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    347c:	cmp	r3, #7
    347e:	bhi.w	32e6 <isr+0x23e>
		dir = setup.wIndex & 0x80;
		if (dir) {
    3482:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    3486:	mov.w	r3, r3, lsl #2
    348a:	ldr	r2, [pc, #584]	; (36d4 <isr+0x62c>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    348c:	mov.w	r1, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    3490:	add	r2, r3
    3492:	ldr	r3, [r2, #0]
    3494:	ite	ne
    3496:	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    349a:	orreq.w	r3, r3, #1
    349e:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    34a0:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    34a2:	ldr	r3, [pc, #564]	; (36d8 <isr+0x630>)
    34a4:	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    34a6:	movs	r1, #0
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    34a8:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    34aa:	ldr.w	r2, [r4, #444]	; 0x1bc
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    34ae:	str	r3, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    34b0:	orr.w	r2, r2, #65537	; 0x10001
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    34b4:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    34b6:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    34b8:	str.w	r2, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    34bc:	ldr.w	r3, [r4, #432]	; 0x1b0
    34c0:	orr.w	r3, r3, #65536	; 0x10000
    34c4:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    34c8:	ldr.w	r3, [r4, #432]	; 0x1b0
    34cc:	cmp	r3, #0
    34ce:	bne.n	34c8 <isr+0x420>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    34d0:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    34d4:	cmp	r3, #0
    34d6:	bne.w	30d4 <isr+0x2c>
    34da:	b.n	3172 <isr+0xca>
		usb_midi_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    34dc:	ldr	r2, [pc, #520]	; (36e8 <isr+0x640>)
		endpoint0_transmit(reply_buffer, 1, 0);
    34de:	movs	r1, #1
		usb_midi_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    34e0:	ldr	r3, [pc, #492]	; (36d0 <isr+0x628>)
    34e2:	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    34e4:	mov	r0, r3
		usb_midi_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    34e6:	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    34e8:	bl	3004 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    34ec:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    34f0:	cmp	r3, #0
    34f2:	bne.w	30d4 <isr+0x2c>
    34f6:	b.n	3172 <isr+0xca>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    34f8:	ldr	r3, [pc, #496]	; (36ec <isr+0x644>)
    34fa:	ldr	r1, [r3, #4]
    34fc:	cmp	r1, #0
    34fe:	beq.w	32e6 <isr+0x23e>
    3502:	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    3504:	uxth.w	lr, r2
    3508:	b.n	3514 <isr+0x46c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    350a:	adds	r3, #12
    350c:	ldr	r1, [r3, #4]
    350e:	cmp	r1, #0
    3510:	beq.w	32e6 <isr+0x23e>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    3514:	ldrh	r7, [r3, #0]
    3516:	cmp	r7, r0
    3518:	bne.n	350a <isr+0x462>
    351a:	ldrh	r7, [r3, #2]
    351c:	cmp	r7, lr
    351e:	bne.n	350a <isr+0x462>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    3520:	lsrs	r7, r0, #8
    3522:	cmp	r7, #3
    3524:	beq.w	3734 <isr+0x68c>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    3528:	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    352a:	lsrs	r2, r2, #16
    352c:	cmp	r3, r2
    352e:	it	cs
    3530:	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    3532:	cmp.w	r0, #512	; 0x200
    3536:	beq.w	36b0 <isr+0x608>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    353a:	cmp.w	r0, #1792	; 0x700
    353e:	beq.w	3654 <isr+0x5ac>
    3542:	ldr	r7, [pc, #428]	; (36f0 <isr+0x648>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    3544:	mov	r2, r3
    3546:	str	r3, [sp, #4]
    3548:	mov	r0, r7
    354a:	bl	2a74 <memcpy>
    354e:	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    3550:	bic.w	r2, r7, #31
	uint32_t end_addr = (uint32_t)addr + size;
    3554:	add	r7, r3
	asm("dsb");
    3556:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    355a:	ldr	r1, [pc, #408]	; (36f4 <isr+0x64c>)
    355c:	str	r2, [r1, #0]
		location += 32;
    355e:	adds	r2, #32
	} while (location < end_addr);
    3560:	cmp	r7, r2
    3562:	bhi.n	355a <isr+0x4b2>
	asm("dsb");
    3564:	dsb	sy
	asm("isb");
    3568:	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    356c:	ldr	r0, [pc, #384]	; (36f0 <isr+0x648>)
    356e:	mov	r1, r3
    3570:	bl	3004 <endpoint0_transmit.constprop.1>
    3574:	b.n	316a <isr+0xc2>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    3576:	lsls	r3, r1, #31
    3578:	bpl.w	3162 <isr+0xba>
    357c:	b.n	315e <isr+0xb6>
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    357e:	ldr	r7, [pc, #376]	; (36f8 <isr+0x650>)
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3580:	mov.w	lr, #1
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    3584:	str	r3, [r6, #12]
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3586:	ldr	r1, [pc, #372]	; (36fc <isr+0x654>)
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    3588:	ldr	r3, [pc, #372]	; (3700 <isr+0x658>)
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    358a:	str	r0, [r7, #0]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    358c:	str.w	lr, [r3]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    3590:	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    3592:	ldr.w	r0, [r5, #432]	; 0x1b0
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
    3596:	ldr	r1, [pc, #364]	; (3704 <isr+0x65c>)
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    3598:	str	r2, [r7, #4]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    359a:	orr.w	r2, r0, lr
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    359e:	add.w	r7, r1, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
    35a2:	add.w	lr, r1, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    35a6:	str	r3, [r6, #8]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    35a8:	add.w	r0, r1, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    35ac:	str.w	r2, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    35b0:	add.w	r2, r1, #16384	; 0x4000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    35b4:	str	r1, [r3, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    35b6:	str	r7, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    35b8:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    35bc:	str	r0, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    35be:	str	r2, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
    35c0:	ldr.w	r3, [r4, #432]	; 0x1b0
    35c4:	cmp	r3, #0
    35c6:	bne.n	35c0 <isr+0x518>
	}
	endpoint0_transfer_ack.next = 1;
    35c8:	ldr	r2, [pc, #268]	; (36d8 <isr+0x630>)
    35ca:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    35cc:	movw	r1, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    35d0:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    35d2:	str	r0, [r2, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    35d4:	mov.w	r0, #65536	; 0x10000
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    35d8:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    35da:	ldr.w	r1, [r5, #444]	; 0x1bc
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    35de:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    35e0:	orr.w	r3, r1, #65537	; 0x10001
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    35e4:	str	r2, [r6, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE |= (1<<0) | (1<<16);
    35e6:	str.w	r3, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    35ea:	ldr.w	r3, [r5, #432]	; 0x1b0
    35ee:	orrs	r3, r0
    35f0:	str.w	r3, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    35f4:	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    35f8:	ldr.w	r3, [r4, #432]	; 0x1b0
    35fc:	cmp	r3, #0
    35fe:	bne.n	35f8 <isr+0x550>
    3600:	b.n	316a <isr+0xc2>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    3602:	ldr	r4, [pc, #244]	; (36f8 <isr+0x650>)
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    3604:	movw	r0, #8225	; 0x2021
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    3608:	movs	r5, #0
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    360a:	ldrh	r4, [r4, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    360c:	str	r5, [r1, #0]
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    360e:	cmp	r4, r0
    3610:	bne.w	322c <isr+0x184>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    3614:	ldr	r1, [pc, #236]	; (3704 <isr+0x65c>)
    3616:	ldr	r4, [pc, #240]	; (3708 <isr+0x660>)
    3618:	ldmia	r1, {r0, r1}
    361a:	lsrs	r5, r1, #16
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    361c:	cmp	r0, #134	; 0x86

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    361e:	str	r0, [r4, #0]
    3620:	strh	r1, [r4, #4]
    3622:	strb	r5, [r4, #6]
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    3624:	bne.w	322c <isr+0x184>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    3628:	cpsid	i
	sof_usage |= (1 << interface);
    362a:	ldr	r0, [pc, #224]	; (370c <isr+0x664>)
    362c:	ldrb	r1, [r0, #0]
    362e:	orr.w	r1, r1, #4
    3632:	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    3634:	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    3638:	lsls	r0, r1, #24
    363a:	bmi.n	364a <isr+0x5a2>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    363c:	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    3640:	movs	r0, #128	; 0x80
    3642:	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    3646:	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    364a:	cpsie	i
	if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    364c:	ldr	r2, [pc, #192]	; (3710 <isr+0x668>)
    364e:	movs	r1, #80	; 0x50
    3650:	strb	r1, [r2, #0]
    3652:	b.n	322c <isr+0x184>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    3654:	ldr	r0, [pc, #188]	; (3714 <isr+0x66c>)
					memcpy(usb_descriptor_buffer, src, datalen);
    3656:	mov	r2, r3
    3658:	ldr	r7, [pc, #148]	; (36f0 <isr+0x648>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    365a:	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    365e:	ldr	r1, [pc, #184]	; (3718 <isr+0x670>)
    3660:	ldr	r0, [pc, #184]	; (371c <isr+0x674>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    3662:	str	r3, [sp, #4]
    3664:	cmp.w	lr, #0
    3668:	it	eq
    366a:	moveq	r1, r0
    366c:	mov	r0, r7
    366e:	bl	2a74 <memcpy>
					usb_descriptor_buffer[1] = 7;
    3672:	movs	r2, #7
    3674:	ldr	r3, [sp, #4]
    3676:	strb	r2, [r7, #1]
    3678:	b.n	3550 <isr+0x4a8>

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
	if (sof_usage == 0) {
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    367a:	ldr.w	r2, [r3, #328]	; 0x148
    367e:	bic.w	r2, r2, #128	; 0x80
    3682:	str.w	r2, [r3, #328]	; 0x148
    3686:	b.n	3216 <isr+0x16e>
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
						run_callbacks(endpoint_queue_head + i * 2);
    3688:	ldr	r0, [pc, #148]	; (3720 <isr+0x678>)
    368a:	bl	2fcc <run_callbacks>
    368e:	b.n	3252 <isr+0x1aa>
					}
					if (completestatus & (1 << (i + 16))) { // transmit
						run_callbacks(endpoint_queue_head + i * 2 + 1);
    3690:	ldr	r0, [pc, #144]	; (3724 <isr+0x67c>)
    3692:	bl	2fcc <run_callbacks>
    3696:	b.n	3240 <isr+0x198>
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
						run_callbacks(endpoint_queue_head + i * 2);
    3698:	ldr	r0, [pc, #140]	; (3728 <isr+0x680>)
    369a:	bl	2fcc <run_callbacks>
    369e:	b.n	323a <isr+0x192>
					}
					if (completestatus & (1 << (i + 16))) { // transmit
						run_callbacks(endpoint_queue_head + i * 2 + 1);
    36a0:	ldr	r0, [pc, #136]	; (372c <isr+0x684>)
    36a2:	bl	2fcc <run_callbacks>
    36a6:	b.n	324c <isr+0x1a4>
			completestatus &= endpointN_notify_mask;
			if (completestatus) {
				int i;   // TODO: optimize with __builtin_ctz()
				for (i=2; i <= NUM_ENDPOINTS; i++) {
					if (completestatus & (1 << i)) { // receive
						run_callbacks(endpoint_queue_head + i * 2);
    36a8:	ldr	r0, [pc, #132]	; (3730 <isr+0x688>)
    36aa:	bl	2fcc <run_callbacks>
    36ae:	b.n	3246 <isr+0x19e>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    36b0:	ldr	r0, [pc, #96]	; (3714 <isr+0x66c>)
					memcpy(usb_descriptor_buffer, src, datalen);
    36b2:	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    36b4:	ldr	r1, [pc, #100]	; (371c <isr+0x674>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    36b6:	ldrb	r7, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    36b8:	ldr	r0, [pc, #92]	; (3718 <isr+0x670>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    36ba:	str	r3, [sp, #4]
    36bc:	cmp	r7, #0
    36be:	it	eq
    36c0:	moveq	r1, r0
    36c2:	ldr	r0, [pc, #44]	; (36f0 <isr+0x648>)
    36c4:	bl	2a74 <memcpy>
    36c8:	ldr	r7, [pc, #36]	; (36f0 <isr+0x648>)
    36ca:	ldr	r3, [sp, #4]
    36cc:	b.n	3550 <isr+0x4a8>
    36ce:	nop
    36d0:	.word	0x20001e58
    36d4:	.word	0x402e01c0
    36d8:	.word	0x20003020
    36dc:	.word	0x20001e74
    36e0:	.word	0x2000428c
    36e4:	.word	0x20001fe8
    36e8:	.word	0x20001e68
    36ec:	.word	0x20000798
    36f0:	.word	0x20200000
    36f4:	.word	0xe000ef70
    36f8:	.word	0x20001e50
    36fc:	.word	0x00070080
    3700:	.word	0x20003000
    3704:	.word	0x20001e60
    3708:	.word	0x20004284
    370c:	.word	0x20001e38
    3710:	.word	0x20001e48
    3714:	.word	0x20001e40
    3718:	.word	0x60001654
    371c:	.word	0x60001698
    3720:	.word	0x20004200
    3724:	.word	0x20004140
    3728:	.word	0x20004100
    372c:	.word	0x200041c0
    3730:	.word	0x20004180
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    3734:	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    3736:	ldrb	r3, [r1, #0]
    3738:	cmp	r3, r2
    373a:	it	cs
    373c:	movcs	r3, r2
    373e:	b.n	353a <isr+0x492>

00003740 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    3740:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    3742:	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    3746:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    374a:	ite	ne
    374c:	movne	r7, #0
    374e:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    3752:	cmp	r2, #2
    3754:	bls.n	375a <usb_config_rx+0x1a>
    3756:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    375a:	mov.w	sl, r0, lsl #7
    375e:	ldr.w	r9, [pc, #64]	; 37a0 <usb_config_rx+0x60>
    3762:	mov	r5, r1
    3764:	mov	r4, r0
    3766:	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    376a:	movs	r1, #0
    376c:	movs	r2, #64	; 0x40
    376e:	mov	r8, r3
    3770:	mov	r0, r6
    3772:	bl	82b8 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    3776:	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    3778:	orr.w	r1, r7, r5, lsl #16
    377c:	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    3780:	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    3784:	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    3786:	cmp.w	r8, #0
    378a:	beq.n	3756 <usb_config_rx+0x16>
    378c:	ldr	r3, [pc, #12]	; (379c <usb_config_rx+0x5c>)
    378e:	lsls	r0, r4
    3790:	ldr	r4, [r3, #0]
    3792:	orrs	r0, r4
    3794:	str	r0, [r3, #0]
    3796:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    379a:	nop
    379c:	.word	0x20001e34
    37a0:	.word	0x20004000

000037a4 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    37a4:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    37a6:	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    37aa:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    37ae:	ite	ne
    37b0:	movne	r7, #0
    37b2:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    37b6:	cmp	r2, #2
    37b8:	bls.n	37be <usb_config_tx+0x1a>
    37ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    37be:	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    37c0:	lsls	r5, r0, #7
    37c2:	ldr.w	r9, [pc, #68]	; 3808 <usb_config_tx+0x64>
    37c6:	mov	r8, r1
    37c8:	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    37ca:	movs	r1, #0
    37cc:	mov	r4, r0
    37ce:	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    37d0:	add.w	sl, r5, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    37d4:	mov	r0, sl
    37d6:	bl	82b8 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    37da:	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    37dc:	orr.w	r1, r7, r8, lsl #16
    37e0:	str.w	r1, [r5, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    37e4:	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    37e8:	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    37ec:	cmp	r6, #0
    37ee:	beq.n	37ba <usb_config_tx+0x16>
    37f0:	add.w	r0, r4, #16
    37f4:	ldr	r3, [pc, #12]	; (3804 <usb_config_tx+0x60>)
    37f6:	lsls	r2, r0
    37f8:	ldr	r0, [r3, #0]
    37fa:	orrs	r2, r0
    37fc:	str	r2, [r3, #0]
    37fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3802:	nop
    3804:	.word	0x20001e34
    3808:	.word	0x20004000

0000380c <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    380c:	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    380e:	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    3810:	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    3812:	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    3816:	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    3818:	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    381a:	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    381c:	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    3820:	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    3824:	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    3828:	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    382c:	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    382e:	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    3830:	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    3832:	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    3834:	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    3836:	pop	{r4, r5, r6, r7}
    3838:	bx	lr
    383a:	nop

0000383c <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    383c:	subs	r3, r0, #2
    383e:	cmp	r3, #2
    3840:	bls.n	3844 <usb_transmit+0x8>
    3842:	bx	lr
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    3844:	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    3846:	ldr	r3, [pc, #24]	; (3860 <usb_transmit+0x24>)
    3848:	add.w	r4, r0, #16
    384c:	movs	r5, #1
    384e:	mov	r2, r1
    3850:	add.w	r0, r3, r0, lsl #7
    3854:	lsl.w	r1, r5, r4
}
    3858:	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    385a:	b.w	2f70 <schedule_transfer>
    385e:	nop
    3860:	.word	0x20004040

00003864 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    3864:	subs	r3, r0, #2
    3866:	cmp	r3, #2
    3868:	bls.n	386c <usb_receive+0x8>
    386a:	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    386c:	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    386e:	ldr	r3, [pc, #20]	; (3884 <usb_receive+0x20>)
    3870:	movs	r4, #1
    3872:	mov	r2, r1
    3874:	lsl.w	r1, r4, r0
    3878:	add.w	r0, r3, r0, lsl #7
}
    387c:	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    3880:	b.w	2f70 <schedule_transfer>
    3884:	.word	0x20004000

00003888 <delay>:

void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    3888:	cmp	r0, #0
    388a:	beq.n	393c <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    388c:	movs	r2, #1
{

}*/

void delay(uint32_t msec)
{
    388e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3892:	sub	sp, #20
    3894:	mov	fp, r0
    3896:	ldr	r4, [pc, #168]	; (3940 <delay+0xb8>)
    3898:	ldr	r5, [pc, #168]	; (3944 <delay+0xbc>)
    389a:	ldr	r6, [pc, #172]	; (3948 <delay+0xc0>)
    389c:	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    38a0:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    38a4:	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    38a6:	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    38a8:	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    38ac:	cmp	r1, #0
    38ae:	bne.n	38a0 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    38b0:	ldr	r7, [pc, #152]	; (394c <delay+0xc4>)
    38b2:	strd	r8, r9, [sp, #8]
    38b6:	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    38b8:	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    38ba:	ldr	r2, [pc, #148]	; (3950 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    38bc:	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    38c0:	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    38c2:	ldr	r2, [r2, #0]
    38c4:	movs	r7, #1
    38c6:	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    38ca:	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    38ce:	mov	r8, r3
	if (frac > 1000) frac = 1000;
    38d0:	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    38d2:	cmp	r3, r1
    38d4:	it	eq
    38d6:	cmpeq	r2, r8
    38d8:	ite	cs
    38da:	movcs	sl, r8
    38dc:	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    38de:	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    38e2:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    38e6:	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    38e8:	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    38ea:	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    38ee:	cmp	r3, #0
    38f0:	bne.n	38e2 <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    38f2:	ldr	r0, [sp, #4]
    38f4:	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    38f6:	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    38f8:	ldr	r0, [pc, #84]	; (3950 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    38fa:	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    38fe:	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    3900:	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    3904:	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    3908:	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    390c:	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    3910:	mov	r8, r1
	if (frac > 1000) frac = 1000;
    3912:	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    3914:	cmp	r1, r3
    3916:	it	eq
    3918:	cmpeq	r0, r8
    391a:	ite	cs
    391c:	movcs	r3, r8
    391e:	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    3920:	add	r2, r3
    3922:	cmp	r2, lr
    3924:	bcc.n	3936 <delay+0xae>
			if (--msec == 0) return;
    3926:	subs.w	fp, fp, #1
			start += 1000;
    392a:	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    392e:	bne.n	38e2 <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    3930:	add	sp, #20
    3932:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    3936:	bl	3d70 <yield>
	}
    393a:	b.n	38e2 <delay+0x5a>
    393c:	bx	lr
    393e:	nop
    3940:	.word	0x20004280
    3944:	.word	0x20001e74
    3948:	.word	0x20001e6c
    394c:	.word	0xe0001004
    3950:	.word	0x20001e70

00003954 <Panic_Temp_isr>:

static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
    3954:	cpsid	i
  IOMUXC_GPR_GPR16 = 0x00000007;
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    3956:	ldr	r2, [pc, #24]	; (3970 <Panic_Temp_isr+0x1c>)
static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
  IOMUXC_GPR_GPR16 = 0x00000007;
    3958:	movs	r1, #7
    395a:	ldr	r3, [pc, #24]	; (3974 <Panic_Temp_isr+0x20>)
    395c:	str	r1, [r3, #64]	; 0x40
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    395e:	ldr	r3, [r2, #56]	; 0x38
    3960:	orr.w	r3, r3, #64	; 0x40
    3964:	str	r3, [r2, #56]	; 0x38
  asm volatile ("dsb":::"memory");
    3966:	dsb	sy
  while (1) asm ("wfi");
    396a:	wfi
    396c:	b.n	396a <Panic_Temp_isr+0x16>
    396e:	nop
    3970:	.word	0x400d4000
    3974:	.word	0x400ac000

00003978 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    3978:	ldr	r0, [pc, #656]	; (3c0c <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    397a:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    397e:	ldr	r3, [pc, #656]	; (3c10 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    3980:	ldr	r2, [r0, #120]	; 0x78
    3982:	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    3986:	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    3988:	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    398a:	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    398c:	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    3990:	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    3994:	ldr	r4, [pc, #636]	; (3c14 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3996:	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    399a:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    399c:	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    39a0:	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    39a2:	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    39a4:	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    39a8:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    39ac:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    39b0:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    39b4:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    39b8:	ldrh.w	r0, [r3, #392]	; 0x188
    39bc:	uxth	r0, r0
    39be:	orr.w	r0, r0, #240	; 0xf0
    39c2:	strh.w	r0, [r3, #392]	; 0x188
    39c6:	add.w	r0, r1, r1, lsl #1
    39ca:	ldr	r3, [pc, #580]	; (3c10 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    39cc:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    39ce:	movs	r5, #0
    39d0:	lsls	r0, r0, #5
    39d2:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    39d4:	cmp	r1, #4
    39d6:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    39d8:	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    39dc:	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    39de:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    39e0:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    39e2:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    39e4:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    39e6:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    39e8:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    39ea:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    39ec:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    39ee:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    39f0:	bne.n	39c6 <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    39f2:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    39f6:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    39fa:	ldr	r3, [pc, #540]	; (3c18 <pwm_init+0x2a0>)
    39fc:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a00:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3a02:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3a04:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    3a08:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a0a:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    3a0e:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a12:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    3a16:	ldrh.w	r0, [r4, #392]	; 0x188
    3a1a:	uxth	r0, r0
    3a1c:	orr.w	r0, r0, #3840	; 0xf00
    3a20:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    3a24:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    3a28:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    3a2c:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    3a30:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    3a34:	ldrh.w	r0, [r3, #392]	; 0x188
    3a38:	uxth	r0, r0
    3a3a:	orr.w	r0, r0, #240	; 0xf0
    3a3e:	strh.w	r0, [r3, #392]	; 0x188
    3a42:	add.w	r0, r1, r1, lsl #1
    3a46:	ldr	r3, [pc, #464]	; (3c18 <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    3a48:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    3a4a:	movs	r5, #0
    3a4c:	lsls	r0, r0, #5
    3a4e:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3a50:	cmp	r1, #4
    3a52:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3a54:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    3a56:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    3a5a:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    3a5c:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    3a5e:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    3a60:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    3a62:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    3a64:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    3a66:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    3a68:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    3a6a:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3a6c:	bne.n	3a42 <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a6e:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    3a72:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    3a76:	ldr	r3, [pc, #420]	; (3c1c <pwm_init+0x2a4>)
    3a78:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a7c:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3a7e:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3a80:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    3a84:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a86:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    3a8a:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3a8e:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    3a92:	ldrh.w	r0, [r4, #392]	; 0x188
    3a96:	uxth	r0, r0
    3a98:	orr.w	r0, r0, #3840	; 0xf00
    3a9c:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    3aa0:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    3aa4:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    3aa8:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    3aac:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    3ab0:	ldrh.w	r0, [r3, #392]	; 0x188
    3ab4:	uxth	r0, r0
    3ab6:	orr.w	r0, r0, #240	; 0xf0
    3aba:	strh.w	r0, [r3, #392]	; 0x188
    3abe:	add.w	r0, r1, r1, lsl #1
    3ac2:	ldr	r3, [pc, #344]	; (3c1c <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    3ac4:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    3ac6:	movs	r5, #0
    3ac8:	lsls	r0, r0, #5
    3aca:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3acc:	cmp	r1, #4
    3ace:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3ad0:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    3ad2:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    3ad6:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    3ad8:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    3ada:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    3adc:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    3ade:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    3ae0:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    3ae2:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    3ae4:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    3ae6:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3ae8:	bne.n	3abe <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3aea:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    3aee:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    3af2:	ldr	r3, [pc, #300]	; (3c20 <pwm_init+0x2a8>)
    3af4:	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3af8:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3afa:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3afc:	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    3b00:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3b02:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    3b06:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3b0a:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    3b0e:	ldrh.w	r0, [r4, #392]	; 0x188
    3b12:	uxth	r0, r0
    3b14:	orr.w	r0, r0, #3840	; 0xf00
    3b18:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    3b1c:	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    3b20:	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    3b24:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    3b28:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    3b2c:	ldrh.w	r0, [r3, #392]	; 0x188
    3b30:	uxth	r0, r0
    3b32:	orr.w	r0, r0, #240	; 0xf0
    3b36:	strh.w	r0, [r3, #392]	; 0x188
    3b3a:	add.w	r0, r1, r1, lsl #1
    3b3e:	ldr	r3, [pc, #224]	; (3c20 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    3b40:	adds	r1, #1
    3b42:	lsls	r0, r0, #5
    3b44:	mov	r4, r3
    3b46:	cmp	r1, #4
    3b48:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    3b4a:	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    3b4c:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    3b50:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    3b52:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    3b54:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    3b56:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    3b58:	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    3b5a:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    3b5c:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    3b5e:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    3b60:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    3b62:	bne.n	3b3a <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3b64:	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    3b68:	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3b6a:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    3b6c:	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3b70:	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    3b72:	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    3b76:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    3b78:	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    3b7c:	orrs	r3, r7
    3b7e:	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    3b82:	ldrh.w	r3, [r4, #392]	; 0x188
    3b86:	uxth	r3, r3
    3b88:	orr.w	r3, r3, #3840	; 0xf00
    3b8c:	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    3b90:	lsls	r0, r2, #5
    3b92:	ldr	r3, [pc, #144]	; (3c24 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3b94:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    3b96:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3b98:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    3b9a:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    3b9c:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    3b9e:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    3ba0:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    3ba2:	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    3ba6:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    3ba8:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    3baa:	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3bac:	bne.n	3b90 <pwm_init+0x218>
    3bae:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    3bb0:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    3bb2:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    3bb6:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    3bba:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    3bbc:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    3bc0:	lsls	r0, r2, #5
    3bc2:	ldr	r3, [pc, #100]	; (3c28 <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3bc4:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    3bc6:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3bc8:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    3bca:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    3bcc:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    3bce:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    3bd0:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    3bd2:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    3bd4:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    3bd6:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    3bd8:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3bda:	bne.n	3bc0 <pwm_init+0x248>
    3bdc:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    3bde:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    3be0:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    3be4:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    3be8:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    3bea:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    3bee:	lsls	r0, r2, #5
    3bf0:	ldr	r3, [pc, #56]	; (3c2c <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3bf2:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    3bf4:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3bf6:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    3bf8:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    3bfa:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    3bfc:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    3bfe:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    3c00:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    3c02:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    3c04:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    3c06:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    3c08:	bne.n	3bee <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    3c0a:	pop	{r4, r5, r6, r7, pc}
    3c0c:	.word	0x400fc000
    3c10:	.word	0x403dc000
    3c14:	.word	0xfc030000
    3c18:	.word	0x403e0000
    3c1c:	.word	0x403e4000
    3c20:	.word	0x403e8000
    3c24:	.word	0x401dc000
    3c28:	.word	0x401e0000
    3c2c:	.word	0x401e4000

00003c30 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    3c30:	lsls	r0, r0, #4
    3c32:	ldr	r3, [pc, #28]	; (3c50 <digitalWrite.part.0+0x20>)
    3c34:	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    3c36:	ldr	r3, [r3, r0]
	mask = p->mask;
    3c38:	ldr	r2, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    3c3a:	ldr	r0, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    3c3c:	tst	r0, r2
    3c3e:	beq.n	3c46 <digitalWrite.part.0+0x16>
		// pin is configured for output mode
		if (val) {
    3c40:	cbnz	r1, 3c48 <digitalWrite.part.0+0x18>
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    3c42:	str.w	r2, [r3, #136]	; 0x88
    3c46:	bx	lr
	pinmode = *(p->reg + 1);
	mask = p->mask;
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
    3c48:	str.w	r2, [r3, #132]	; 0x84
    3c4c:	bx	lr
    3c4e:	nop
    3c50:	.word	0x20000518

00003c54 <digitalRead.part.1>:
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    3c54:	lsls	r0, r0, #4
    3c56:	ldr	r3, [pc, #20]	; (3c6c <digitalRead.part.1+0x18>)
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    3c58:	ldr	r2, [r3, r0]
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    3c5a:	adds	r1, r3, r0
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    3c5c:	ldr	r2, [r2, #8]
    3c5e:	ldr	r3, [r1, #12]
    3c60:	tst	r2, r3
}
    3c62:	ite	ne
    3c64:	movne	r0, #1
    3c66:	moveq	r0, #0
    3c68:	bx	lr
    3c6a:	nop
    3c6c:	.word	0x20000518

00003c70 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    3c70:	cmp	r0, #39	; 0x27
    3c72:	bhi.n	3c78 <digitalWrite+0x8>
    3c74:	b.w	3c30 <digitalWrite.part.0>
    3c78:	bx	lr
    3c7a:	nop

00003c7c <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    3c7c:	cmp	r0, #39	; 0x27
    3c7e:	bhi.n	3c84 <digitalRead+0x8>
    3c80:	b.w	3c54 <digitalRead.part.1>
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}
    3c84:	movs	r0, #0
    3c86:	bx	lr

00003c88 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    3c88:	cmp	r0, #39	; 0x27
    3c8a:	bhi.n	3cc6 <pinMode+0x3e>
	p = digital_pin_to_info_PGM + pin;
    3c8c:	lsls	r0, r0, #4
    3c8e:	ldr	r2, [pc, #104]	; (3cf8 <pinMode+0x70>)
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    3c90:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    3c92:	add.w	r3, r2, r0
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    3c96:	ldr	r0, [r2, r0]
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}

void pinMode(uint8_t pin, uint8_t mode)
{
    3c98:	push	{r4}
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    3c9a:	beq.n	3cc8 <pinMode+0x40>
    3c9c:	cmp	r1, #4
    3c9e:	beq.n	3cc8 <pinMode+0x40>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    3ca0:	ldr	r4, [r3, #12]
    3ca2:	ldr	r2, [r0, #4]
    3ca4:	bic.w	r2, r2, r4
    3ca8:	str	r2, [r0, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    3caa:	ldr	r2, [r3, #8]
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
    3cac:	cbz	r1, 3cea <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
    3cae:	cmp	r1, #2
    3cb0:	beq.n	3cf0 <pinMode+0x68>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    3cb2:	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    3cb4:	ldr	r3, [r3, #4]
}
    3cb6:	ldr.w	r4, [sp], #4
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    3cba:	ite	eq
    3cbc:	ldreq	r1, [pc, #60]	; (3cfc <pinMode+0x74>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    3cbe:	ldrne	r1, [pc, #64]	; (3d00 <pinMode+0x78>)
    3cc0:	str	r1, [r2, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    3cc2:	movs	r2, #21
    3cc4:	str	r2, [r3, #0]
}
    3cc6:	bx	lr
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    3cc8:	ldr	r2, [r3, #12]
		if (mode == OUTPUT) {
    3cca:	cmp	r1, #1
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    3ccc:	ldr	r4, [r0, #4]
    3cce:	orr.w	r2, r2, r4
    3cd2:	str	r2, [r0, #4]
		if (mode == OUTPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    3cd4:	ldr	r2, [r3, #8]

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
		if (mode == OUTPUT) {
    3cd6:	beq.n	3cea <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    3cd8:	movw	r1, #2104	; 0x838
    3cdc:	str	r1, [r2, #0]
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    3cde:	ldr	r3, [r3, #4]
    3ce0:	movs	r2, #21
}
    3ce2:	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    3ce6:	str	r2, [r3, #0]
}
    3ce8:	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    3cea:	movs	r1, #56	; 0x38
    3cec:	str	r1, [r2, #0]
    3cee:	b.n	3cde <pinMode+0x56>
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    3cf0:	ldr	r1, [pc, #16]	; (3d04 <pinMode+0x7c>)
    3cf2:	str	r1, [r2, #0]
    3cf4:	b.n	3cde <pinMode+0x56>
    3cf6:	nop
    3cf8:	.word	0x20000518
    3cfc:	.word	0x00013038
    3d00:	.word	0x00010038
    3d04:	.word	0x0001f038

00003d08 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    3d08:	ldr	r2, [pc, #72]	; (3d54 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    3d0a:	ldr	r3, [pc, #76]	; (3d58 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    3d0c:	ldr.w	r0, [r2, #544]	; 0x220
    3d10:	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    3d14:	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    3d16:	push	{r4, lr}
    3d18:	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    3d1a:	bhi.n	3d22 <usb_init_serialnumber+0x1a>
    3d1c:	add.w	r0, r0, r0, lsl #2
    3d20:	lsls	r0, r0, #1
    3d22:	ldr	r4, [pc, #56]	; (3d5c <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    3d24:	add	r1, sp, #4
    3d26:	movs	r2, #10
    3d28:	bl	439c <ultoa>
    3d2c:	add	r1, sp, #4
	for (i=0; i<10; i++) {
    3d2e:	movs	r3, #0
    3d30:	mov	r0, r4
		char c = buf[i];
    3d32:	ldrb.w	r2, [r1], #1
    3d36:	adds	r3, #1
		if (!c) break;
    3d38:	cbz	r2, 3d4a <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    3d3a:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    3d3c:	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    3d40:	bne.n	3d32 <usb_init_serialnumber+0x2a>
    3d42:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    3d44:	strb	r3, [r4, #0]
}
    3d46:	add	sp, #16
    3d48:	pop	{r4, pc}
    3d4a:	lsls	r3, r3, #1
    3d4c:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    3d4e:	strb	r3, [r4, #0]
}
    3d50:	add	sp, #16
    3d52:	pop	{r4, pc}
    3d54:	.word	0x401f4400
    3d58:	.word	0x0098967f
    3d5c:	.word	0x2000100c

00003d60 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    3d60:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    3d62:	bl	7c <setup>
	while (1) {
		loop();
    3d66:	bl	84 <loop>
		yield();
    3d6a:	bl	3d70 <yield>
    3d6e:	b.n	3d66 <main+0x6>

00003d70 <yield>:

extern uint8_t usb_enable_serial_event_processing; // from usb_inst.cpp

void yield(void) __attribute__ ((weak));
void yield(void)
{
    3d70:	push	{r4, r5, r6, lr}
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
    3d72:	ldr	r4, [pc, #132]	; (3df8 <yield+0x88>)
    3d74:	ldrb	r3, [r4, #0]
    3d76:	cbnz	r3, 3d9a <yield+0x2a>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    3d78:	ldr	r3, [pc, #128]	; (3dfc <yield+0x8c>)
void yield(void)
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    3d7a:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    3d7c:	ldrb	r3, [r3, #0]
void yield(void)
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    3d7e:	strb	r2, [r4, #0]


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    3d80:	cbnz	r3, 3dca <yield+0x5a>

	// Current workaround until integrate with EventResponder.
	if (HardwareSerial::serial_event_handlers_active) HardwareSerial::processSerialEvents();
    3d82:	ldr	r3, [pc, #124]	; (3e00 <yield+0x90>)
    3d84:	ldrb	r3, [r3, #0]
    3d86:	cmp	r3, #0
    3d88:	bne.n	3dde <yield+0x6e>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;
    3d8a:	ldr	r3, [pc, #120]	; (3e04 <yield+0x94>)

	running = 0;
    3d8c:	movs	r1, #0
    3d8e:	ldr	r2, [r3, #0]
    3d90:	strb	r1, [r4, #0]
    3d92:	cbz	r2, 3d9a <yield+0x2a>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    3d94:	mrs	r2, IPSR
		if (ipsr != 0) return;
    3d98:	cbz	r2, 3d9c <yield+0x2c>
    3d9a:	pop	{r4, r5, r6, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3d9c:	mrs	r0, PRIMASK
		__disable_irq();
    3da0:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    3da2:	ldr	r2, [r3, #0]
		if (first == nullptr) {
    3da4:	cbz	r2, 3de4 <yield+0x74>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    3da6:	ldr	r4, [pc, #96]	; (3e08 <yield+0x98>)
    3da8:	ldrb	r1, [r4, #0]
    3daa:	cbnz	r1, 3de4 <yield+0x74>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    3dac:	movs	r6, #1
		firstYield = first->_next;
    3dae:	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    3db0:	strb	r6, [r4, #0]
		firstYield = first->_next;
    3db2:	str	r5, [r3, #0]
		if (firstYield) {
    3db4:	cbz	r5, 3dec <yield+0x7c>
			firstYield->_prev = nullptr;
    3db6:	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3db8:	cbnz	r0, 3dbc <yield+0x4c>
    3dba:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3dbc:	movs	r5, #0
		(*(first->_function))(*first);
    3dbe:	ldr	r3, [r2, #8]
    3dc0:	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3dc2:	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    3dc4:	blx	r3
		runningFromYield = false;
    3dc6:	strb	r5, [r4, #0]
    3dc8:	pop	{r4, r5, r6, pc}
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    3dca:	bl	4390 <usb_serial_available>
	if (running) return; // TODO: does this need to be atomic?
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (usb_enable_serial_event_processing && Serial.available()) serialEvent();
    3dce:	cmp	r0, #0
    3dd0:	beq.n	3d82 <yield+0x12>
    3dd2:	bl	3ff8 <serialEvent()>

	// Current workaround until integrate with EventResponder.
	if (HardwareSerial::serial_event_handlers_active) HardwareSerial::processSerialEvents();
    3dd6:	ldr	r3, [pc, #40]	; (3e00 <yield+0x90>)
    3dd8:	ldrb	r3, [r3, #0]
    3dda:	cmp	r3, #0
    3ddc:	beq.n	3d8a <yield+0x1a>
    3dde:	bl	43ec <HardwareSerial::processSerialEvents()>
    3de2:	b.n	3d8a <yield+0x1a>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3de4:	cmp	r0, #0
    3de6:	bne.n	3d9a <yield+0x2a>
    3de8:	cpsie	i
    3dea:	pop	{r4, r5, r6, pc}
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    3dec:	ldr	r3, [pc, #28]	; (3e0c <yield+0x9c>)
    3dee:	str	r5, [r3, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3df0:	cmp	r0, #0
    3df2:	bne.n	3dbc <yield+0x4c>
    3df4:	b.n	3dba <yield+0x4a>
    3df6:	nop
    3df8:	.word	0x20001e8c
    3dfc:	.word	0x20001022
    3e00:	.word	0x2000209c
    3e04:	.word	0x20001ea0
    3e08:	.word	0x20001ea4
    3e0c:	.word	0x20001e9c

00003e10 <EventResponder::triggerEventNotImmediate()>:
bool EventResponder::runningFromYield = false;

// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
    3e10:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3e12:	mrs	r2, PRIMASK
		__disable_irq();
    3e16:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    3e18:	ldrb	r3, [r0, #29]
    3e1a:	cbnz	r3, 3e2a <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    3e1c:	ldrb	r1, [r0, #28]
    3e1e:	cmp	r1, #1
    3e20:	beq.n	3e34 <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    3e22:	cmp	r1, #3
    3e24:	beq.n	3e48 <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    3e26:	movs	r3, #1
    3e28:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3e2a:	cbnz	r2, 3e2e <EventResponder::triggerEventNotImmediate()+0x1e>
    3e2c:	cpsie	i
	}
	enableInterrupts(irq);
}
    3e2e:	ldr.w	r4, [sp], #4
    3e32:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    3e34:	ldr	r4, [pc, #68]	; (3e7c <EventResponder::triggerEventNotImmediate()+0x6c>)
    3e36:	ldr	r1, [r4, #0]
    3e38:	cbz	r1, 3e64 <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    3e3a:	ldr	r1, [pc, #68]	; (3e80 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    3e3c:	str	r3, [r0, #20]
				_prev = lastYield;
    3e3e:	ldr	r3, [r1, #0]
				_prev->_next = this;
				lastYield = this;
    3e40:	str	r0, [r1, #0]
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    3e42:	str	r3, [r0, #24]
				_prev->_next = this;
    3e44:	str	r0, [r3, #20]
    3e46:	b.n	3e26 <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    3e48:	ldr	r4, [pc, #56]	; (3e84 <EventResponder::triggerEventNotImmediate()+0x74>)
    3e4a:	ldr	r1, [r4, #0]
    3e4c:	cbz	r1, 3e70 <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    3e4e:	ldr	r1, [pc, #56]	; (3e88 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    3e50:	str	r3, [r0, #20]
				_prev = lastInterrupt;
    3e52:	ldr	r3, [r1, #0]
				_prev->_next = this;
				lastInterrupt = this;
    3e54:	str	r0, [r1, #0]
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    3e56:	str	r3, [r0, #24]
				_prev->_next = this;
    3e58:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    3e5a:	ldr	r3, [pc, #48]	; (3e8c <EventResponder::triggerEventNotImmediate()+0x7c>)
    3e5c:	mov.w	r1, #268435456	; 0x10000000
    3e60:	str	r1, [r3, #0]
    3e62:	b.n	3e26 <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    3e64:	ldr	r3, [pc, #24]	; (3e80 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    3e66:	str	r1, [r0, #20]
				_prev = nullptr;
    3e68:	str	r1, [r0, #24]
				firstYield = this;
    3e6a:	str	r0, [r4, #0]
				lastYield = this;
    3e6c:	str	r0, [r3, #0]
    3e6e:	b.n	3e26 <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    3e70:	ldr	r3, [pc, #20]	; (3e88 <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    3e72:	str	r1, [r0, #20]
				_prev = nullptr;
    3e74:	str	r1, [r0, #24]
				firstInterrupt = this;
    3e76:	str	r0, [r4, #0]
				lastInterrupt = this;
    3e78:	str	r0, [r3, #0]
    3e7a:	b.n	3e5a <EventResponder::triggerEventNotImmediate()+0x4a>
    3e7c:	.word	0x20001ea0
    3e80:	.word	0x20001e9c
    3e84:	.word	0x20001e90
    3e88:	.word	0x20001e94
    3e8c:	.word	0xe000ed04

00003e90 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    3e90:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3e92:	mrs	r1, PRIMASK
		__disable_irq();
    3e96:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    3e98:	ldr	r4, [pc, #48]	; (3ecc <EventResponder::runFromInterrupt()+0x3c>)
    3e9a:	ldr	r3, [r4, #0]
		if (first) {
    3e9c:	cbz	r3, 3ec2 <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    3e9e:	ldr	r6, [pc, #48]	; (3ed0 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    3ea0:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    3ea2:	ldr	r2, [r3, #20]
    3ea4:	str	r2, [r4, #0]
			if (firstInterrupt) {
    3ea6:	cbz	r2, 3ec8 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    3ea8:	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3eaa:	cbnz	r1, 3eae <EventResponder::runFromInterrupt()+0x1e>
    3eac:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    3eae:	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    3eb0:	mov	r0, r3
    3eb2:	ldr	r3, [r3, #8]
    3eb4:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3eb6:	mrs	r1, PRIMASK
		__disable_irq();
    3eba:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    3ebc:	ldr	r3, [r4, #0]
		if (first) {
    3ebe:	cmp	r3, #0
    3ec0:	bne.n	3ea2 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3ec2:	cbnz	r1, 3ec6 <EventResponder::runFromInterrupt()+0x36>
    3ec4:	cpsie	i
    3ec6:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    3ec8:	str	r2, [r6, #0]
    3eca:	b.n	3eaa <EventResponder::runFromInterrupt()+0x1a>
    3ecc:	.word	0x20001e90
    3ed0:	.word	0x20001e94

00003ed4 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    3ed4:	b.w	3e90 <EventResponder::runFromInterrupt()>

00003ed8 <MillisTimer::addToActiveList()>:
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    3ed8:	ldr	r2, [pc, #96]	; (3f3c <MillisTimer::addToActiveList()+0x64>)
	_state = TimerWaiting;
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
    3eda:	push	{r4, r5}
	if (listActive == nullptr) {
    3edc:	ldr	r4, [r2, #0]
    3ede:	cmp	r4, #0
    3ee0:	beq.n	3f34 <MillisTimer::addToActiveList()+0x5c>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    3ee2:	ldr	r3, [r0, #0]
    3ee4:	ldr	r1, [r4, #0]
    3ee6:	cmp	r3, r1
    3ee8:	bcs.n	3f0a <MillisTimer::addToActiveList()+0x32>
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    3eea:	subs	r3, r1, r3
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
    3eec:	movs	r1, #0
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    3eee:	str	r4, [r0, #8]
		_prev = nullptr;
    3ef0:	str	r1, [r0, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    3ef2:	str	r3, [r4, #0]
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    3ef4:	str	r0, [r4, #12]
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
		listActive = this;
    3ef6:	str	r0, [r2, #0]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    3ef8:	movs	r3, #2
}
    3efa:	pop	{r4, r5}
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    3efc:	strb	r3, [r0, #20]
}
    3efe:	bx	lr
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
    3f00:	str	r3, [r0, #0]
    3f02:	mov	r4, r2
			timer = timer->_next;
			if (_ms < timer->_ms) {
    3f04:	ldr	r1, [r2, #0]
    3f06:	cmp	r3, r1
    3f08:	bcc.n	3f1c <MillisTimer::addToActiveList()+0x44>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    3f0a:	ldr	r2, [r4, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    3f0c:	subs	r3, r3, r1
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    3f0e:	cmp	r2, #0
    3f10:	bne.n	3f00 <MillisTimer::addToActiveList()+0x28>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    3f12:	str	r2, [r0, #8]
		_prev = timer;
    3f14:	str	r4, [r0, #12]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    3f16:	str	r3, [r0, #0]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
    3f18:	str	r0, [r4, #8]
    3f1a:	b.n	3ef8 <MillisTimer::addToActiveList()+0x20>
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    3f1c:	ldr	r5, [r2, #12]
				timer->_prev = this;
				_prev->_next = this;
				timer->_ms -= _ms;
    3f1e:	subs	r3, r1, r3
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    3f20:	str	r2, [r0, #8]
				_prev = timer->_prev;
				timer->_prev = this;
				_prev->_next = this;
				timer->_ms -= _ms;
				_state = TimerActive;
    3f22:	movs	r2, #2
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    3f24:	str	r5, [r0, #12]
				timer->_prev = this;
    3f26:	str	r0, [r4, #12]
				_prev->_next = this;
    3f28:	ldr	r1, [r0, #12]
    3f2a:	str	r0, [r1, #8]
				timer->_ms -= _ms;
    3f2c:	str	r3, [r4, #0]
				_state = TimerActive;
    3f2e:	strb	r2, [r0, #20]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
}
    3f30:	pop	{r4, r5}
    3f32:	bx	lr

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    3f34:	str	r4, [r0, #8]
		_prev = nullptr;
    3f36:	str	r4, [r0, #12]
		listActive = this;
    3f38:	str	r0, [r2, #0]
    3f3a:	b.n	3ef8 <MillisTimer::addToActiveList()+0x20>
    3f3c:	.word	0x20001e98

00003f40 <MillisTimer::runFromTimer()>:
	}
	enableTimerInterrupt(irq);
}

void MillisTimer::runFromTimer()
{
    3f40:	push	{r3, r4, r5, r6, r7, lr}
	MillisTimer *timer = listActive;
    3f42:	ldr	r6, [pc, #136]	; (3fcc <MillisTimer::runFromTimer()+0x8c>)
    3f44:	ldr	r4, [r6, #0]
	while (timer) {
    3f46:	cbz	r4, 3f94 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    3f48:	ldr	r3, [r4, #0]
    3f4a:	cmp	r3, #0
    3f4c:	bne.n	3fc4 <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
    3f4e:	mov	r5, r3
    3f50:	ldr	r7, [pc, #124]	; (3fd0 <MillisTimer::runFromTimer()+0x90>)
    3f52:	b.n	3f5e <MillisTimer::runFromTimer()+0x1e>
			event.triggerEvent(0, timer);
			if (timer->_reload) {
				timer->_ms = timer->_reload;
				timer->addToActiveList();
			}
			timer = listActive;
    3f54:	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    3f56:	cbz	r4, 3f94 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    3f58:	ldr	r3, [r4, #0]
    3f5a:	cmp	r3, #0
    3f5c:	bne.n	3fc4 <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
    3f5e:	ldr	r3, [r4, #8]
			if (next) next->_prev = nullptr;
    3f60:	cbz	r3, 3f64 <MillisTimer::runFromTimer()+0x24>
    3f62:	str	r5, [r3, #12]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
    3f64:	ldr	r0, [r4, #16]
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
    3f66:	str	r3, [r6, #0]
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    3f68:	ldr	r3, [r0, #0]
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
    3f6a:	strb	r5, [r4, #20]
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    3f6c:	ldr	r3, [r3, #0]
    3f6e:	cmp	r3, r7
    3f70:	bne.n	3fb6 <MillisTimer::runFromTimer()+0x76>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    3f72:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    3f74:	str	r5, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    3f76:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    3f78:	str	r4, [r0, #12]
		if (_type == EventTypeImmediate) {
    3f7a:	beq.n	3fbe <MillisTimer::runFromTimer()+0x7e>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    3f7c:	bl	3e10 <EventResponder::triggerEventNotImmediate()>
			if (timer->_reload) {
    3f80:	ldr	r3, [r4, #4]
    3f82:	cmp	r3, #0
    3f84:	beq.n	3f54 <MillisTimer::runFromTimer()+0x14>
				timer->_ms = timer->_reload;
    3f86:	str	r3, [r4, #0]
				timer->addToActiveList();
    3f88:	mov	r0, r4
    3f8a:	bl	3ed8 <MillisTimer::addToActiveList()>
			}
			timer = listActive;
    3f8e:	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    3f90:	cmp	r4, #0
    3f92:	bne.n	3f58 <MillisTimer::runFromTimer()+0x18>
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3f94:	mrs	r3, PRIMASK
		__disable_irq();
    3f98:	cpsid	i
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    3f9a:	ldr	r2, [pc, #56]	; (3fd4 <MillisTimer::runFromTimer()+0x94>)
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    3f9c:	movs	r1, #0
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    3f9e:	ldr	r0, [r2, #0]
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    3fa0:	str	r1, [r2, #0]
		return (primask == 0) ? true : false;
	}
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    3fa2:	cbnz	r3, 3fa6 <MillisTimer::runFromTimer()+0x66>
    3fa4:	cpsie	i
	enableTimerInterrupt(irq);
	while (waiting) {
    3fa6:	cbz	r0, 3fb4 <MillisTimer::runFromTimer()+0x74>
		MillisTimer *next = waiting->_next;
    3fa8:	ldr	r4, [r0, #8]
		waiting->addToActiveList();
    3faa:	bl	3ed8 <MillisTimer::addToActiveList()>
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    3fae:	mov	r0, r4
    3fb0:	cmp	r0, #0
    3fb2:	bne.n	3fa8 <MillisTimer::runFromTimer()+0x68>
    3fb4:	pop	{r3, r4, r5, r6, r7, pc}
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    3fb6:	mov	r2, r4
    3fb8:	movs	r1, #0
    3fba:	blx	r3
    3fbc:	b.n	3f80 <MillisTimer::runFromTimer()+0x40>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    3fbe:	ldr	r3, [r0, #8]
    3fc0:	blx	r3
    3fc2:	b.n	3f80 <MillisTimer::runFromTimer()+0x40>
void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
    3fc4:	subs	r3, #1
    3fc6:	str	r3, [r4, #0]
			break;
    3fc8:	b.n	3f94 <MillisTimer::runFromTimer()+0x54>
    3fca:	nop
    3fcc:	.word	0x20001e98
    3fd0:	.word	0x00002a59
    3fd4:	.word	0x20001ea8

00003fd8 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    3fd8:	ldr	r2, [pc, #16]	; (3fec <systick_isr+0x14>)
    3fda:	ldr	r3, [pc, #20]	; (3ff0 <systick_isr+0x18>)
    3fdc:	ldr	r1, [r2, #0]
	systick_millis_count++;
    3fde:	ldr	r2, [pc, #20]	; (3ff4 <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    3fe0:	str	r1, [r3, #0]
	systick_millis_count++;
    3fe2:	ldr	r3, [r2, #0]
    3fe4:	adds	r3, #1
    3fe6:	str	r3, [r2, #0]
	MillisTimer::runFromTimer();
    3fe8:	b.w	3f40 <MillisTimer::runFromTimer()>
    3fec:	.word	0xe0001004
    3ff0:	.word	0x20001e6c
    3ff4:	.word	0x20001e74

00003ff8 <serialEvent()>:
#endif

#endif // F_CPU
uint8_t usb_enable_serial_event_processing = 1;
void serialEvent() __attribute__((weak));
void serialEvent() {usb_enable_serial_event_processing = 0;}
    3ff8:	ldr	r3, [pc, #4]	; (4000 <serialEvent()+0x8>)
    3ffa:	movs	r2, #0
    3ffc:	strb	r2, [r3, #0]
    3ffe:	bx	lr
    4000:	.word	0x20001022

00004004 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    4004:	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    4006:	ldr	r4, [pc, #24]	; (4020 <Print::println()+0x1c>)
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    4008:	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    400a:	ldr	r3, [r0, #0]
    400c:	movs	r2, #2
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    400e:	ldrh	r4, [r4, #0]
	return write(buf, 2);
    4010:	add	r1, sp, #4
    4012:	ldr	r3, [r3, #4]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    4014:	strh.w	r4, [sp, #4]
	return write(buf, 2);
    4018:	blx	r3
}
    401a:	add	sp, #8
    401c:	pop	{r4, pc}
    401e:	nop
    4020:	.word	0x20000804

00004024 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    4024:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    4026:	push	{r4, lr}
    4028:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    402a:	ldr	r3, [r3, #4]
    402c:	blx	r3
	return len;
}
    402e:	mov	r0, r4
    4030:	pop	{r4, pc}
    4032:	nop

00004034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	return vdprintf((int)this, (const char *)format, ap);
#endif
}

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    4034:	push	{r4, r5, r6, r7, lr}
    4036:	mov	r6, r0
    4038:	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    403a:	cmp	r2, #0
    403c:	beq.n	40a6 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    403e:	cmp	r2, #1
    4040:	it	eq
    4042:	moveq	r2, #10
	}


	if (n == 0) {
    4044:	cbz	r1, 409c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    4046:	movs	r5, #33	; 0x21
    4048:	b.n	404c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    404a:	uxtb	r5, r7
    404c:	subs	r7, r5, #1
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    404e:	udiv	r4, r1, r2
    4052:	mls	r1, r2, r4, r1
    4056:	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    4058:	cmp	r1, #9
    405a:	add.w	r1, r0, #55	; 0x37
    405e:	add.w	r0, r0, #48	; 0x30
    4062:	it	hi
    4064:	uxtbhi	r0, r1
			n /= base;
			if (n == 0) break;
    4066:	mov	r1, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    4068:	add	r4, sp, #40	; 0x28
    406a:	it	ls
    406c:	uxtbls	r0, r0
    406e:	add	r4, r5
    4070:	strb.w	r0, [r4, #-36]
			n /= base;
			if (n == 0) break;
    4074:	cmp	r1, #0
    4076:	bne.n	404a <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    4078:	cbz	r3, 4088 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    407a:	subs	r5, #1
		buf[i] = '-';
    407c:	add	r3, sp, #40	; 0x28
    407e:	movs	r2, #45	; 0x2d
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
		i--;
    4080:	uxtb	r5, r5
		buf[i] = '-';
    4082:	add	r3, r5
    4084:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    4088:	ldr	r3, [r6, #0]
    408a:	add	r1, sp, #4
    408c:	rsb	r2, r5, #34	; 0x22
    4090:	mov	r0, r6
    4092:	add	r1, r5
    4094:	ldr	r3, [r3, #4]
    4096:	blx	r3
}
    4098:	add	sp, #44	; 0x2c
    409a:	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    409c:	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    409e:	movs	r5, #33	; 0x21
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    40a0:	strb.w	r2, [sp, #37]	; 0x25
    40a4:	b.n	4078 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    40a6:	ldr	r3, [r0, #0]
    40a8:	uxtb	r1, r1
    40aa:	ldr	r3, [r3, #0]
    40ac:	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    40ae:	add	sp, #44	; 0x2c
    40b0:	pop	{r4, r5, r6, r7, pc}
    40b2:	nop

000040b4 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    40b4:	cmp	r1, #0
    40b6:	blt.n	40c0 <Print::print(long)+0xc>
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    40b8:	movs	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    40ba:	movs	r2, #10
    40bc:	b.w	4034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
		n = -n;
    40c0:	negs	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    40c2:	movs	r3, #45	; 0x2d
		n = -n;
	}
	return printNumber(n, 10, sign);
    40c4:	movs	r2, #10
    40c6:	b.w	4034 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    40ca:	nop

000040cc <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    40cc:	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    40ce:	ldr	r1, [pc, #80]	; (4120 <rx_queue_transfer+0x54>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    40d0:	mov.w	r7, #131072	; 0x20000
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    40d4:	ldr	r5, [pc, #76]	; (4124 <rx_queue_transfer+0x58>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    40d6:	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    40d8:	add.w	r4, r1, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    40dc:	ldr	r6, [pc, #72]	; (4128 <rx_queue_transfer+0x5c>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    40de:	ldr	r2, [pc, #76]	; (412c <rx_queue_transfer+0x60>)
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    40e0:	add.w	r5, r5, r0, lsl #5
    40e4:	mov	r1, r4
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    40e6:	str	r7, [r2, #0]
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    40e8:	mov	r0, r5
    40ea:	ldrh	r2, [r6, #0]
    40ec:	bl	380c <usb_prepare_transfer>
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    40f0:	ldrh	r1, [r6, #0]
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    40f2:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    40f6:	add	r1, r4
	asm("dsb");
    40f8:	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    40fc:	ldr	r2, [pc, #48]	; (4130 <rx_queue_transfer+0x64>)
    40fe:	str	r3, [r2, #0]
		location += 32;
    4100:	adds	r3, #32
	} while (location < end_addr);
    4102:	cmp	r1, r3
    4104:	bhi.n	40fe <rx_queue_transfer+0x32>
	asm("dsb");
    4106:	dsb	sy
	asm("isb");
    410a:	isb	sy
	arm_dcache_delete(buffer, rx_packet_size);
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    410e:	movs	r0, #3
    4110:	mov	r1, r5
    4112:	bl	3864 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    4116:	ldr	r3, [pc, #28]	; (4134 <rx_queue_transfer+0x68>)
    4118:	mov.w	r2, #131072	; 0x20000
    411c:	str	r2, [r3, #0]
    411e:	pop	{r3, r4, r5, r6, r7, pc}
    4120:	.word	0x20200060
    4124:	.word	0x20001ec0
    4128:	.word	0x20001fce
    412c:	.word	0xe000e18c
    4130:	.word	0xe000ef5c
    4134:	.word	0xe000e10c

00004138 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    4138:	ldr	r2, [pc, #144]	; (41cc <rx_event+0x94>)
    413a:	ldr	r3, [r0, #4]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    413c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    4140:	ubfx	r3, r3, #16, #15
    4144:	ldrh	r4, [r2, #0]
	int i = t->callback_param;
    4146:	ldr	r5, [r0, #28]
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    4148:	subs	r4, r4, r3
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    414a:	cmp	r4, #0
    414c:	ble.n	41c0 <rx_event+0x88>
		// received a packet with data
		uint32_t head = rx_head;
    414e:	ldr	r1, [pc, #128]	; (41d0 <rx_event+0x98>)
		if (head != rx_tail) {
    4150:	ldr	r2, [pc, #128]	; (41d4 <rx_event+0x9c>)
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
    4152:	ldrb	r3, [r1, #0]
		if (head != rx_tail) {
    4154:	ldrb	r2, [r2, #0]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
    4156:	uxtb	r3, r3
		if (head != rx_tail) {
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    4158:	ldr	r0, [pc, #124]	; (41d8 <rx_event+0xa0>)
			uint32_t count = rx_count[ii];
    415a:	ldr	r6, [pc, #128]	; (41dc <rx_event+0xa4>)
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
		if (head != rx_tail) {
    415c:	cmp	r3, r2
    415e:	beq.n	4170 <rx_event+0x38>
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    4160:	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    4164:	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    4168:	rsb	r2, r7, #512	; 0x200
    416c:	cmp	r4, r2
    416e:	bls.n	4196 <rx_event+0x5e>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    4170:	adds	r3, #1
				return;
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
    4172:	movs	r2, #0
    4174:	ldr	r7, [pc, #104]	; (41e0 <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    4176:	cmp	r3, #8
				// TODO: trigger serialEvent
				return;
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
    4178:	strh.w	r4, [r6, r5, lsl #1]
		rx_index[i] = 0;
    417c:	strh.w	r2, [r7, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    4180:	ldr	r6, [pc, #96]	; (41e4 <rx_event+0xac>)
    4182:	ite	ls
    4184:	uxtbls	r2, r3
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    4186:	movhi	r3, r2
		rx_list[head] = i;
		rx_head = head;
    4188:	strb	r2, [r1, #0]
		rx_available += len;
    418a:	ldr	r2, [r6, #0]
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    418c:	strb	r5, [r0, r3]
		rx_head = head;
		rx_available += len;
    418e:	add	r4, r2
    4190:	str	r4, [r6, #0]
    4192:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    4196:	ldr	r3, [pc, #80]	; (41e8 <rx_event+0xb0>)
    4198:	add.w	r0, r7, r8, lsl #9
    419c:	mov	r2, r4
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    419e:	add	r7, r4
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    41a0:	add.w	r1, r3, r5, lsl #9
    41a4:	add	r0, r3
    41a6:	bl	2a74 <memcpy>
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
				rx_available += len;
    41aa:	ldr	r2, [pc, #56]	; (41e4 <rx_event+0xac>)
				rx_queue_transfer(i);
    41ac:	mov	r0, r5
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    41ae:	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    41b2:	ldr	r3, [r2, #0]
    41b4:	add	r4, r3
    41b6:	str	r4, [r2, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    41b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
				rx_available += len;
				rx_queue_transfer(i);
    41bc:	b.w	40cc <rx_queue_transfer>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    41c0:	mov	r0, r5
	}
}
    41c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    41c6:	b.w	40cc <rx_queue_transfer>
    41ca:	nop
    41cc:	.word	0x20001fce
    41d0:	.word	0x20001fe4
    41d4:	.word	0x20001fc0
    41d8:	.word	0x20001fc4
    41dc:	.word	0x20001fd0
    41e0:	.word	0x20001eac
    41e4:	.word	0x20001fe0
    41e8:	.word	0x20200060

000041ec <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    41ec:	ldr	r3, [pc, #120]	; (4268 <usb_serial_flush_callback+0x7c>)
    41ee:	ldrb	r2, [r3, #0]
    41f0:	cbnz	r2, 420a <usb_serial_flush_callback+0x1e>
    41f2:	and.w	r3, r2, #255	; 0xff
	if (!usb_configuration) return;
    41f6:	ldr	r2, [pc, #116]	; (426c <usb_serial_flush_callback+0x80>)
    41f8:	ldrb	r2, [r2, #0]
    41fa:	cbz	r2, 420a <usb_serial_flush_callback+0x1e>
	tx_available = 0;
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
    41fc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
    4200:	ldr	r5, [pc, #108]	; (4270 <usb_serial_flush_callback+0x84>)
    4202:	ldrh	r2, [r5, #0]
    4204:	cbnz	r2, 420c <usb_serial_flush_callback+0x20>
    4206:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    420a:	bx	lr
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    420c:	ldr	r6, [pc, #100]	; (4274 <usb_serial_flush_callback+0x88>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    420e:	rsb	r8, r2, #2048	; 0x800
{
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    4212:	ldr	r7, [pc, #100]	; (4278 <usb_serial_flush_callback+0x8c>)
    4214:	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    4216:	mov	r2, r8
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    4218:	ldr	r4, [pc, #96]	; (427c <usb_serial_flush_callback+0x90>)
{
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    421a:	add.w	r7, r7, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    421e:	add.w	r4, r4, r1, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    4222:	mov	r0, r7
    4224:	mov	r1, r4
    4226:	bl	380c <usb_prepare_transfer>
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    422a:	add.w	r2, r8, r4
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    422e:	bic.w	r1, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
	asm("dsb");
    4232:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    4236:	ldr	r3, [pc, #72]	; (4280 <usb_serial_flush_callback+0x94>)
    4238:	str	r1, [r3, #0]
		location += 32;
    423a:	adds	r1, #32
	} while (location < end_addr);
    423c:	cmp	r2, r1
    423e:	bhi.n	4238 <usb_serial_flush_callback+0x4c>
	asm("dsb");
    4240:	dsb	sy
	asm("isb");
    4244:	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    4248:	movs	r0, #4
    424a:	mov	r1, r7
    424c:	bl	383c <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    4250:	ldrb	r3, [r6, #0]
    4252:	ldr	r2, [pc, #32]	; (4274 <usb_serial_flush_callback+0x88>)
    4254:	adds	r3, #1
    4256:	uxtb	r3, r3
    4258:	cmp	r3, #3
    425a:	it	hi
    425c:	movhi	r3, #0
    425e:	strb	r3, [r2, #0]
	tx_available = 0;
    4260:	movs	r3, #0
    4262:	strh	r3, [r5, #0]
    4264:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4268:	.word	0x20001ebe
    426c:	.word	0x20001e68
    4270:	.word	0x20001fe6
    4274:	.word	0x20001ebf
    4278:	.word	0x20002000
    427c:	.word	0x20201060
    4280:	.word	0xe000ef70

00004284 <usb_serial_reset>:
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_serial_reset(void)
{
    4284:	bx	lr
    4286:	nop

00004288 <usb_serial_configure>:
void usb_serial_configure(void)
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    4288:	ldr	r3, [pc, #196]	; (4350 <usb_serial_configure+0xc8>)
	printf("usb_serial_reset\n");
	// deallocate all transfer descriptors
}

void usb_serial_configure(void)
{
    428a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    428e:	ldrb	r3, [r3, #0]
		tx_packet_size = CDC_TX_SIZE_480;
    4290:	ldr	r7, [pc, #192]	; (4354 <usb_serial_configure+0xcc>)
void usb_serial_configure(void)
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    4292:	cmp	r3, #0
    4294:	beq.n	4340 <usb_serial_configure+0xb8>
		tx_packet_size = CDC_TX_SIZE_480;
    4296:	mov.w	r3, #512	; 0x200
		rx_packet_size = CDC_RX_SIZE_480;
    429a:	ldr.w	r8, [pc, #236]	; 4388 <usb_serial_configure+0x100>
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
    429e:	strh	r3, [r7, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    42a0:	strh.w	r3, [r8]
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    42a4:	movs	r1, #0
    42a6:	movs	r2, #128	; 0x80
    42a8:	ldr	r0, [pc, #172]	; (4358 <usb_serial_configure+0xd0>)
	tx_head = 0;
    42aa:	mov	r5, r1
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    42ac:	ldr	r6, [pc, #172]	; (435c <usb_serial_configure+0xd4>)
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    42ae:	bl	82b8 <memset>
	tx_head = 0;
    42b2:	ldr	r4, [pc, #172]	; (4360 <usb_serial_configure+0xd8>)
	tx_available = 0;
    42b4:	ldr	r3, [pc, #172]	; (4364 <usb_serial_configure+0xdc>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    42b6:	mov	r1, r5
    42b8:	mov.w	r2, #256	; 0x100
    42bc:	ldr	r0, [pc, #168]	; (4368 <usb_serial_configure+0xe0>)
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    42be:	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    42c0:	mov	r4, r5
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    42c2:	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    42c4:	bl	82b8 <memset>
	memset(rx_count, 0, sizeof(rx_count));
    42c8:	str	r5, [r6, #0]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    42ca:	mov	r3, r5
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    42cc:	str	r5, [r6, #4]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    42ce:	mov	r2, r5
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    42d0:	str	r5, [r6, #8]
    42d2:	str	r5, [r6, #12]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    42d4:	ldr	r1, [pc, #148]	; (436c <usb_serial_configure+0xe4>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
    42d6:	ldr	r6, [pc, #152]	; (4370 <usb_serial_configure+0xe8>)
	rx_head = 0;
	rx_tail = 0;
    42d8:	ldr	r0, [pc, #152]	; (4374 <usb_serial_configure+0xec>)
	rx_available = 0;
    42da:	ldr.w	lr, [pc, #176]	; 438c <usb_serial_configure+0x104>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    42de:	strb	r5, [r1, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    42e0:	movs	r1, #16
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    42e2:	strb	r5, [r0, #0]
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    42e4:	movs	r0, #2
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
    42e6:	str	r5, [r6, #0]
    42e8:	str	r5, [r6, #4]
    42ea:	str	r5, [r6, #8]
    42ec:	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    42ee:	str.w	r5, [lr]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    42f2:	bl	37a4 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    42f6:	ldrh.w	r1, [r8]
    42fa:	mov	r2, r5
    42fc:	ldr	r3, [pc, #120]	; (4378 <usb_serial_configure+0xf0>)
    42fe:	movs	r0, #3
    4300:	bl	3740 <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    4304:	mov	r3, r5
    4306:	ldrh	r1, [r7, #0]
    4308:	movs	r2, #1
    430a:	movs	r0, #4
    430c:	bl	37a4 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    4310:	mov	r0, r4
    4312:	adds	r4, #1
    4314:	bl	40cc <rx_queue_transfer>
    4318:	cmp	r4, #8
    431a:	bne.n	4310 <usb_serial_configure+0x88>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    431c:	ldr	r3, [pc, #92]	; (437c <usb_serial_configure+0xf4>)
	USB1_GPTIMER0LD = microseconds - 1;
    431e:	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    4320:	ldr	r0, [pc, #92]	; (4380 <usb_serial_configure+0xf8>)
	USB1_GPTIMER0CTRL = 0;
    4322:	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    4324:	ldr	r4, [pc, #92]	; (4384 <usb_serial_configure+0xfc>)
    4326:	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    4328:	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    432c:	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    4330:	ldr.w	r2, [r3, #328]	; 0x148
    4334:	orr.w	r2, r2, #16777216	; 0x1000000
    4338:	str.w	r2, [r3, #328]	; 0x148
    433c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    4340:	movs	r3, #64	; 0x40
		rx_packet_size = CDC_RX_SIZE_12;
    4342:	ldr.w	r8, [pc, #68]	; 4388 <usb_serial_configure+0x100>
	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    4346:	strh	r3, [r7, #0]
		rx_packet_size = CDC_RX_SIZE_12;
    4348:	strh.w	r3, [r8]
    434c:	b.n	42a4 <usb_serial_configure+0x1c>
    434e:	nop
    4350:	.word	0x20001e40
    4354:	.word	0x20001ebc
    4358:	.word	0x20002000
    435c:	.word	0x20001fd0
    4360:	.word	0x20001ebf
    4364:	.word	0x20001fe6
    4368:	.word	0x20001ec0
    436c:	.word	0x20001fe4
    4370:	.word	0x20001eac
    4374:	.word	0x20001fc0
    4378:	.word	0x00004139
    437c:	.word	0x402e0000
    4380:	.word	0x20001e30
    4384:	.word	0x000041ed
    4388:	.word	0x20001fce
    438c:	.word	0x20001fe0

00004390 <usb_serial_available>:
}

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	return rx_available;
    4390:	ldr	r3, [pc, #4]	; (4398 <usb_serial_available+0x8>)
    4392:	ldr	r0, [r3, #0]
}
    4394:	bx	lr
    4396:	nop
    4398:	.word	0x20001fe0

0000439c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    439c:	push	{r4, r5, r6, r7}
    439e:	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    43a0:	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    43a2:	mov	r7, r6
    43a4:	b.n	43a8 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    43a6:	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    43a8:	udiv	r3, r0, r2
    43ac:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    43b0:	add.w	r4, r0, #55	; 0x37
    43b4:	cmp	r0, #9
    43b6:	add.w	r0, r0, #48	; 0x30
    43ba:	uxtb	r4, r4
    43bc:	it	ls
    43be:	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    43c0:	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    43c2:	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    43c6:	cmp	r3, #0
    43c8:	bne.n	43a6 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    43ca:	adds	r2, r1, r5
    43cc:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    43ce:	cbz	r5, 43e4 <ultoa+0x48>
    43d0:	adds	r3, #1
		t = buf[j];
    43d2:	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    43d6:	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    43d8:	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    43da:	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    43dc:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    43de:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    43e2:	blt.n	43d0 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    43e4:	mov	r0, r1
    43e6:	pop	{r4, r5, r6, r7}
    43e8:	bx	lr
    43ea:	nop

000043ec <HardwareSerial::processSerialEvents()>:
	//digitalWrite(4, LOW);
}


void HardwareSerial::processSerialEvents()
{
    43ec:	push	{r3, r4, r5, lr}
	if (!serial_event_handlers_active) return;	// bail quick if no one processing SerialEvents.
    43ee:	ldr	r3, [pc, #28]	; (440c <HardwareSerial::processSerialEvents()+0x20>)
    43f0:	ldrb	r4, [r3, #0]
    43f2:	cbz	r4, 4408 <HardwareSerial::processSerialEvents()+0x1c>
    43f4:	ldr	r5, [pc, #24]	; (4410 <HardwareSerial::processSerialEvents()+0x24>)
	uint8_t handlers_still_to_process = serial_event_handlers_active;
	for (uint8_t i = 0; i < 8; i++) {
		if (serial_event_handler_checks[i]) {
    43f6:	ldr.w	r3, [r5, #4]!
    43fa:	cmp	r3, #0
    43fc:	beq.n	43f6 <HardwareSerial::processSerialEvents()+0xa>
			(*serial_event_handler_checks[i])();
    43fe:	blx	r3
			if (--handlers_still_to_process == 0) return;
    4400:	subs	r3, r4, #1
    4402:	ands.w	r4, r3, #255	; 0xff
    4406:	bne.n	43f6 <HardwareSerial::processSerialEvents()+0xa>
    4408:	pop	{r3, r4, r5, pc}
    440a:	nop
    440c:	.word	0x2000209c
    4410:	.word	0x2000207c
    4414:	.word	0x00000000

00004418 <sin>:
    4418:	push	{lr}
    441a:	vmov.f64	d7, d0
    441e:	vmov	r3, s15
    4422:	ldr	r2, [pc, #140]	; (44b0 <sin+0x98>)
    4424:	bic.w	r3, r3, #2147483648	; 0x80000000
    4428:	cmp	r3, r2
    442a:	sub	sp, #20
    442c:	ble.n	4464 <sin+0x4c>
    442e:	ldr	r2, [pc, #132]	; (44b4 <sin+0x9c>)
    4430:	cmp	r3, r2
    4432:	ble.n	443e <sin+0x26>
    4434:	vsub.f64	d0, d0, d0
    4438:	add	sp, #20
    443a:	ldr.w	pc, [sp], #4
    443e:	mov	r0, sp
    4440:	bl	59a8 <__ieee754_rem_pio2>
    4444:	and.w	r0, r0, #3
    4448:	cmp	r0, #1
    444a:	beq.n	4488 <sin+0x70>
    444c:	cmp	r0, #2
    444e:	beq.n	4474 <sin+0x5c>
    4450:	cbz	r0, 4496 <sin+0x7e>
    4452:	vldr	d1, [sp, #8]
    4456:	vldr	d0, [sp]
    445a:	bl	6270 <__kernel_cos>
    445e:	vneg.f64	d0, d0
    4462:	b.n	4438 <sin+0x20>
    4464:	movs	r0, #0
    4466:	vldr	d1, [pc, #64]	; 44a8 <sin+0x90>
    446a:	bl	6a10 <__kernel_sin>
    446e:	add	sp, #20
    4470:	ldr.w	pc, [sp], #4
    4474:	movs	r0, #1
    4476:	vldr	d1, [sp, #8]
    447a:	vldr	d0, [sp]
    447e:	bl	6a10 <__kernel_sin>
    4482:	vneg.f64	d0, d0
    4486:	b.n	4438 <sin+0x20>
    4488:	vldr	d1, [sp, #8]
    448c:	vldr	d0, [sp]
    4490:	bl	6270 <__kernel_cos>
    4494:	b.n	4438 <sin+0x20>
    4496:	movs	r0, #1
    4498:	vldr	d1, [sp, #8]
    449c:	vldr	d0, [sp]
    44a0:	bl	6a10 <__kernel_sin>
    44a4:	b.n	4438 <sin+0x20>
    44a6:	nop
	...
    44b0:	.word	0x3fe921fb
    44b4:	.word	0x7fefffff

000044b8 <cosf>:
    44b8:	push	{lr}
    44ba:	vmov	r3, s0
    44be:	ldr	r2, [pc, #128]	; (4540 <cosf+0x88>)
    44c0:	bic.w	r3, r3, #2147483648	; 0x80000000
    44c4:	cmp	r3, r2
    44c6:	sub	sp, #12
    44c8:	ble.n	44fe <cosf+0x46>
    44ca:	cmp.w	r3, #2139095040	; 0x7f800000
    44ce:	blt.n	44da <cosf+0x22>
    44d0:	vsub.f32	s0, s0, s0
    44d4:	add	sp, #12
    44d6:	ldr.w	pc, [sp], #4
    44da:	mov	r0, sp
    44dc:	bl	5f34 <__ieee754_rem_pio2f>
    44e0:	and.w	r0, r0, #3
    44e4:	cmp	r0, #1
    44e6:	beq.n	451e <cosf+0x66>
    44e8:	cmp	r0, #2
    44ea:	beq.n	450c <cosf+0x54>
    44ec:	cbz	r0, 4530 <cosf+0x78>
    44ee:	movs	r0, #1
    44f0:	vldr	s1, [sp, #4]
    44f4:	vldr	s0, [sp]
    44f8:	bl	71f4 <__kernel_sinf>
    44fc:	b.n	44d4 <cosf+0x1c>
    44fe:	vldr	s1, [pc, #68]	; 4544 <cosf+0x8c>
    4502:	bl	6ac0 <__kernel_cosf>
    4506:	add	sp, #12
    4508:	ldr.w	pc, [sp], #4
    450c:	vldr	s1, [sp, #4]
    4510:	vldr	s0, [sp]
    4514:	bl	6ac0 <__kernel_cosf>
    4518:	vneg.f32	s0, s0
    451c:	b.n	44d4 <cosf+0x1c>
    451e:	vldr	s1, [sp, #4]
    4522:	vldr	s0, [sp]
    4526:	bl	71f4 <__kernel_sinf>
    452a:	vneg.f32	s0, s0
    452e:	b.n	44d4 <cosf+0x1c>
    4530:	vldr	s1, [sp, #4]
    4534:	vldr	s0, [sp]
    4538:	bl	6ac0 <__kernel_cosf>
    453c:	b.n	44d4 <cosf+0x1c>
    453e:	nop
    4540:	.word	0x3f490fd8
    4544:	.word	0x00000000

00004548 <sinf>:
    4548:	push	{lr}
    454a:	vmov	r3, s0
    454e:	ldr	r2, [pc, #132]	; (45d4 <sinf+0x8c>)
    4550:	bic.w	r3, r3, #2147483648	; 0x80000000
    4554:	cmp	r3, r2
    4556:	sub	sp, #12
    4558:	ble.n	4590 <sinf+0x48>
    455a:	cmp.w	r3, #2139095040	; 0x7f800000
    455e:	blt.n	456a <sinf+0x22>
    4560:	vsub.f32	s0, s0, s0
    4564:	add	sp, #12
    4566:	ldr.w	pc, [sp], #4
    456a:	mov	r0, sp
    456c:	bl	5f34 <__ieee754_rem_pio2f>
    4570:	and.w	r0, r0, #3
    4574:	cmp	r0, #1
    4576:	beq.n	45b4 <sinf+0x6c>
    4578:	cmp	r0, #2
    457a:	beq.n	45a0 <sinf+0x58>
    457c:	cbz	r0, 45c2 <sinf+0x7a>
    457e:	vldr	s1, [sp, #4]
    4582:	vldr	s0, [sp]
    4586:	bl	6ac0 <__kernel_cosf>
    458a:	vneg.f32	s0, s0
    458e:	b.n	4564 <sinf+0x1c>
    4590:	movs	r0, #0
    4592:	vldr	s1, [pc, #68]	; 45d8 <sinf+0x90>
    4596:	bl	71f4 <__kernel_sinf>
    459a:	add	sp, #12
    459c:	ldr.w	pc, [sp], #4
    45a0:	movs	r0, #1
    45a2:	vldr	s1, [sp, #4]
    45a6:	vldr	s0, [sp]
    45aa:	bl	71f4 <__kernel_sinf>
    45ae:	vneg.f32	s0, s0
    45b2:	b.n	4564 <sinf+0x1c>
    45b4:	vldr	s1, [sp, #4]
    45b8:	vldr	s0, [sp]
    45bc:	bl	6ac0 <__kernel_cosf>
    45c0:	b.n	4564 <sinf+0x1c>
    45c2:	movs	r0, #1
    45c4:	vldr	s1, [sp, #4]
    45c8:	vldr	s0, [sp]
    45cc:	bl	71f4 <__kernel_sinf>
    45d0:	b.n	4564 <sinf+0x1c>
    45d2:	nop
    45d4:	.word	0x3f490fd8
    45d8:	.word	0x00000000

000045dc <acos>:
    45dc:	push	{r4, lr}
    45de:	vpush	{d8-d9}
    45e2:	vmov.f64	d8, d0
    45e6:	ldr	r4, [pc, #148]	; (467c <acos+0xa0>)
    45e8:	sub	sp, #40	; 0x28
    45ea:	bl	4b18 <__ieee754_acos>
    45ee:	ldrsb.w	r3, [r4]
    45f2:	vmov.f64	d9, d0
    45f6:	adds	r3, #1
    45f8:	beq.n	4658 <acos+0x7c>
    45fa:	vcmp.f64	d8, d8
    45fe:	vmrs	APSR_nzcv, fpscr
    4602:	bvs.n	4658 <acos+0x7c>
    4604:	vmov.f64	d0, d8
    4608:	bl	748c <fabs>
    460c:	vmov.f64	d7, #112	; 0x3f800000  1.0
    4610:	vcmpe.f64	d0, d7
    4614:	vmrs	APSR_nzcv, fpscr
    4618:	ble.n	4658 <acos+0x7c>
    461a:	movs	r3, #1
    461c:	ldr	r2, [pc, #96]	; (4680 <acos+0xa4>)
    461e:	str	r3, [sp, #0]
    4620:	ldr	r0, [pc, #96]	; (4684 <acos+0xa8>)
    4622:	str	r2, [sp, #4]
    4624:	movs	r3, #0
    4626:	str	r3, [sp, #32]
    4628:	vstr	d8, [sp, #16]
    462c:	vstr	d8, [sp, #8]
    4630:	bl	75d0 <nan>
    4634:	ldrsb.w	r3, [r4]
    4638:	cmp	r3, #2
    463a:	vstr	d0, [sp, #24]
    463e:	beq.n	4664 <acos+0x88>
    4640:	mov	r0, sp
    4642:	bl	75c8 <matherr>
    4646:	cbz	r0, 4664 <acos+0x88>
    4648:	ldr	r3, [sp, #32]
    464a:	cbnz	r3, 4672 <acos+0x96>
    464c:	vldr	d0, [sp, #24]
    4650:	add	sp, #40	; 0x28
    4652:	vpop	{d8-d9}
    4656:	pop	{r4, pc}
    4658:	vmov.f64	d0, d9
    465c:	add	sp, #40	; 0x28
    465e:	vpop	{d8-d9}
    4662:	pop	{r4, pc}
    4664:	bl	7bb4 <__errno>
    4668:	movs	r3, #33	; 0x21
    466a:	str	r3, [r0, #0]
    466c:	ldr	r3, [sp, #32]
    466e:	cmp	r3, #0
    4670:	beq.n	464c <acos+0x70>
    4672:	bl	7bb4 <__errno>
    4676:	ldr	r3, [sp, #32]
    4678:	str	r3, [r0, #0]
    467a:	b.n	464c <acos+0x70>
    467c:	.word	0x20001023
    4680:	.word	0x20000808
    4684:	.word	0x20000e54

00004688 <asin>:
    4688:	push	{r4, lr}
    468a:	vpush	{d8-d9}
    468e:	vmov.f64	d8, d0
    4692:	ldr	r4, [pc, #148]	; (4728 <asin+0xa0>)
    4694:	sub	sp, #40	; 0x28
    4696:	bl	4dd8 <__ieee754_asin>
    469a:	ldrsb.w	r3, [r4]
    469e:	vmov.f64	d9, d0
    46a2:	adds	r3, #1
    46a4:	beq.n	4704 <asin+0x7c>
    46a6:	vcmp.f64	d8, d8
    46aa:	vmrs	APSR_nzcv, fpscr
    46ae:	bvs.n	4704 <asin+0x7c>
    46b0:	vmov.f64	d0, d8
    46b4:	bl	748c <fabs>
    46b8:	vmov.f64	d7, #112	; 0x3f800000  1.0
    46bc:	vcmpe.f64	d0, d7
    46c0:	vmrs	APSR_nzcv, fpscr
    46c4:	ble.n	4704 <asin+0x7c>
    46c6:	movs	r3, #1
    46c8:	ldr	r2, [pc, #96]	; (472c <asin+0xa4>)
    46ca:	str	r3, [sp, #0]
    46cc:	ldr	r0, [pc, #96]	; (4730 <asin+0xa8>)
    46ce:	str	r2, [sp, #4]
    46d0:	movs	r3, #0
    46d2:	str	r3, [sp, #32]
    46d4:	vstr	d8, [sp, #16]
    46d8:	vstr	d8, [sp, #8]
    46dc:	bl	75d0 <nan>
    46e0:	ldrsb.w	r3, [r4]
    46e4:	cmp	r3, #2
    46e6:	vstr	d0, [sp, #24]
    46ea:	beq.n	4710 <asin+0x88>
    46ec:	mov	r0, sp
    46ee:	bl	75c8 <matherr>
    46f2:	cbz	r0, 4710 <asin+0x88>
    46f4:	ldr	r3, [sp, #32]
    46f6:	cbnz	r3, 471e <asin+0x96>
    46f8:	vldr	d0, [sp, #24]
    46fc:	add	sp, #40	; 0x28
    46fe:	vpop	{d8-d9}
    4702:	pop	{r4, pc}
    4704:	vmov.f64	d0, d9
    4708:	add	sp, #40	; 0x28
    470a:	vpop	{d8-d9}
    470e:	pop	{r4, pc}
    4710:	bl	7bb4 <__errno>
    4714:	movs	r3, #33	; 0x21
    4716:	str	r3, [r0, #0]
    4718:	ldr	r3, [sp, #32]
    471a:	cmp	r3, #0
    471c:	beq.n	46f8 <asin+0x70>
    471e:	bl	7bb4 <__errno>
    4722:	ldr	r3, [sp, #32]
    4724:	str	r3, [r0, #0]
    4726:	b.n	46f8 <asin+0x70>
    4728:	.word	0x20001023
    472c:	.word	0x20000810
    4730:	.word	0x20000e54

00004734 <atan2>:
    4734:	b.w	5040 <__ieee754_atan2>

00004738 <pow>:
    4738:	push	{r4, r5, r6, r7, lr}
    473a:	vpush	{d8-d11}
    473e:	vmov.f64	d10, d0
    4742:	vmov.f64	d9, d1
    4746:	ldr	r4, [pc, #600]	; (49a0 <pow+0x268>)
    4748:	sub	sp, #44	; 0x2c
    474a:	bl	5220 <__ieee754_pow>
    474e:	ldrsb.w	r3, [r4]
    4752:	vmov.f64	d8, d0
    4756:	adds	r2, r3, #1
    4758:	beq.n	47c4 <pow+0x8c>
    475a:	vcmp.f64	d9, d9
    475e:	vmrs	APSR_nzcv, fpscr
    4762:	bvs.n	47c4 <pow+0x8c>
    4764:	vcmp.f64	d10, d10
    4768:	vmrs	APSR_nzcv, fpscr
    476c:	bvs.n	485c <pow+0x124>
    476e:	vldr	d11, [pc, #552]	; 4998 <pow+0x260>
    4772:	vcmp.f64	d10, d11
    4776:	vmrs	APSR_nzcv, fpscr
    477a:	bne.n	47d0 <pow+0x98>
    477c:	vcmp.f64	d9, d11
    4780:	vmrs	APSR_nzcv, fpscr
    4784:	bne.n	47ae <pow+0x76>
    4786:	movs	r2, #1
    4788:	ldr	r1, [pc, #536]	; (49a4 <pow+0x26c>)
    478a:	str	r2, [sp, #0]
    478c:	movs	r2, #0
    478e:	vstr	d10, [sp, #8]
    4792:	vstr	d9, [sp, #16]
    4796:	vstr	d11, [sp, #24]
    479a:	str	r1, [sp, #4]
    479c:	str	r2, [sp, #32]
    479e:	cmp	r3, #0
    47a0:	beq.n	483a <pow+0x102>
    47a2:	vmov.f64	d0, #112	; 0x3f800000  1.0
    47a6:	add	sp, #44	; 0x2c
    47a8:	vpop	{d8-d11}
    47ac:	pop	{r4, r5, r6, r7, pc}
    47ae:	vmov.f64	d0, d9
    47b2:	bl	749c <finite>
    47b6:	cbz	r0, 47c4 <pow+0x8c>
    47b8:	vcmpe.f64	d9, #0.0
    47bc:	vmrs	APSR_nzcv, fpscr
    47c0:	bmi.w	4904 <pow+0x1cc>
    47c4:	vmov.f64	d0, d8
    47c8:	add	sp, #44	; 0x2c
    47ca:	vpop	{d8-d11}
    47ce:	pop	{r4, r5, r6, r7, pc}
    47d0:	bl	749c <finite>
    47d4:	mov	r5, r0
    47d6:	cmp	r0, #0
    47d8:	beq.n	488a <pow+0x152>
    47da:	vcmp.f64	d8, #0.0
    47de:	vmrs	APSR_nzcv, fpscr
    47e2:	mov.w	r6, #0
    47e6:	mov.w	r7, #0
    47ea:	bne.n	47c4 <pow+0x8c>
    47ec:	vmov.f64	d0, d10
    47f0:	bl	749c <finite>
    47f4:	cmp	r0, #0
    47f6:	beq.n	47c4 <pow+0x8c>
    47f8:	vmov.f64	d0, d9
    47fc:	bl	749c <finite>
    4800:	cmp	r0, #0
    4802:	beq.n	47c4 <pow+0x8c>
    4804:	ldr	r2, [pc, #412]	; (49a4 <pow+0x26c>)
    4806:	str	r2, [sp, #4]
    4808:	vstr	d10, [sp, #8]
    480c:	vstr	d9, [sp, #16]
    4810:	strd	r6, r7, [sp, #24]
    4814:	movs	r1, #4
    4816:	movs	r2, #0
    4818:	ldrsb.w	r3, [r4]
    481c:	str	r1, [sp, #0]
    481e:	str	r2, [sp, #32]
    4820:	cmp	r3, #2
    4822:	beq.n	482c <pow+0xf4>
    4824:	mov	r0, sp
    4826:	bl	75c8 <matherr>
    482a:	cbnz	r0, 4844 <pow+0x10c>
    482c:	bl	7bb4 <__errno>
    4830:	movs	r3, #34	; 0x22
    4832:	str	r3, [r0, #0]
    4834:	b.n	4844 <pow+0x10c>
    4836:	vstr	d11, [sp, #24]
    483a:	mov	r0, sp
    483c:	bl	75c8 <matherr>
    4840:	cmp	r0, #0
    4842:	beq.n	492c <pow+0x1f4>
    4844:	ldr	r3, [sp, #32]
    4846:	cbz	r3, 4850 <pow+0x118>
    4848:	bl	7bb4 <__errno>
    484c:	ldr	r3, [sp, #32]
    484e:	str	r3, [r0, #0]
    4850:	vldr	d0, [sp, #24]
    4854:	add	sp, #44	; 0x2c
    4856:	vpop	{d8-d11}
    485a:	pop	{r4, r5, r6, r7, pc}
    485c:	vcmp.f64	d9, #0.0
    4860:	vmrs	APSR_nzcv, fpscr
    4864:	bne.n	47c4 <pow+0x8c>
    4866:	vmov.f64	d0, #112	; 0x3f800000  1.0
    486a:	movs	r2, #1
    486c:	ldr	r1, [pc, #308]	; (49a4 <pow+0x26c>)
    486e:	str	r2, [sp, #0]
    4870:	cmp	r3, #2
    4872:	mov.w	r2, #0
    4876:	vstr	d10, [sp, #8]
    487a:	vstr	d9, [sp, #16]
    487e:	str	r1, [sp, #4]
    4880:	str	r2, [sp, #32]
    4882:	vstr	d0, [sp, #24]
    4886:	bne.n	483a <pow+0x102>
    4888:	b.n	47c8 <pow+0x90>
    488a:	vmov.f64	d0, d10
    488e:	bl	749c <finite>
    4892:	cmp	r0, #0
    4894:	beq.n	47da <pow+0xa2>
    4896:	vmov.f64	d0, d9
    489a:	bl	749c <finite>
    489e:	cmp	r0, #0
    48a0:	beq.n	47da <pow+0xa2>
    48a2:	vcmp.f64	d8, d8
    48a6:	vmrs	APSR_nzcv, fpscr
    48aa:	ldrsb.w	r3, [r4]
    48ae:	ldr	r2, [pc, #244]	; (49a4 <pow+0x26c>)
    48b0:	str	r5, [sp, #32]
    48b2:	bvs.n	4972 <pow+0x23a>
    48b4:	movs	r1, #3
    48b6:	vstr	d10, [sp, #8]
    48ba:	vstr	d9, [sp, #16]
    48be:	stmia.w	sp, {r1, r2}
    48c2:	cmp	r3, #0
    48c4:	bne.n	4936 <pow+0x1fe>
    48c6:	vcmpe.f64	d10, #0.0
    48ca:	ldr	r3, [pc, #220]	; (49a8 <pow+0x270>)
    48cc:	mov.w	r2, #3758096384	; 0xe0000000
    48d0:	vmrs	APSR_nzcv, fpscr
    48d4:	strd	r2, r3, [sp, #24]
    48d8:	bpl.n	4824 <pow+0xec>
    48da:	vmov.f64	d7, #96	; 0x3f000000  0.5
    48de:	vmul.f64	d9, d9, d7
    48e2:	vmov.f64	d0, d9
    48e6:	bl	75e0 <rint>
    48ea:	vcmp.f64	d9, d0
    48ee:	vmrs	APSR_nzcv, fpscr
    48f2:	beq.n	496c <pow+0x234>
    48f4:	ldr	r1, [pc, #180]	; (49ac <pow+0x274>)
    48f6:	ldrsb.w	r3, [r4]
    48fa:	mov.w	r0, #3758096384	; 0xe0000000
    48fe:	strd	r0, r1, [sp, #24]
    4902:	b.n	4820 <pow+0xe8>
    4904:	ldr	r2, [pc, #156]	; (49a4 <pow+0x26c>)
    4906:	ldrsb.w	r3, [r4]
    490a:	str	r2, [sp, #4]
    490c:	movs	r1, #1
    490e:	movs	r2, #0
    4910:	vstr	d10, [sp, #8]
    4914:	vstr	d9, [sp, #16]
    4918:	str	r1, [sp, #0]
    491a:	str	r2, [sp, #32]
    491c:	cmp	r3, #0
    491e:	beq.n	4836 <pow+0xfe>
    4920:	ldr	r1, [pc, #140]	; (49b0 <pow+0x278>)
    4922:	movs	r0, #0
    4924:	cmp	r3, #2
    4926:	strd	r0, r1, [sp, #24]
    492a:	bne.n	483a <pow+0x102>
    492c:	bl	7bb4 <__errno>
    4930:	movs	r3, #33	; 0x21
    4932:	str	r3, [r0, #0]
    4934:	b.n	4844 <pow+0x10c>
    4936:	ldr	r1, [pc, #124]	; (49b4 <pow+0x27c>)
    4938:	vcmpe.f64	d10, #0.0
    493c:	movs	r0, #0
    493e:	vmrs	APSR_nzcv, fpscr
    4942:	strd	r0, r1, [sp, #24]
    4946:	bpl.w	4820 <pow+0xe8>
    494a:	vmov.f64	d7, #96	; 0x3f000000  0.5
    494e:	vmul.f64	d9, d9, d7
    4952:	vmov.f64	d0, d9
    4956:	bl	75e0 <rint>
    495a:	vcmp.f64	d9, d0
    495e:	vmrs	APSR_nzcv, fpscr
    4962:	beq.n	496c <pow+0x234>
    4964:	ldr	r3, [pc, #72]	; (49b0 <pow+0x278>)
    4966:	movs	r2, #0
    4968:	strd	r2, r3, [sp, #24]
    496c:	ldrsb.w	r3, [r4]
    4970:	b.n	4820 <pow+0xe8>
    4972:	movs	r1, #1
    4974:	vstr	d10, [sp, #8]
    4978:	vstr	d9, [sp, #16]
    497c:	stmia.w	sp, {r1, r2}
    4980:	cmp	r3, #0
    4982:	beq.w	4836 <pow+0xfe>
    4986:	vdiv.f64	d7, d11, d11
    498a:	cmp	r3, #2
    498c:	vstr	d7, [sp, #24]
    4990:	beq.n	492c <pow+0x1f4>
    4992:	b.n	483a <pow+0x102>
    4994:	nop.w
	...
    49a0:	.word	0x20001023
    49a4:	.word	0x20000818
    49a8:	.word	0x47efffff
    49ac:	.word	0xc7efffff
    49b0:	.word	0xfff00000
    49b4:	.word	0x7ff00000

000049b8 <sqrt>:
    49b8:	push	{lr}
    49ba:	vpush	{d8}
    49be:	vmov.f64	d8, d0
    49c2:	sub	sp, #44	; 0x2c
    49c4:	bl	5c44 <__ieee754_sqrt>
    49c8:	ldr	r3, [pc, #140]	; (4a58 <sqrt+0xa0>)
    49ca:	ldrsb.w	r3, [r3]
    49ce:	adds	r2, r3, #1
    49d0:	beq.n	49ea <sqrt+0x32>
    49d2:	vcmp.f64	d8, d8
    49d6:	vmrs	APSR_nzcv, fpscr
    49da:	bvs.n	49ea <sqrt+0x32>
    49dc:	vldr	d7, [pc, #112]	; 4a50 <sqrt+0x98>
    49e0:	vcmpe.f64	d8, d7
    49e4:	vmrs	APSR_nzcv, fpscr
    49e8:	bmi.n	49f4 <sqrt+0x3c>
    49ea:	add	sp, #44	; 0x2c
    49ec:	vpop	{d8}
    49f0:	ldr.w	pc, [sp], #4
    49f4:	movs	r2, #1
    49f6:	ldr	r1, [pc, #100]	; (4a5c <sqrt+0xa4>)
    49f8:	str	r2, [sp, #0]
    49fa:	movs	r2, #0
    49fc:	vstr	d8, [sp, #16]
    4a00:	vstr	d8, [sp, #8]
    4a04:	str	r1, [sp, #4]
    4a06:	str	r2, [sp, #32]
    4a08:	cbz	r3, 4a30 <sqrt+0x78>
    4a0a:	vdiv.f64	d6, d7, d7
    4a0e:	cmp	r3, #2
    4a10:	vstr	d6, [sp, #24]
    4a14:	bne.n	4a34 <sqrt+0x7c>
    4a16:	bl	7bb4 <__errno>
    4a1a:	movs	r3, #33	; 0x21
    4a1c:	str	r3, [r0, #0]
    4a1e:	ldr	r3, [sp, #32]
    4a20:	cbnz	r3, 4a40 <sqrt+0x88>
    4a22:	vldr	d0, [sp, #24]
    4a26:	add	sp, #44	; 0x2c
    4a28:	vpop	{d8}
    4a2c:	ldr.w	pc, [sp], #4
    4a30:	vstr	d7, [sp, #24]
    4a34:	mov	r0, sp
    4a36:	bl	75c8 <matherr>
    4a3a:	cmp	r0, #0
    4a3c:	bne.n	4a1e <sqrt+0x66>
    4a3e:	b.n	4a16 <sqrt+0x5e>
    4a40:	bl	7bb4 <__errno>
    4a44:	ldr	r3, [sp, #32]
    4a46:	str	r3, [r0, #0]
    4a48:	b.n	4a22 <sqrt+0x6a>
    4a4a:	nop
    4a4c:	nop.w
	...
    4a58:	.word	0x20001023
    4a5c:	.word	0x2000081c

00004a60 <atan2f>:
    4a60:	b.w	5dc8 <__ieee754_atan2f>
    4a64:	movs	r0, r0
	...

00004a68 <sqrtf>:
    4a68:	push	{lr}
    4a6a:	vpush	{d8}
    4a6e:	sub	sp, #44	; 0x2c
    4a70:	vmov.f32	s16, s0
    4a74:	bl	61cc <__ieee754_sqrtf>
    4a78:	ldr	r3, [pc, #148]	; (4b10 <sqrtf+0xa8>)
    4a7a:	ldrsb.w	r3, [r3]
    4a7e:	adds	r2, r3, #1
    4a80:	beq.n	4a96 <sqrtf+0x2e>
    4a82:	vcmp.f32	s16, s16
    4a86:	vmrs	APSR_nzcv, fpscr
    4a8a:	bvs.n	4a96 <sqrtf+0x2e>
    4a8c:	vcmpe.f32	s16, #0.0
    4a90:	vmrs	APSR_nzcv, fpscr
    4a94:	bmi.n	4aa0 <sqrtf+0x38>
    4a96:	add	sp, #44	; 0x2c
    4a98:	vpop	{d8}
    4a9c:	ldr.w	pc, [sp], #4
    4aa0:	vcvt.f64.f32	d0, s16
    4aa4:	movs	r2, #1
    4aa6:	ldr	r1, [pc, #108]	; (4b14 <sqrtf+0xac>)
    4aa8:	str	r2, [sp, #0]
    4aaa:	movs	r2, #0
    4aac:	vstr	d0, [sp, #16]
    4ab0:	vstr	d0, [sp, #8]
    4ab4:	str	r1, [sp, #4]
    4ab6:	str	r2, [sp, #32]
    4ab8:	cbz	r3, 4ae8 <sqrtf+0x80>
    4aba:	vldr	d7, [pc, #76]	; 4b08 <sqrtf+0xa0>
    4abe:	cmp	r3, #2
    4ac0:	vdiv.f64	d6, d7, d7
    4ac4:	vstr	d6, [sp, #24]
    4ac8:	bne.n	4af0 <sqrtf+0x88>
    4aca:	bl	7bb4 <__errno>
    4ace:	movs	r3, #33	; 0x21
    4ad0:	str	r3, [r0, #0]
    4ad2:	ldr	r3, [sp, #32]
    4ad4:	cbnz	r3, 4afc <sqrtf+0x94>
    4ad6:	vldr	d0, [sp, #24]
    4ada:	vcvt.f32.f64	s0, d0
    4ade:	add	sp, #44	; 0x2c
    4ae0:	vpop	{d8}
    4ae4:	ldr.w	pc, [sp], #4
    4ae8:	movs	r2, #0
    4aea:	movs	r3, #0
    4aec:	strd	r2, r3, [sp, #24]
    4af0:	mov	r0, sp
    4af2:	bl	75c8 <matherr>
    4af6:	cmp	r0, #0
    4af8:	bne.n	4ad2 <sqrtf+0x6a>
    4afa:	b.n	4aca <sqrtf+0x62>
    4afc:	bl	7bb4 <__errno>
    4b00:	ldr	r3, [sp, #32]
    4b02:	str	r3, [r0, #0]
    4b04:	b.n	4ad6 <sqrtf+0x6e>
    4b06:	nop
	...
    4b10:	.word	0x20001023
    4b14:	.word	0x20000824

00004b18 <__ieee754_acos>:
    4b18:	push	{lr}
    4b1a:	vpush	{d8-d9}
    4b1e:	sub	sp, #12
    4b20:	vstr	d0, [sp]
    4b24:	ldr	r2, [sp, #4]
    4b26:	ldr	r1, [pc, #672]	; (4dc8 <__ieee754_acos+0x2b0>)
    4b28:	bic.w	r3, r2, #2147483648	; 0x80000000
    4b2c:	cmp	r3, r1
    4b2e:	ble.n	4b58 <__ieee754_acos+0x40>
    4b30:	add.w	r3, r3, #3221225472	; 0xc0000000
    4b34:	ldr	r1, [sp, #0]
    4b36:	add.w	r3, r3, #1048576	; 0x100000
    4b3a:	orrs	r3, r1
    4b3c:	bne.n	4c24 <__ieee754_acos+0x10c>
    4b3e:	vldr	d7, [pc, #528]	; 4d50 <__ieee754_acos+0x238>
    4b42:	vldr	d0, [pc, #532]	; 4d58 <__ieee754_acos+0x240>
    4b46:	cmp	r2, #0
    4b48:	it	gt
    4b4a:	vmovgt.f64	d0, d7
    4b4e:	add	sp, #12
    4b50:	vpop	{d8-d9}
    4b54:	ldr.w	pc, [sp], #4
    4b58:	ldr	r1, [pc, #624]	; (4dcc <__ieee754_acos+0x2b4>)
    4b5a:	cmp	r3, r1
    4b5c:	ble.n	4c10 <__ieee754_acos+0xf8>
    4b5e:	cmp	r2, #0
    4b60:	ldrd	r0, r1, [sp]
    4b64:	blt.w	4cbc <__ieee754_acos+0x1a4>
    4b68:	vmov.f64	d7, #96	; 0x3f000000  0.5
    4b6c:	vmov.f64	d9, #112	; 0x3f800000  1.0
    4b70:	vmov	d6, r0, r1
    4b74:	vsub.f64	d8, d9, d6
    4b78:	vmul.f64	d8, d8, d7
    4b7c:	vmov.f64	d0, d8
    4b80:	bl	5c44 <__ieee754_sqrt>
    4b84:	vldr	d5, [pc, #472]	; 4d60 <__ieee754_acos+0x248>
    4b88:	vldr	d6, [pc, #476]	; 4d68 <__ieee754_acos+0x250>
    4b8c:	vldr	d7, [pc, #480]	; 4d70 <__ieee754_acos+0x258>
    4b90:	vfma.f64	d6, d8, d5
    4b94:	vldr	d5, [pc, #480]	; 4d78 <__ieee754_acos+0x260>
    4b98:	vfma.f64	d7, d8, d6
    4b9c:	vldr	d6, [pc, #480]	; 4d80 <__ieee754_acos+0x268>
    4ba0:	vfma.f64	d5, d8, d7
    4ba4:	vldr	d7, [pc, #480]	; 4d88 <__ieee754_acos+0x270>
    4ba8:	vfma.f64	d6, d8, d5
    4bac:	vstr	d0, [sp]
    4bb0:	vfma.f64	d7, d8, d6
    4bb4:	vmul.f64	d4, d7, d8
    4bb8:	ldrd	r2, r3, [sp]
    4bbc:	vldr	d3, [pc, #464]	; 4d90 <__ieee754_acos+0x278>
    4bc0:	vldr	d7, [pc, #468]	; 4d98 <__ieee754_acos+0x280>
    4bc4:	vldr	d5, [pc, #472]	; 4da0 <__ieee754_acos+0x288>
    4bc8:	vfma.f64	d7, d8, d3
    4bcc:	vmov.f64	d3, d8
    4bd0:	movs	r2, #0
    4bd2:	vldr	d6, [pc, #468]	; 4da8 <__ieee754_acos+0x290>
    4bd6:	vfma.f64	d5, d8, d7
    4bda:	vmov	d7, r2, r3
    4bde:	vfma.f64	d6, d8, d5
    4be2:	vfms.f64	d3, d7, d7
    4be6:	vadd.f64	d5, d0, d7
    4bea:	vdiv.f64	d0, d3, d5
    4bee:	vldr	d5, [sp]
    4bf2:	vfma.f64	d9, d8, d6
    4bf6:	vdiv.f64	d6, d4, d9
    4bfa:	vfma.f64	d0, d5, d6
    4bfe:	vadd.f64	d0, d0, d7
    4c02:	vadd.f64	d0, d0, d0
    4c06:	add	sp, #12
    4c08:	vpop	{d8-d9}
    4c0c:	ldr.w	pc, [sp], #4
    4c10:	ldr	r2, [pc, #444]	; (4dd0 <__ieee754_acos+0x2b8>)
    4c12:	cmp	r3, r2
    4c14:	bgt.n	4c3a <__ieee754_acos+0x122>
    4c16:	vldr	d0, [pc, #408]	; 4db0 <__ieee754_acos+0x298>
    4c1a:	add	sp, #12
    4c1c:	vpop	{d8-d9}
    4c20:	ldr.w	pc, [sp], #4
    4c24:	vldr	d7, [sp]
    4c28:	vsub.f64	d7, d7, d7
    4c2c:	vdiv.f64	d0, d7, d7
    4c30:	add	sp, #12
    4c32:	vpop	{d8-d9}
    4c36:	ldr.w	pc, [sp], #4
    4c3a:	vldr	d7, [sp]
    4c3e:	vmov.f64	d5, #112	; 0x3f800000  1.0
    4c42:	vldr	d3, [pc, #284]	; 4d60 <__ieee754_acos+0x248>
    4c46:	vmul.f64	d7, d7, d7
    4c4a:	vldr	d4, [pc, #284]	; 4d68 <__ieee754_acos+0x250>
    4c4e:	vldr	d6, [pc, #288]	; 4d70 <__ieee754_acos+0x258>
    4c52:	vfma.f64	d4, d7, d3
    4c56:	vldr	d3, [pc, #288]	; 4d78 <__ieee754_acos+0x260>
    4c5a:	vfma.f64	d6, d7, d4
    4c5e:	vldr	d4, [pc, #288]	; 4d80 <__ieee754_acos+0x268>
    4c62:	vfma.f64	d3, d7, d6
    4c66:	vldr	d6, [pc, #288]	; 4d88 <__ieee754_acos+0x270>
    4c6a:	vfma.f64	d4, d7, d3
    4c6e:	vldr	d1, [pc, #288]	; 4d90 <__ieee754_acos+0x278>
    4c72:	vfma.f64	d6, d7, d4
    4c76:	vmul.f64	d6, d6, d7
    4c7a:	vldr	d2, [pc, #284]	; 4d98 <__ieee754_acos+0x280>
    4c7e:	vldr	d3, [pc, #288]	; 4da0 <__ieee754_acos+0x288>
    4c82:	vfma.f64	d2, d7, d1
    4c86:	vldr	d4, [pc, #288]	; 4da8 <__ieee754_acos+0x290>
    4c8a:	vfma.f64	d3, d7, d2
    4c8e:	vldr	d0, [pc, #296]	; 4db8 <__ieee754_acos+0x2a0>
    4c92:	vfma.f64	d4, d7, d3
    4c96:	vfma.f64	d5, d7, d4
    4c9a:	vldr	d7, [pc, #276]	; 4db0 <__ieee754_acos+0x298>
    4c9e:	vdiv.f64	d4, d6, d5
    4ca2:	vldr	d6, [sp]
    4ca6:	vfms.f64	d0, d6, d4
    4caa:	vsub.f64	d0, d6, d0
    4cae:	vsub.f64	d0, d7, d0
    4cb2:	add	sp, #12
    4cb4:	vpop	{d8-d9}
    4cb8:	ldr.w	pc, [sp], #4
    4cbc:	vmov	d5, r0, r1
    4cc0:	vmov.f64	d6, #112	; 0x3f800000  1.0
    4cc4:	vldr	d4, [pc, #152]	; 4d60 <__ieee754_acos+0x248>
    4cc8:	vadd.f64	d8, d5, d6
    4ccc:	vmov.f64	d7, #96	; 0x3f000000  0.5
    4cd0:	vldr	d5, [pc, #148]	; 4d68 <__ieee754_acos+0x250>
    4cd4:	vmul.f64	d7, d8, d7
    4cd8:	vmov.f64	d0, d7
    4cdc:	vldr	d3, [pc, #144]	; 4d70 <__ieee754_acos+0x258>
    4ce0:	vfma.f64	d5, d7, d4
    4ce4:	vldr	d8, [pc, #160]	; 4d88 <__ieee754_acos+0x270>
    4ce8:	vfma.f64	d3, d7, d5
    4cec:	vldr	d4, [pc, #136]	; 4d78 <__ieee754_acos+0x260>
    4cf0:	vldr	d5, [pc, #140]	; 4d80 <__ieee754_acos+0x268>
    4cf4:	vfma.f64	d4, d7, d3
    4cf8:	vldr	d2, [pc, #148]	; 4d90 <__ieee754_acos+0x278>
    4cfc:	vfma.f64	d5, d7, d4
    4d00:	vfma.f64	d8, d7, d5
    4d04:	vldr	d3, [pc, #144]	; 4d98 <__ieee754_acos+0x280>
    4d08:	vmul.f64	d8, d8, d7
    4d0c:	vldr	d4, [pc, #144]	; 4da0 <__ieee754_acos+0x288>
    4d10:	vfma.f64	d3, d7, d2
    4d14:	vldr	d5, [pc, #144]	; 4da8 <__ieee754_acos+0x290>
    4d18:	vfma.f64	d4, d7, d3
    4d1c:	vfma.f64	d5, d7, d4
    4d20:	vfma.f64	d6, d7, d5
    4d24:	vmov.f64	d9, d6
    4d28:	bl	5c44 <__ieee754_sqrt>
    4d2c:	vdiv.f64	d4, d8, d9
    4d30:	vmov.f64	d5, #0	; 0x40000000  2.0
    4d34:	vldr	d6, [pc, #136]	; 4dc0 <__ieee754_acos+0x2a8>
    4d38:	vldr	d7, [pc, #28]	; 4d58 <__ieee754_acos+0x240>
    4d3c:	vfma.f64	d6, d0, d4
    4d40:	vadd.f64	d0, d6, d0
    4d44:	vfms.f64	d7, d0, d5
    4d48:	vmov.f64	d0, d7
    4d4c:	b.n	4b4e <__ieee754_acos+0x36>
    4d4e:	nop
	...
    4d58:	.word	0x54442d18
    4d5c:	.word	0x400921fb
    4d60:	.word	0x0dfdf709
    4d64:	.word	0x3f023de1
    4d68:	.word	0x7501b288
    4d6c:	.word	0x3f49efe0
    4d70:	.word	0xb5688f3b
    4d74:	.word	0xbfa48228
    4d78:	.word	0x0e884455
    4d7c:	.word	0x3fc9c155
    4d80:	.word	0x03eb6f7d
    4d84:	.word	0xbfd4d612
    4d88:	.word	0x55555555
    4d8c:	.word	0x3fc55555
    4d90:	.word	0xb12e9282
    4d94:	.word	0x3fb3b8c5
    4d98:	.word	0x1b8d0159
    4d9c:	.word	0xbfe6066c
    4da0:	.word	0x9c598ac8
    4da4:	.word	0x40002ae5
    4da8:	.word	0x1c8a2d4b
    4dac:	.word	0xc0033a27
    4db0:	.word	0x54442d18
    4db4:	.word	0x3ff921fb
    4db8:	.word	0x33145c07
    4dbc:	.word	0x3c91a626
    4dc0:	.word	0x33145c07
    4dc4:	.word	0xbc91a626
    4dc8:	.word	0x3fefffff
    4dcc:	.word	0x3fdfffff
    4dd0:	.word	0x3c600000
    4dd4:	.word	0x00000000

00004dd8 <__ieee754_asin>:
    4dd8:	push	{r4, r5, lr}
    4dda:	vmov	r5, s1
    4dde:	vpush	{d8-d10}
    4de2:	ldr	r3, [pc, #588]	; (5030 <__ieee754_asin+0x258>)
    4de4:	bic.w	r4, r5, #2147483648	; 0x80000000
    4de8:	cmp	r4, r3
    4dea:	sub	sp, #12
    4dec:	ble.n	4e10 <__ieee754_asin+0x38>
    4dee:	add.w	r4, r4, #3221225472	; 0xc0000000
    4df2:	vmov	r3, s0
    4df6:	add.w	r4, r4, #1048576	; 0x100000
    4dfa:	orrs	r3, r4
    4dfc:	beq.w	4f10 <__ieee754_asin+0x138>
    4e00:	vsub.f64	d7, d0, d0
    4e04:	vdiv.f64	d0, d7, d7
    4e08:	add	sp, #12
    4e0a:	vpop	{d8-d10}
    4e0e:	pop	{r4, r5, pc}
    4e10:	ldr	r3, [pc, #544]	; (5034 <__ieee754_asin+0x25c>)
    4e12:	cmp	r4, r3
    4e14:	bgt.n	4e34 <__ieee754_asin+0x5c>
    4e16:	cmp.w	r4, #1044381696	; 0x3e400000
    4e1a:	bge.w	4f4e <__ieee754_asin+0x176>
    4e1e:	vmov.f64	d6, #112	; 0x3f800000  1.0
    4e22:	vldr	d7, [pc, #404]	; 4fb8 <__ieee754_asin+0x1e0>
    4e26:	vadd.f64	d7, d0, d7
    4e2a:	vcmpe.f64	d7, d6
    4e2e:	vmrs	APSR_nzcv, fpscr
    4e32:	bgt.n	4e08 <__ieee754_asin+0x30>
    4e34:	bl	748c <fabs>
    4e38:	vmov.f64	d7, #112	; 0x3f800000  1.0
    4e3c:	vmov.f64	d6, #96	; 0x3f000000  0.5
    4e40:	vsub.f64	d0, d7, d0
    4e44:	vldr	d5, [pc, #376]	; 4fc0 <__ieee754_asin+0x1e8>
    4e48:	vmul.f64	d8, d0, d6
    4e4c:	vmov.f64	d0, d8
    4e50:	vldr	d6, [pc, #372]	; 4fc8 <__ieee754_asin+0x1f0>
    4e54:	vldr	d4, [pc, #376]	; 4fd0 <__ieee754_asin+0x1f8>
    4e58:	vfma.f64	d6, d8, d5
    4e5c:	vldr	d9, [pc, #376]	; 4fd8 <__ieee754_asin+0x200>
    4e60:	vfma.f64	d4, d8, d6
    4e64:	vldr	d5, [pc, #376]	; 4fe0 <__ieee754_asin+0x208>
    4e68:	vldr	d6, [pc, #380]	; 4fe8 <__ieee754_asin+0x210>
    4e6c:	vfma.f64	d5, d8, d4
    4e70:	vldr	d3, [pc, #380]	; 4ff0 <__ieee754_asin+0x218>
    4e74:	vfma.f64	d6, d8, d5
    4e78:	vfma.f64	d9, d8, d6
    4e7c:	vldr	d4, [pc, #376]	; 4ff8 <__ieee754_asin+0x220>
    4e80:	vmul.f64	d9, d9, d8
    4e84:	vldr	d5, [pc, #376]	; 5000 <__ieee754_asin+0x228>
    4e88:	vfma.f64	d4, d8, d3
    4e8c:	vldr	d6, [pc, #376]	; 5008 <__ieee754_asin+0x230>
    4e90:	vfma.f64	d5, d8, d4
    4e94:	vfma.f64	d6, d8, d5
    4e98:	vfma.f64	d7, d8, d6
    4e9c:	vmov.f64	d10, d7
    4ea0:	bl	5c44 <__ieee754_sqrt>
    4ea4:	ldr	r3, [pc, #400]	; (5038 <__ieee754_asin+0x260>)
    4ea6:	cmp	r4, r3
    4ea8:	vstr	d0, [sp]
    4eac:	bgt.n	4f2c <__ieee754_asin+0x154>
    4eae:	vmov.f64	d5, #0	; 0x40000000  2.0
    4eb2:	vdiv.f64	d4, d9, d10
    4eb6:	ldrd	r2, r3, [sp]
    4eba:	vldr	d6, [sp]
    4ebe:	vldr	d7, [pc, #336]	; 5010 <__ieee754_asin+0x238>
    4ec2:	vadd.f64	d2, d6, d6
    4ec6:	vldr	d1, [sp]
    4eca:	movs	r2, #0
    4ecc:	vldr	d0, [pc, #328]	; 5018 <__ieee754_asin+0x240>
    4ed0:	vmov	d6, r2, r3
    4ed4:	vneg.f64	d3, d6
    4ed8:	vfma.f64	d8, d3, d6
    4edc:	vadd.f64	d6, d1, d6
    4ee0:	vmov.f64	d1, d7
    4ee4:	vfma.f64	d1, d3, d5
    4ee8:	vmov.f64	d3, d1
    4eec:	vdiv.f64	d1, d8, d6
    4ef0:	vfms.f64	d0, d1, d5
    4ef4:	vfnms.f64	d0, d4, d2
    4ef8:	vsub.f64	d0, d0, d3
    4efc:	vsub.f64	d0, d7, d0
    4f00:	cmp	r5, #0
    4f02:	it	le
    4f04:	vnegle.f64	d0, d0
    4f08:	add	sp, #12
    4f0a:	vpop	{d8-d10}
    4f0e:	pop	{r4, r5, pc}
    4f10:	vldr	d6, [pc, #268]	; 5020 <__ieee754_asin+0x248>
    4f14:	vldr	d7, [pc, #256]	; 5018 <__ieee754_asin+0x240>
    4f18:	vmul.f64	d7, d0, d7
    4f1c:	vfma.f64	d7, d0, d6
    4f20:	vmov.f64	d0, d7
    4f24:	add	sp, #12
    4f26:	vpop	{d8-d10}
    4f2a:	pop	{r4, r5, pc}
    4f2c:	vldr	d5, [sp]
    4f30:	vdiv.f64	d7, d9, d10
    4f34:	vmov.f64	d6, #0	; 0x40000000  2.0
    4f38:	vfma.f64	d5, d5, d7
    4f3c:	vldr	d0, [pc, #232]	; 5028 <__ieee754_asin+0x250>
    4f40:	vldr	d7, [pc, #220]	; 5020 <__ieee754_asin+0x248>
    4f44:	vfma.f64	d0, d5, d6
    4f48:	vsub.f64	d0, d7, d0
    4f4c:	b.n	4f00 <__ieee754_asin+0x128>
    4f4e:	vldr	d4, [pc, #112]	; 4fc0 <__ieee754_asin+0x1e8>
    4f52:	vmul.f64	d7, d0, d0
    4f56:	vmov.f64	d2, #112	; 0x3f800000  1.0
    4f5a:	vldr	d5, [pc, #108]	; 4fc8 <__ieee754_asin+0x1f0>
    4f5e:	vldr	d6, [pc, #112]	; 4fd0 <__ieee754_asin+0x1f8>
    4f62:	vfma.f64	d5, d7, d4
    4f66:	vldr	d4, [pc, #120]	; 4fe0 <__ieee754_asin+0x208>
    4f6a:	vfma.f64	d6, d7, d5
    4f6e:	vldr	d5, [pc, #120]	; 4fe8 <__ieee754_asin+0x210>
    4f72:	vfma.f64	d4, d7, d6
    4f76:	vldr	d6, [pc, #96]	; 4fd8 <__ieee754_asin+0x200>
    4f7a:	vfma.f64	d5, d7, d4
    4f7e:	vldr	d1, [pc, #112]	; 4ff0 <__ieee754_asin+0x218>
    4f82:	vfma.f64	d6, d7, d5
    4f86:	vmul.f64	d6, d6, d7
    4f8a:	vldr	d3, [pc, #108]	; 4ff8 <__ieee754_asin+0x220>
    4f8e:	vldr	d4, [pc, #112]	; 5000 <__ieee754_asin+0x228>
    4f92:	vfma.f64	d3, d7, d1
    4f96:	vldr	d5, [pc, #112]	; 5008 <__ieee754_asin+0x230>
    4f9a:	vfma.f64	d4, d7, d3
    4f9e:	vfma.f64	d5, d7, d4
    4fa2:	vfma.f64	d2, d7, d5
    4fa6:	vdiv.f64	d5, d6, d2
    4faa:	vfma.f64	d0, d0, d5
    4fae:	add	sp, #12
    4fb0:	vpop	{d8-d10}
    4fb4:	pop	{r4, r5, pc}
    4fb6:	nop
    4fb8:	.word	0x8800759c
    4fbc:	.word	0x7e37e43c
    4fc0:	.word	0x0dfdf709
    4fc4:	.word	0x3f023de1
    4fc8:	.word	0x7501b288
    4fcc:	.word	0x3f49efe0
    4fd0:	.word	0xb5688f3b
    4fd4:	.word	0xbfa48228
    4fd8:	.word	0x55555555
    4fdc:	.word	0x3fc55555
    4fe0:	.word	0x0e884455
    4fe4:	.word	0x3fc9c155
    4fe8:	.word	0x03eb6f7d
    4fec:	.word	0xbfd4d612
    4ff0:	.word	0xb12e9282
    4ff4:	.word	0x3fb3b8c5
    4ff8:	.word	0x1b8d0159
    4ffc:	.word	0xbfe6066c
    5000:	.word	0x9c598ac8
    5004:	.word	0x40002ae5
    5008:	.word	0x1c8a2d4b
    500c:	.word	0xc0033a27
    5010:	.word	0x54442d18
    5014:	.word	0x3fe921fb
    5018:	.word	0x33145c07
    501c:	.word	0x3c91a626
    5020:	.word	0x54442d18
    5024:	.word	0x3ff921fb
    5028:	.word	0x33145c07
    502c:	.word	0xbc91a626
    5030:	.word	0x3fefffff
    5034:	.word	0x3fdfffff
    5038:	.word	0x3fef3332
    503c:	.word	0x00000000

00005040 <__ieee754_atan2>:
    5040:	push	{r4, r5, r6, r7, lr}
    5042:	sub	sp, #20
    5044:	vstr	d1, [sp, #8]
    5048:	ldr	r2, [sp, #8]
    504a:	ldr	r0, [sp, #12]
    504c:	ldr	r1, [pc, #456]	; (5218 <__ieee754_atan2+0x1d8>)
    504e:	negs	r3, r2
    5050:	vstr	d0, [sp]
    5054:	orrs	r3, r2
    5056:	bic.w	r5, r0, #2147483648	; 0x80000000
    505a:	orr.w	r3, r5, r3, lsr #31
    505e:	cmp	r3, r1
    5060:	ldmia.w	sp, {r4, r7}
    5064:	bhi.n	50ec <__ieee754_atan2+0xac>
    5066:	negs	r3, r4
    5068:	orrs	r3, r4
    506a:	bic.w	lr, r7, #2147483648	; 0x80000000
    506e:	orr.w	r3, lr, r3, lsr #31
    5072:	cmp	r3, r1
    5074:	bhi.n	50ec <__ieee754_atan2+0xac>
    5076:	add.w	r3, r0, #3221225472	; 0xc0000000
    507a:	add.w	r3, r3, #1048576	; 0x100000
    507e:	orrs	r3, r2
    5080:	beq.n	512a <__ieee754_atan2+0xea>
    5082:	asrs	r6, r0, #30
    5084:	and.w	r6, r6, #2
    5088:	orrs.w	r3, r4, lr
    508c:	orr.w	r6, r6, r7, lsr #31
    5090:	beq.n	50fc <__ieee754_atan2+0xbc>
    5092:	orrs.w	r3, r2, r5
    5096:	beq.n	5116 <__ieee754_atan2+0xd6>
    5098:	cmp	r5, r1
    509a:	beq.n	5142 <__ieee754_atan2+0x102>
    509c:	cmp	lr, r1
    509e:	beq.n	5116 <__ieee754_atan2+0xd6>
    50a0:	rsb	r5, r5, lr
    50a4:	asrs	r5, r5, #20
    50a6:	cmp	r5, #60	; 0x3c
    50a8:	bgt.n	5134 <__ieee754_atan2+0xf4>
    50aa:	cmp	r0, #0
    50ac:	blt.n	5186 <__ieee754_atan2+0x146>
    50ae:	ldrd	r2, r3, [sp]
    50b2:	vldr	d0, [sp, #8]
    50b6:	vmov	d7, r2, r3
    50ba:	vdiv.f64	d0, d7, d0
    50be:	bl	748c <fabs>
    50c2:	bl	7288 <atan>
    50c6:	vmov	r2, r3, d0
    50ca:	cmp	r6, #1
    50cc:	beq.n	517c <__ieee754_atan2+0x13c>
    50ce:	cmp	r6, #2
    50d0:	beq.n	5166 <__ieee754_atan2+0x126>
    50d2:	cmp	r6, #0
    50d4:	beq.n	5160 <__ieee754_atan2+0x120>
    50d6:	vldr	d7, [pc, #232]	; 51c0 <__ieee754_atan2+0x180>
    50da:	vldr	d6, [pc, #236]	; 51c8 <__ieee754_atan2+0x188>
    50de:	vmov	d5, r2, r3
    50e2:	vsub.f64	d7, d5, d7
    50e6:	vsub.f64	d0, d7, d6
    50ea:	b.n	50f8 <__ieee754_atan2+0xb8>
    50ec:	vldr	d7, [sp, #8]
    50f0:	vldr	d6, [sp]
    50f4:	vadd.f64	d0, d7, d6
    50f8:	add	sp, #20
    50fa:	pop	{r4, r5, r6, r7, pc}
    50fc:	cmp	r6, #2
    50fe:	beq.n	513c <__ieee754_atan2+0xfc>
    5100:	vldr	d0, [pc, #204]	; 51d0 <__ieee754_atan2+0x190>
    5104:	vldr	d7, [sp]
    5108:	cmp	r6, #3
    510a:	it	eq
    510c:	vmoveq.f64	d7, d0
    5110:	vmov.f64	d0, d7
    5114:	b.n	50f8 <__ieee754_atan2+0xb8>
    5116:	vldr	d7, [pc, #192]	; 51d8 <__ieee754_atan2+0x198>
    511a:	vldr	d0, [pc, #196]	; 51e0 <__ieee754_atan2+0x1a0>
    511e:	cmp	r7, #0
    5120:	it	ge
    5122:	vmovge.f64	d0, d7
    5126:	add	sp, #20
    5128:	pop	{r4, r5, r6, r7, pc}
    512a:	add	sp, #20
    512c:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    5130:	b.w	7288 <atan>
    5134:	add	r3, pc, #160	; (adr r3, 51d8 <__ieee754_atan2+0x198>)
    5136:	ldrd	r2, r3, [r3]
    513a:	b.n	50ca <__ieee754_atan2+0x8a>
    513c:	vldr	d0, [pc, #136]	; 51c8 <__ieee754_atan2+0x188>
    5140:	b.n	50f8 <__ieee754_atan2+0xb8>
    5142:	cmp	lr, r5
    5144:	beq.n	5190 <__ieee754_atan2+0x150>
    5146:	cmp	r6, #2
    5148:	beq.n	513c <__ieee754_atan2+0xfc>
    514a:	cmp	r6, #3
    514c:	beq.n	51aa <__ieee754_atan2+0x16a>
    514e:	vldr	d7, [pc, #152]	; 51e8 <__ieee754_atan2+0x1a8>
    5152:	vldr	d0, [pc, #156]	; 51f0 <__ieee754_atan2+0x1b0>
    5156:	cmp	r6, #1
    5158:	it	eq
    515a:	vmoveq.f64	d0, d7
    515e:	b.n	50f8 <__ieee754_atan2+0xb8>
    5160:	vmov	d0, r2, r3
    5164:	b.n	50f8 <__ieee754_atan2+0xb8>
    5166:	vldr	d7, [pc, #88]	; 51c0 <__ieee754_atan2+0x180>
    516a:	vldr	d6, [pc, #92]	; 51c8 <__ieee754_atan2+0x188>
    516e:	vmov	d5, r2, r3
    5172:	vsub.f64	d7, d5, d7
    5176:	vsub.f64	d0, d6, d7
    517a:	b.n	50f8 <__ieee754_atan2+0xb8>
    517c:	add.w	r3, r3, #2147483648	; 0x80000000
    5180:	vmov	d0, r2, r3
    5184:	b.n	50f8 <__ieee754_atan2+0xb8>
    5186:	adds	r5, #60	; 0x3c
    5188:	bge.n	50ae <__ieee754_atan2+0x6e>
    518a:	movs	r2, #0
    518c:	movs	r3, #0
    518e:	b.n	50ca <__ieee754_atan2+0x8a>
    5190:	cmp	r6, #2
    5192:	beq.n	51b6 <__ieee754_atan2+0x176>
    5194:	cmp	r6, #3
    5196:	beq.n	51b0 <__ieee754_atan2+0x170>
    5198:	vldr	d7, [pc, #92]	; 51f8 <__ieee754_atan2+0x1b8>
    519c:	vldr	d0, [pc, #96]	; 5200 <__ieee754_atan2+0x1c0>
    51a0:	cmp	r6, #1
    51a2:	it	eq
    51a4:	vmoveq.f64	d0, d7
    51a8:	b.n	50f8 <__ieee754_atan2+0xb8>
    51aa:	vldr	d0, [pc, #36]	; 51d0 <__ieee754_atan2+0x190>
    51ae:	b.n	50f8 <__ieee754_atan2+0xb8>
    51b0:	vldr	d0, [pc, #84]	; 5208 <__ieee754_atan2+0x1c8>
    51b4:	b.n	50f8 <__ieee754_atan2+0xb8>
    51b6:	vldr	d0, [pc, #88]	; 5210 <__ieee754_atan2+0x1d0>
    51ba:	b.n	50f8 <__ieee754_atan2+0xb8>
    51bc:	nop.w
    51c0:	.word	0x33145c07
    51c4:	.word	0x3ca1a626
    51c8:	.word	0x54442d18
    51cc:	.word	0x400921fb
    51d0:	.word	0x54442d18
    51d4:	.word	0xc00921fb
    51d8:	.word	0x54442d18
    51dc:	.word	0x3ff921fb
    51e0:	.word	0x54442d18
    51e4:	.word	0xbff921fb
    51e8:	.word	0x00000000
    51ec:	.word	0x80000000
	...
    51f8:	.word	0x54442d18
    51fc:	.word	0xbfe921fb
    5200:	.word	0x54442d18
    5204:	.word	0x3fe921fb
    5208:	.word	0x7f3321d2
    520c:	.word	0xc002d97c
    5210:	.word	0x7f3321d2
    5214:	.word	0x4002d97c
    5218:	.word	0x7ff00000
    521c:	.word	0x00000000

00005220 <__ieee754_pow>:
    5220:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5224:	vmov	r0, r1, d1
    5228:	vpush	{d8-d11}
    522c:	bic.w	r5, r1, #2147483648	; 0x80000000
    5230:	orrs.w	r4, r5, r0
    5234:	sub	sp, #28
    5236:	beq.n	52ae <__ieee754_pow+0x8e>
    5238:	vmov	r2, r3, d0
    523c:	ldr	r7, [pc, #424]	; (53e8 <__ieee754_pow+0x1c8>)
    523e:	bic.w	r4, r3, #2147483648	; 0x80000000
    5242:	cmp	r4, r7
    5244:	vmov	sl, s0
    5248:	mov	r9, r3
    524a:	bgt.n	52a0 <__ieee754_pow+0x80>
    524c:	mov	r8, r1
    524e:	vmov	r6, s2
    5252:	beq.n	529e <__ieee754_pow+0x7e>
    5254:	cmp	r5, r7
    5256:	bgt.n	52a0 <__ieee754_pow+0x80>
    5258:	ldr	r7, [pc, #396]	; (53e8 <__ieee754_pow+0x1c8>)
    525a:	cmp	r5, r7
    525c:	beq.n	5354 <__ieee754_pow+0x134>
    525e:	cmp.w	r9, #0
    5262:	blt.n	535a <__ieee754_pow+0x13a>
    5264:	mov.w	fp, #0
    5268:	cbnz	r6, 52d4 <__ieee754_pow+0xb4>
    526a:	ldr	r6, [pc, #380]	; (53e8 <__ieee754_pow+0x1c8>)
    526c:	cmp	r5, r6
    526e:	beq.w	5392 <__ieee754_pow+0x172>
    5272:	ldr	r6, [pc, #376]	; (53ec <__ieee754_pow+0x1cc>)
    5274:	cmp	r5, r6
    5276:	beq.n	5346 <__ieee754_pow+0x126>
    5278:	cmp.w	r8, #1073741824	; 0x40000000
    527c:	beq.w	572e <__ieee754_pow+0x50e>
    5280:	ldr	r6, [pc, #364]	; (53f0 <__ieee754_pow+0x1d0>)
    5282:	cmp	r8, r6
    5284:	bne.n	52d4 <__ieee754_pow+0xb4>
    5286:	cmp.w	r9, #0
    528a:	blt.n	52d4 <__ieee754_pow+0xb4>
    528c:	vmov	d0, r2, r3
    5290:	add	sp, #28
    5292:	vpop	{d8-d11}
    5296:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    529a:	b.w	5c44 <__ieee754_sqrt>
    529e:	cbz	r2, 52bc <__ieee754_pow+0x9c>
    52a0:	add.w	r4, r4, #3221225472	; 0xc0000000
    52a4:	add.w	r4, r4, #1048576	; 0x100000
    52a8:	orrs.w	r3, r4, sl
    52ac:	bne.n	52c0 <__ieee754_pow+0xa0>
    52ae:	vmov.f64	d0, #112	; 0x3f800000  1.0
    52b2:	add	sp, #28
    52b4:	vpop	{d8-d11}
    52b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    52bc:	cmp	r5, r4
    52be:	ble.n	5258 <__ieee754_pow+0x38>
    52c0:	ldr	r0, [pc, #304]	; (53f4 <__ieee754_pow+0x1d4>)
    52c2:	add	sp, #28
    52c4:	vpop	{d8-d11}
    52c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    52cc:	b.w	75d0 <nan>
    52d0:	mov.w	fp, #0
    52d4:	mov	r6, r2
    52d6:	mov	r7, r3
    52d8:	vmov	d0, r6, r7
    52dc:	strd	r0, r1, [sp, #8]
    52e0:	bl	748c <fabs>
    52e4:	vstr	d0, [sp]
    52e8:	cmp.w	sl, #0
    52ec:	beq.n	5324 <__ieee754_pow+0x104>
    52ee:	mov.w	r9, r9, lsr #31
    52f2:	add.w	r9, r9, #4294967295
    52f6:	orrs.w	r3, fp, r9
    52fa:	beq.n	53ba <__ieee754_pow+0x19a>
    52fc:	ldr	r3, [pc, #248]	; (53f8 <__ieee754_pow+0x1d8>)
    52fe:	cmp	r5, r3
    5300:	ble.w	5404 <__ieee754_pow+0x1e4>
    5304:	add.w	r3, r3, #34603008	; 0x2100000
    5308:	cmp	r5, r3
    530a:	ble.w	5842 <__ieee754_pow+0x622>
    530e:	ldr	r3, [pc, #236]	; (53fc <__ieee754_pow+0x1dc>)
    5310:	cmp	r4, r3
    5312:	ble.n	53c8 <__ieee754_pow+0x1a8>
    5314:	cmp.w	r8, #0
    5318:	ble.n	53ce <__ieee754_pow+0x1ae>
    531a:	vldr	d0, [pc, #188]	; 53d8 <__ieee754_pow+0x1b8>
    531e:	vmul.f64	d0, d0, d0
    5322:	b.n	52b2 <__ieee754_pow+0x92>
    5324:	cbz	r4, 5330 <__ieee754_pow+0x110>
    5326:	ldr	r3, [pc, #196]	; (53ec <__ieee754_pow+0x1cc>)
    5328:	bic.w	r2, r9, #3221225472	; 0xc0000000
    532c:	cmp	r2, r3
    532e:	bne.n	52ee <__ieee754_pow+0xce>
    5330:	cmp.w	r8, #0
    5334:	blt.w	5830 <__ieee754_pow+0x610>
    5338:	cmp.w	r9, #0
    533c:	blt.w	570c <__ieee754_pow+0x4ec>
    5340:	vldr	d0, [sp]
    5344:	b.n	52b2 <__ieee754_pow+0x92>
    5346:	cmp.w	r8, #0
    534a:	blt.w	58c6 <__ieee754_pow+0x6a6>
    534e:	vmov	d0, r2, r3
    5352:	b.n	52b2 <__ieee754_pow+0x92>
    5354:	cmp	r6, #0
    5356:	beq.n	525e <__ieee754_pow+0x3e>
    5358:	b.n	52a0 <__ieee754_pow+0x80>
    535a:	ldr	r7, [pc, #164]	; (5400 <__ieee754_pow+0x1e0>)
    535c:	cmp	r5, r7
    535e:	bgt.n	53b4 <__ieee754_pow+0x194>
    5360:	sub.w	r7, r7, #55574528	; 0x3500000
    5364:	cmp	r5, r7
    5366:	ble.w	5264 <__ieee754_pow+0x44>
    536a:	asrs	r7, r5, #20
    536c:	subw	r7, r7, #1023	; 0x3ff
    5370:	cmp	r7, #20
    5372:	ble.w	58e2 <__ieee754_pow+0x6c2>
    5376:	rsb	r7, r7, #52	; 0x34
    537a:	lsr.w	lr, r6, r7
    537e:	lsl.w	r7, lr, r7
    5382:	cmp	r6, r7
    5384:	bne.w	5264 <__ieee754_pow+0x44>
    5388:	and.w	lr, lr, #1
    538c:	rsb	fp, lr, #2
    5390:	b.n	5268 <__ieee754_pow+0x48>
    5392:	add.w	r3, r4, #3221225472	; 0xc0000000
    5396:	add.w	r3, r3, #1048576	; 0x100000
    539a:	orrs.w	r3, r3, sl
    539e:	beq.n	52ae <__ieee754_pow+0x8e>
    53a0:	ldr	r3, [pc, #88]	; (53fc <__ieee754_pow+0x1dc>)
    53a2:	cmp	r4, r3
    53a4:	ble.w	581e <__ieee754_pow+0x5fe>
    53a8:	cmp.w	r8, #0
    53ac:	blt.n	53ce <__ieee754_pow+0x1ae>
    53ae:	vmov	d0, r0, r1
    53b2:	b.n	52b2 <__ieee754_pow+0x92>
    53b4:	mov.w	fp, #2
    53b8:	b.n	5268 <__ieee754_pow+0x48>
    53ba:	vmov	d7, r6, r7
    53be:	vsub.f64	d7, d7, d7
    53c2:	vdiv.f64	d0, d7, d7
    53c6:	b.n	52b2 <__ieee754_pow+0x92>
    53c8:	cmp.w	r8, #0
    53cc:	blt.n	531a <__ieee754_pow+0xfa>
    53ce:	vldr	d0, [pc, #16]	; 53e0 <__ieee754_pow+0x1c0>
    53d2:	b.n	52b2 <__ieee754_pow+0x92>
    53d4:	nop.w
    53d8:	.word	0x8800759c
    53dc:	.word	0x7e37e43c
	...
    53e8:	.word	0x7ff00000
    53ec:	.word	0x3ff00000
    53f0:	.word	0x3fe00000
    53f4:	.word	0x20000e54
    53f8:	.word	0x41e00000
    53fc:	.word	0x3fefffff
    5400:	.word	0x433fffff
    5404:	cmp.w	r4, #1048576	; 0x100000
    5408:	bge.w	58c2 <__ieee754_pow+0x6a2>
    540c:	vldr	d6, [sp]
    5410:	vldr	d7, [pc, #804]	; 5738 <__ieee754_pow+0x518>
    5414:	vmul.f64	d7, d6, d7
    5418:	vstr	d7, [sp]
    541c:	ldr	r4, [sp, #4]
    541e:	mvn.w	r6, #52	; 0x34
    5422:	ldr	r2, [pc, #948]	; (57d8 <__ieee754_pow+0x5b8>)
    5424:	asrs	r3, r4, #20
    5426:	ubfx	r4, r4, #0, #20
    542a:	subw	r3, r3, #1023	; 0x3ff
    542e:	orr.w	r1, r4, #1069547520	; 0x3fc00000
    5432:	cmp	r4, r2
    5434:	add	r6, r3
    5436:	orr.w	r1, r1, #3145728	; 0x300000
    543a:	ble.w	58b2 <__ieee754_pow+0x692>
    543e:	ldr	r3, [pc, #924]	; (57dc <__ieee754_pow+0x5bc>)
    5440:	cmp	r4, r3
    5442:	ble.w	591e <__ieee754_pow+0x6fe>
    5446:	vmov.f64	d7, #112	; 0x3f800000  1.0
    544a:	vldr	d3, [pc, #756]	; 5740 <__ieee754_pow+0x520>
    544e:	adds	r6, #1
    5450:	sub.w	r1, r1, #1048576	; 0x100000
    5454:	movs	r5, #0
    5456:	vmov.f64	d0, d3
    545a:	ldrd	r2, r3, [sp]
    545e:	vmov.f64	d4, #112	; 0x3f800000  1.0
    5462:	mov	r3, r1
    5464:	vmov	d1, r2, r3
    5468:	asrs	r4, r1, #1
    546a:	vadd.f64	d6, d1, d7
    546e:	vsub.f64	d2, d1, d7
    5472:	vdiv.f64	d5, d4, d6
    5476:	vmul.f64	d6, d2, d5
    547a:	vstr	d6, [sp]
    547e:	ldrd	r2, r3, [sp]
    5482:	orr.w	r4, r4, #536870912	; 0x20000000
    5486:	add.w	r4, r4, #524288	; 0x80000
    548a:	movs	r2, #0
    548c:	movs	r0, #0
    548e:	adds	r1, r4, r5
    5490:	vmov	d4, r2, r3
    5494:	vmov	d6, r0, r1
    5498:	vneg.f64	d10, d4
    549c:	vsub.f64	d7, d6, d7
    54a0:	vfma.f64	d2, d10, d6
    54a4:	vsub.f64	d7, d1, d7
    54a8:	vmov.f64	d6, d2
    54ac:	vfma.f64	d6, d10, d7
    54b0:	vldr	d7, [sp]
    54b4:	vmul.f64	d2, d6, d5
    54b8:	vldr	d6, [sp]
    54bc:	vadd.f64	d7, d7, d4
    54c0:	vmul.f64	d11, d6, d6
    54c4:	vldr	d9, [pc, #640]	; 5748 <__ieee754_pow+0x528>
    54c8:	vmul.f64	d6, d7, d2
    54cc:	vldr	d8, [pc, #640]	; 5750 <__ieee754_pow+0x530>
    54d0:	vldr	d1, [pc, #644]	; 5758 <__ieee754_pow+0x538>
    54d4:	vfma.f64	d8, d11, d9
    54d8:	vldr	d7, [pc, #644]	; 5760 <__ieee754_pow+0x540>
    54dc:	vfma.f64	d1, d11, d8
    54e0:	vmul.f64	d8, d11, d11
    54e4:	vldr	d5, [pc, #640]	; 5768 <__ieee754_pow+0x548>
    54e8:	vfma.f64	d7, d11, d1
    54ec:	vfma.f64	d5, d11, d7
    54f0:	vldr	d7, [pc, #636]	; 5770 <__ieee754_pow+0x550>
    54f4:	vfma.f64	d7, d11, d5
    54f8:	vmov.f64	d5, #8	; 0x40400000  3.0
    54fc:	vfma.f64	d6, d8, d7
    5500:	vmov.f64	d7, d5
    5504:	vfma.f64	d7, d4, d4
    5508:	vadd.f64	d7, d7, d6
    550c:	vstr	d7, [sp, #16]
    5510:	str	r2, [sp, #16]
    5512:	vldr	d9, [sp, #16]
    5516:	vsub.f64	d5, d9, d5
    551a:	vfma.f64	d5, d10, d4
    551e:	vsub.f64	d5, d6, d5
    5522:	vldr	d6, [sp]
    5526:	vmul.f64	d6, d5, d6
    552a:	vfma.f64	d6, d2, d9
    552e:	vmov.f64	d5, d6
    5532:	vfma.f64	d5, d4, d9
    5536:	vstr	d5, [sp]
    553a:	str	r2, [sp, #0]
    553c:	vldr	d4, [sp]
    5540:	vldr	d2, [pc, #564]	; 5778 <__ieee754_pow+0x558>
    5544:	vmov.f64	d5, d4
    5548:	vfma.f64	d5, d10, d9
    554c:	vldr	d7, [pc, #560]	; 5780 <__ieee754_pow+0x560>
    5550:	vsub.f64	d6, d6, d5
    5554:	vldr	d8, [pc, #560]	; 5788 <__ieee754_pow+0x568>
    5558:	vmul.f64	d7, d6, d7
    555c:	vmov	s3, r6
    5560:	vfma.f64	d7, d4, d8
    5564:	vcvt.f64.s32	d1, s3
    5568:	vadd.f64	d7, d7, d0
    556c:	vmov.f64	d6, d7
    5570:	vfma.f64	d6, d4, d2
    5574:	vadd.f64	d6, d6, d3
    5578:	vadd.f64	d6, d6, d1
    557c:	vstr	d6, [sp]
    5580:	str	r2, [sp, #0]
    5582:	vldr	d5, [sp]
    5586:	vsub.f64	d6, d5, d1
    558a:	vsub.f64	d6, d6, d3
    558e:	vfms.f64	d6, d4, d2
    5592:	vsub.f64	d6, d7, d6
    5596:	ldrd	r3, r4, [sp, #8]
    559a:	vmov.f64	d0, #240	; 0xbf800000 -1.0
    559e:	mov	r1, r4
    55a0:	movs	r0, #0
    55a2:	vmov	d7, r3, r4
    55a6:	vmov	d4, r0, r1
    55aa:	vmul.f64	d6, d6, d7
    55ae:	vsub.f64	d7, d7, d4
    55b2:	vfma.f64	d6, d5, d7
    55b6:	vmul.f64	d5, d5, d4
    55ba:	vadd.f64	d7, d6, d5
    55be:	vstr	d7, [sp]
    55c2:	vmov.f64	d7, #112	; 0x3f800000  1.0
    55c6:	ldr	r3, [pc, #536]	; (57e0 <__ieee754_pow+0x5c0>)
    55c8:	ldr	r2, [sp, #4]
    55ca:	add.w	fp, fp, #4294967295
    55ce:	orrs.w	r4, fp, r9
    55d2:	ite	ne
    55d4:	vmovne.f64	d8, d7
    55d8:	vmoveq.f64	d8, d0
    55dc:	cmp	r2, r3
    55de:	ldr	r4, [sp, #0]
    55e0:	ble.w	57e8 <__ieee754_pow+0x5c8>
    55e4:	add.w	r3, r2, #3204448256	; 0xbf000000
    55e8:	add.w	r3, r3, #7340032	; 0x700000
    55ec:	orrs	r3, r4
    55ee:	bne.w	58d4 <__ieee754_pow+0x6b4>
    55f2:	vadd.f64	d4, d6, d5
    55f6:	vsub.f64	d4, d4, d5
    55fa:	vldr	d7, [pc, #404]	; 5790 <__ieee754_pow+0x570>
    55fe:	vadd.f64	d7, d6, d7
    5602:	vcmpe.f64	d7, d4
    5606:	vmrs	APSR_nzcv, fpscr
    560a:	bgt.w	58d4 <__ieee754_pow+0x6b4>
    560e:	mov	r3, r2
    5610:	asrs	r3, r3, #20
    5612:	mov.w	r1, #1048576	; 0x100000
    5616:	subw	r3, r3, #1022	; 0x3fe
    561a:	asr.w	r3, r1, r3
    561e:	adds	r1, r3, r2
    5620:	ubfx	r0, r1, #20, #11
    5624:	ldr	r6, [pc, #444]	; (57e4 <__ieee754_pow+0x5c4>)
    5626:	subw	r0, r0, #1023	; 0x3ff
    562a:	asrs	r6, r0
    562c:	bic.w	r5, r1, r6
    5630:	movs	r4, #0
    5632:	ubfx	r3, r1, #0, #20
    5636:	vmov	d7, r4, r5
    563a:	rsb	r0, r0, #20
    563e:	orr.w	r3, r3, #1048576	; 0x100000
    5642:	asr.w	r0, r3, r0
    5646:	cmp	r2, #0
    5648:	vsub.f64	d5, d5, d7
    564c:	vadd.f64	d7, d6, d5
    5650:	vstr	d7, [sp]
    5654:	it	lt
    5656:	neglt	r0, r0
    5658:	lsls	r1, r0, #20
    565a:	ldrd	r2, r3, [sp]
    565e:	vmov.f64	d2, #0	; 0x40000000  2.0
    5662:	vmov.f64	d7, #112	; 0x3f800000  1.0
    5666:	vldr	d1, [pc, #304]	; 5798 <__ieee754_pow+0x578>
    566a:	vldr	d0, [pc, #308]	; 57a0 <__ieee754_pow+0x580>
    566e:	movs	r2, #0
    5670:	vldr	d4, [pc, #308]	; 57a8 <__ieee754_pow+0x588>
    5674:	vmov	d3, r2, r3
    5678:	vldr	d9, [pc, #308]	; 57b0 <__ieee754_pow+0x590>
    567c:	vmul.f64	d4, d3, d4
    5680:	vsub.f64	d5, d3, d5
    5684:	vsub.f64	d5, d6, d5
    5688:	vmov.f64	d6, d4
    568c:	vfma.f64	d6, d5, d0
    5690:	vldr	d5, [pc, #292]	; 57b8 <__ieee754_pow+0x598>
    5694:	vmov.f64	d4, d6
    5698:	vfma.f64	d4, d3, d1
    569c:	vmov.f64	d0, d4
    56a0:	vfms.f64	d0, d3, d1
    56a4:	vsub.f64	d6, d6, d0
    56a8:	vldr	d0, [pc, #276]	; 57c0 <__ieee754_pow+0x5a0>
    56ac:	vmul.f64	d3, d4, d4
    56b0:	vfma.f64	d5, d3, d9
    56b4:	vldr	d1, [pc, #272]	; 57c8 <__ieee754_pow+0x5a8>
    56b8:	vfma.f64	d0, d3, d5
    56bc:	vfma.f64	d6, d4, d6
    56c0:	vldr	d5, [pc, #268]	; 57d0 <__ieee754_pow+0x5b0>
    56c4:	vfma.f64	d1, d3, d0
    56c8:	vfma.f64	d5, d3, d1
    56cc:	vmov.f64	d1, d4
    56d0:	vfms.f64	d1, d3, d5
    56d4:	vmul.f64	d3, d4, d1
    56d8:	vsub.f64	d2, d1, d2
    56dc:	vdiv.f64	d5, d3, d2
    56e0:	vsub.f64	d6, d5, d6
    56e4:	vsub.f64	d6, d6, d4
    56e8:	vsub.f64	d7, d7, d6
    56ec:	vstr	d7, [sp]
    56f0:	ldr	r3, [sp, #4]
    56f2:	add	r1, r3
    56f4:	cmp.w	r1, #1048576	; 0x100000
    56f8:	blt.w	5930 <__ieee754_pow+0x710>
    56fc:	ldrd	r2, r3, [sp]
    5700:	mov	r3, r1
    5702:	vmov	d0, r2, r3
    5706:	vmul.f64	d0, d0, d8
    570a:	b.n	52b2 <__ieee754_pow+0x92>
    570c:	add.w	r4, r4, #3221225472	; 0xc0000000
    5710:	add.w	r4, r4, #1048576	; 0x100000
    5714:	orrs.w	r3, r4, fp
    5718:	beq.w	5910 <__ieee754_pow+0x6f0>
    571c:	cmp.w	fp, #1
    5720:	bne.w	5340 <__ieee754_pow+0x120>
    5724:	vldr	d7, [sp]
    5728:	vneg.f64	d0, d7
    572c:	b.n	52b2 <__ieee754_pow+0x92>
    572e:	vmov	d7, r2, r3
    5732:	vmul.f64	d0, d7, d7
    5736:	b.n	52b2 <__ieee754_pow+0x92>
    5738:	.word	0x00000000
    573c:	.word	0x43400000
	...
    5748:	.word	0x4a454eef
    574c:	.word	0x3fca7e28
    5750:	.word	0x93c9db65
    5754:	.word	0x3fcd864a
    5758:	.word	0xa91d4101
    575c:	.word	0x3fd17460
    5760:	.word	0x518f264d
    5764:	.word	0x3fd55555
    5768:	.word	0xdb6fabff
    576c:	.word	0x3fdb6db6
    5770:	.word	0x33333303
    5774:	.word	0x3fe33333
    5778:	.word	0xe0000000
    577c:	.word	0x3feec709
    5780:	.word	0xdc3a03fd
    5784:	.word	0x3feec709
    5788:	.word	0x145b01f5
    578c:	.word	0xbe3e2fe0
    5790:	.word	0x652b82fe
    5794:	.word	0x3c971547
    5798:	.word	0x00000000
    579c:	.word	0x3fe62e43
    57a0:	.word	0xfefa39ef
    57a4:	.word	0x3fe62e42
    57a8:	.word	0x0ca86c39
    57ac:	.word	0xbe205c61
    57b0:	.word	0x72bea4d0
    57b4:	.word	0x3e663769
    57b8:	.word	0xc5d26bf1
    57bc:	.word	0xbebbbd41
    57c0:	.word	0xaf25de2c
    57c4:	.word	0x3f11566a
    57c8:	.word	0x16bebd93
    57cc:	.word	0xbf66c16c
    57d0:	.word	0x5555553e
    57d4:	.word	0x3fc55555
    57d8:	.word	0x0003988e
    57dc:	.word	0x000bb679
    57e0:	.word	0x408fffff
    57e4:	.word	0x000fffff
    57e8:	ldr	r5, [pc, #420]	; (5990 <__ieee754_pow+0x770>)
    57ea:	bic.w	r3, r2, #2147483648	; 0x80000000
    57ee:	cmp	r3, r5
    57f0:	ble.w	58fc <__ieee754_pow+0x6dc>
    57f4:	ldr	r1, [pc, #412]	; (5994 <__ieee754_pow+0x774>)
    57f6:	add	r1, r2
    57f8:	orrs	r1, r4
    57fa:	bne.n	5810 <__ieee754_pow+0x5f0>
    57fc:	vadd.f64	d7, d6, d5
    5800:	vsub.f64	d7, d7, d5
    5804:	vcmpe.f64	d6, d7
    5808:	vmrs	APSR_nzcv, fpscr
    580c:	bhi.w	5610 <__ieee754_pow+0x3f0>
    5810:	vldr	d0, [pc, #308]	; 5948 <__ieee754_pow+0x728>
    5814:	vmul.f64	d7, d8, d0
    5818:	vmul.f64	d0, d7, d0
    581c:	b.n	52b2 <__ieee754_pow+0x92>
    581e:	cmp.w	r8, #0
    5822:	bge.w	53ce <__ieee754_pow+0x1ae>
    5826:	vmov	d7, r0, r1
    582a:	vneg.f64	d0, d7
    582e:	b.n	52b2 <__ieee754_pow+0x92>
    5830:	vldr	d5, [sp]
    5834:	vmov.f64	d7, #112	; 0x3f800000  1.0
    5838:	vdiv.f64	d6, d7, d5
    583c:	vstr	d6, [sp]
    5840:	b.n	5338 <__ieee754_pow+0x118>
    5842:	ldr	r3, [pc, #340]	; (5998 <__ieee754_pow+0x778>)
    5844:	cmp	r4, r3
    5846:	ble.w	53c8 <__ieee754_pow+0x1a8>
    584a:	ldr	r3, [pc, #336]	; (599c <__ieee754_pow+0x77c>)
    584c:	cmp	r4, r3
    584e:	bgt.w	5314 <__ieee754_pow+0xf4>
    5852:	vmov.f64	d7, #112	; 0x3f800000  1.0
    5856:	vmov.f64	d8, #80	; 0x3e800000  0.250
    585a:	vldr	d5, [sp]
    585e:	vldr	d2, [pc, #240]	; 5950 <__ieee754_pow+0x730>
    5862:	vsub.f64	d7, d5, d7
    5866:	vmov.f64	d5, #96	; 0x3f000000  0.5
    586a:	vldr	d3, [pc, #236]	; 5958 <__ieee754_pow+0x738>
    586e:	vneg.f64	d4, d7
    5872:	vmul.f64	d0, d7, d7
    5876:	vldr	d6, [pc, #232]	; 5960 <__ieee754_pow+0x740>
    587a:	vfma.f64	d3, d4, d8
    587e:	vfma.f64	d5, d4, d3
    5882:	vldr	d1, [pc, #228]	; 5968 <__ieee754_pow+0x748>
    5886:	vmul.f64	d5, d5, d0
    588a:	vnmul.f64	d6, d6, d5
    588e:	vfma.f64	d6, d7, d1
    5892:	vmov.f64	d5, d6
    5896:	vfma.f64	d5, d7, d2
    589a:	vmov	r2, r3, d5
    589e:	movs	r2, #0
    58a0:	vmov	d5, r2, r3
    58a4:	vmov.f64	d7, d5
    58a8:	vfma.f64	d7, d4, d2
    58ac:	vsub.f64	d6, d6, d7
    58b0:	b.n	5596 <__ieee754_pow+0x376>
    58b2:	vldr	d3, [pc, #188]	; 5970 <__ieee754_pow+0x750>
    58b6:	vmov.f64	d7, #112	; 0x3f800000  1.0
    58ba:	vmov.f64	d0, d3
    58be:	movs	r5, #0
    58c0:	b.n	545a <__ieee754_pow+0x23a>
    58c2:	movs	r6, #0
    58c4:	b.n	5422 <__ieee754_pow+0x202>
    58c6:	vmov	d6, r2, r3
    58ca:	vmov.f64	d7, #112	; 0x3f800000  1.0
    58ce:	vdiv.f64	d0, d7, d6
    58d2:	b.n	52b2 <__ieee754_pow+0x92>
    58d4:	vldr	d0, [pc, #160]	; 5978 <__ieee754_pow+0x758>
    58d8:	vmul.f64	d7, d8, d0
    58dc:	vmul.f64	d0, d7, d0
    58e0:	b.n	52b2 <__ieee754_pow+0x92>
    58e2:	cmp	r6, #0
    58e4:	bne.w	52d0 <__ieee754_pow+0xb0>
    58e8:	rsb	r7, r7, #20
    58ec:	asr.w	lr, r5, r7
    58f0:	lsl.w	r7, lr, r7
    58f4:	cmp	r5, r7
    58f6:	beq.n	593a <__ieee754_pow+0x71a>
    58f8:	mov	fp, r6
    58fa:	b.n	5272 <__ieee754_pow+0x52>
    58fc:	ldr	r4, [pc, #160]	; (59a0 <__ieee754_pow+0x780>)
    58fe:	cmp	r3, r4
    5900:	bgt.w	5610 <__ieee754_pow+0x3f0>
    5904:	vadd.f64	d7, d6, d5
    5908:	mov	r1, r0
    590a:	vstr	d7, [sp]
    590e:	b.n	565a <__ieee754_pow+0x43a>
    5910:	vldr	d7, [sp]
    5914:	vsub.f64	d7, d7, d7
    5918:	vdiv.f64	d0, d7, d7
    591c:	b.n	52b2 <__ieee754_pow+0x92>
    591e:	vldr	d3, [pc, #96]	; 5980 <__ieee754_pow+0x760>
    5922:	vmov.f64	d7, #120	; 0x3fc00000  1.5
    5926:	vldr	d0, [pc, #96]	; 5988 <__ieee754_pow+0x768>
    592a:	mov.w	r5, #262144	; 0x40000
    592e:	b.n	545a <__ieee754_pow+0x23a>
    5930:	vmov.f64	d0, d7
    5934:	bl	7700 <scalbn>
    5938:	b.n	5706 <__ieee754_pow+0x4e6>
    593a:	and.w	lr, lr, #1
    593e:	rsb	fp, lr, #2
    5942:	b.n	5272 <__ieee754_pow+0x52>
    5944:	nop.w
    5948:	.word	0xc2f8f359
    594c:	.word	0x01a56e1f
    5950:	.word	0x60000000
    5954:	.word	0x3ff71547
    5958:	.word	0x55555555
    595c:	.word	0x3fd55555
    5960:	.word	0x652b82fe
    5964:	.word	0x3ff71547
    5968:	.word	0xf85ddf44
    596c:	.word	0x3e54ae0b
	...
    5978:	.word	0x8800759c
    597c:	.word	0x7e37e43c
    5980:	.word	0x40000000
    5984:	.word	0x3fe2b803
    5988:	.word	0x43cfd006
    598c:	.word	0x3e4cfdeb
    5990:	.word	0x4090cbff
    5994:	.word	0x3f6f3400
    5998:	.word	0x3feffffe
    599c:	.word	0x3ff00000
    59a0:	.word	0x3fe00000
    59a4:	.word	0x00000000

000059a8 <__ieee754_rem_pio2>:
    59a8:	push	{r4, r5, r6, lr}
    59aa:	vmov	r2, r3, d0
    59ae:	ldr	r1, [pc, #632]	; (5c28 <__ieee754_rem_pio2+0x280>)
    59b0:	bic.w	r6, r3, #2147483648	; 0x80000000
    59b4:	cmp	r6, r1
    59b6:	sub	sp, #32
    59b8:	ble.n	5a80 <__ieee754_rem_pio2+0xd8>
    59ba:	ldr	r1, [pc, #624]	; (5c2c <__ieee754_rem_pio2+0x284>)
    59bc:	cmp	r6, r1
    59be:	mov	r5, r3
    59c0:	bgt.n	59fc <__ieee754_rem_pio2+0x54>
    59c2:	cmp	r3, #0
    59c4:	vldr	d7, [pc, #544]	; 5be8 <__ieee754_rem_pio2+0x240>
    59c8:	ble.w	5b8a <__ieee754_rem_pio2+0x1e2>
    59cc:	vsub.f64	d7, d0, d7
    59d0:	sub.w	r1, r1, #634880	; 0x9b000
    59d4:	sub.w	r1, r1, #1920	; 0x780
    59d8:	cmp	r6, r1
    59da:	beq.n	5aa4 <__ieee754_rem_pio2+0xfc>
    59dc:	vldr	d6, [pc, #528]	; 5bf0 <__ieee754_rem_pio2+0x248>
    59e0:	vsub.f64	d5, d7, d6
    59e4:	vsub.f64	d7, d7, d5
    59e8:	movs	r3, #1
    59ea:	vstr	d5, [r0]
    59ee:	vsub.f64	d7, d7, d6
    59f2:	vstr	d7, [r0, #8]
    59f6:	mov	r0, r3
    59f8:	add	sp, #32
    59fa:	pop	{r4, r5, r6, pc}
    59fc:	ldr	r1, [pc, #560]	; (5c30 <__ieee754_rem_pio2+0x288>)
    59fe:	cmp	r6, r1
    5a00:	mov	r4, r0
    5a02:	ble.n	5ab2 <__ieee754_rem_pio2+0x10a>
    5a04:	ldr	r1, [pc, #556]	; (5c34 <__ieee754_rem_pio2+0x28c>)
    5a06:	cmp	r6, r1
    5a08:	bgt.n	5a94 <__ieee754_rem_pio2+0xec>
    5a0a:	mov	r0, r2
    5a0c:	asrs	r2, r6, #20
    5a0e:	subw	r2, r2, #1046	; 0x416
    5a12:	sub.w	r1, r6, r2, lsl #20
    5a16:	vmov	d6, r0, r1
    5a1a:	vldr	d7, [pc, #476]	; 5bf8 <__ieee754_rem_pio2+0x250>
    5a1e:	vcvt.s32.f64	s8, d6
    5a22:	movs	r3, #0
    5a24:	vcvt.f64.s32	d4, s8
    5a28:	vsub.f64	d6, d6, d4
    5a2c:	vmul.f64	d6, d6, d7
    5a30:	vcvt.s32.f64	s10, d6
    5a34:	vstr	d4, [sp, #8]
    5a38:	vcvt.f64.s32	d5, s10
    5a3c:	vsub.f64	d6, d6, d5
    5a40:	vmul.f64	d7, d6, d7
    5a44:	vcmp.f64	d7, #0.0
    5a48:	vmrs	APSR_nzcv, fpscr
    5a4c:	vstr	d5, [sp, #16]
    5a50:	vstr	d7, [sp, #24]
    5a54:	bne.w	5bce <__ieee754_rem_pio2+0x226>
    5a58:	vcmp.f64	d5, #0.0
    5a5c:	vmrs	APSR_nzcv, fpscr
    5a60:	ite	eq
    5a62:	moveq	r3, #1
    5a64:	movne	r3, #2
    5a66:	ldr	r1, [pc, #464]	; (5c38 <__ieee754_rem_pio2+0x290>)
    5a68:	str	r1, [sp, #4]
    5a6a:	movs	r1, #2
    5a6c:	str	r1, [sp, #0]
    5a6e:	add	r0, sp, #8
    5a70:	mov	r1, r4
    5a72:	bl	6390 <__kernel_rem_pio2>
    5a76:	cmp	r5, #0
    5a78:	blt.w	5bb2 <__ieee754_rem_pio2+0x20a>
    5a7c:	mov	r3, r0
    5a7e:	b.n	5a8e <__ieee754_rem_pio2+0xe6>
    5a80:	movs	r4, #0
    5a82:	movs	r5, #0
    5a84:	vstr	d0, [r0]
    5a88:	strd	r4, r5, [r0, #8]
    5a8c:	movs	r3, #0
    5a8e:	mov	r0, r3
    5a90:	add	sp, #32
    5a92:	pop	{r4, r5, r6, pc}
    5a94:	vsub.f64	d7, d0, d0
    5a98:	movs	r3, #0
    5a9a:	vstr	d7, [r0, #8]
    5a9e:	vstr	d7, [r0]
    5aa2:	b.n	5a8e <__ieee754_rem_pio2+0xe6>
    5aa4:	vldr	d5, [pc, #344]	; 5c00 <__ieee754_rem_pio2+0x258>
    5aa8:	vldr	d6, [pc, #348]	; 5c08 <__ieee754_rem_pio2+0x260>
    5aac:	vsub.f64	d7, d7, d5
    5ab0:	b.n	59e0 <__ieee754_rem_pio2+0x38>
    5ab2:	bl	748c <fabs>
    5ab6:	vmov.f64	d7, #96	; 0x3f000000  0.5
    5aba:	vldr	d6, [pc, #340]	; 5c10 <__ieee754_rem_pio2+0x268>
    5abe:	vfma.f64	d7, d0, d6
    5ac2:	vcvt.s32.f64	s15, d7
    5ac6:	vldr	d3, [pc, #288]	; 5be8 <__ieee754_rem_pio2+0x240>
    5aca:	vmov	r3, s15
    5ace:	vldr	d6, [pc, #288]	; 5bf0 <__ieee754_rem_pio2+0x248>
    5ad2:	cmp	r3, #31
    5ad4:	vcvt.f64.s32	d5, s15
    5ad8:	vneg.f64	d4, d5
    5adc:	vmul.f64	d7, d5, d6
    5ae0:	vfma.f64	d0, d4, d3
    5ae4:	bgt.n	5b1e <__ieee754_rem_pio2+0x176>
    5ae6:	ldr	r2, [pc, #340]	; (5c3c <__ieee754_rem_pio2+0x294>)
    5ae8:	subs	r1, r3, #1
    5aea:	ldr.w	r2, [r2, r1, lsl #2]
    5aee:	cmp	r6, r2
    5af0:	beq.n	5b1e <__ieee754_rem_pio2+0x176>
    5af2:	vsub.f64	d6, d0, d7
    5af6:	vstr	d6, [r4]
    5afa:	vsub.f64	d0, d0, d6
    5afe:	vsub.f64	d0, d0, d7
    5b02:	cmp	r5, #0
    5b04:	vstr	d0, [r4, #8]
    5b08:	bge.n	5a8e <__ieee754_rem_pio2+0xe6>
    5b0a:	vneg.f64	d6, d6
    5b0e:	vneg.f64	d0, d0
    5b12:	vstr	d6, [r4]
    5b16:	vstr	d0, [r4, #8]
    5b1a:	negs	r3, r3
    5b1c:	b.n	5a8e <__ieee754_rem_pio2+0xe6>
    5b1e:	vsub.f64	d6, d0, d7
    5b22:	vmov	r2, s13
    5b26:	asrs	r6, r6, #20
    5b28:	ubfx	r2, r2, #20, #11
    5b2c:	subs	r2, r6, r2
    5b2e:	cmp	r2, #16
    5b30:	vstr	d6, [r4]
    5b34:	ble.n	5afa <__ieee754_rem_pio2+0x152>
    5b36:	vmov.f64	d3, d0
    5b3a:	vldr	d7, [pc, #196]	; 5c00 <__ieee754_rem_pio2+0x258>
    5b3e:	vldr	d6, [pc, #200]	; 5c08 <__ieee754_rem_pio2+0x260>
    5b42:	vfma.f64	d3, d4, d7
    5b46:	vsub.f64	d0, d0, d3
    5b4a:	vfma.f64	d0, d4, d7
    5b4e:	vmov.f64	d7, d0
    5b52:	vfnms.f64	d7, d5, d6
    5b56:	vsub.f64	d6, d3, d7
    5b5a:	vmov	r2, s13
    5b5e:	ubfx	r2, r2, #20, #11
    5b62:	subs	r6, r6, r2
    5b64:	cmp	r6, #49	; 0x31
    5b66:	vstr	d6, [r4]
    5b6a:	ble.n	5be0 <__ieee754_rem_pio2+0x238>
    5b6c:	vmov.f64	d0, d3
    5b70:	vldr	d6, [pc, #164]	; 5c18 <__ieee754_rem_pio2+0x270>
    5b74:	vldr	d2, [pc, #168]	; 5c20 <__ieee754_rem_pio2+0x278>
    5b78:	vfma.f64	d0, d4, d6
    5b7c:	vsub.f64	d7, d3, d0
    5b80:	vfma.f64	d7, d4, d6
    5b84:	vfnms.f64	d7, d5, d2
    5b88:	b.n	5af2 <__ieee754_rem_pio2+0x14a>
    5b8a:	ldr	r1, [pc, #180]	; (5c40 <__ieee754_rem_pio2+0x298>)
    5b8c:	vadd.f64	d7, d0, d7
    5b90:	cmp	r6, r1
    5b92:	beq.n	5bd2 <__ieee754_rem_pio2+0x22a>
    5b94:	vldr	d6, [pc, #88]	; 5bf0 <__ieee754_rem_pio2+0x248>
    5b98:	vadd.f64	d5, d7, d6
    5b9c:	vsub.f64	d7, d7, d5
    5ba0:	mov.w	r3, #4294967295
    5ba4:	vadd.f64	d7, d7, d6
    5ba8:	vstr	d5, [r0]
    5bac:	vstr	d7, [r0, #8]
    5bb0:	b.n	5a8e <__ieee754_rem_pio2+0xe6>
    5bb2:	vldr	d6, [r4]
    5bb6:	vldr	d7, [r4, #8]
    5bba:	vneg.f64	d6, d6
    5bbe:	vneg.f64	d7, d7
    5bc2:	negs	r3, r0
    5bc4:	vstr	d6, [r4]
    5bc8:	vstr	d7, [r4, #8]
    5bcc:	b.n	5a8e <__ieee754_rem_pio2+0xe6>
    5bce:	movs	r3, #3
    5bd0:	b.n	5a66 <__ieee754_rem_pio2+0xbe>
    5bd2:	vldr	d5, [pc, #44]	; 5c00 <__ieee754_rem_pio2+0x258>
    5bd6:	vldr	d6, [pc, #48]	; 5c08 <__ieee754_rem_pio2+0x260>
    5bda:	vadd.f64	d7, d7, d5
    5bde:	b.n	5b98 <__ieee754_rem_pio2+0x1f0>
    5be0:	vmov.f64	d0, d3
    5be4:	b.n	5afa <__ieee754_rem_pio2+0x152>
    5be6:	nop
    5be8:	.word	0x54400000
    5bec:	.word	0x3ff921fb
    5bf0:	.word	0x1a626331
    5bf4:	.word	0x3dd0b461
    5bf8:	.word	0x00000000
    5bfc:	.word	0x41700000
    5c00:	.word	0x1a600000
    5c04:	.word	0x3dd0b461
    5c08:	.word	0x2e037073
    5c0c:	.word	0x3ba3198a
    5c10:	.word	0x6dc9c883
    5c14:	.word	0x3fe45f30
    5c18:	.word	0x2e000000
    5c1c:	.word	0x3ba3198a
    5c20:	.word	0x252049c1
    5c24:	.word	0x397b839a
    5c28:	.word	0x3fe921fb
    5c2c:	.word	0x4002d97b
    5c30:	.word	0x413921fb
    5c34:	.word	0x7fefffff
    5c38:	.word	0x200008ac
    5c3c:	.word	0x2000082c
    5c40:	.word	0x3ff921fb

00005c44 <__ieee754_sqrt>:
    5c44:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5c48:	sub	sp, #8
    5c4a:	vstr	d0, [sp]
    5c4e:	ldr	r1, [pc, #372]	; (5dc4 <__ieee754_sqrt+0x180>)
    5c50:	ldr	r3, [sp, #4]
    5c52:	ldr	r0, [sp, #0]
    5c54:	mov	r4, r1
    5c56:	ands	r1, r3
    5c58:	cmp	r1, r4
    5c5a:	beq.w	5d8e <__ieee754_sqrt+0x14a>
    5c5e:	cmp	r3, #0
    5c60:	mov	r2, r0
    5c62:	ble.n	5d54 <__ieee754_sqrt+0x110>
    5c64:	asrs	r7, r3, #20
    5c66:	beq.w	5d6e <__ieee754_sqrt+0x12a>
    5c6a:	subw	r7, r7, #1023	; 0x3ff
    5c6e:	ubfx	r3, r3, #0, #20
    5c72:	lsls	r1, r7, #31
    5c74:	orr.w	r3, r3, #1048576	; 0x100000
    5c78:	bmi.n	5d4a <__ieee754_sqrt+0x106>
    5c7a:	add.w	r1, r3, r2, lsr #31
    5c7e:	movs	r6, #0
    5c80:	add	r3, r1
    5c82:	asrs	r7, r7, #1
    5c84:	lsls	r2, r2, #1
    5c86:	mov	lr, r6
    5c88:	movs	r0, #22
    5c8a:	mov.w	r1, #2097152	; 0x200000
    5c8e:	add.w	r4, lr, r1
    5c92:	cmp	r4, r3
    5c94:	mov.w	r5, r2, lsr #31
    5c98:	mov.w	r2, r2, lsl #1
    5c9c:	bgt.n	5ca6 <__ieee754_sqrt+0x62>
    5c9e:	subs	r3, r3, r4
    5ca0:	add.w	lr, r4, r1
    5ca4:	add	r6, r1
    5ca6:	subs	r0, #1
    5ca8:	add.w	r3, r5, r3, lsl #1
    5cac:	mov.w	r1, r1, lsr #1
    5cb0:	bne.n	5c8e <__ieee754_sqrt+0x4a>
    5cb2:	mov	ip, r0
    5cb4:	movs	r4, #32
    5cb6:	mov.w	r1, #2147483648	; 0x80000000
    5cba:	b.n	5cd0 <__ieee754_sqrt+0x8c>
    5cbc:	beq.n	5d00 <__ieee754_sqrt+0xbc>
    5cbe:	add.w	r5, r3, r2, lsr #31
    5cc2:	subs	r4, #1
    5cc4:	mov.w	r1, r1, lsr #1
    5cc8:	add	r3, r5
    5cca:	mov.w	r2, r2, lsl #1
    5cce:	beq.n	5d12 <__ieee754_sqrt+0xce>
    5cd0:	cmp	lr, r3
    5cd2:	add.w	r5, r1, ip
    5cd6:	bge.n	5cbc <__ieee754_sqrt+0x78>
    5cd8:	cmp	r5, #0
    5cda:	add.w	ip, r5, r1
    5cde:	blt.n	5cf4 <__ieee754_sqrt+0xb0>
    5ce0:	mov	r8, lr
    5ce2:	cmp	r5, r2
    5ce4:	rsb	r3, lr, r3
    5ce8:	bls.n	5cec <__ieee754_sqrt+0xa8>
    5cea:	subs	r3, #1
    5cec:	subs	r2, r2, r5
    5cee:	add	r0, r1
    5cf0:	mov	lr, r8
    5cf2:	b.n	5cbe <__ieee754_sqrt+0x7a>
    5cf4:	cmp.w	ip, #0
    5cf8:	blt.n	5ce0 <__ieee754_sqrt+0x9c>
    5cfa:	add.w	r8, lr, #1
    5cfe:	b.n	5ce2 <__ieee754_sqrt+0x9e>
    5d00:	cmp	r5, r2
    5d02:	bhi.n	5d3a <__ieee754_sqrt+0xf6>
    5d04:	cmp	r5, #0
    5d06:	add.w	ip, r5, r1
    5d0a:	blt.n	5d9e <__ieee754_sqrt+0x15a>
    5d0c:	mov	r8, r3
    5d0e:	movs	r3, #0
    5d10:	b.n	5cec <__ieee754_sqrt+0xa8>
    5d12:	orrs	r3, r2
    5d14:	bne.n	5d3e <__ieee754_sqrt+0xfa>
    5d16:	lsrs	r0, r0, #1
    5d18:	asrs	r1, r6, #1
    5d1a:	lsls	r3, r6, #31
    5d1c:	add.w	r1, r1, #1069547520	; 0x3fc00000
    5d20:	add.w	r1, r1, #2097152	; 0x200000
    5d24:	it	mi
    5d26:	orrmi.w	r0, r0, #2147483648	; 0x80000000
    5d2a:	add.w	r3, r1, r7, lsl #20
    5d2e:	mov	r2, r0
    5d30:	vmov	d0, r2, r3
    5d34:	add	sp, #8
    5d36:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5d3a:	mov	r3, lr
    5d3c:	b.n	5cbe <__ieee754_sqrt+0x7a>
    5d3e:	adds	r2, r0, #1
    5d40:	beq.n	5da6 <__ieee754_sqrt+0x162>
    5d42:	and.w	r3, r0, #1
    5d46:	add	r0, r3
    5d48:	b.n	5d16 <__ieee754_sqrt+0xd2>
    5d4a:	lsls	r3, r3, #1
    5d4c:	add.w	r3, r3, r2, lsr #31
    5d50:	lsls	r2, r2, #1
    5d52:	b.n	5c7a <__ieee754_sqrt+0x36>
    5d54:	bic.w	r1, r3, #2147483648	; 0x80000000
    5d58:	orrs	r1, r0
    5d5a:	beq.n	5d98 <__ieee754_sqrt+0x154>
    5d5c:	cbnz	r3, 5db6 <__ieee754_sqrt+0x172>
    5d5e:	mov	r7, r3
    5d60:	lsrs	r3, r2, #11
    5d62:	subs	r7, #21
    5d64:	lsls	r2, r2, #21
    5d66:	cmp	r3, #0
    5d68:	beq.n	5d60 <__ieee754_sqrt+0x11c>
    5d6a:	lsls	r5, r3, #11
    5d6c:	bmi.n	5dac <__ieee754_sqrt+0x168>
    5d6e:	movs	r1, #0
    5d70:	b.n	5d74 <__ieee754_sqrt+0x130>
    5d72:	mov	r1, r0
    5d74:	lsls	r3, r3, #1
    5d76:	lsls	r4, r3, #11
    5d78:	add.w	r0, r1, #1
    5d7c:	bpl.n	5d72 <__ieee754_sqrt+0x12e>
    5d7e:	rsb	r4, r0, #32
    5d82:	lsr.w	r4, r2, r4
    5d86:	orrs	r3, r4
    5d88:	subs	r7, r7, r1
    5d8a:	lsls	r2, r0
    5d8c:	b.n	5c6a <__ieee754_sqrt+0x26>
    5d8e:	vfma.f64	d0, d0, d0
    5d92:	add	sp, #8
    5d94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5d98:	vldr	d0, [sp]
    5d9c:	b.n	5d34 <__ieee754_sqrt+0xf0>
    5d9e:	cmp.w	ip, #0
    5da2:	bge.n	5cfa <__ieee754_sqrt+0xb6>
    5da4:	b.n	5d0c <__ieee754_sqrt+0xc8>
    5da6:	adds	r6, #1
    5da8:	mov	r0, r4
    5daa:	b.n	5d18 <__ieee754_sqrt+0xd4>
    5dac:	movs	r4, #32
    5dae:	mov.w	r1, #4294967295
    5db2:	movs	r0, #0
    5db4:	b.n	5d82 <__ieee754_sqrt+0x13e>
    5db6:	vldr	d7, [sp]
    5dba:	vsub.f64	d7, d7, d7
    5dbe:	vdiv.f64	d0, d7, d7
    5dc2:	b.n	5d34 <__ieee754_sqrt+0xf0>
    5dc4:	.word	0x7ff00000

00005dc8 <__ieee754_atan2f>:
    5dc8:	push	{r4, lr}
    5dca:	sub	sp, #8
    5dcc:	vstr	s1, [sp, #4]
    5dd0:	ldr	r3, [sp, #4]
    5dd2:	bic.w	r2, r3, #2147483648	; 0x80000000
    5dd6:	cmp.w	r2, #2139095040	; 0x7f800000
    5dda:	vmov.f32	s15, s0
    5dde:	bgt.n	5e14 <__ieee754_atan2f+0x4c>
    5de0:	vmov	r0, s0
    5de4:	bic.w	r1, r0, #2147483648	; 0x80000000
    5de8:	cmp.w	r1, #2139095040	; 0x7f800000
    5dec:	bgt.n	5e14 <__ieee754_atan2f+0x4c>
    5dee:	cmp.w	r3, #1065353216	; 0x3f800000
    5df2:	beq.n	5e88 <__ieee754_atan2f+0xc0>
    5df4:	asrs	r4, r3, #30
    5df6:	and.w	r4, r4, #2
    5dfa:	orr.w	r4, r4, r0, lsr #31
    5dfe:	cbnz	r1, 5e20 <__ieee754_atan2f+0x58>
    5e00:	cmp	r4, #2
    5e02:	beq.n	5e82 <__ieee754_atan2f+0xba>
    5e04:	vldr	s0, [pc, #256]	; 5f08 <__ieee754_atan2f+0x140>
    5e08:	cmp	r4, #3
    5e0a:	it	ne
    5e0c:	vmovne.f32	s0, s15
    5e10:	add	sp, #8
    5e12:	pop	{r4, pc}
    5e14:	vldr	s14, [sp, #4]
    5e18:	vadd.f32	s0, s14, s15
    5e1c:	add	sp, #8
    5e1e:	pop	{r4, pc}
    5e20:	cbz	r2, 5e68 <__ieee754_atan2f+0xa0>
    5e22:	cmp.w	r2, #2139095040	; 0x7f800000
    5e26:	beq.n	5e92 <__ieee754_atan2f+0xca>
    5e28:	cmp.w	r1, #2139095040	; 0x7f800000
    5e2c:	beq.n	5e68 <__ieee754_atan2f+0xa0>
    5e2e:	subs	r2, r1, r2
    5e30:	asrs	r2, r2, #23
    5e32:	cmp	r2, #60	; 0x3c
    5e34:	bgt.n	5e7c <__ieee754_atan2f+0xb4>
    5e36:	cmp	r3, #0
    5e38:	blt.n	5ed2 <__ieee754_atan2f+0x10a>
    5e3a:	vldr	s0, [sp, #4]
    5e3e:	vdiv.f32	s0, s15, s0
    5e42:	bl	79d4 <fabsf>
    5e46:	bl	781c <atanf>
    5e4a:	cmp	r4, #1
    5e4c:	beq.n	5ec4 <__ieee754_atan2f+0xfc>
    5e4e:	cmp	r4, #2
    5e50:	beq.n	5eb2 <__ieee754_atan2f+0xea>
    5e52:	cmp	r4, #0
    5e54:	beq.n	5e1c <__ieee754_atan2f+0x54>
    5e56:	vldr	s14, [pc, #180]	; 5f0c <__ieee754_atan2f+0x144>
    5e5a:	vldr	s15, [pc, #180]	; 5f10 <__ieee754_atan2f+0x148>
    5e5e:	vadd.f32	s0, s0, s14
    5e62:	vsub.f32	s0, s0, s15
    5e66:	b.n	5e1c <__ieee754_atan2f+0x54>
    5e68:	vldr	s15, [pc, #168]	; 5f14 <__ieee754_atan2f+0x14c>
    5e6c:	vldr	s0, [pc, #168]	; 5f18 <__ieee754_atan2f+0x150>
    5e70:	cmp	r0, #0
    5e72:	it	ge
    5e74:	vmovge.f32	s0, s15
    5e78:	add	sp, #8
    5e7a:	pop	{r4, pc}
    5e7c:	vldr	s0, [pc, #148]	; 5f14 <__ieee754_atan2f+0x14c>
    5e80:	b.n	5e4a <__ieee754_atan2f+0x82>
    5e82:	vldr	s0, [pc, #140]	; 5f10 <__ieee754_atan2f+0x148>
    5e86:	b.n	5e1c <__ieee754_atan2f+0x54>
    5e88:	add	sp, #8
    5e8a:	ldmia.w	sp!, {r4, lr}
    5e8e:	b.w	781c <atanf>
    5e92:	cmp.w	r1, #2139095040	; 0x7f800000
    5e96:	beq.n	5edc <__ieee754_atan2f+0x114>
    5e98:	cmp	r4, #2
    5e9a:	beq.n	5e82 <__ieee754_atan2f+0xba>
    5e9c:	cmp	r4, #3
    5e9e:	beq.n	5ef6 <__ieee754_atan2f+0x12e>
    5ea0:	vldr	s15, [pc, #120]	; 5f1c <__ieee754_atan2f+0x154>
    5ea4:	vldr	s0, [pc, #120]	; 5f20 <__ieee754_atan2f+0x158>
    5ea8:	cmp	r4, #1
    5eaa:	it	eq
    5eac:	vmoveq.f32	s0, s15
    5eb0:	b.n	5e1c <__ieee754_atan2f+0x54>
    5eb2:	vldr	s14, [pc, #88]	; 5f0c <__ieee754_atan2f+0x144>
    5eb6:	vldr	s15, [pc, #88]	; 5f10 <__ieee754_atan2f+0x148>
    5eba:	vadd.f32	s0, s0, s14
    5ebe:	vsub.f32	s0, s15, s0
    5ec2:	b.n	5e1c <__ieee754_atan2f+0x54>
    5ec4:	vmov	r3, s0
    5ec8:	add.w	r3, r3, #2147483648	; 0x80000000
    5ecc:	vmov	s0, r3
    5ed0:	b.n	5e1c <__ieee754_atan2f+0x54>
    5ed2:	adds	r2, #60	; 0x3c
    5ed4:	bge.n	5e3a <__ieee754_atan2f+0x72>
    5ed6:	vldr	s0, [pc, #72]	; 5f20 <__ieee754_atan2f+0x158>
    5eda:	b.n	5e4a <__ieee754_atan2f+0x82>
    5edc:	cmp	r4, #2
    5ede:	beq.n	5f02 <__ieee754_atan2f+0x13a>
    5ee0:	cmp	r4, #3
    5ee2:	beq.n	5efc <__ieee754_atan2f+0x134>
    5ee4:	vldr	s15, [pc, #60]	; 5f24 <__ieee754_atan2f+0x15c>
    5ee8:	vldr	s0, [pc, #60]	; 5f28 <__ieee754_atan2f+0x160>
    5eec:	cmp	r4, #1
    5eee:	it	eq
    5ef0:	vmoveq.f32	s0, s15
    5ef4:	b.n	5e1c <__ieee754_atan2f+0x54>
    5ef6:	vldr	s0, [pc, #16]	; 5f08 <__ieee754_atan2f+0x140>
    5efa:	b.n	5e1c <__ieee754_atan2f+0x54>
    5efc:	vldr	s0, [pc, #44]	; 5f2c <__ieee754_atan2f+0x164>
    5f00:	b.n	5e1c <__ieee754_atan2f+0x54>
    5f02:	vldr	s0, [pc, #44]	; 5f30 <__ieee754_atan2f+0x168>
    5f06:	b.n	5e1c <__ieee754_atan2f+0x54>
    5f08:	.word	0xc0490fdb
    5f0c:	.word	0x33bbbd2e
    5f10:	.word	0x40490fdb
    5f14:	.word	0x3fc90fdb
    5f18:	.word	0xbfc90fdb
    5f1c:	.word	0x80000000
    5f20:	.word	0x00000000
    5f24:	.word	0xbf490fdb
    5f28:	.word	0x3f490fdb
    5f2c:	.word	0xc016cbe4
    5f30:	.word	0x4016cbe4

00005f34 <__ieee754_rem_pio2f>:
    5f34:	push	{r4, r5, r6, lr}
    5f36:	vmov	r3, s0
    5f3a:	ldr	r2, [pc, #600]	; (6194 <__ieee754_rem_pio2f+0x260>)
    5f3c:	bic.w	r4, r3, #2147483648	; 0x80000000
    5f40:	cmp	r4, r2
    5f42:	sub	sp, #24
    5f44:	ble.n	6006 <__ieee754_rem_pio2f+0xd2>
    5f46:	ldr	r2, [pc, #592]	; (6198 <__ieee754_rem_pio2f+0x264>)
    5f48:	cmp	r4, r2
    5f4a:	vmov	r6, s0
    5f4e:	bgt.n	5f88 <__ieee754_rem_pio2f+0x54>
    5f50:	cmp	r3, #0
    5f52:	vldr	s15, [pc, #584]	; 619c <__ieee754_rem_pio2f+0x268>
    5f56:	ldr	r2, [pc, #584]	; (61a0 <__ieee754_rem_pio2f+0x26c>)
    5f58:	bic.w	r4, r4, #15
    5f5c:	ble.w	610a <__ieee754_rem_pio2f+0x1d6>
    5f60:	cmp	r4, r2
    5f62:	vsub.f32	s15, s0, s15
    5f66:	beq.n	6026 <__ieee754_rem_pio2f+0xf2>
    5f68:	vldr	s14, [pc, #568]	; 61a4 <__ieee754_rem_pio2f+0x270>
    5f6c:	vsub.f32	s13, s15, s14
    5f70:	movs	r3, #1
    5f72:	vsub.f32	s15, s15, s13
    5f76:	vstr	s13, [r0]
    5f7a:	vsub.f32	s15, s15, s14
    5f7e:	vstr	s15, [r0, #4]
    5f82:	mov	r0, r3
    5f84:	add	sp, #24
    5f86:	pop	{r4, r5, r6, pc}
    5f88:	ldr	r2, [pc, #540]	; (61a8 <__ieee754_rem_pio2f+0x274>)
    5f8a:	cmp	r4, r2
    5f8c:	mov	r5, r0
    5f8e:	ble.n	604a <__ieee754_rem_pio2f+0x116>
    5f90:	cmp.w	r4, #2139095040	; 0x7f800000
    5f94:	bge.n	6016 <__ieee754_rem_pio2f+0xe2>
    5f96:	asrs	r2, r4, #23
    5f98:	subs	r2, #134	; 0x86
    5f9a:	sub.w	r3, r4, r2, lsl #23
    5f9e:	vmov	s14, r3
    5fa2:	vcvt.s32.f32	s13, s14
    5fa6:	vldr	s15, [pc, #516]	; 61ac <__ieee754_rem_pio2f+0x278>
    5faa:	vcvt.f32.s32	s13, s13
    5fae:	vsub.f32	s14, s14, s13
    5fb2:	vstr	s13, [sp, #12]
    5fb6:	vmul.f32	s14, s14, s15
    5fba:	vcvt.s32.f32	s13, s14
    5fbe:	vcvt.f32.s32	s13, s13
    5fc2:	vsub.f32	s14, s14, s13
    5fc6:	vstr	s13, [sp, #16]
    5fca:	vmul.f32	s15, s14, s15
    5fce:	vcmp.f32	s15, #0.0
    5fd2:	vmrs	APSR_nzcv, fpscr
    5fd6:	vstr	s15, [sp, #20]
    5fda:	bne.w	614c <__ieee754_rem_pio2f+0x218>
    5fde:	vcmp.f32	s13, #0.0
    5fe2:	vmrs	APSR_nzcv, fpscr
    5fe6:	ite	eq
    5fe8:	moveq	r3, #1
    5fea:	movne	r3, #2
    5fec:	ldr	r1, [pc, #448]	; (61b0 <__ieee754_rem_pio2f+0x27c>)
    5fee:	str	r1, [sp, #4]
    5ff0:	movs	r1, #2
    5ff2:	str	r1, [sp, #0]
    5ff4:	add	r0, sp, #12
    5ff6:	mov	r1, r5
    5ff8:	bl	6bc4 <__kernel_rem_pio2f>
    5ffc:	cmp	r6, #0
    5ffe:	blt.w	6130 <__ieee754_rem_pio2f+0x1fc>
    6002:	mov	r3, r0
    6004:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    6006:	movs	r2, #0
    6008:	vstr	s0, [r0]
    600c:	str	r2, [r0, #4]
    600e:	movs	r3, #0
    6010:	mov	r0, r3
    6012:	add	sp, #24
    6014:	pop	{r4, r5, r6, pc}
    6016:	vsub.f32	s15, s0, s0
    601a:	movs	r3, #0
    601c:	vstr	s15, [r0, #4]
    6020:	vstr	s15, [r0]
    6024:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    6026:	vldr	s13, [pc, #396]	; 61b4 <__ieee754_rem_pio2f+0x280>
    602a:	vldr	s14, [pc, #396]	; 61b8 <__ieee754_rem_pio2f+0x284>
    602e:	vsub.f32	s15, s15, s13
    6032:	movs	r3, #1
    6034:	vsub.f32	s13, s15, s14
    6038:	vsub.f32	s15, s15, s13
    603c:	vstr	s13, [r0]
    6040:	vsub.f32	s15, s15, s14
    6044:	vstr	s15, [r0, #4]
    6048:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    604a:	bl	79d4 <fabsf>
    604e:	vldr	s13, [pc, #364]	; 61bc <__ieee754_rem_pio2f+0x288>
    6052:	vldr	s11, [pc, #328]	; 619c <__ieee754_rem_pio2f+0x268>
    6056:	vldr	s14, [pc, #332]	; 61a4 <__ieee754_rem_pio2f+0x270>
    605a:	vmov.f32	s15, #96	; 0x3f000000  0.5
    605e:	vfma.f32	s15, s0, s13
    6062:	vcvt.s32.f32	s15, s15
    6066:	vmov	r3, s15
    606a:	vcvt.f32.s32	s13, s15
    606e:	cmp	r3, #31
    6070:	vneg.f32	s12, s13
    6074:	vfma.f32	s0, s12, s11
    6078:	vmul.f32	s15, s13, s14
    607c:	bgt.n	60ba <__ieee754_rem_pio2f+0x186>
    607e:	ldr	r1, [pc, #320]	; (61c0 <__ieee754_rem_pio2f+0x28c>)
    6080:	subs	r0, r3, #1
    6082:	bic.w	r2, r4, #255	; 0xff
    6086:	ldr.w	r1, [r1, r0, lsl #2]
    608a:	cmp	r2, r1
    608c:	beq.n	60ba <__ieee754_rem_pio2f+0x186>
    608e:	vsub.f32	s14, s0, s15
    6092:	vstr	s14, [r5]
    6096:	vsub.f32	s0, s0, s14
    609a:	cmp	r6, #0
    609c:	vsub.f32	s0, s0, s15
    60a0:	vstr	s0, [r5, #4]
    60a4:	bge.n	6010 <__ieee754_rem_pio2f+0xdc>
    60a6:	vneg.f32	s14, s14
    60aa:	vneg.f32	s0, s0
    60ae:	vstr	s14, [r5]
    60b2:	vstr	s0, [r5, #4]
    60b6:	negs	r3, r3
    60b8:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    60ba:	vsub.f32	s14, s0, s15
    60be:	asrs	r4, r4, #23
    60c0:	vmov	r2, s14
    60c4:	ubfx	r2, r2, #23, #8
    60c8:	subs	r2, r4, r2
    60ca:	cmp	r2, #8
    60cc:	ble.n	6092 <__ieee754_rem_pio2f+0x15e>
    60ce:	vldr	s15, [pc, #228]	; 61b4 <__ieee754_rem_pio2f+0x280>
    60d2:	vldr	s14, [pc, #228]	; 61b8 <__ieee754_rem_pio2f+0x284>
    60d6:	vmov.f32	s11, s0
    60da:	vfma.f32	s11, s12, s15
    60de:	vsub.f32	s0, s0, s11
    60e2:	vfma.f32	s0, s12, s15
    60e6:	vmov.f32	s15, s0
    60ea:	vfnms.f32	s15, s13, s14
    60ee:	vsub.f32	s14, s11, s15
    60f2:	vmov	r2, s14
    60f6:	ubfx	r2, r2, #23, #8
    60fa:	subs	r4, r4, r2
    60fc:	cmp	r4, #25
    60fe:	bgt.n	6176 <__ieee754_rem_pio2f+0x242>
    6100:	vstr	s14, [r5]
    6104:	vmov.f32	s0, s11
    6108:	b.n	6096 <__ieee754_rem_pio2f+0x162>
    610a:	cmp	r4, r2
    610c:	vadd.f32	s15, s0, s15
    6110:	beq.n	6150 <__ieee754_rem_pio2f+0x21c>
    6112:	vldr	s14, [pc, #144]	; 61a4 <__ieee754_rem_pio2f+0x270>
    6116:	vadd.f32	s13, s15, s14
    611a:	mov.w	r3, #4294967295
    611e:	vsub.f32	s15, s15, s13
    6122:	vstr	s13, [r0]
    6126:	vadd.f32	s15, s15, s14
    612a:	vstr	s15, [r0, #4]
    612e:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    6130:	vldr	s14, [r5]
    6134:	vldr	s15, [r5, #4]
    6138:	vneg.f32	s14, s14
    613c:	vneg.f32	s15, s15
    6140:	negs	r3, r0
    6142:	vstr	s14, [r5]
    6146:	vstr	s15, [r5, #4]
    614a:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    614c:	movs	r3, #3
    614e:	b.n	5fec <__ieee754_rem_pio2f+0xb8>
    6150:	vldr	s13, [pc, #96]	; 61b4 <__ieee754_rem_pio2f+0x280>
    6154:	vldr	s14, [pc, #96]	; 61b8 <__ieee754_rem_pio2f+0x284>
    6158:	vadd.f32	s15, s15, s13
    615c:	mov.w	r3, #4294967295
    6160:	vadd.f32	s13, s15, s14
    6164:	vsub.f32	s15, s15, s13
    6168:	vstr	s13, [r0]
    616c:	vadd.f32	s15, s15, s14
    6170:	vstr	s15, [r0, #4]
    6174:	b.n	6010 <__ieee754_rem_pio2f+0xdc>
    6176:	vldr	s14, [pc, #76]	; 61c4 <__ieee754_rem_pio2f+0x290>
    617a:	vldr	s10, [pc, #76]	; 61c8 <__ieee754_rem_pio2f+0x294>
    617e:	vmov.f32	s0, s11
    6182:	vfma.f32	s0, s12, s14
    6186:	vsub.f32	s15, s11, s0
    618a:	vfma.f32	s15, s12, s14
    618e:	vfnms.f32	s15, s13, s10
    6192:	b.n	608e <__ieee754_rem_pio2f+0x15a>
    6194:	.word	0x3f490fd8
    6198:	.word	0x4016cbe3
    619c:	.word	0x3fc90f80
    61a0:	.word	0x3fc90fd0
    61a4:	.word	0x37354443
    61a8:	.word	0x43490f80
    61ac:	.word	0x43800000
    61b0:	.word	0x20000a34
    61b4:	.word	0x37354400
    61b8:	.word	0x2e85a308
    61bc:	.word	0x3f22f984
    61c0:	.word	0x200009b4
    61c4:	.word	0x2e85a300
    61c8:	.word	0x248d3132

000061cc <__ieee754_sqrtf>:
    61cc:	vmov	r3, s0
    61d0:	bic.w	r2, r3, #2147483648	; 0x80000000
    61d4:	cmp.w	r2, #2139095040	; 0x7f800000
    61d8:	push	{r4, r5, r6}
    61da:	bcs.n	623e <__ieee754_sqrtf+0x72>
    61dc:	cbz	r2, 623a <__ieee754_sqrtf+0x6e>
    61de:	cmp	r3, #0
    61e0:	blt.n	625e <__ieee754_sqrtf+0x92>
    61e2:	cmp.w	r2, #8388608	; 0x800000
    61e6:	mov.w	r0, r3, asr #23
    61ea:	bcc.n	6246 <__ieee754_sqrtf+0x7a>
    61ec:	sub.w	r2, r0, #127	; 0x7f
    61f0:	ubfx	r3, r3, #0, #23
    61f4:	lsls	r1, r2, #31
    61f6:	orr.w	r3, r3, #8388608	; 0x800000
    61fa:	it	mi
    61fc:	lslmi	r3, r3, #1
    61fe:	movs	r4, #0
    6200:	asrs	r6, r2, #1
    6202:	lsls	r3, r3, #1
    6204:	mov	r5, r4
    6206:	movs	r1, #25
    6208:	mov.w	r2, #16777216	; 0x1000000
    620c:	adds	r0, r5, r2
    620e:	cmp	r0, r3
    6210:	bgt.n	6218 <__ieee754_sqrtf+0x4c>
    6212:	subs	r3, r3, r0
    6214:	adds	r5, r0, r2
    6216:	add	r4, r2
    6218:	subs	r1, #1
    621a:	mov.w	r3, r3, lsl #1
    621e:	mov.w	r2, r2, lsr #1
    6222:	bne.n	620c <__ieee754_sqrtf+0x40>
    6224:	cbz	r3, 622c <__ieee754_sqrtf+0x60>
    6226:	and.w	r3, r4, #1
    622a:	add	r4, r3
    622c:	asrs	r4, r4, #1
    622e:	add.w	r4, r4, #1056964608	; 0x3f000000
    6232:	add.w	r3, r4, r6, lsl #23
    6236:	vmov	s0, r3
    623a:	pop	{r4, r5, r6}
    623c:	bx	lr
    623e:	vfma.f32	s0, s0, s0
    6242:	pop	{r4, r5, r6}
    6244:	bx	lr
    6246:	ands.w	r2, r3, #8388608	; 0x800000
    624a:	beq.n	6250 <__ieee754_sqrtf+0x84>
    624c:	b.n	6268 <__ieee754_sqrtf+0x9c>
    624e:	mov	r2, r1
    6250:	lsls	r3, r3, #1
    6252:	lsls	r4, r3, #8
    6254:	add.w	r1, r2, #1
    6258:	bpl.n	624e <__ieee754_sqrtf+0x82>
    625a:	subs	r0, r0, r2
    625c:	b.n	61ec <__ieee754_sqrtf+0x20>
    625e:	vsub.f32	s15, s0, s0
    6262:	vdiv.f32	s0, s15, s15
    6266:	b.n	623a <__ieee754_sqrtf+0x6e>
    6268:	mov.w	r2, #4294967295
    626c:	b.n	625a <__ieee754_sqrtf+0x8e>
    626e:	nop

00006270 <__kernel_cos>:
    6270:	vmov	r3, s1
    6274:	bic.w	r3, r3, #2147483648	; 0x80000000
    6278:	cmp.w	r3, #1044381696	; 0x3e400000
    627c:	bge.n	62d8 <__kernel_cos+0x68>
    627e:	vcvt.s32.f64	s15, d0
    6282:	vmov	r3, s15
    6286:	cmp	r3, #0
    6288:	beq.n	634e <__kernel_cos+0xde>
    628a:	vmul.f64	d7, d0, d0
    628e:	vldr	d4, [pc, #200]	; 6358 <__kernel_cos+0xe8>
    6292:	vldr	d5, [pc, #204]	; 6360 <__kernel_cos+0xf0>
    6296:	vldr	d6, [pc, #208]	; 6368 <__kernel_cos+0xf8>
    629a:	vfma.f64	d5, d7, d4
    629e:	vldr	d4, [pc, #208]	; 6370 <__kernel_cos+0x100>
    62a2:	vfma.f64	d6, d7, d5
    62a6:	vldr	d5, [pc, #208]	; 6378 <__kernel_cos+0x108>
    62aa:	vfma.f64	d4, d7, d6
    62ae:	vldr	d6, [pc, #208]	; 6380 <__kernel_cos+0x110>
    62b2:	vfma.f64	d5, d7, d4
    62b6:	vfma.f64	d6, d7, d5
    62ba:	vmul.f64	d6, d6, d7
    62be:	vnmul.f64	d0, d1, d0
    62c2:	vmov.f64	d5, #96	; 0x3f000000  0.5
    62c6:	vfma.f64	d0, d7, d6
    62ca:	vmov.f64	d6, #112	; 0x3f800000  1.0
    62ce:	vfnms.f64	d0, d7, d5
    62d2:	vsub.f64	d0, d6, d0
    62d6:	bx	lr
    62d8:	vldr	d4, [pc, #124]	; 6358 <__kernel_cos+0xe8>
    62dc:	vmul.f64	d7, d0, d0
    62e0:	vldr	d5, [pc, #124]	; 6360 <__kernel_cos+0xf0>
    62e4:	vldr	d6, [pc, #128]	; 6368 <__kernel_cos+0xf8>
    62e8:	vfma.f64	d5, d7, d4
    62ec:	vldr	d4, [pc, #128]	; 6370 <__kernel_cos+0x100>
    62f0:	vfma.f64	d6, d7, d5
    62f4:	ldr	r2, [pc, #144]	; (6388 <__kernel_cos+0x118>)
    62f6:	vfma.f64	d4, d7, d6
    62fa:	vldr	d5, [pc, #124]	; 6378 <__kernel_cos+0x108>
    62fe:	vldr	d6, [pc, #128]	; 6380 <__kernel_cos+0x110>
    6302:	vfma.f64	d5, d7, d4
    6306:	cmp	r3, r2
    6308:	vfma.f64	d6, d7, d5
    630c:	vmul.f64	d6, d6, d7
    6310:	ble.n	62be <__kernel_cos+0x4e>
    6312:	ldr	r2, [pc, #120]	; (638c <__kernel_cos+0x11c>)
    6314:	cmp	r3, r2
    6316:	bgt.n	6344 <__kernel_cos+0xd4>
    6318:	vmov.f64	d4, #112	; 0x3f800000  1.0
    631c:	movs	r0, #0
    631e:	sub.w	r1, r3, #2097152	; 0x200000
    6322:	vmov	d5, r0, r1
    6326:	vsub.f64	d4, d4, d5
    632a:	vnmul.f64	d1, d1, d0
    632e:	vmov.f64	d3, #96	; 0x3f000000  0.5
    6332:	vfma.f64	d1, d7, d6
    6336:	vfnms.f64	d5, d7, d3
    633a:	vsub.f64	d5, d5, d1
    633e:	vsub.f64	d0, d4, d5
    6342:	bx	lr
    6344:	vmov.f64	d4, #103	; 0x3f380000  0.7187500
    6348:	vmov.f64	d5, #82	; 0x3e900000  0.2812500
    634c:	b.n	632a <__kernel_cos+0xba>
    634e:	vmov.f64	d0, #112	; 0x3f800000  1.0
    6352:	bx	lr
    6354:	nop.w
    6358:	.word	0xbe8838d4
    635c:	.word	0xbda8fae9
    6360:	.word	0xbdb4b1c4
    6364:	.word	0x3e21ee9e
    6368:	.word	0x809c52ad
    636c:	.word	0xbe927e4f
    6370:	.word	0x19cb1590
    6374:	.word	0x3efa01a0
    6378:	.word	0x16c15177
    637c:	.word	0xbf56c16c
    6380:	.word	0x5555554c
    6384:	.word	0x3fa55555
    6388:	.word	0x3fd33332
    638c:	.word	0x3fe90000

00006390 <__kernel_rem_pio2>:
    6390:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6394:	vpush	{d8-d11}
    6398:	sub.w	sp, sp, #588	; 0x24c
    639c:	ldr	r4, [pc, #704]	; (6660 <__kernel_rem_pio2+0x2d0>)
    639e:	ldr	r6, [sp, #656]	; 0x290
    63a0:	ldr	r5, [pc, #704]	; (6664 <__kernel_rem_pio2+0x2d4>)
    63a2:	ldr.w	r6, [r4, r6, lsl #2]
    63a6:	str	r3, [sp, #4]
    63a8:	subs	r4, r2, #3
    63aa:	smull	r7, r5, r5, r4
    63ae:	asrs	r4, r4, #31
    63b0:	rsb	r4, r4, r5, asr #2
    63b4:	bic.w	r4, r4, r4, asr #31
    63b8:	subs	r7, r3, #1
    63ba:	add.w	sl, r4, #1
    63be:	sub.w	sl, sl, sl, lsl #2
    63c2:	mov	fp, r1
    63c4:	adds	r1, r6, r7
    63c6:	str	r4, [sp, #8]
    63c8:	mov	r9, r0
    63ca:	add.w	sl, r2, sl, lsl #3
    63ce:	sub.w	r3, r4, r7
    63d2:	bmi.n	6406 <__kernel_rem_pio2+0x76>
    63d4:	add	r1, r3
    63d6:	adds	r1, #1
    63d8:	add	r2, sp, #104	; 0x68
    63da:	ldr	r0, [sp, #660]	; 0x294
    63dc:	b.n	63f4 <__kernel_rem_pio2+0x64>
    63de:	ldr.w	r4, [r0, r3, lsl #2]
    63e2:	vmov	s15, r4
    63e6:	adds	r3, #1
    63e8:	vcvt.f64.s32	d7, s15
    63ec:	cmp	r3, r1
    63ee:	vstmia	r2!, {d7}
    63f2:	beq.n	6406 <__kernel_rem_pio2+0x76>
    63f4:	cmp	r3, #0
    63f6:	bge.n	63de <__kernel_rem_pio2+0x4e>
    63f8:	vldr	d7, [pc, #588]	; 6648 <__kernel_rem_pio2+0x2b8>
    63fc:	adds	r3, #1
    63fe:	cmp	r3, r1
    6400:	vstmia	r2!, {d7}
    6404:	bne.n	63f4 <__kernel_rem_pio2+0x64>
    6406:	cmp	r6, #0
    6408:	blt.w	69d0 <__kernel_rem_pio2+0x640>
    640c:	ldr	r3, [sp, #4]
    640e:	add	r0, sp, #424	; 0x1a8
    6410:	add.w	lr, r6, #1
    6414:	lsls	r4, r3, #3
    6416:	add.w	lr, r0, lr, lsl #3
    641a:	add.w	r1, r9, r4
    641e:	mov	r5, r7
    6420:	cmp	r7, #0
    6422:	blt.w	67b6 <__kernel_rem_pio2+0x426>
    6426:	add	r3, sp, #104	; 0x68
    6428:	vldr	d7, [pc, #540]	; 6648 <__kernel_rem_pio2+0x2b8>
    642c:	add.w	r2, r3, r5, lsl #3
    6430:	adds	r2, #8
    6432:	mov	r3, r9
    6434:	vldmia	r3!, {d5}
    6438:	vldmdb	r2!, {d6}
    643c:	cmp	r3, r1
    643e:	vfma.f64	d7, d5, d6
    6442:	bne.n	6434 <__kernel_rem_pio2+0xa4>
    6444:	vstmia	r0!, {d7}
    6448:	cmp	r0, lr
    644a:	add.w	r5, r5, #1
    644e:	bne.n	6420 <__kernel_rem_pio2+0x90>
    6450:	add.w	r3, r6, #1073741824	; 0x40000000
    6454:	subs	r3, #2
    6456:	lsls	r3, r3, #2
    6458:	add	r2, sp, #24
    645a:	vldr	d9, [pc, #500]	; 6650 <__kernel_rem_pio2+0x2c0>
    645e:	vldr	d8, [pc, #504]	; 6658 <__kernel_rem_pio2+0x2c8>
    6462:	add.w	r8, r3, #4
    6466:	add	r3, r2
    6468:	add	r4, r9
    646a:	add	r8, r2
    646c:	str	r3, [sp, #12]
    646e:	mov	r5, r6
    6470:	str.w	fp, [sp, #16]
    6474:	add	r3, sp, #584	; 0x248
    6476:	add.w	r3, r3, r5, lsl #3
    647a:	cmp	r5, #0
    647c:	vldr	d0, [r3, #-160]	; 0xffffff60
    6480:	ble.n	64b2 <__kernel_rem_pio2+0x122>
    6482:	add	r1, sp, #424	; 0x1a8
    6484:	add.w	r3, r1, r5, lsl #3
    6488:	add	r2, sp, #20
    648a:	vmul.f64	d7, d0, d9
    648e:	vcvt.s32.f64	s14, d7
    6492:	vldmdb	r3!, {d6}
    6496:	vcvt.f64.s32	d7, s14
    649a:	vfms.f64	d0, d7, d8
    649e:	vcvt.s32.f64	s11, d0
    64a2:	cmp	r3, r1
    64a4:	vmov	r0, s11
    64a8:	vadd.f64	d0, d7, d6
    64ac:	str.w	r0, [r2, #4]!
    64b0:	bne.n	648a <__kernel_rem_pio2+0xfa>
    64b2:	mov	r0, sl
    64b4:	bl	7700 <scalbn>
    64b8:	vmov.f64	d10, d0
    64bc:	vmov.f64	d0, #64	; 0x3e000000  0.125
    64c0:	vmul.f64	d0, d10, d0
    64c4:	bl	74b0 <floor>
    64c8:	vmov.f64	d7, #32	; 0x41000000  8.0
    64cc:	vfms.f64	d10, d0, d7
    64d0:	vcvt.s32.f64	s15, d10
    64d4:	cmp.w	sl, #0
    64d8:	vmov	fp, s15
    64dc:	vcvt.f64.s32	d7, s15
    64e0:	vsub.f64	d10, d10, d7
    64e4:	ble.w	6780 <__kernel_rem_pio2+0x3f0>
    64e8:	add.w	lr, r5, #4294967295
    64ec:	add	r3, sp, #24
    64ee:	rsb	r2, sl, #24
    64f2:	ldr.w	r3, [r3, lr, lsl #2]
    64f6:	asr.w	r0, r3, r2
    64fa:	lsl.w	r2, r0, r2
    64fe:	add	r1, sp, #24
    6500:	subs	r3, r3, r2
    6502:	rsb	r2, sl, #23
    6506:	str.w	r3, [r1, lr, lsl #2]
    650a:	add	fp, r0
    650c:	asr.w	r1, r3, r2
    6510:	cmp	r1, #0
    6512:	ble.n	6588 <__kernel_rem_pio2+0x1f8>
    6514:	cmp	r5, #0
    6516:	add.w	fp, fp, #1
    651a:	ble.w	6966 <__kernel_rem_pio2+0x5d6>
    651e:	movs	r2, #0
    6520:	mov	r0, r2
    6522:	add.w	lr, sp, #20
    6526:	mov	ip, r1
    6528:	b.n	653c <__kernel_rem_pio2+0x1ac>
    652a:	rsb	r1, r3, #16777216	; 0x1000000
    652e:	cbz	r3, 6536 <__kernel_rem_pio2+0x1a6>
    6530:	str.w	r1, [lr]
    6534:	movs	r0, #1
    6536:	adds	r2, #1
    6538:	cmp	r5, r2
    653a:	ble.n	655a <__kernel_rem_pio2+0x1ca>
    653c:	ldr.w	r3, [lr, #4]!
    6540:	cmp	r0, #0
    6542:	beq.n	652a <__kernel_rem_pio2+0x19a>
    6544:	rsb	r3, r3, #16711935	; 0xff00ff
    6548:	adds	r2, #1
    654a:	add.w	r3, r3, #65280	; 0xff00
    654e:	cmp	r5, r2
    6550:	str.w	r3, [lr]
    6554:	mov.w	r0, #1
    6558:	bgt.n	653c <__kernel_rem_pio2+0x1ac>
    655a:	mov	r1, ip
    655c:	cmp.w	sl, #0
    6560:	ble.n	6584 <__kernel_rem_pio2+0x1f4>
    6562:	cmp.w	sl, #1
    6566:	beq.w	678e <__kernel_rem_pio2+0x3fe>
    656a:	cmp.w	sl, #2
    656e:	bne.n	6584 <__kernel_rem_pio2+0x1f4>
    6570:	subs	r2, r5, #1
    6572:	add	r3, sp, #24
    6574:	add.w	lr, sp, #24
    6578:	ldr.w	r3, [r3, r2, lsl #2]
    657c:	ubfx	r3, r3, #0, #22
    6580:	str.w	r3, [lr, r2, lsl #2]
    6584:	cmp	r1, #2
    6586:	beq.n	6668 <__kernel_rem_pio2+0x2d8>
    6588:	vcmp.f64	d10, #0.0
    658c:	vmrs	APSR_nzcv, fpscr
    6590:	bne.n	668c <__kernel_rem_pio2+0x2fc>
    6592:	add.w	lr, r5, #4294967295
    6596:	cmp	r6, lr
    6598:	bgt.n	65ba <__kernel_rem_pio2+0x22a>
    659a:	add.w	r2, r5, #1073741824	; 0x40000000
    659e:	subs	r2, #1
    65a0:	add	r3, sp, #24
    65a2:	add.w	r2, r3, r2, lsl #2
    65a6:	movs	r0, #0
    65a8:	ldr.w	r3, [r2], #-4
    65ac:	cmp	r2, r8
    65ae:	orr.w	r0, r0, r3
    65b2:	bne.n	65a8 <__kernel_rem_pio2+0x218>
    65b4:	cmp	r0, #0
    65b6:	bne.w	67e4 <__kernel_rem_pio2+0x454>
    65ba:	subs	r3, r6, #1
    65bc:	add	r2, sp, #24
    65be:	ldr.w	r3, [r2, r3, lsl #2]
    65c2:	cmp	r3, #0
    65c4:	bne.w	6960 <__kernel_rem_pio2+0x5d0>
    65c8:	ldr	r3, [sp, #12]
    65ca:	mov.w	lr, #1
    65ce:	ldr.w	r2, [r3], #-4
    65d2:	add.w	lr, lr, #1
    65d6:	cmp	r2, #0
    65d8:	beq.n	65ce <__kernel_rem_pio2+0x23e>
    65da:	add	lr, r5
    65dc:	adds	r3, r5, #1
    65de:	cmp	r3, lr
    65e0:	bgt.n	663e <__kernel_rem_pio2+0x2ae>
    65e2:	ldr	r2, [sp, #8]
    65e4:	adds	r0, r3, r2
    65e6:	ldr	r2, [sp, #4]
    65e8:	add.w	r0, r0, #1073741824	; 0x40000000
    65ec:	adds	r1, r2, r5
    65ee:	add.w	ip, lr, r2
    65f2:	ldr	r2, [sp, #660]	; 0x294
    65f4:	subs	r0, #1
    65f6:	add.w	r0, r2, r0, lsl #2
    65fa:	add	r2, sp, #104	; 0x68
    65fc:	add.w	r1, r2, r1, lsl #3
    6600:	add.w	ip, r2, ip, lsl #3
    6604:	add	r2, sp, #424	; 0x1a8
    6606:	add.w	r5, r2, r3, lsl #3
    660a:	ldr.w	r3, [r0, #4]!
    660e:	vmov	s14, r3
    6612:	vcvt.f64.s32	d7, s14
    6616:	cmp	r7, #0
    6618:	vstmia	r1!, {d7}
    661c:	vldr	d7, [pc, #40]	; 6648 <__kernel_rem_pio2+0x2b8>
    6620:	blt.n	6636 <__kernel_rem_pio2+0x2a6>
    6622:	mov	r3, r9
    6624:	mov	r2, r1
    6626:	vldmia	r3!, {d5}
    662a:	vldmdb	r2!, {d6}
    662e:	cmp	r3, r4
    6630:	vfma.f64	d7, d5, d6
    6634:	bne.n	6626 <__kernel_rem_pio2+0x296>
    6636:	cmp	r1, ip
    6638:	vstmia	r5!, {d7}
    663c:	bne.n	660a <__kernel_rem_pio2+0x27a>
    663e:	mov	r5, lr
    6640:	b.n	6474 <__kernel_rem_pio2+0xe4>
    6642:	nop
    6644:	nop.w
	...
    6654:	.word	0x3e700000
    6658:	.word	0x00000000
    665c:	.word	0x41700000
    6660:	.word	0x20000d4c
    6664:	.word	0x2aaaaaab
    6668:	vmov.f64	d0, #112	; 0x3f800000  1.0
    666c:	vsub.f64	d10, d0, d10
    6670:	cmp	r0, #0
    6672:	beq.n	6588 <__kernel_rem_pio2+0x1f8>
    6674:	mov	r0, sl
    6676:	str	r1, [sp, #20]
    6678:	bl	7700 <scalbn>
    667c:	vsub.f64	d10, d10, d0
    6680:	vcmp.f64	d10, #0.0
    6684:	vmrs	APSR_nzcv, fpscr
    6688:	ldr	r1, [sp, #20]
    668a:	beq.n	6592 <__kernel_rem_pio2+0x202>
    668c:	vmov.f64	d0, d10
    6690:	rsb	r0, sl, #0
    6694:	vmov	s22, fp
    6698:	mov	r9, r1
    669a:	ldr.w	fp, [sp, #16]
    669e:	bl	7700 <scalbn>
    66a2:	vldr	d6, [pc, #836]	; 69e8 <__kernel_rem_pio2+0x658>
    66a6:	vcmpe.f64	d0, d6
    66aa:	vmrs	APSR_nzcv, fpscr
    66ae:	blt.w	6996 <__kernel_rem_pio2+0x606>
    66b2:	vldr	d7, [pc, #828]	; 69f0 <__kernel_rem_pio2+0x660>
    66b6:	vmul.f64	d7, d0, d7
    66ba:	vcvt.s32.f64	s14, d7
    66be:	add	r1, sp, #24
    66c0:	vcvt.f64.s32	d5, s14
    66c4:	vfms.f64	d0, d5, d6
    66c8:	vcvt.s32.f64	s0, d0
    66cc:	adds	r3, r5, #1
    66ce:	vmov	r2, s0
    66d2:	str.w	r2, [r1, r5, lsl #2]
    66d6:	vmov	r2, s14
    66da:	str.w	r2, [r1, r3, lsl #2]
    66de:	add.w	sl, sl, #24
    66e2:	vmov.f64	d0, #112	; 0x3f800000  1.0
    66e6:	mov	r0, sl
    66e8:	str	r3, [sp, #4]
    66ea:	bl	7700 <scalbn>
    66ee:	ldr	r3, [sp, #4]
    66f0:	cmp	r3, #0
    66f2:	blt.w	69b2 <__kernel_rem_pio2+0x622>
    66f6:	add	r4, sp, #424	; 0x1a8
    66f8:	lsls	r7, r3, #3
    66fa:	add	r2, sp, #24
    66fc:	vldr	d6, [pc, #752]	; 69f0 <__kernel_rem_pio2+0x660>
    6700:	add.w	r2, r2, r3, lsl #2
    6704:	add.w	ip, r4, r7
    6708:	adds	r2, #4
    670a:	add.w	r0, ip, #8
    670e:	vldmdb	r2!, {s14}
    6712:	vcvt.f64.s32	d7, s14
    6716:	vmul.f64	d7, d7, d0
    671a:	vstmdb	r0!, {d7}
    671e:	vmul.f64	d0, d0, d6
    6722:	cmp	r0, r4
    6724:	bne.n	670e <__kernel_rem_pio2+0x37e>
    6726:	add.w	r8, sp, #416	; 0x1a0
    672a:	movs	r5, #0
    672c:	add.w	lr, sp, #264	; 0x108
    6730:	cmp	r6, #0
    6732:	blt.w	695a <__kernel_rem_pio2+0x5ca>
    6736:	ldr	r0, [pc, #720]	; (6a08 <__kernel_rem_pio2+0x678>)
    6738:	mov	r1, ip
    673a:	vldr	d6, [pc, #700]	; 69f8 <__kernel_rem_pio2+0x668>
    673e:	vldr	d7, [pc, #704]	; 6a00 <__kernel_rem_pio2+0x670>
    6742:	movs	r2, #0
    6744:	b.n	674e <__kernel_rem_pio2+0x3be>
    6746:	cmp	r5, r2
    6748:	blt.n	675c <__kernel_rem_pio2+0x3cc>
    674a:	vldmia	r0!, {d6}
    674e:	vldmia	r1!, {d5}
    6752:	adds	r2, #1
    6754:	cmp	r6, r2
    6756:	vfma.f64	d7, d5, d6
    675a:	bge.n	6746 <__kernel_rem_pio2+0x3b6>
    675c:	sub.w	ip, ip, #8
    6760:	add.w	r2, lr, r5, lsl #3
    6764:	cmp	ip, r8
    6766:	vstr	d7, [r2]
    676a:	add.w	r5, r5, #1
    676e:	bne.n	6730 <__kernel_rem_pio2+0x3a0>
    6770:	ldr	r2, [sp, #656]	; 0x290
    6772:	cmp	r2, #3
    6774:	bhi.w	68d2 <__kernel_rem_pio2+0x542>
    6778:	tbb	[pc, r2]
    677c:	.word	0x50b5b5dd
    6780:	bne.n	67a4 <__kernel_rem_pio2+0x414>
    6782:	subs	r3, r5, #1
    6784:	add	r2, sp, #24
    6786:	ldr.w	r1, [r2, r3, lsl #2]
    678a:	asrs	r1, r1, #23
    678c:	b.n	6510 <__kernel_rem_pio2+0x180>
    678e:	subs	r2, r5, #1
    6790:	add	r3, sp, #24
    6792:	add.w	lr, sp, #24
    6796:	ldr.w	r3, [r3, r2, lsl #2]
    679a:	ubfx	r3, r3, #0, #23
    679e:	str.w	r3, [lr, r2, lsl #2]
    67a2:	b.n	6584 <__kernel_rem_pio2+0x1f4>
    67a4:	vmov.f64	d7, #96	; 0x3f000000  0.5
    67a8:	vcmpe.f64	d10, d7
    67ac:	vmrs	APSR_nzcv, fpscr
    67b0:	bge.n	67ca <__kernel_rem_pio2+0x43a>
    67b2:	movs	r1, #0
    67b4:	b.n	6588 <__kernel_rem_pio2+0x1f8>
    67b6:	vldr	d7, [pc, #584]	; 6a00 <__kernel_rem_pio2+0x670>
    67ba:	vstmia	r0!, {d7}
    67be:	cmp	r0, lr
    67c0:	add.w	r5, r5, #1
    67c4:	bne.w	6420 <__kernel_rem_pio2+0x90>
    67c8:	b.n	6450 <__kernel_rem_pio2+0xc0>
    67ca:	cmp	r5, #0
    67cc:	add.w	fp, fp, #1
    67d0:	it	gt
    67d2:	movgt	r1, #2
    67d4:	bgt.w	651e <__kernel_rem_pio2+0x18e>
    67d8:	vmov.f64	d7, #112	; 0x3f800000  1.0
    67dc:	movs	r1, #2
    67de:	vsub.f64	d10, d7, d10
    67e2:	b.n	6588 <__kernel_rem_pio2+0x1f8>
    67e4:	add	r2, sp, #24
    67e6:	vmov	s22, fp
    67ea:	ldr.w	r2, [r2, lr, lsl #2]
    67ee:	ldr.w	fp, [sp, #16]
    67f2:	mov	r3, lr
    67f4:	mov	r9, r1
    67f6:	sub.w	sl, sl, #24
    67fa:	cmp	r2, #0
    67fc:	bne.w	66e2 <__kernel_rem_pio2+0x352>
    6800:	add.w	r2, lr, #1073741824	; 0x40000000
    6804:	subs	r2, #1
    6806:	add	r1, sp, #24
    6808:	add.w	r2, r1, r2, lsl #2
    680c:	ldr.w	r1, [r2], #-4
    6810:	subs	r3, #1
    6812:	sub.w	sl, sl, #24
    6816:	cmp	r1, #0
    6818:	beq.n	680c <__kernel_rem_pio2+0x47c>
    681a:	b.n	66e2 <__kernel_rem_pio2+0x352>
    681c:	cmp	r3, #0
    681e:	ble.w	69ac <__kernel_rem_pio2+0x61c>
    6822:	add.w	r2, r3, #536870912	; 0x20000000
    6826:	subs	r2, #1
    6828:	add.w	r4, lr, r7
    682c:	lsls	r0, r2, #3
    682e:	vldr	d7, [r4]
    6832:	add.w	r4, r0, #8
    6836:	adds	r0, #16
    6838:	add	r4, lr
    683a:	add	r0, lr
    683c:	add	r5, sp, #272	; 0x110
    683e:	vldmdb	r4!, {d6}
    6842:	vadd.f64	d5, d6, d7
    6846:	vsub.f64	d6, d6, d5
    684a:	vadd.f64	d7, d6, d7
    684e:	vstmdb	r0!, {d7}
    6852:	vmov.f64	d7, d5
    6856:	cmp	r0, r5
    6858:	vstr	d5, [r4]
    685c:	bne.n	683e <__kernel_rem_pio2+0x4ae>
    685e:	cmp	r3, #1
    6860:	ble.w	69ac <__kernel_rem_pio2+0x61c>
    6864:	lsls	r2, r2, #3
    6866:	add	r7, lr
    6868:	add.w	r0, r2, #16
    686c:	vldr	d7, [r7]
    6870:	adds	r2, #8
    6872:	add	r0, lr
    6874:	add.w	r3, lr, r2
    6878:	add	r4, sp, #280	; 0x118
    687a:	mov	r2, r0
    687c:	vldmdb	r3!, {d6}
    6880:	vadd.f64	d5, d7, d6
    6884:	vsub.f64	d6, d6, d5
    6888:	vadd.f64	d7, d6, d7
    688c:	vstmdb	r2!, {d7}
    6890:	vmov.f64	d7, d5
    6894:	cmp	r4, r2
    6896:	vstr	d5, [r3]
    689a:	bne.n	687c <__kernel_rem_pio2+0x4ec>
    689c:	vldr	d7, [pc, #352]	; 6a00 <__kernel_rem_pio2+0x670>
    68a0:	vldmdb	r0!, {d6}
    68a4:	cmp	r4, r0
    68a6:	vadd.f64	d7, d7, d6
    68aa:	bne.n	68a0 <__kernel_rem_pio2+0x510>
    68ac:	mov	r3, r9
    68ae:	cmp	r3, #0
    68b0:	beq.n	6980 <__kernel_rem_pio2+0x5f0>
    68b2:	vneg.f64	d7, d7
    68b6:	vldr	d5, [lr]
    68ba:	vldr	d6, [lr, #8]
    68be:	vneg.f64	d5, d5
    68c2:	vstr	d5, [fp]
    68c6:	vstr	d7, [fp, #16]
    68ca:	vneg.f64	d7, d6
    68ce:	vstr	d7, [fp, #8]
    68d2:	vmov	r3, s22
    68d6:	and.w	r0, r3, #7
    68da:	add.w	sp, sp, #588	; 0x24c
    68de:	vpop	{d8-d11}
    68e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    68e6:	vldr	d7, [pc, #280]	; 6a00 <__kernel_rem_pio2+0x670>
    68ea:	add.w	r2, r7, #8
    68ee:	add	r2, lr
    68f0:	vldmdb	r2!, {d6}
    68f4:	cmp	r2, lr
    68f6:	vadd.f64	d7, d7, d6
    68fa:	bne.n	68f0 <__kernel_rem_pio2+0x560>
    68fc:	mov	r2, r9
    68fe:	cbz	r2, 696a <__kernel_rem_pio2+0x5da>
    6900:	vneg.f64	d5, d7
    6904:	vldr	d6, [lr]
    6908:	cmp	r3, #0
    690a:	vstr	d5, [fp]
    690e:	vsub.f64	d7, d6, d7
    6912:	ble.n	692c <__kernel_rem_pio2+0x59c>
    6914:	add	r0, sp, #272	; 0x110
    6916:	movs	r2, #1
    6918:	vldmia	r0!, {d6}
    691c:	adds	r2, #1
    691e:	cmp	r3, r2
    6920:	vadd.f64	d7, d7, d6
    6924:	bge.n	6918 <__kernel_rem_pio2+0x588>
    6926:	mov	r3, r9
    6928:	cmp	r3, #0
    692a:	beq.n	68ce <__kernel_rem_pio2+0x53e>
    692c:	vneg.f64	d7, d7
    6930:	vstr	d7, [fp, #8]
    6934:	b.n	68d2 <__kernel_rem_pio2+0x542>
    6936:	vldr	d7, [pc, #200]	; 6a00 <__kernel_rem_pio2+0x670>
    693a:	adds	r7, #8
    693c:	add	lr, r7
    693e:	vldmdb	lr!, {d6}
    6942:	subs	r3, #1
    6944:	adds	r2, r3, #1
    6946:	vadd.f64	d7, d7, d6
    694a:	bne.n	693e <__kernel_rem_pio2+0x5ae>
    694c:	mov	r3, r9
    694e:	cbz	r3, 6954 <__kernel_rem_pio2+0x5c4>
    6950:	vneg.f64	d7, d7
    6954:	vstr	d7, [fp]
    6958:	b.n	68d2 <__kernel_rem_pio2+0x542>
    695a:	vldr	d7, [pc, #164]	; 6a00 <__kernel_rem_pio2+0x670>
    695e:	b.n	675c <__kernel_rem_pio2+0x3cc>
    6960:	mov.w	lr, #1
    6964:	b.n	65da <__kernel_rem_pio2+0x24a>
    6966:	movs	r0, #0
    6968:	b.n	655c <__kernel_rem_pio2+0x1cc>
    696a:	vldr	d6, [lr]
    696e:	cmp	r3, #0
    6970:	vstr	d7, [fp]
    6974:	vsub.f64	d7, d6, d7
    6978:	bgt.n	6914 <__kernel_rem_pio2+0x584>
    697a:	vstr	d7, [fp, #8]
    697e:	b.n	68d2 <__kernel_rem_pio2+0x542>
    6980:	ldrd	r0, r1, [lr]
    6984:	ldrd	r2, r3, [lr, #8]
    6988:	vstr	d7, [fp, #16]
    698c:	strd	r0, r1, [fp]
    6990:	strd	r2, r3, [fp, #8]
    6994:	b.n	68d2 <__kernel_rem_pio2+0x542>
    6996:	vcvt.s32.f64	s0, d0
    699a:	add	r1, sp, #24
    699c:	vmov	r2, s0
    69a0:	mov	r3, r5
    69a2:	str.w	r2, [r1, r5, lsl #2]
    69a6:	b.n	66e2 <__kernel_rem_pio2+0x352>
    69a8:	add.w	lr, sp, #264	; 0x108
    69ac:	vldr	d7, [pc, #80]	; 6a00 <__kernel_rem_pio2+0x670>
    69b0:	b.n	68ac <__kernel_rem_pio2+0x51c>
    69b2:	ldr	r2, [sp, #656]	; 0x290
    69b4:	cmp	r2, #3
    69b6:	bhi.n	68d2 <__kernel_rem_pio2+0x542>
    69b8:	add	r1, pc, #4	; (adr r1, 69c0 <__kernel_rem_pio2+0x630>)
    69ba:	ldr.w	pc, [r1, r2, lsl #2]
    69be:	nop
    69c0:	.word	0x000069e1
    69c4:	.word	0x000069d7
    69c8:	.word	0x000069d7
    69cc:	.word	0x000069a9
    69d0:	ldr	r3, [sp, #4]
    69d2:	lsls	r4, r3, #3
    69d4:	b.n	6450 <__kernel_rem_pio2+0xc0>
    69d6:	vldr	d7, [pc, #40]	; 6a00 <__kernel_rem_pio2+0x670>
    69da:	add.w	lr, sp, #264	; 0x108
    69de:	b.n	68fc <__kernel_rem_pio2+0x56c>
    69e0:	vldr	d7, [pc, #28]	; 6a00 <__kernel_rem_pio2+0x670>
    69e4:	b.n	694c <__kernel_rem_pio2+0x5bc>
    69e6:	nop
    69e8:	.word	0x00000000
    69ec:	.word	0x41700000
    69f0:	.word	0x00000000
    69f4:	.word	0x3e700000
    69f8:	.word	0x40000000
    69fc:	.word	0x3ff921fb
	...
    6a08:	.word	0x20000d68
    6a0c:	.word	0x00000000

00006a10 <__kernel_sin>:
    6a10:	vmov	r3, s1
    6a14:	bic.w	r3, r3, #2147483648	; 0x80000000
    6a18:	cmp.w	r3, #1044381696	; 0x3e400000
    6a1c:	bge.n	6a28 <__kernel_sin+0x18>
    6a1e:	vcvt.s32.f64	s15, d0
    6a22:	vmov	r3, s15
    6a26:	cbz	r3, 6a72 <__kernel_sin+0x62>
    6a28:	vmul.f64	d7, d0, d0
    6a2c:	vmul.f64	d4, d0, d7
    6a30:	vldr	d5, [pc, #84]	; 6a88 <__kernel_sin+0x78>
    6a34:	vldr	d6, [pc, #88]	; 6a90 <__kernel_sin+0x80>
    6a38:	vldr	d3, [pc, #92]	; 6a98 <__kernel_sin+0x88>
    6a3c:	vfma.f64	d6, d7, d5
    6a40:	vldr	d5, [pc, #92]	; 6aa0 <__kernel_sin+0x90>
    6a44:	vfma.f64	d3, d7, d6
    6a48:	vldr	d6, [pc, #92]	; 6aa8 <__kernel_sin+0x98>
    6a4c:	vfma.f64	d5, d7, d3
    6a50:	vfma.f64	d6, d7, d5
    6a54:	cbz	r0, 6a74 <__kernel_sin+0x64>
    6a56:	vnmul.f64	d6, d6, d4
    6a5a:	vmov.f64	d3, #96	; 0x3f000000  0.5
    6a5e:	vldr	d5, [pc, #80]	; 6ab0 <__kernel_sin+0xa0>
    6a62:	vfma.f64	d6, d1, d3
    6a66:	vfnms.f64	d1, d7, d6
    6a6a:	vfma.f64	d1, d4, d5
    6a6e:	vsub.f64	d0, d0, d1
    6a72:	bx	lr
    6a74:	vldr	d5, [pc, #64]	; 6ab8 <__kernel_sin+0xa8>
    6a78:	vfma.f64	d5, d7, d6
    6a7c:	vfma.f64	d0, d4, d5
    6a80:	bx	lr
    6a82:	nop
    6a84:	nop.w
    6a88:	.word	0x5acfd57c
    6a8c:	.word	0x3de5d93a
    6a90:	.word	0x8a2b9ceb
    6a94:	.word	0xbe5ae5e6
    6a98:	.word	0x57b1fe7d
    6a9c:	.word	0x3ec71de3
    6aa0:	.word	0x19c161d5
    6aa4:	.word	0xbf2a01a0
    6aa8:	.word	0x1110f8a6
    6aac:	.word	0x3f811111
    6ab0:	.word	0x55555549
    6ab4:	.word	0x3fc55555
    6ab8:	.word	0x55555549
    6abc:	.word	0xbfc55555

00006ac0 <__kernel_cosf>:
    6ac0:	vmov	r3, s0
    6ac4:	bic.w	r3, r3, #2147483648	; 0x80000000
    6ac8:	cmp.w	r3, #838860800	; 0x32000000
    6acc:	bge.n	6b28 <__kernel_cosf+0x68>
    6ace:	vcvt.s32.f32	s15, s0
    6ad2:	vmov	r3, s15
    6ad6:	cmp	r3, #0
    6ad8:	beq.n	6b9c <__kernel_cosf+0xdc>
    6ada:	vmul.f32	s14, s0, s0
    6ade:	vldr	s9, [pc, #196]	; 6ba4 <__kernel_cosf+0xe4>
    6ae2:	vldr	s10, [pc, #196]	; 6ba8 <__kernel_cosf+0xe8>
    6ae6:	vldr	s11, [pc, #196]	; 6bac <__kernel_cosf+0xec>
    6aea:	vldr	s12, [pc, #196]	; 6bb0 <__kernel_cosf+0xf0>
    6aee:	vldr	s15, [pc, #196]	; 6bb4 <__kernel_cosf+0xf4>
    6af2:	vldr	s13, [pc, #196]	; 6bb8 <__kernel_cosf+0xf8>
    6af6:	vfma.f32	s10, s14, s9
    6afa:	vfma.f32	s11, s14, s10
    6afe:	vfma.f32	s12, s14, s11
    6b02:	vfma.f32	s15, s14, s12
    6b06:	vfma.f32	s13, s14, s15
    6b0a:	vmul.f32	s13, s13, s14
    6b0e:	vnmul.f32	s1, s1, s0
    6b12:	vmov.f32	s12, #96	; 0x3f000000  0.5
    6b16:	vfma.f32	s1, s14, s13
    6b1a:	vmov.f32	s15, #112	; 0x3f800000  1.0
    6b1e:	vfnms.f32	s1, s14, s12
    6b22:	vsub.f32	s0, s15, s1
    6b26:	bx	lr
    6b28:	vmul.f32	s14, s0, s0
    6b2c:	vldr	s9, [pc, #116]	; 6ba4 <__kernel_cosf+0xe4>
    6b30:	vldr	s10, [pc, #116]	; 6ba8 <__kernel_cosf+0xe8>
    6b34:	vldr	s11, [pc, #116]	; 6bac <__kernel_cosf+0xec>
    6b38:	vldr	s12, [pc, #116]	; 6bb0 <__kernel_cosf+0xf0>
    6b3c:	vldr	s15, [pc, #116]	; 6bb4 <__kernel_cosf+0xf4>
    6b40:	vldr	s13, [pc, #116]	; 6bb8 <__kernel_cosf+0xf8>
    6b44:	ldr	r2, [pc, #116]	; (6bbc <__kernel_cosf+0xfc>)
    6b46:	vfma.f32	s10, s14, s9
    6b4a:	cmp	r3, r2
    6b4c:	vfma.f32	s11, s14, s10
    6b50:	vfma.f32	s12, s14, s11
    6b54:	vfma.f32	s15, s14, s12
    6b58:	vfma.f32	s13, s14, s15
    6b5c:	vmul.f32	s13, s13, s14
    6b60:	ble.n	6b0e <__kernel_cosf+0x4e>
    6b62:	ldr	r2, [pc, #92]	; (6bc0 <__kernel_cosf+0x100>)
    6b64:	cmp	r3, r2
    6b66:	bgt.n	6b92 <__kernel_cosf+0xd2>
    6b68:	add.w	r3, r3, #4278190080	; 0xff000000
    6b6c:	vmov	s15, r3
    6b70:	vmov.f32	s12, #112	; 0x3f800000  1.0
    6b74:	vsub.f32	s12, s12, s15
    6b78:	vnmul.f32	s1, s1, s0
    6b7c:	vmov.f32	s11, #96	; 0x3f000000  0.5
    6b80:	vfma.f32	s1, s14, s13
    6b84:	vfnms.f32	s15, s14, s11
    6b88:	vsub.f32	s15, s15, s1
    6b8c:	vsub.f32	s0, s12, s15
    6b90:	bx	lr
    6b92:	vmov.f32	s12, #103	; 0x3f380000  0.7187500
    6b96:	vmov.f32	s15, #82	; 0x3e900000  0.2812500
    6b9a:	b.n	6b78 <__kernel_cosf+0xb8>
    6b9c:	vmov.f32	s0, #112	; 0x3f800000  1.0
    6ba0:	bx	lr
    6ba2:	nop
    6ba4:	.word	0xad47d74e
    6ba8:	.word	0x310f74f6
    6bac:	.word	0xb493f27c
    6bb0:	.word	0x37d00d01
    6bb4:	.word	0xbab60b61
    6bb8:	.word	0x3d2aaaab
    6bbc:	.word	0x3e999999
    6bc0:	.word	0x3f480000

00006bc4 <__kernel_rem_pio2f>:
    6bc4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6bc8:	vpush	{d8-d9}
    6bcc:	sub	sp, #348	; 0x15c
    6bce:	subs	r7, r3, #1
    6bd0:	ldr	r4, [pc, #656]	; (6e64 <__kernel_rem_pio2f+0x2a0>)
    6bd2:	ldr	r5, [sp, #400]	; 0x190
    6bd4:	str	r3, [sp, #4]
    6bd6:	subs	r3, r2, #3
    6bd8:	it	mi
    6bda:	addmi	r3, r2, #4
    6bdc:	ldr.w	r6, [r4, r5, lsl #2]
    6be0:	asrs	r3, r3, #3
    6be2:	bic.w	r3, r3, r3, asr #31
    6be6:	add.w	sl, r3, #1
    6bea:	mov	fp, r1
    6bec:	adds	r1, r6, r7
    6bee:	str	r3, [sp, #8]
    6bf0:	mov	r9, r0
    6bf2:	sub.w	sl, r2, sl, lsl #3
    6bf6:	sub.w	r3, r3, r7
    6bfa:	bmi.n	6c26 <__kernel_rem_pio2f+0x62>
    6bfc:	add	r1, r3
    6bfe:	ldr	r0, [sp, #404]	; 0x194
    6c00:	adds	r1, #1
    6c02:	add	r2, sp, #104	; 0x68
    6c04:	cmp	r3, #0
    6c06:	itet	ge
    6c08:	ldrge.w	r4, [r0, r3, lsl #2]
    6c0c:	vldrlt	s15, [pc, #600]	; 6e68 <__kernel_rem_pio2f+0x2a4>
    6c10:	vmovge	s15, r4
    6c14:	add.w	r3, r3, #1
    6c18:	it	ge
    6c1a:	vcvtge.f32.s32	s15, s15
    6c1e:	cmp	r3, r1
    6c20:	vstmia	r2!, {s15}
    6c24:	bne.n	6c04 <__kernel_rem_pio2f+0x40>
    6c26:	cmp	r6, #0
    6c28:	blt.w	71d4 <__kernel_rem_pio2f+0x610>
    6c2c:	ldr	r3, [sp, #4]
    6c2e:	add	r0, sp, #264	; 0x108
    6c30:	add.w	lr, r6, #1
    6c34:	lsls	r4, r3, #2
    6c36:	add.w	lr, r0, lr, lsl #2
    6c3a:	add.w	r1, r9, r4
    6c3e:	mov	r5, r7
    6c40:	cmp	r7, #0
    6c42:	blt.w	6fc4 <__kernel_rem_pio2f+0x400>
    6c46:	add	r3, sp, #104	; 0x68
    6c48:	add.w	r2, r3, r5, lsl #2
    6c4c:	vldr	s15, [pc, #536]	; 6e68 <__kernel_rem_pio2f+0x2a4>
    6c50:	adds	r2, #4
    6c52:	mov	r3, r9
    6c54:	vldmia	r3!, {s13}
    6c58:	vldmdb	r2!, {s14}
    6c5c:	cmp	r3, r1
    6c5e:	vfma.f32	s15, s13, s14
    6c62:	bne.n	6c54 <__kernel_rem_pio2f+0x90>
    6c64:	vstmia	r0!, {s15}
    6c68:	cmp	r0, lr
    6c6a:	add.w	r5, r5, #1
    6c6e:	bne.n	6c40 <__kernel_rem_pio2f+0x7c>
    6c70:	add.w	r3, r6, #1073741824	; 0x40000000
    6c74:	subs	r3, #2
    6c76:	lsls	r3, r3, #2
    6c78:	add	r2, sp, #24
    6c7a:	add.w	r8, r3, #4
    6c7e:	vldr	s17, [pc, #496]	; 6e70 <__kernel_rem_pio2f+0x2ac>
    6c82:	vldr	s16, [pc, #488]	; 6e6c <__kernel_rem_pio2f+0x2a8>
    6c86:	str.w	fp, [sp, #16]
    6c8a:	add	r3, r2
    6c8c:	add	r4, r9
    6c8e:	add	r8, r2
    6c90:	str	r3, [sp, #12]
    6c92:	mov	r5, r6
    6c94:	add	r3, sp, #344	; 0x158
    6c96:	add.w	r3, r3, r5, lsl #2
    6c9a:	cmp	r5, #0
    6c9c:	vldr	s0, [r3, #-80]	; 0xffffffb0
    6ca0:	ble.n	6cd6 <__kernel_rem_pio2f+0x112>
    6ca2:	add	r1, sp, #264	; 0x108
    6ca4:	add.w	r3, r1, r5, lsl #2
    6ca8:	add	r2, sp, #20
    6caa:	vmul.f32	s15, s0, s17
    6cae:	vmov.f32	s14, s0
    6cb2:	vcvt.s32.f32	s15, s15
    6cb6:	vldmdb	r3!, {s13}
    6cba:	vcvt.f32.s32	s15, s15
    6cbe:	cmp	r3, r1
    6cc0:	vfms.f32	s14, s15, s16
    6cc4:	vadd.f32	s0, s15, s13
    6cc8:	vcvt.s32.f32	s14, s14
    6ccc:	vmov	r0, s14
    6cd0:	str.w	r0, [r2, #4]!
    6cd4:	bne.n	6caa <__kernel_rem_pio2f+0xe6>
    6cd6:	mov	r0, sl
    6cd8:	bl	7a74 <scalbnf>
    6cdc:	vmov.f32	s18, s0
    6ce0:	vmov.f32	s0, #64	; 0x3e000000  0.125
    6ce4:	vmul.f32	s0, s18, s0
    6ce8:	bl	79e4 <floorf>
    6cec:	vmov.f32	s15, #32	; 0x41000000  8.0
    6cf0:	vfms.f32	s18, s0, s15
    6cf4:	cmp.w	sl, #0
    6cf8:	vcvt.s32.f32	s15, s18
    6cfc:	vmov	fp, s15
    6d00:	vcvt.f32.s32	s15, s15
    6d04:	vsub.f32	s18, s18, s15
    6d08:	ble.w	6f8e <__kernel_rem_pio2f+0x3ca>
    6d0c:	add.w	lr, r5, #4294967295
    6d10:	add	r3, sp, #24
    6d12:	rsb	r2, sl, #8
    6d16:	ldr.w	r3, [r3, lr, lsl #2]
    6d1a:	asr.w	r0, r3, r2
    6d1e:	lsl.w	r2, r0, r2
    6d22:	add	r1, sp, #24
    6d24:	subs	r3, r3, r2
    6d26:	rsb	r2, sl, #7
    6d2a:	str.w	r3, [r1, lr, lsl #2]
    6d2e:	add	fp, r0
    6d30:	asr.w	r1, r3, r2
    6d34:	cmp	r1, #0
    6d36:	ble.n	6da8 <__kernel_rem_pio2f+0x1e4>
    6d38:	cmp	r5, #0
    6d3a:	add.w	fp, fp, #1
    6d3e:	ble.w	718a <__kernel_rem_pio2f+0x5c6>
    6d42:	movs	r2, #0
    6d44:	mov	r0, r2
    6d46:	add.w	lr, sp, #20
    6d4a:	mov	ip, r1
    6d4c:	b.n	6d60 <__kernel_rem_pio2f+0x19c>
    6d4e:	rsb	r1, r3, #256	; 0x100
    6d52:	cbz	r3, 6d5a <__kernel_rem_pio2f+0x196>
    6d54:	str.w	r1, [lr]
    6d58:	movs	r0, #1
    6d5a:	adds	r2, #1
    6d5c:	cmp	r5, r2
    6d5e:	ble.n	6d7a <__kernel_rem_pio2f+0x1b6>
    6d60:	ldr.w	r3, [lr, #4]!
    6d64:	cmp	r0, #0
    6d66:	beq.n	6d4e <__kernel_rem_pio2f+0x18a>
    6d68:	adds	r2, #1
    6d6a:	rsb	r3, r3, #255	; 0xff
    6d6e:	cmp	r5, r2
    6d70:	str.w	r3, [lr]
    6d74:	mov.w	r0, #1
    6d78:	bgt.n	6d60 <__kernel_rem_pio2f+0x19c>
    6d7a:	mov	r1, ip
    6d7c:	cmp.w	sl, #0
    6d80:	ble.n	6da4 <__kernel_rem_pio2f+0x1e0>
    6d82:	cmp.w	sl, #1
    6d86:	beq.w	6f9c <__kernel_rem_pio2f+0x3d8>
    6d8a:	cmp.w	sl, #2
    6d8e:	bne.n	6da4 <__kernel_rem_pio2f+0x1e0>
    6d90:	subs	r2, r5, #1
    6d92:	add	r3, sp, #24
    6d94:	add.w	lr, sp, #24
    6d98:	ldr.w	r3, [r3, r2, lsl #2]
    6d9c:	and.w	r3, r3, #63	; 0x3f
    6da0:	str.w	r3, [lr, r2, lsl #2]
    6da4:	cmp	r1, #2
    6da6:	beq.n	6e74 <__kernel_rem_pio2f+0x2b0>
    6da8:	vcmp.f32	s18, #0.0
    6dac:	vmrs	APSR_nzcv, fpscr
    6db0:	bne.n	6e98 <__kernel_rem_pio2f+0x2d4>
    6db2:	add.w	lr, r5, #4294967295
    6db6:	cmp	r6, lr
    6db8:	bgt.n	6dda <__kernel_rem_pio2f+0x216>
    6dba:	add.w	r2, r5, #1073741824	; 0x40000000
    6dbe:	subs	r2, #1
    6dc0:	add	r3, sp, #24
    6dc2:	add.w	r2, r3, r2, lsl #2
    6dc6:	movs	r0, #0
    6dc8:	ldr.w	r3, [r2], #-4
    6dcc:	cmp	r2, r8
    6dce:	orr.w	r0, r0, r3
    6dd2:	bne.n	6dc8 <__kernel_rem_pio2f+0x204>
    6dd4:	cmp	r0, #0
    6dd6:	bne.w	6ff2 <__kernel_rem_pio2f+0x42e>
    6dda:	subs	r3, r6, #1
    6ddc:	add	r2, sp, #24
    6dde:	ldr.w	r3, [r2, r3, lsl #2]
    6de2:	cmp	r3, #0
    6de4:	bne.w	7184 <__kernel_rem_pio2f+0x5c0>
    6de8:	ldr	r3, [sp, #12]
    6dea:	mov.w	lr, #1
    6dee:	ldr.w	r2, [r3], #-4
    6df2:	add.w	lr, lr, #1
    6df6:	cmp	r2, #0
    6df8:	beq.n	6dee <__kernel_rem_pio2f+0x22a>
    6dfa:	add	lr, r5
    6dfc:	adds	r3, r5, #1
    6dfe:	cmp	r3, lr
    6e00:	bgt.n	6e5e <__kernel_rem_pio2f+0x29a>
    6e02:	ldr	r2, [sp, #8]
    6e04:	adds	r0, r3, r2
    6e06:	ldr	r2, [sp, #4]
    6e08:	add.w	r0, r0, #1073741824	; 0x40000000
    6e0c:	adds	r1, r2, r5
    6e0e:	add.w	ip, lr, r2
    6e12:	ldr	r2, [sp, #404]	; 0x194
    6e14:	subs	r0, #1
    6e16:	add.w	r0, r2, r0, lsl #2
    6e1a:	add	r2, sp, #104	; 0x68
    6e1c:	add.w	r1, r2, r1, lsl #2
    6e20:	add.w	ip, r2, ip, lsl #2
    6e24:	add	r2, sp, #264	; 0x108
    6e26:	add.w	r5, r2, r3, lsl #2
    6e2a:	ldr.w	r3, [r0, #4]!
    6e2e:	vmov	s15, r3
    6e32:	vcvt.f32.s32	s15, s15
    6e36:	cmp	r7, #0
    6e38:	vstmia	r1!, {s15}
    6e3c:	vldr	s15, [pc, #40]	; 6e68 <__kernel_rem_pio2f+0x2a4>
    6e40:	blt.n	6e56 <__kernel_rem_pio2f+0x292>
    6e42:	mov	r3, r9
    6e44:	mov	r2, r1
    6e46:	vldmia	r3!, {s13}
    6e4a:	vldmdb	r2!, {s14}
    6e4e:	cmp	r3, r4
    6e50:	vfma.f32	s15, s13, s14
    6e54:	bne.n	6e46 <__kernel_rem_pio2f+0x282>
    6e56:	cmp	r1, ip
    6e58:	vstmia	r5!, {s15}
    6e5c:	bne.n	6e2a <__kernel_rem_pio2f+0x266>
    6e5e:	mov	r5, lr
    6e60:	b.n	6c94 <__kernel_rem_pio2f+0xd0>
    6e62:	nop
    6e64:	.word	0x20000da0
    6e68:	.word	0x00000000
    6e6c:	.word	0x43800000
    6e70:	.word	0x3b800000
    6e74:	vmov.f32	s0, #112	; 0x3f800000  1.0
    6e78:	vsub.f32	s18, s0, s18
    6e7c:	cmp	r0, #0
    6e7e:	beq.n	6da8 <__kernel_rem_pio2f+0x1e4>
    6e80:	mov	r0, sl
    6e82:	str	r1, [sp, #20]
    6e84:	bl	7a74 <scalbnf>
    6e88:	vsub.f32	s18, s18, s0
    6e8c:	ldr	r1, [sp, #20]
    6e8e:	vcmp.f32	s18, #0.0
    6e92:	vmrs	APSR_nzcv, fpscr
    6e96:	beq.n	6db2 <__kernel_rem_pio2f+0x1ee>
    6e98:	vmov.f32	s0, s18
    6e9c:	rsb	r0, sl, #0
    6ea0:	vmov	s19, fp
    6ea4:	mov	r8, r1
    6ea6:	ldr.w	fp, [sp, #16]
    6eaa:	bl	7a74 <scalbnf>
    6eae:	vldr	s14, [pc, #-68]	; 6e6c <__kernel_rem_pio2f+0x2a8>
    6eb2:	vcmpe.f32	s0, s14
    6eb6:	vmrs	APSR_nzcv, fpscr
    6eba:	blt.w	71a0 <__kernel_rem_pio2f+0x5dc>
    6ebe:	vldr	s15, [pc, #-80]	; 6e70 <__kernel_rem_pio2f+0x2ac>
    6ec2:	vmul.f32	s15, s0, s15
    6ec6:	add	r1, sp, #24
    6ec8:	vcvt.s32.f32	s15, s15
    6ecc:	adds	r3, r5, #1
    6ece:	vcvt.f32.s32	s15, s15
    6ed2:	add.w	sl, sl, #8
    6ed6:	vfms.f32	s0, s15, s14
    6eda:	vcvt.s32.f32	s15, s15
    6ede:	vcvt.s32.f32	s0, s0
    6ee2:	vmov	r2, s0
    6ee6:	str.w	r2, [r1, r5, lsl #2]
    6eea:	vmov	r2, s15
    6eee:	str.w	r2, [r1, r3, lsl #2]
    6ef2:	mov	r0, sl
    6ef4:	vmov.f32	s0, #112	; 0x3f800000  1.0
    6ef8:	str	r3, [sp, #4]
    6efa:	bl	7a74 <scalbnf>
    6efe:	ldr	r3, [sp, #4]
    6f00:	cmp	r3, #0
    6f02:	blt.w	71b8 <__kernel_rem_pio2f+0x5f4>
    6f06:	lsls	r7, r3, #2
    6f08:	add	r4, sp, #264	; 0x108
    6f0a:	add	r2, sp, #24
    6f0c:	adds	r0, r7, #4
    6f0e:	add.w	lr, r4, r7
    6f12:	vldr	s14, [pc, #-164]	; 6e70 <__kernel_rem_pio2f+0x2ac>
    6f16:	add	r0, r2
    6f18:	add.w	r2, lr, #4
    6f1c:	vldmdb	r0!, {s15}
    6f20:	vcvt.f32.s32	s15, s15
    6f24:	vmul.f32	s15, s15, s0
    6f28:	vmul.f32	s0, s0, s14
    6f2c:	vstmdb	r2!, {s15}
    6f30:	cmp	r2, r4
    6f32:	bne.n	6f1c <__kernel_rem_pio2f+0x358>
    6f34:	add.w	ip, sp, #260	; 0x104
    6f38:	movs	r5, #0
    6f3a:	cmp	r6, #0
    6f3c:	blt.w	7168 <__kernel_rem_pio2f+0x5a4>
    6f40:	ldr	r0, [pc, #676]	; (71e8 <__kernel_rem_pio2f+0x624>)
    6f42:	vldr	s14, [pc, #680]	; 71ec <__kernel_rem_pio2f+0x628>
    6f46:	vldr	s15, [pc, #680]	; 71f0 <__kernel_rem_pio2f+0x62c>
    6f4a:	mov	r1, lr
    6f4c:	movs	r2, #0
    6f4e:	b.n	6f5a <__kernel_rem_pio2f+0x396>
    6f50:	cmp	r5, r2
    6f52:	blt.n	6f68 <__kernel_rem_pio2f+0x3a4>
    6f54:	adds	r0, #4
    6f56:	vldr	s14, [r0]
    6f5a:	vldmia	r1!, {s13}
    6f5e:	adds	r2, #1
    6f60:	cmp	r6, r2
    6f62:	vfma.f32	s15, s13, s14
    6f66:	bge.n	6f50 <__kernel_rem_pio2f+0x38c>
    6f68:	sub.w	lr, lr, #4
    6f6c:	add	r2, sp, #344	; 0x158
    6f6e:	add.w	r2, r2, r5, lsl #2
    6f72:	cmp	ip, lr
    6f74:	vstr	s15, [r2, #-160]	; 0xffffff60
    6f78:	add.w	r5, r5, #1
    6f7c:	bne.n	6f3a <__kernel_rem_pio2f+0x376>
    6f7e:	ldr	r2, [sp, #400]	; 0x190
    6f80:	cmp	r2, #3
    6f82:	bhi.w	70e2 <__kernel_rem_pio2f+0x51e>
    6f86:	tbb	[pc, r2]
    6f8a:	.short	0xb5dc
    6f8c:	.short	0x50b5
    6f8e:	bne.n	6fb2 <__kernel_rem_pio2f+0x3ee>
    6f90:	subs	r3, r5, #1
    6f92:	add	r2, sp, #24
    6f94:	ldr.w	r1, [r2, r3, lsl #2]
    6f98:	asrs	r1, r1, #8
    6f9a:	b.n	6d34 <__kernel_rem_pio2f+0x170>
    6f9c:	subs	r2, r5, #1
    6f9e:	add	r3, sp, #24
    6fa0:	add.w	lr, sp, #24
    6fa4:	ldr.w	r3, [r3, r2, lsl #2]
    6fa8:	and.w	r3, r3, #127	; 0x7f
    6fac:	str.w	r3, [lr, r2, lsl #2]
    6fb0:	b.n	6da4 <__kernel_rem_pio2f+0x1e0>
    6fb2:	vmov.f32	s15, #96	; 0x3f000000  0.5
    6fb6:	vcmpe.f32	s18, s15
    6fba:	vmrs	APSR_nzcv, fpscr
    6fbe:	bge.n	6fd8 <__kernel_rem_pio2f+0x414>
    6fc0:	movs	r1, #0
    6fc2:	b.n	6da8 <__kernel_rem_pio2f+0x1e4>
    6fc4:	vldr	s15, [pc, #552]	; 71f0 <__kernel_rem_pio2f+0x62c>
    6fc8:	vstmia	r0!, {s15}
    6fcc:	cmp	r0, lr
    6fce:	add.w	r5, r5, #1
    6fd2:	bne.w	6c40 <__kernel_rem_pio2f+0x7c>
    6fd6:	b.n	6c70 <__kernel_rem_pio2f+0xac>
    6fd8:	cmp	r5, #0
    6fda:	add.w	fp, fp, #1
    6fde:	it	gt
    6fe0:	movgt	r1, #2
    6fe2:	bgt.w	6d42 <__kernel_rem_pio2f+0x17e>
    6fe6:	vmov.f32	s15, #112	; 0x3f800000  1.0
    6fea:	vsub.f32	s18, s15, s18
    6fee:	movs	r1, #2
    6ff0:	b.n	6da8 <__kernel_rem_pio2f+0x1e4>
    6ff2:	add	r2, sp, #24
    6ff4:	vmov	s19, fp
    6ff8:	ldr.w	r2, [r2, lr, lsl #2]
    6ffc:	ldr.w	fp, [sp, #16]
    7000:	mov	r3, lr
    7002:	mov	r8, r1
    7004:	sub.w	sl, sl, #8
    7008:	cmp	r2, #0
    700a:	bne.w	6ef2 <__kernel_rem_pio2f+0x32e>
    700e:	add.w	r2, lr, #1073741824	; 0x40000000
    7012:	subs	r2, #1
    7014:	add	r1, sp, #24
    7016:	add.w	r2, r1, r2, lsl #2
    701a:	ldr.w	r1, [r2], #-4
    701e:	subs	r3, #1
    7020:	sub.w	sl, sl, #8
    7024:	cmp	r1, #0
    7026:	beq.n	701a <__kernel_rem_pio2f+0x456>
    7028:	b.n	6ef2 <__kernel_rem_pio2f+0x32e>
    702a:	cmp	r3, #0
    702c:	ble.w	71b2 <__kernel_rem_pio2f+0x5ee>
    7030:	add.w	r2, r3, #1073741824	; 0x40000000
    7034:	subs	r2, #1
    7036:	lsls	r0, r2, #2
    7038:	add	r1, sp, #344	; 0x158
    703a:	adds	r5, r1, r7
    703c:	adds	r4, r0, #4
    703e:	add	r1, sp, #184	; 0xb8
    7040:	adds	r0, #8
    7042:	vldr	s14, [r5, #-160]	; 0xffffff60
    7046:	add	r4, r1
    7048:	add	r0, r1
    704a:	add	r5, sp, #188	; 0xbc
    704c:	vldmdb	r4!, {s15}
    7050:	vadd.f32	s13, s15, s14
    7054:	vsub.f32	s15, s15, s13
    7058:	vadd.f32	s15, s15, s14
    705c:	vmov.f32	s14, s13
    7060:	vstmdb	r0!, {s15}
    7064:	cmp	r0, r5
    7066:	vstr	s13, [r4]
    706a:	bne.n	704c <__kernel_rem_pio2f+0x488>
    706c:	cmp	r3, #1
    706e:	ble.w	71b2 <__kernel_rem_pio2f+0x5ee>
    7072:	lsls	r2, r2, #2
    7074:	add	r3, sp, #344	; 0x158
    7076:	add	r7, r3
    7078:	add.w	r0, r2, #8
    707c:	add	r3, sp, #184	; 0xb8
    707e:	add	r0, r3
    7080:	adds	r2, #4
    7082:	vldr	s14, [r7, #-160]	; 0xffffff60
    7086:	add	r3, r2
    7088:	add	r4, sp, #192	; 0xc0
    708a:	mov	r2, r0
    708c:	vldmdb	r3!, {s15}
    7090:	vadd.f32	s13, s14, s15
    7094:	vsub.f32	s15, s15, s13
    7098:	vadd.f32	s15, s15, s14
    709c:	vmov.f32	s14, s13
    70a0:	vstmdb	r2!, {s15}
    70a4:	cmp	r4, r2
    70a6:	vstr	s13, [r3]
    70aa:	bne.n	708c <__kernel_rem_pio2f+0x4c8>
    70ac:	vldr	s15, [pc, #320]	; 71f0 <__kernel_rem_pio2f+0x62c>
    70b0:	vldmdb	r0!, {s14}
    70b4:	cmp	r4, r0
    70b6:	vadd.f32	s15, s15, s14
    70ba:	bne.n	70b0 <__kernel_rem_pio2f+0x4ec>
    70bc:	mov	r3, r8
    70be:	cmp	r3, #0
    70c0:	beq.n	718e <__kernel_rem_pio2f+0x5ca>
    70c2:	vldr	s13, [sp, #184]	; 0xb8
    70c6:	vldr	s14, [sp, #188]	; 0xbc
    70ca:	vneg.f32	s15, s15
    70ce:	vneg.f32	s13, s13
    70d2:	vneg.f32	s14, s14
    70d6:	vstr	s15, [fp, #8]
    70da:	vstr	s13, [fp]
    70de:	vstr	s14, [fp, #4]
    70e2:	vmov	r3, s19
    70e6:	and.w	r0, r3, #7
    70ea:	add	sp, #348	; 0x15c
    70ec:	vpop	{d8-d9}
    70f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    70f4:	adds	r2, r7, #4
    70f6:	add	r0, sp, #184	; 0xb8
    70f8:	vldr	s15, [pc, #244]	; 71f0 <__kernel_rem_pio2f+0x62c>
    70fc:	add	r2, r0
    70fe:	vldmdb	r2!, {s14}
    7102:	cmp	r2, r0
    7104:	vadd.f32	s15, s15, s14
    7108:	bne.n	70fe <__kernel_rem_pio2f+0x53a>
    710a:	mov	r2, r8
    710c:	cbz	r2, 716e <__kernel_rem_pio2f+0x5aa>
    710e:	vldr	s13, [sp, #184]	; 0xb8
    7112:	vneg.f32	s14, s15
    7116:	cmp	r3, #0
    7118:	vsub.f32	s15, s13, s15
    711c:	vstr	s14, [fp]
    7120:	ble.n	7138 <__kernel_rem_pio2f+0x574>
    7122:	add	r0, sp, #188	; 0xbc
    7124:	movs	r2, #1
    7126:	vldmia	r0!, {s14}
    712a:	adds	r2, #1
    712c:	cmp	r3, r2
    712e:	vadd.f32	s15, s15, s14
    7132:	bge.n	7126 <__kernel_rem_pio2f+0x562>
    7134:	mov	r3, r8
    7136:	cbz	r3, 713c <__kernel_rem_pio2f+0x578>
    7138:	vneg.f32	s15, s15
    713c:	vstr	s15, [fp, #4]
    7140:	b.n	70e2 <__kernel_rem_pio2f+0x51e>
    7142:	add	r2, sp, #344	; 0x158
    7144:	add	r2, r7
    7146:	vldr	s15, [pc, #168]	; 71f0 <__kernel_rem_pio2f+0x62c>
    714a:	subs	r2, #156	; 0x9c
    714c:	vldmdb	r2!, {s14}
    7150:	subs	r3, #1
    7152:	adds	r1, r3, #1
    7154:	vadd.f32	s15, s15, s14
    7158:	bne.n	714c <__kernel_rem_pio2f+0x588>
    715a:	mov	r3, r8
    715c:	cbz	r3, 7162 <__kernel_rem_pio2f+0x59e>
    715e:	vneg.f32	s15, s15
    7162:	vstr	s15, [fp]
    7166:	b.n	70e2 <__kernel_rem_pio2f+0x51e>
    7168:	vldr	s15, [pc, #132]	; 71f0 <__kernel_rem_pio2f+0x62c>
    716c:	b.n	6f68 <__kernel_rem_pio2f+0x3a4>
    716e:	vldr	s14, [sp, #184]	; 0xb8
    7172:	vstr	s15, [fp]
    7176:	cmp	r3, #0
    7178:	vsub.f32	s15, s14, s15
    717c:	bgt.n	7122 <__kernel_rem_pio2f+0x55e>
    717e:	vstr	s15, [fp, #4]
    7182:	b.n	70e2 <__kernel_rem_pio2f+0x51e>
    7184:	mov.w	lr, #1
    7188:	b.n	6dfa <__kernel_rem_pio2f+0x236>
    718a:	movs	r0, #0
    718c:	b.n	6d7c <__kernel_rem_pio2f+0x1b8>
    718e:	ldr	r2, [sp, #184]	; 0xb8
    7190:	ldr	r3, [sp, #188]	; 0xbc
    7192:	vstr	s15, [fp, #8]
    7196:	str.w	r2, [fp]
    719a:	str.w	r3, [fp, #4]
    719e:	b.n	70e2 <__kernel_rem_pio2f+0x51e>
    71a0:	vcvt.s32.f32	s0, s0
    71a4:	add	r1, sp, #24
    71a6:	vmov	r2, s0
    71aa:	mov	r3, r5
    71ac:	str.w	r2, [r1, r5, lsl #2]
    71b0:	b.n	6ef2 <__kernel_rem_pio2f+0x32e>
    71b2:	vldr	s15, [pc, #60]	; 71f0 <__kernel_rem_pio2f+0x62c>
    71b6:	b.n	70bc <__kernel_rem_pio2f+0x4f8>
    71b8:	ldr	r2, [sp, #400]	; 0x190
    71ba:	cmp	r2, #3
    71bc:	bhi.n	70e2 <__kernel_rem_pio2f+0x51e>
    71be:	add	r1, pc, #4	; (adr r1, 71c4 <__kernel_rem_pio2f+0x600>)
    71c0:	ldr.w	pc, [r1, r2, lsl #2]
    71c4:	.word	0x000071e1
    71c8:	.word	0x000071db
    71cc:	.word	0x000071db
    71d0:	.word	0x000071b3
    71d4:	ldr	r3, [sp, #4]
    71d6:	lsls	r4, r3, #2
    71d8:	b.n	6c70 <__kernel_rem_pio2f+0xac>
    71da:	vldr	s15, [pc, #20]	; 71f0 <__kernel_rem_pio2f+0x62c>
    71de:	b.n	710a <__kernel_rem_pio2f+0x546>
    71e0:	vldr	s15, [pc, #12]	; 71f0 <__kernel_rem_pio2f+0x62c>
    71e4:	b.n	715a <__kernel_rem_pio2f+0x596>
    71e6:	nop
    71e8:	.word	0x20000dac
    71ec:	.word	0x3fc90000
    71f0:	.word	0x00000000

000071f4 <__kernel_sinf>:
    71f4:	vmov	r3, s0
    71f8:	bic.w	r3, r3, #2147483648	; 0x80000000
    71fc:	cmp.w	r3, #838860800	; 0x32000000
    7200:	bge.n	720c <__kernel_sinf+0x18>
    7202:	vcvt.s32.f32	s15, s0
    7206:	vmov	r3, s15
    720a:	cbz	r3, 7256 <__kernel_sinf+0x62>
    720c:	vmul.f32	s15, s0, s0
    7210:	vldr	s10, [pc, #84]	; 7268 <__kernel_sinf+0x74>
    7214:	vldr	s11, [pc, #84]	; 726c <__kernel_sinf+0x78>
    7218:	vldr	s12, [pc, #84]	; 7270 <__kernel_sinf+0x7c>
    721c:	vldr	s13, [pc, #84]	; 7274 <__kernel_sinf+0x80>
    7220:	vldr	s14, [pc, #84]	; 7278 <__kernel_sinf+0x84>
    7224:	vfma.f32	s11, s15, s10
    7228:	vmul.f32	s10, s0, s15
    722c:	vfma.f32	s12, s15, s11
    7230:	vfma.f32	s13, s15, s12
    7234:	vfma.f32	s14, s15, s13
    7238:	cbz	r0, 7258 <__kernel_sinf+0x64>
    723a:	vnmul.f32	s14, s14, s10
    723e:	vmov.f32	s13, #96	; 0x3f000000  0.5
    7242:	vfma.f32	s14, s1, s13
    7246:	vldr	s13, [pc, #52]	; 727c <__kernel_sinf+0x88>
    724a:	vfnms.f32	s1, s15, s14
    724e:	vfma.f32	s1, s10, s13
    7252:	vsub.f32	s0, s0, s1
    7256:	bx	lr
    7258:	vldr	s13, [pc, #36]	; 7280 <__kernel_sinf+0x8c>
    725c:	vfma.f32	s13, s15, s14
    7260:	vfma.f32	s0, s10, s13
    7264:	bx	lr
    7266:	nop
    7268:	.word	0x2f2ec9d3
    726c:	.word	0xb2d72f34
    7270:	.word	0x3638ef1b
    7274:	.word	0xb9500d01
    7278:	.word	0x3c088889
    727c:	.word	0x3e2aaaab
    7280:	.word	0xbe2aaaab
    7284:	.word	0x00000000

00007288 <atan>:
    7288:	push	{r3, r4, r5, lr}
    728a:	vmov.f64	d7, d0
    728e:	vmov	r5, s15
    7292:	ldr	r3, [pc, #476]	; (7470 <atan+0x1e8>)
    7294:	bic.w	r4, r5, #2147483648	; 0x80000000
    7298:	cmp	r4, r3
    729a:	ble.n	72ba <atan+0x32>
    729c:	ldr	r3, [pc, #468]	; (7474 <atan+0x1ec>)
    729e:	cmp	r4, r3
    72a0:	vmov	r2, s0
    72a4:	bgt.n	7360 <atan+0xd8>
    72a6:	beq.n	735c <atan+0xd4>
    72a8:	vldr	d7, [pc, #340]	; 7400 <atan+0x178>
    72ac:	vldr	d0, [pc, #344]	; 7408 <atan+0x180>
    72b0:	cmp	r5, #0
    72b2:	it	gt
    72b4:	vmovgt.f64	d0, d7
    72b8:	pop	{r3, r4, r5, pc}
    72ba:	ldr	r3, [pc, #444]	; (7478 <atan+0x1f0>)
    72bc:	cmp	r4, r3
    72be:	bgt.n	7382 <atan+0xfa>
    72c0:	sub.w	r3, r3, #29097984	; 0x1bc0000
    72c4:	cmp	r4, r3
    72c6:	ble.n	7366 <atan+0xde>
    72c8:	mov.w	r3, #4294967295
    72cc:	vldr	d2, [pc, #320]	; 7410 <atan+0x188>
    72d0:	vmul.f64	d4, d7, d7
    72d4:	vmul.f64	d6, d4, d4
    72d8:	vldr	d3, [pc, #316]	; 7418 <atan+0x190>
    72dc:	vldr	d5, [pc, #320]	; 7420 <atan+0x198>
    72e0:	vfma.f64	d3, d6, d2
    72e4:	vldr	d2, [pc, #320]	; 7428 <atan+0x1a0>
    72e8:	vfma.f64	d5, d6, d3
    72ec:	vldr	d3, [pc, #320]	; 7430 <atan+0x1a8>
    72f0:	vfma.f64	d2, d6, d5
    72f4:	vldr	d5, [pc, #320]	; 7438 <atan+0x1b0>
    72f8:	vfma.f64	d3, d6, d2
    72fc:	vldr	d1, [pc, #320]	; 7440 <atan+0x1b8>
    7300:	vfma.f64	d5, d6, d3
    7304:	vmul.f64	d5, d5, d4
    7308:	vldr	d2, [pc, #316]	; 7448 <atan+0x1c0>
    730c:	vldr	d4, [pc, #320]	; 7450 <atan+0x1c8>
    7310:	vldr	d3, [pc, #324]	; 7458 <atan+0x1d0>
    7314:	vfma.f64	d4, d6, d1
    7318:	vfma.f64	d2, d6, d4
    731c:	vldr	d4, [pc, #320]	; 7460 <atan+0x1d8>
    7320:	vfma.f64	d3, d6, d2
    7324:	adds	r2, r3, #1
    7326:	vfma.f64	d4, d6, d3
    732a:	vmul.f64	d6, d4, d6
    732e:	beq.n	73b2 <atan+0x12a>
    7330:	vadd.f64	d5, d5, d6
    7334:	ldr	r2, [pc, #324]	; (747c <atan+0x1f4>)
    7336:	ldr	r1, [pc, #328]	; (7480 <atan+0x1f8>)
    7338:	lsls	r3, r3, #3
    733a:	add	r2, r3
    733c:	add	r3, r1
    733e:	vldr	d6, [r2]
    7342:	vldr	d0, [r3]
    7346:	vfnms.f64	d6, d7, d5
    734a:	vsub.f64	d7, d6, d7
    734e:	cmp	r5, #0
    7350:	vsub.f64	d7, d0, d7
    7354:	blt.n	73ac <atan+0x124>
    7356:	vmov.f64	d0, d7
    735a:	pop	{r3, r4, r5, pc}
    735c:	cmp	r2, #0
    735e:	beq.n	72a8 <atan+0x20>
    7360:	vadd.f64	d0, d7, d7
    7364:	pop	{r3, r4, r5, pc}
    7366:	vldr	d6, [pc, #256]	; 7468 <atan+0x1e0>
    736a:	vmov.f64	d5, #112	; 0x3f800000  1.0
    736e:	vadd.f64	d6, d0, d6
    7372:	vcmpe.f64	d6, d5
    7376:	vmrs	APSR_nzcv, fpscr
    737a:	ble.n	72c8 <atan+0x40>
    737c:	vmov.f64	d0, d7
    7380:	pop	{r3, r4, r5, pc}
    7382:	bl	748c <fabs>
    7386:	ldr	r3, [pc, #252]	; (7484 <atan+0x1fc>)
    7388:	cmp	r4, r3
    738a:	bgt.n	73c0 <atan+0x138>
    738c:	sub.w	r3, r3, #851968	; 0xd0000
    7390:	cmp	r4, r3
    7392:	bgt.n	73ea <atan+0x162>
    7394:	vmov.f64	d7, #0	; 0x40000000  2.0
    7398:	vmov.f64	d6, #240	; 0xbf800000 -1.0
    739c:	vadd.f64	d5, d0, d7
    73a0:	vfma.f64	d6, d0, d7
    73a4:	movs	r3, #0
    73a6:	vdiv.f64	d7, d6, d5
    73aa:	b.n	72cc <atan+0x44>
    73ac:	vneg.f64	d0, d7
    73b0:	pop	{r3, r4, r5, pc}
    73b2:	vadd.f64	d6, d5, d6
    73b6:	vfms.f64	d7, d7, d6
    73ba:	vmov.f64	d0, d7
    73be:	pop	{r3, r4, r5, pc}
    73c0:	ldr	r3, [pc, #196]	; (7488 <atan+0x200>)
    73c2:	cmp	r4, r3
    73c4:	bgt.n	73de <atan+0x156>
    73c6:	vmov.f64	d7, #120	; 0x3fc00000  1.5
    73ca:	vmov.f64	d6, #112	; 0x3f800000  1.0
    73ce:	vsub.f64	d5, d0, d7
    73d2:	vfma.f64	d6, d0, d7
    73d6:	movs	r3, #2
    73d8:	vdiv.f64	d7, d5, d6
    73dc:	b.n	72cc <atan+0x44>
    73de:	vmov.f64	d6, #240	; 0xbf800000 -1.0
    73e2:	movs	r3, #3
    73e4:	vdiv.f64	d7, d6, d0
    73e8:	b.n	72cc <atan+0x44>
    73ea:	vmov.f64	d7, #112	; 0x3f800000  1.0
    73ee:	movs	r3, #1
    73f0:	vsub.f64	d6, d0, d7
    73f4:	vadd.f64	d0, d0, d7
    73f8:	vdiv.f64	d7, d6, d0
    73fc:	b.n	72cc <atan+0x44>
    73fe:	nop
    7400:	.word	0x54442d18
    7404:	.word	0x3ff921fb
    7408:	.word	0x54442d18
    740c:	.word	0xbff921fb
    7410:	.word	0xe322da11
    7414:	.word	0x3f90ad3a
    7418:	.word	0x24760deb
    741c:	.word	0x3fa97b4b
    7420:	.word	0xa0d03d51
    7424:	.word	0x3fb10d66
    7428:	.word	0xc54c206e
    742c:	.word	0x3fb745cd
    7430:	.word	0x920083ff
    7434:	.word	0x3fc24924
    7438:	.word	0x5555550d
    743c:	.word	0x3fd55555
    7440:	.word	0x2c6a6c2f
    7444:	.word	0xbfa2b444
    7448:	.word	0xaf749a6d
    744c:	.word	0xbfb3b0f2
    7450:	.word	0x52defd9a
    7454:	.word	0xbfadde2d
    7458:	.word	0xfe231671
    745c:	.word	0xbfbc71c6
    7460:	.word	0x9998ebc4
    7464:	.word	0xbfc99999
    7468:	.word	0x8800759c
    746c:	.word	0x7e37e43c
    7470:	.word	0x440fffff
    7474:	.word	0x7ff00000
    7478:	.word	0x3fdbffff
    747c:	.word	0x20000dd8
    7480:	.word	0x20000df8
    7484:	.word	0x3ff2ffff
    7488:	.word	0x40037fff

0000748c <fabs>:
    748c:	vmov	r2, r3, d0
    7490:	bic.w	r3, r3, #2147483648	; 0x80000000
    7494:	vmov	d0, r2, r3
    7498:	bx	lr
    749a:	nop

0000749c <finite>:
    749c:	vmov	r3, s1
    74a0:	orr.w	r0, r3, #2147483648	; 0x80000000
    74a4:	add.w	r0, r0, #1048576	; 0x100000
    74a8:	lsrs	r0, r0, #31
    74aa:	bx	lr
    74ac:	movs	r0, r0
	...

000074b0 <floor>:
    74b0:	push	{r4, r5, r6}
    74b2:	sub	sp, #12
    74b4:	vstr	d0, [sp]
    74b8:	ldr	r1, [sp, #4]
    74ba:	ldr	r4, [sp, #0]
    74bc:	ubfx	r2, r1, #20, #11
    74c0:	subw	r3, r2, #1023	; 0x3ff
    74c4:	cmp	r3, #19
    74c6:	mov	r5, r1
    74c8:	mov	r0, r4
    74ca:	bgt.n	750a <floor+0x5a>
    74cc:	cmp	r3, #0
    74ce:	blt.n	7558 <floor+0xa8>
    74d0:	ldr	r2, [pc, #236]	; (75c0 <floor+0x110>)
    74d2:	asrs	r2, r3
    74d4:	and.w	r6, r1, r2
    74d8:	orrs	r4, r6
    74da:	beq.n	7514 <floor+0x64>
    74dc:	vldr	d7, [pc, #216]	; 75b8 <floor+0x108>
    74e0:	vldr	d6, [sp]
    74e4:	vadd.f64	d7, d6, d7
    74e8:	vcmpe.f64	d7, #0.0
    74ec:	vmrs	APSR_nzcv, fpscr
    74f0:	ble.n	74fc <floor+0x4c>
    74f2:	cmp	r1, #0
    74f4:	blt.n	757e <floor+0xce>
    74f6:	bic.w	r1, r5, r2
    74fa:	movs	r0, #0
    74fc:	mov	r3, r1
    74fe:	mov	r2, r0
    7500:	vmov	d0, r2, r3
    7504:	add	sp, #12
    7506:	pop	{r4, r5, r6}
    7508:	bx	lr
    750a:	cmp	r3, #51	; 0x33
    750c:	ble.n	751e <floor+0x6e>
    750e:	cmp.w	r3, #1024	; 0x400
    7512:	beq.n	7574 <floor+0xc4>
    7514:	vldr	d0, [sp]
    7518:	add	sp, #12
    751a:	pop	{r4, r5, r6}
    751c:	bx	lr
    751e:	subw	r2, r2, #1043	; 0x413
    7522:	mov.w	r4, #4294967295
    7526:	lsr.w	r2, r4, r2
    752a:	tst	r0, r2
    752c:	beq.n	7514 <floor+0x64>
    752e:	vldr	d7, [pc, #136]	; 75b8 <floor+0x108>
    7532:	vldr	d6, [sp]
    7536:	vadd.f64	d7, d6, d7
    753a:	vcmpe.f64	d7, #0.0
    753e:	vmrs	APSR_nzcv, fpscr
    7542:	ble.n	74fc <floor+0x4c>
    7544:	cmp	r1, #0
    7546:	blt.n	758a <floor+0xda>
    7548:	mov	r1, r5
    754a:	bic.w	r0, r0, r2
    754e:	mov	r3, r1
    7550:	mov	r2, r0
    7552:	vmov	d0, r2, r3
    7556:	b.n	7504 <floor+0x54>
    7558:	vldr	d7, [pc, #92]	; 75b8 <floor+0x108>
    755c:	vadd.f64	d7, d0, d7
    7560:	vcmpe.f64	d7, #0.0
    7564:	vmrs	APSR_nzcv, fpscr
    7568:	ble.n	74fc <floor+0x4c>
    756a:	cmp	r1, #0
    756c:	blt.n	75a0 <floor+0xf0>
    756e:	movs	r0, #0
    7570:	mov	r1, r0
    7572:	b.n	74fc <floor+0x4c>
    7574:	vldr	d7, [sp]
    7578:	vadd.f64	d0, d7, d7
    757c:	b.n	7518 <floor+0x68>
    757e:	mov.w	r1, #1048576	; 0x100000
    7582:	asr.w	r3, r1, r3
    7586:	add	r5, r3
    7588:	b.n	74f6 <floor+0x46>
    758a:	cmp	r3, #20
    758c:	beq.n	75b0 <floor+0x100>
    758e:	movs	r1, #1
    7590:	rsb	r3, r3, #52	; 0x34
    7594:	lsl.w	r3, r1, r3
    7598:	adds	r0, r3, r0
    759a:	it	cs
    759c:	addcs	r5, r5, r1
    759e:	b.n	7548 <floor+0x98>
    75a0:	bic.w	r2, r1, #2147483648	; 0x80000000
    75a4:	ldr	r3, [pc, #28]	; (75c4 <floor+0x114>)
    75a6:	orrs	r2, r4
    75a8:	it	ne
    75aa:	movne	r1, r3
    75ac:	movs	r0, #0
    75ae:	b.n	74fc <floor+0x4c>
    75b0:	adds	r5, #1
    75b2:	b.n	7548 <floor+0x98>
    75b4:	nop.w
    75b8:	.word	0x8800759c
    75bc:	.word	0x7e37e43c
    75c0:	.word	0x000fffff
    75c4:	.word	0xbff00000

000075c8 <matherr>:
    75c8:	movs	r0, #0
    75ca:	bx	lr
    75cc:	movs	r0, r0
	...

000075d0 <nan>:
    75d0:	vldr	d0, [pc, #4]	; 75d8 <nan+0x8>
    75d4:	bx	lr
    75d6:	nop
    75d8:	.word	0x00000000
    75dc:	.word	0x7ff80000

000075e0 <rint>:
    75e0:	push	{r4, r5, r6, r7}
    75e2:	vmov	r2, r3, d0
    75e6:	ubfx	r5, r3, #20, #11
    75ea:	subw	r0, r5, #1023	; 0x3ff
    75ee:	cmp	r0, #19
    75f0:	sub	sp, #16
    75f2:	mov	r1, r3
    75f4:	mov.w	r7, r3, lsr #31
    75f8:	vmov	r4, s0
    75fc:	bgt.n	7658 <rint+0x78>
    75fe:	cmp	r0, #0
    7600:	blt.n	7692 <rint+0xb2>
    7602:	ldr	r5, [pc, #240]	; (76f4 <rint+0x114>)
    7604:	asrs	r5, r0
    7606:	and.w	r6, r3, r5
    760a:	orrs	r6, r2
    760c:	beq.n	7662 <rint+0x82>
    760e:	lsrs	r5, r5, #1
    7610:	ands	r3, r5
    7612:	orrs	r4, r3
    7614:	beq.n	7630 <rint+0x50>
    7616:	mov.w	r3, #262144	; 0x40000
    761a:	cmp	r0, #19
    761c:	bic.w	r5, r1, r5
    7620:	asr.w	r1, r3, r0
    7624:	orr.w	r1, r1, r5
    7628:	ite	eq
    762a:	moveq.w	r4, #2147483648	; 0x80000000
    762e:	movne	r4, #0
    7630:	ldr	r0, [pc, #196]	; (76f8 <rint+0x118>)
    7632:	add.w	r7, r0, r7, lsl #3
    7636:	vldr	d0, [r7]
    763a:	mov	r3, r1
    763c:	mov	r2, r4
    763e:	vmov	d7, r2, r3
    7642:	vadd.f64	d7, d7, d0
    7646:	vstr	d7, [sp, #8]
    764a:	vldr	d7, [sp, #8]
    764e:	vsub.f64	d0, d7, d0
    7652:	add	sp, #16
    7654:	pop	{r4, r5, r6, r7}
    7656:	bx	lr
    7658:	cmp	r0, #51	; 0x33
    765a:	ble.n	766c <rint+0x8c>
    765c:	cmp.w	r0, #1024	; 0x400
    7660:	beq.n	76ec <rint+0x10c>
    7662:	vmov	d0, r2, r3
    7666:	add	sp, #16
    7668:	pop	{r4, r5, r6, r7}
    766a:	bx	lr
    766c:	subw	r5, r5, #1043	; 0x413
    7670:	mov.w	r0, #4294967295
    7674:	lsrs	r0, r5
    7676:	tst	r2, r0
    7678:	beq.n	7662 <rint+0x82>
    767a:	lsrs	r0, r0, #1
    767c:	tst	r2, r0
    767e:	beq.n	7630 <rint+0x50>
    7680:	mov.w	r3, #1073741824	; 0x40000000
    7684:	bic.w	r0, r4, r0
    7688:	asr.w	r5, r3, r5
    768c:	orr.w	r4, r5, r0
    7690:	b.n	7630 <rint+0x50>
    7692:	bic.w	r0, r3, #2147483648	; 0x80000000
    7696:	orrs	r0, r2
    7698:	vmov	r6, s0
    769c:	beq.n	7662 <rint+0x82>
    769e:	ubfx	r0, r3, #0, #20
    76a2:	orrs	r6, r0
    76a4:	negs	r0, r6
    76a6:	orrs	r6, r0
    76a8:	ldr	r0, [pc, #76]	; (76f8 <rint+0x118>)
    76aa:	lsrs	r1, r3, #17
    76ac:	lsrs	r6, r6, #12
    76ae:	lsls	r1, r1, #17
    76b0:	and.w	r6, r6, #524288	; 0x80000
    76b4:	add.w	r0, r0, r7, lsl #3
    76b8:	orr.w	r3, r6, r1
    76bc:	vldr	d6, [r0]
    76c0:	vmov	d7, r2, r3
    76c4:	vadd.f64	d7, d7, d6
    76c8:	vstr	d7, [sp, #8]
    76cc:	vldr	d7, [sp, #8]
    76d0:	vsub.f64	d7, d7, d6
    76d4:	vstr	d7, [sp]
    76d8:	ldr	r1, [sp, #4]
    76da:	ldrd	r2, r3, [sp]
    76de:	bic.w	r1, r1, #2147483648	; 0x80000000
    76e2:	orr.w	r3, r1, r7, lsl #31
    76e6:	vmov	d0, r2, r3
    76ea:	b.n	7666 <rint+0x86>
    76ec:	vadd.f64	d0, d0, d0
    76f0:	b.n	7666 <rint+0x86>
    76f2:	nop
    76f4:	.word	0x000fffff
    76f8:	.word	0x20000e18
    76fc:	.word	0x00000000

00007700 <scalbn>:
    7700:	push	{r4, lr}
    7702:	vpush	{d8}
    7706:	sub	sp, #8
    7708:	vstr	d0, [sp]
    770c:	ldr	r3, [sp, #4]
    770e:	ldr	r1, [sp, #0]
    7710:	ubfx	r2, r3, #20, #11
    7714:	cbnz	r2, 7762 <scalbn+0x62>
    7716:	bic.w	r3, r3, #2147483648	; 0x80000000
    771a:	orrs	r3, r1
    771c:	beq.n	777a <scalbn+0x7a>
    771e:	vldr	d7, [pc, #216]	; 77f8 <scalbn+0xf8>
    7722:	ldr	r2, [pc, #244]	; (7818 <scalbn+0x118>)
    7724:	vmul.f64	d7, d0, d7
    7728:	cmp	r0, r2
    772a:	vstr	d7, [sp]
    772e:	ldr	r3, [sp, #4]
    7730:	blt.n	7786 <scalbn+0x86>
    7732:	ubfx	r2, r3, #20, #11
    7736:	subs	r2, #54	; 0x36
    7738:	adds	r4, r0, r2
    773a:	movw	r2, #2046	; 0x7fe
    773e:	cmp	r4, r2
    7740:	bgt.n	77a4 <scalbn+0xa4>
    7742:	cmp	r4, #0
    7744:	ble.n	7796 <scalbn+0x96>
    7746:	bic.w	r1, r3, #2139095040	; 0x7f800000
    774a:	ldrd	r2, r3, [sp]
    774e:	bic.w	r1, r1, #7340032	; 0x700000
    7752:	orr.w	r3, r1, r4, lsl #20
    7756:	vmov	d0, r2, r3
    775a:	add	sp, #8
    775c:	vpop	{d8}
    7760:	pop	{r4, pc}
    7762:	movw	r1, #2047	; 0x7ff
    7766:	cmp	r2, r1
    7768:	bne.n	7738 <scalbn+0x38>
    776a:	vldr	d7, [sp]
    776e:	vadd.f64	d0, d7, d7
    7772:	add	sp, #8
    7774:	vpop	{d8}
    7778:	pop	{r4, pc}
    777a:	vldr	d0, [sp]
    777e:	add	sp, #8
    7780:	vpop	{d8}
    7784:	pop	{r4, pc}
    7786:	vldr	d0, [pc, #120]	; 7800 <scalbn+0x100>
    778a:	vmul.f64	d0, d7, d0
    778e:	add	sp, #8
    7790:	vpop	{d8}
    7794:	pop	{r4, pc}
    7796:	cmn.w	r4, #53	; 0x35
    779a:	bge.n	77c0 <scalbn+0xc0>
    779c:	movw	r3, #50000	; 0xc350
    77a0:	cmp	r0, r3
    77a2:	ble.n	77e0 <scalbn+0xe0>
    77a4:	vldr	d8, [pc, #96]	; 7808 <scalbn+0x108>
    77a8:	vldr	d1, [sp]
    77ac:	vmov.f64	d0, d8
    77b0:	bl	7b44 <copysign>
    77b4:	vmul.f64	d0, d0, d8
    77b8:	add	sp, #8
    77ba:	vpop	{d8}
    77be:	pop	{r4, pc}
    77c0:	bic.w	r1, r3, #2139095040	; 0x7f800000
    77c4:	ldrd	r2, r3, [sp]
    77c8:	bic.w	r1, r1, #7340032	; 0x700000
    77cc:	adds	r4, #54	; 0x36
    77ce:	orr.w	r3, r1, r4, lsl #20
    77d2:	vldr	d0, [pc, #60]	; 7810 <scalbn+0x110>
    77d6:	vmov	d7, r2, r3
    77da:	vmul.f64	d0, d7, d0
    77de:	b.n	775a <scalbn+0x5a>
    77e0:	vldr	d8, [pc, #28]	; 7800 <scalbn+0x100>
    77e4:	vldr	d1, [sp]
    77e8:	vmov.f64	d0, d8
    77ec:	bl	7b44 <copysign>
    77f0:	vmul.f64	d0, d0, d8
    77f4:	b.n	775a <scalbn+0x5a>
    77f6:	nop
    77f8:	.word	0x00000000
    77fc:	.word	0x43500000
    7800:	.word	0xc2f8f359
    7804:	.word	0x01a56e1f
    7808:	.word	0x8800759c
    780c:	.word	0x7e37e43c
    7810:	.word	0x00000000
    7814:	.word	0x3c900000
    7818:	.word	0xffff3cb0

0000781c <atanf>:
    781c:	push	{r3, r4, r5, lr}
    781e:	vmov	r5, s0
    7822:	bic.w	r4, r5, #2147483648	; 0x80000000
    7826:	cmp.w	r4, #1350565888	; 0x50800000
    782a:	vmov.f32	s15, s0
    782e:	blt.n	7848 <atanf+0x2c>
    7830:	cmp.w	r4, #2139095040	; 0x7f800000
    7834:	bgt.n	78e8 <atanf+0xcc>
    7836:	vldr	s15, [pc, #336]	; 7988 <atanf+0x16c>
    783a:	vldr	s0, [pc, #336]	; 798c <atanf+0x170>
    783e:	cmp	r5, #0
    7840:	it	gt
    7842:	vmovgt.f32	s0, s15
    7846:	pop	{r3, r4, r5, pc}
    7848:	ldr	r3, [pc, #324]	; (7990 <atanf+0x174>)
    784a:	cmp	r4, r3
    784c:	bgt.n	790a <atanf+0xee>
    784e:	cmp.w	r4, #822083584	; 0x31000000
    7852:	blt.n	78ee <atanf+0xd2>
    7854:	mov.w	r3, #4294967295
    7858:	vmul.f32	s11, s15, s15
    785c:	vldr	s2, [pc, #308]	; 7994 <atanf+0x178>
    7860:	vldr	s4, [pc, #308]	; 7998 <atanf+0x17c>
    7864:	vldr	s6, [pc, #308]	; 799c <atanf+0x180>
    7868:	vldr	s3, [pc, #308]	; 79a0 <atanf+0x184>
    786c:	vldr	s5, [pc, #308]	; 79a4 <atanf+0x188>
    7870:	vldr	s8, [pc, #308]	; 79a8 <atanf+0x18c>
    7874:	vldr	s7, [pc, #308]	; 79ac <atanf+0x190>
    7878:	vldr	s10, [pc, #308]	; 79b0 <atanf+0x194>
    787c:	vldr	s9, [pc, #308]	; 79b4 <atanf+0x198>
    7880:	vldr	s12, [pc, #308]	; 79b8 <atanf+0x19c>
    7884:	vldr	s13, [pc, #308]	; 79bc <atanf+0x1a0>
    7888:	vmul.f32	s14, s11, s11
    788c:	adds	r2, r3, #1
    788e:	vfma.f32	s4, s14, s2
    7892:	vfma.f32	s5, s14, s3
    7896:	vfma.f32	s6, s14, s4
    789a:	vfma.f32	s7, s14, s5
    789e:	vfma.f32	s8, s14, s6
    78a2:	vfma.f32	s9, s14, s7
    78a6:	vfma.f32	s10, s14, s8
    78aa:	vfma.f32	s13, s14, s9
    78ae:	vfma.f32	s12, s14, s10
    78b2:	vmul.f32	s14, s13, s14
    78b6:	vmul.f32	s13, s12, s11
    78ba:	beq.n	793a <atanf+0x11e>
    78bc:	ldr	r2, [pc, #256]	; (79c0 <atanf+0x1a4>)
    78be:	ldr	r1, [pc, #260]	; (79c4 <atanf+0x1a8>)
    78c0:	lsls	r3, r3, #2
    78c2:	add	r2, r3
    78c4:	vadd.f32	s13, s13, s14
    78c8:	vldr	s14, [r2]
    78cc:	vfnms.f32	s14, s15, s13
    78d0:	add	r3, r1
    78d2:	cmp	r5, #0
    78d4:	vldr	s0, [r3]
    78d8:	vsub.f32	s15, s14, s15
    78dc:	vsub.f32	s15, s0, s15
    78e0:	blt.n	7934 <atanf+0x118>
    78e2:	vmov.f32	s0, s15
    78e6:	pop	{r3, r4, r5, pc}
    78e8:	vadd.f32	s0, s0, s0
    78ec:	pop	{r3, r4, r5, pc}
    78ee:	vldr	s14, [pc, #216]	; 79c8 <atanf+0x1ac>
    78f2:	vadd.f32	s14, s0, s14
    78f6:	vmov.f32	s13, #112	; 0x3f800000  1.0
    78fa:	vcmpe.f32	s14, s13
    78fe:	vmrs	APSR_nzcv, fpscr
    7902:	ble.n	7854 <atanf+0x38>
    7904:	vmov.f32	s0, s15
    7908:	pop	{r3, r4, r5, pc}
    790a:	bl	79d4 <fabsf>
    790e:	ldr	r3, [pc, #188]	; (79cc <atanf+0x1b0>)
    7910:	cmp	r4, r3
    7912:	bgt.n	7948 <atanf+0x12c>
    7914:	sub.w	r3, r3, #6815744	; 0x680000
    7918:	cmp	r4, r3
    791a:	bgt.n	7972 <atanf+0x156>
    791c:	vmov.f32	s15, #0	; 0x40000000  2.0
    7920:	vmov.f32	s14, #240	; 0xbf800000 -1.0
    7924:	vfma.f32	s14, s0, s15
    7928:	movs	r3, #0
    792a:	vadd.f32	s0, s0, s15
    792e:	vdiv.f32	s15, s14, s0
    7932:	b.n	7858 <atanf+0x3c>
    7934:	vneg.f32	s0, s15
    7938:	pop	{r3, r4, r5, pc}
    793a:	vadd.f32	s13, s13, s14
    793e:	vfms.f32	s15, s15, s13
    7942:	vmov.f32	s0, s15
    7946:	pop	{r3, r4, r5, pc}
    7948:	ldr	r3, [pc, #132]	; (79d0 <atanf+0x1b4>)
    794a:	cmp	r4, r3
    794c:	bgt.n	7966 <atanf+0x14a>
    794e:	vmov.f32	s15, #120	; 0x3fc00000  1.5
    7952:	vmov.f32	s14, #112	; 0x3f800000  1.0
    7956:	vfma.f32	s14, s0, s15
    795a:	movs	r3, #2
    795c:	vsub.f32	s0, s0, s15
    7960:	vdiv.f32	s15, s0, s14
    7964:	b.n	7858 <atanf+0x3c>
    7966:	vmov.f32	s14, #240	; 0xbf800000 -1.0
    796a:	vdiv.f32	s15, s14, s0
    796e:	movs	r3, #3
    7970:	b.n	7858 <atanf+0x3c>
    7972:	vmov.f32	s15, #112	; 0x3f800000  1.0
    7976:	vsub.f32	s14, s0, s15
    797a:	vadd.f32	s0, s0, s15
    797e:	movs	r3, #1
    7980:	vdiv.f32	s15, s14, s0
    7984:	b.n	7858 <atanf+0x3c>
    7986:	nop
    7988:	.word	0x3fc90fdb
    798c:	.word	0xbfc90fdb
    7990:	.word	0x3edfffff
    7994:	.word	0x3c8569d7
    7998:	.word	0x3d4bda59
    799c:	.word	0x3d886b35
    79a0:	.word	0xbd15a221
    79a4:	.word	0xbd6ef16b
    79a8:	.word	0x3dba2e6e
    79ac:	.word	0xbd9d8795
    79b0:	.word	0x3e124925
    79b4:	.word	0xbde38e38
    79b8:	.word	0x3eaaaaab
    79bc:	.word	0xbe4ccccd
    79c0:	.word	0x20000e28
    79c4:	.word	0x20000e38
    79c8:	.word	0x7149f2ca
    79cc:	.word	0x3f97ffff
    79d0:	.word	0x401bffff

000079d4 <fabsf>:
    79d4:	vmov	r3, s0
    79d8:	bic.w	r3, r3, #2147483648	; 0x80000000
    79dc:	vmov	s0, r3
    79e0:	bx	lr
    79e2:	nop

000079e4 <floorf>:
    79e4:	vmov	r2, s0
    79e8:	bic.w	r1, r2, #2147483648	; 0x80000000
    79ec:	lsrs	r3, r1, #23
    79ee:	subs	r3, #127	; 0x7f
    79f0:	cmp	r3, #22
    79f2:	bgt.n	7a24 <floorf+0x40>
    79f4:	cmp	r3, #0
    79f6:	vmov	r0, s0
    79fa:	blt.n	7a30 <floorf+0x4c>
    79fc:	ldr	r1, [pc, #104]	; (7a68 <floorf+0x84>)
    79fe:	asrs	r1, r3
    7a00:	tst	r2, r1
    7a02:	beq.n	7a4a <floorf+0x66>
    7a04:	vldr	s15, [pc, #100]	; 7a6c <floorf+0x88>
    7a08:	vadd.f32	s15, s0, s15
    7a0c:	vcmpe.f32	s15, #0.0
    7a10:	vmrs	APSR_nzcv, fpscr
    7a14:	ble.n	7a4a <floorf+0x66>
    7a16:	cmp	r2, #0
    7a18:	blt.n	7a4c <floorf+0x68>
    7a1a:	bic.w	r3, r0, r1
    7a1e:	vmov	s0, r3
    7a22:	bx	lr
    7a24:	cmp.w	r1, #2139095040	; 0x7f800000
    7a28:	bcc.n	7a4a <floorf+0x66>
    7a2a:	vadd.f32	s0, s0, s0
    7a2e:	bx	lr
    7a30:	vldr	s15, [pc, #56]	; 7a6c <floorf+0x88>
    7a34:	vadd.f32	s15, s0, s15
    7a38:	vcmpe.f32	s15, #0.0
    7a3c:	vmrs	APSR_nzcv, fpscr
    7a40:	ble.n	7a4a <floorf+0x66>
    7a42:	cmp	r2, #0
    7a44:	blt.n	7a58 <floorf+0x74>
    7a46:	vldr	s0, [pc, #40]	; 7a70 <floorf+0x8c>
    7a4a:	bx	lr
    7a4c:	mov.w	r2, #8388608	; 0x800000
    7a50:	asr.w	r3, r2, r3
    7a54:	add	r0, r3
    7a56:	b.n	7a1a <floorf+0x36>
    7a58:	cmp	r1, #0
    7a5a:	vmov.f32	s15, #240	; 0xbf800000 -1.0
    7a5e:	it	ne
    7a60:	vmovne.f32	s0, s15
    7a64:	bx	lr
    7a66:	nop
    7a68:	.word	0x007fffff
    7a6c:	.word	0x7149f2ca
    7a70:	.word	0x00000000

00007a74 <scalbnf>:
    7a74:	push	{r3, lr}
    7a76:	vmov	r3, s0
    7a7a:	bics.w	r2, r3, #2147483648	; 0x80000000
    7a7e:	vpush	{d8}
    7a82:	beq.n	7aa8 <scalbnf+0x34>
    7a84:	cmp.w	r2, #2139095040	; 0x7f800000
    7a88:	bcs.n	7aae <scalbnf+0x3a>
    7a8a:	cmp.w	r2, #8388608	; 0x800000
    7a8e:	bcc.n	7ab8 <scalbnf+0x44>
    7a90:	lsrs	r2, r2, #23
    7a92:	add	r2, r0
    7a94:	cmp	r2, #254	; 0xfe
    7a96:	bgt.n	7af6 <scalbnf+0x82>
    7a98:	cmp	r2, #0
    7a9a:	ble.n	7ad2 <scalbnf+0x5e>
    7a9c:	bic.w	r3, r3, #2139095040	; 0x7f800000
    7aa0:	orr.w	r3, r3, r2, lsl #23
    7aa4:	vmov	s0, r3
    7aa8:	vpop	{d8}
    7aac:	pop	{r3, pc}
    7aae:	vpop	{d8}
    7ab2:	vadd.f32	s0, s0, s0
    7ab6:	pop	{r3, pc}
    7ab8:	ldr	r3, [pc, #116]	; (7b30 <scalbnf+0xbc>)
    7aba:	vldr	s15, [pc, #120]	; 7b34 <scalbnf+0xc0>
    7abe:	cmp	r0, r3
    7ac0:	vmul.f32	s0, s0, s15
    7ac4:	blt.n	7b0c <scalbnf+0x98>
    7ac6:	vmov	r3, s0
    7aca:	ubfx	r2, r3, #23, #8
    7ace:	subs	r2, #25
    7ad0:	b.n	7a92 <scalbnf+0x1e>
    7ad2:	cmn.w	r2, #22
    7ad6:	bge.n	7b16 <scalbnf+0xa2>
    7ad8:	movw	r3, #50000	; 0xc350
    7adc:	cmp	r0, r3
    7ade:	bgt.n	7af6 <scalbnf+0x82>
    7ae0:	vldr	s16, [pc, #84]	; 7b38 <scalbnf+0xc4>
    7ae4:	vmov.f32	s1, s0
    7ae8:	vmov.f32	s0, s16
    7aec:	bl	7b60 <copysignf>
    7af0:	vmul.f32	s0, s0, s16
    7af4:	b.n	7aa8 <scalbnf+0x34>
    7af6:	vldr	s16, [pc, #68]	; 7b3c <scalbnf+0xc8>
    7afa:	vmov.f32	s1, s0
    7afe:	vmov.f32	s0, s16
    7b02:	bl	7b60 <copysignf>
    7b06:	vmul.f32	s0, s0, s16
    7b0a:	b.n	7aa8 <scalbnf+0x34>
    7b0c:	vldr	s1, [pc, #40]	; 7b38 <scalbnf+0xc4>
    7b10:	vmul.f32	s0, s0, s1
    7b14:	b.n	7aa8 <scalbnf+0x34>
    7b16:	adds	r2, #25
    7b18:	bic.w	r3, r3, #2139095040	; 0x7f800000
    7b1c:	orr.w	r3, r3, r2, lsl #23
    7b20:	vldr	s15, [pc, #28]	; 7b40 <scalbnf+0xcc>
    7b24:	vmov	s0, r3
    7b28:	vmul.f32	s0, s0, s15
    7b2c:	b.n	7aa8 <scalbnf+0x34>
    7b2e:	nop
    7b30:	.word	0xffff3cb0
    7b34:	.word	0x4c000000
    7b38:	.word	0x0da24260
    7b3c:	.word	0x7149f2ca
    7b40:	.word	0x33000000

00007b44 <copysign>:
    7b44:	vmov	r2, r3, d0
    7b48:	vmov	r0, s3
    7b4c:	bic.w	r1, r3, #2147483648	; 0x80000000
    7b50:	and.w	r0, r0, #2147483648	; 0x80000000
    7b54:	orr.w	r3, r1, r0
    7b58:	vmov	d0, r2, r3
    7b5c:	bx	lr
    7b5e:	nop

00007b60 <copysignf>:
    7b60:	vmov	r3, s0
    7b64:	bic.w	r2, r3, #2147483648	; 0x80000000
    7b68:	vmov	r3, s1
    7b6c:	and.w	r3, r3, #2147483648	; 0x80000000
    7b70:	orrs	r3, r2
    7b72:	vmov	s0, r3
    7b76:	bx	lr

00007b78 <__assert_func>:
    7b78:	push	{lr}
    7b7a:	ldr	r4, [pc, #40]	; (7ba4 <__assert_func+0x2c>)
    7b7c:	ldr	r6, [r4, #0]
    7b7e:	mov	r5, r0
    7b80:	sub	sp, #20
    7b82:	mov	r4, r3
    7b84:	ldr	r0, [r6, #12]
    7b86:	cbz	r2, 7b9e <__assert_func+0x26>
    7b88:	ldr	r3, [pc, #28]	; (7ba8 <__assert_func+0x30>)
    7b8a:	str	r2, [sp, #8]
    7b8c:	stmia.w	sp, {r1, r3}
    7b90:	mov	r2, r4
    7b92:	mov	r3, r5
    7b94:	ldr	r1, [pc, #20]	; (7bac <__assert_func+0x34>)
    7b96:	bl	7bc0 <fiprintf>
    7b9a:	bl	2ca8 <abort>
    7b9e:	ldr	r3, [pc, #16]	; (7bb0 <__assert_func+0x38>)
    7ba0:	mov	r2, r3
    7ba2:	b.n	7b8a <__assert_func+0x12>
    7ba4:	.word	0x20001450
    7ba8:	.word	0x20000e48
    7bac:	.word	0x20000e58
    7bb0:	.word	0x20000e54

00007bb4 <__errno>:
    7bb4:	ldr	r3, [pc, #4]	; (7bbc <__errno+0x8>)
    7bb6:	ldr	r0, [r3, #0]
    7bb8:	bx	lr
    7bba:	nop
    7bbc:	.word	0x20001450

00007bc0 <fiprintf>:
    7bc0:	push	{r1, r2, r3}
    7bc2:	push	{r4, lr}
    7bc4:	sub	sp, #12
    7bc6:	add	r3, sp, #20
    7bc8:	ldr	r4, [pc, #24]	; (7be4 <fiprintf+0x24>)
    7bca:	ldr.w	r2, [r3], #4
    7bce:	str	r3, [sp, #4]
    7bd0:	mov	r1, r0
    7bd2:	ldr	r0, [r4, #0]
    7bd4:	bl	88d4 <_vfiprintf_r>
    7bd8:	add	sp, #12
    7bda:	ldmia.w	sp!, {r4, lr}
    7bde:	add	sp, #12
    7be0:	bx	lr
    7be2:	nop
    7be4:	.word	0x20001450

00007be8 <__libc_init_array>:
    7be8:	push	{r4, r5, r6, lr}
    7bea:	ldr	r6, [pc, #60]	; (7c28 <__libc_init_array+0x40>)
    7bec:	ldr	r5, [pc, #60]	; (7c2c <__libc_init_array+0x44>)
    7bee:	subs	r6, r6, r5
    7bf0:	asrs	r6, r6, #2
    7bf2:	it	ne
    7bf4:	movne	r4, #0
    7bf6:	beq.n	7c04 <__libc_init_array+0x1c>
    7bf8:	adds	r4, #1
    7bfa:	ldr.w	r3, [r5], #4
    7bfe:	blx	r3
    7c00:	cmp	r6, r4
    7c02:	bne.n	7bf8 <__libc_init_array+0x10>
    7c04:	ldr	r6, [pc, #40]	; (7c30 <__libc_init_array+0x48>)
    7c06:	ldr	r5, [pc, #44]	; (7c34 <__libc_init_array+0x4c>)
    7c08:	subs	r6, r6, r5
    7c0a:	bl	a8d0 <___init_veneer>
    7c0e:	asrs	r6, r6, #2
    7c10:	it	ne
    7c12:	movne	r4, #0
    7c14:	beq.n	7c24 <__libc_init_array+0x3c>
    7c16:	adds	r4, #1
    7c18:	ldr.w	r3, [r5], #4
    7c1c:	blx	r3
    7c1e:	cmp	r6, r4
    7c20:	bne.n	7c16 <__libc_init_array+0x2e>
    7c22:	pop	{r4, r5, r6, pc}
    7c24:	pop	{r4, r5, r6, pc}
    7c26:	nop
    7c28:	.word	0x60001740
    7c2c:	.word	0x60001740
    7c30:	.word	0x60001748
    7c34:	.word	0x60001740

00007c38 <__locale_mb_cur_max>:
    7c38:	ldr	r3, [pc, #16]	; (7c4c <__locale_mb_cur_max+0x14>)
    7c3a:	ldr	r2, [pc, #20]	; (7c50 <__locale_mb_cur_max+0x18>)
    7c3c:	ldr	r3, [r3, #0]
    7c3e:	ldr	r3, [r3, #52]	; 0x34
    7c40:	cmp	r3, #0
    7c42:	it	eq
    7c44:	moveq	r3, r2
    7c46:	ldrb.w	r0, [r3, #296]	; 0x128
    7c4a:	bx	lr
    7c4c:	.word	0x20001450
    7c50:	.word	0x20001454

00007c54 <_malloc_r>:
    7c54:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7c58:	add.w	r5, r1, #11
    7c5c:	cmp	r5, #22
    7c5e:	sub	sp, #12
    7c60:	mov	r6, r0
    7c62:	bls.w	7da4 <_malloc_r+0x150>
    7c66:	bics.w	r5, r5, #7
    7c6a:	bmi.w	7dec <_malloc_r+0x198>
    7c6e:	cmp	r1, r5
    7c70:	bhi.w	7dec <_malloc_r+0x198>
    7c74:	bl	8354 <__malloc_lock>
    7c78:	cmp.w	r5, #504	; 0x1f8
    7c7c:	bcc.w	81b8 <_malloc_r+0x564>
    7c80:	lsrs	r3, r5, #9
    7c82:	beq.w	7dfa <_malloc_r+0x1a6>
    7c86:	cmp	r3, #4
    7c88:	bhi.w	7f92 <_malloc_r+0x33e>
    7c8c:	lsrs	r0, r5, #6
    7c8e:	add.w	lr, r0, #57	; 0x39
    7c92:	mov.w	r3, lr, lsl #1
    7c96:	adds	r0, #56	; 0x38
    7c98:	ldr	r7, [pc, #784]	; (7fac <_malloc_r+0x358>)
    7c9a:	add.w	r3, r7, r3, lsl #2
    7c9e:	sub.w	r1, r3, #8
    7ca2:	ldr	r4, [r3, #4]
    7ca4:	cmp	r1, r4
    7ca6:	bne.n	7cb8 <_malloc_r+0x64>
    7ca8:	b.n	7e04 <_malloc_r+0x1b0>
    7caa:	cmp	r2, #0
    7cac:	bge.w	7e08 <_malloc_r+0x1b4>
    7cb0:	ldr	r4, [r4, #12]
    7cb2:	cmp	r1, r4
    7cb4:	beq.w	7e04 <_malloc_r+0x1b0>
    7cb8:	ldr	r3, [r4, #4]
    7cba:	bic.w	r3, r3, #3
    7cbe:	subs	r2, r3, r5
    7cc0:	cmp	r2, #15
    7cc2:	ble.n	7caa <_malloc_r+0x56>
    7cc4:	ldr	r1, [pc, #740]	; (7fac <_malloc_r+0x358>)
    7cc6:	ldr	r4, [r7, #16]
    7cc8:	add.w	lr, r1, #8
    7ccc:	cmp	r4, lr
    7cce:	beq.w	8038 <_malloc_r+0x3e4>
    7cd2:	ldr	r3, [r4, #4]
    7cd4:	bic.w	r3, r3, #3
    7cd8:	subs	r2, r3, r5
    7cda:	cmp	r2, #15
    7cdc:	bgt.w	8012 <_malloc_r+0x3be>
    7ce0:	cmp	r2, #0
    7ce2:	str.w	lr, [r1, #20]
    7ce6:	str.w	lr, [r1, #16]
    7cea:	bge.w	7e2a <_malloc_r+0x1d6>
    7cee:	cmp.w	r3, #512	; 0x200
    7cf2:	bcs.w	7fc4 <_malloc_r+0x370>
    7cf6:	lsrs	r3, r3, #3
    7cf8:	add.w	ip, r3, #1
    7cfc:	movs	r2, #1
    7cfe:	asrs	r3, r3, #2
    7d00:	lsl.w	r3, r2, r3
    7d04:	ldr	r2, [r1, #4]
    7d06:	ldr.w	r8, [r1, ip, lsl #3]
    7d0a:	str.w	r8, [r4, #8]
    7d0e:	add.w	r9, r1, ip, lsl #3
    7d12:	orrs	r2, r3
    7d14:	sub.w	r3, r9, #8
    7d18:	str	r3, [r4, #12]
    7d1a:	str	r2, [r1, #4]
    7d1c:	str.w	r4, [r1, ip, lsl #3]
    7d20:	str.w	r4, [r8, #12]
    7d24:	asrs	r3, r0, #2
    7d26:	movs	r4, #1
    7d28:	lsls	r4, r3
    7d2a:	cmp	r4, r2
    7d2c:	bhi.w	7e44 <_malloc_r+0x1f0>
    7d30:	tst	r4, r2
    7d32:	bne.n	7d42 <_malloc_r+0xee>
    7d34:	bic.w	r0, r0, #3
    7d38:	lsls	r4, r4, #1
    7d3a:	tst	r4, r2
    7d3c:	add.w	r0, r0, #4
    7d40:	beq.n	7d38 <_malloc_r+0xe4>
    7d42:	add.w	r9, r7, r0, lsl #3
    7d46:	mov	ip, r9
    7d48:	mov	r8, r0
    7d4a:	ldr.w	r1, [ip, #12]
    7d4e:	cmp	ip, r1
    7d50:	bne.n	7d62 <_malloc_r+0x10e>
    7d52:	b.n	803c <_malloc_r+0x3e8>
    7d54:	cmp	r2, #0
    7d56:	bge.w	805c <_malloc_r+0x408>
    7d5a:	ldr	r1, [r1, #12]
    7d5c:	cmp	ip, r1
    7d5e:	beq.w	803c <_malloc_r+0x3e8>
    7d62:	ldr	r3, [r1, #4]
    7d64:	bic.w	r3, r3, #3
    7d68:	subs	r2, r3, r5
    7d6a:	cmp	r2, #15
    7d6c:	ble.n	7d54 <_malloc_r+0x100>
    7d6e:	mov	r4, r1
    7d70:	ldr.w	ip, [r1, #12]
    7d74:	ldr.w	r8, [r4, #8]!
    7d78:	adds	r3, r1, r5
    7d7a:	orr.w	r5, r5, #1
    7d7e:	str	r5, [r1, #4]
    7d80:	orr.w	r1, r2, #1
    7d84:	str.w	ip, [r8, #12]
    7d88:	mov	r0, r6
    7d8a:	str.w	r8, [ip, #8]
    7d8e:	str	r3, [r7, #20]
    7d90:	str	r3, [r7, #16]
    7d92:	str.w	lr, [r3, #12]
    7d96:	str.w	lr, [r3, #8]
    7d9a:	str	r1, [r3, #4]
    7d9c:	str	r2, [r3, r2]
    7d9e:	bl	8358 <__malloc_unlock>
    7da2:	b.n	7de4 <_malloc_r+0x190>
    7da4:	cmp	r1, #16
    7da6:	bhi.n	7dec <_malloc_r+0x198>
    7da8:	bl	8354 <__malloc_lock>
    7dac:	movs	r5, #16
    7dae:	movs	r3, #6
    7db0:	movs	r0, #2
    7db2:	ldr	r7, [pc, #504]	; (7fac <_malloc_r+0x358>)
    7db4:	add.w	r3, r7, r3, lsl #2
    7db8:	sub.w	r2, r3, #8
    7dbc:	ldr	r4, [r3, #4]
    7dbe:	cmp	r4, r2
    7dc0:	beq.w	804e <_malloc_r+0x3fa>
    7dc4:	ldr	r3, [r4, #4]
    7dc6:	ldr	r1, [r4, #12]
    7dc8:	ldr	r5, [r4, #8]
    7dca:	bic.w	r3, r3, #3
    7dce:	add	r3, r4
    7dd0:	mov	r0, r6
    7dd2:	ldr	r2, [r3, #4]
    7dd4:	str	r1, [r5, #12]
    7dd6:	orr.w	r2, r2, #1
    7dda:	str	r5, [r1, #8]
    7ddc:	str	r2, [r3, #4]
    7dde:	bl	8358 <__malloc_unlock>
    7de2:	adds	r4, #8
    7de4:	mov	r0, r4
    7de6:	add	sp, #12
    7de8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7dec:	movs	r4, #0
    7dee:	movs	r3, #12
    7df0:	mov	r0, r4
    7df2:	str	r3, [r6, #0]
    7df4:	add	sp, #12
    7df6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7dfa:	movs	r3, #128	; 0x80
    7dfc:	mov.w	lr, #64	; 0x40
    7e00:	movs	r0, #63	; 0x3f
    7e02:	b.n	7c98 <_malloc_r+0x44>
    7e04:	mov	r0, lr
    7e06:	b.n	7cc4 <_malloc_r+0x70>
    7e08:	add	r3, r4
    7e0a:	ldr	r1, [r4, #12]
    7e0c:	ldr	r2, [r3, #4]
    7e0e:	ldr	r5, [r4, #8]
    7e10:	orr.w	r2, r2, #1
    7e14:	str	r1, [r5, #12]
    7e16:	mov	r0, r6
    7e18:	str	r5, [r1, #8]
    7e1a:	str	r2, [r3, #4]
    7e1c:	bl	8358 <__malloc_unlock>
    7e20:	adds	r4, #8
    7e22:	mov	r0, r4
    7e24:	add	sp, #12
    7e26:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e2a:	add	r3, r4
    7e2c:	mov	r0, r6
    7e2e:	ldr	r2, [r3, #4]
    7e30:	orr.w	r2, r2, #1
    7e34:	str	r2, [r3, #4]
    7e36:	bl	8358 <__malloc_unlock>
    7e3a:	adds	r4, #8
    7e3c:	mov	r0, r4
    7e3e:	add	sp, #12
    7e40:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e44:	ldr	r4, [r7, #8]
    7e46:	ldr	r3, [r4, #4]
    7e48:	bic.w	r8, r3, #3
    7e4c:	cmp	r8, r5
    7e4e:	bcc.n	7e5a <_malloc_r+0x206>
    7e50:	rsb	r3, r5, r8
    7e54:	cmp	r3, #15
    7e56:	bgt.w	7f72 <_malloc_r+0x31e>
    7e5a:	ldr	r3, [pc, #340]	; (7fb0 <_malloc_r+0x35c>)
    7e5c:	ldr.w	r9, [pc, #352]	; 7fc0 <_malloc_r+0x36c>
    7e60:	ldr	r2, [r3, #0]
    7e62:	ldr.w	r3, [r9]
    7e66:	adds	r3, #1
    7e68:	add	r2, r5
    7e6a:	add.w	sl, r4, r8
    7e6e:	beq.w	8132 <_malloc_r+0x4de>
    7e72:	add.w	r2, r2, #4096	; 0x1000
    7e76:	adds	r2, #15
    7e78:	bic.w	r2, r2, #4080	; 0xff0
    7e7c:	bic.w	r2, r2, #15
    7e80:	mov	r1, r2
    7e82:	mov	r0, r6
    7e84:	str	r2, [sp, #4]
    7e86:	bl	873c <_sbrk_r>
    7e8a:	cmp.w	r0, #4294967295
    7e8e:	mov	fp, r0
    7e90:	ldr	r2, [sp, #4]
    7e92:	beq.w	8146 <_malloc_r+0x4f2>
    7e96:	cmp	sl, r0
    7e98:	bhi.w	8094 <_malloc_r+0x440>
    7e9c:	ldr	r3, [pc, #276]	; (7fb4 <_malloc_r+0x360>)
    7e9e:	ldr	r1, [r3, #0]
    7ea0:	cmp	sl, fp
    7ea2:	add	r1, r2
    7ea4:	str	r1, [r3, #0]
    7ea6:	beq.w	8150 <_malloc_r+0x4fc>
    7eaa:	ldr.w	r0, [r9]
    7eae:	ldr.w	lr, [pc, #272]	; 7fc0 <_malloc_r+0x36c>
    7eb2:	adds	r0, #1
    7eb4:	ittet	ne
    7eb6:	rsbne	sl, sl, fp
    7eba:	addne	r1, sl
    7ebc:	streq.w	fp, [lr]
    7ec0:	strne	r1, [r3, #0]
    7ec2:	ands.w	r1, fp, #7
    7ec6:	beq.w	80f8 <_malloc_r+0x4a4>
    7eca:	rsb	r0, r1, #8
    7ece:	rsb	r1, r1, #4096	; 0x1000
    7ed2:	add	fp, r0
    7ed4:	adds	r1, #8
    7ed6:	add	r2, fp
    7ed8:	ubfx	r2, r2, #0, #12
    7edc:	rsb	r9, r2, r1
    7ee0:	mov	r1, r9
    7ee2:	mov	r0, r6
    7ee4:	str	r3, [sp, #4]
    7ee6:	bl	873c <_sbrk_r>
    7eea:	adds	r3, r0, #1
    7eec:	ldr	r3, [sp, #4]
    7eee:	beq.w	8170 <_malloc_r+0x51c>
    7ef2:	rsb	r2, fp, r0
    7ef6:	add	r2, r9
    7ef8:	orr.w	r2, r2, #1
    7efc:	ldr	r1, [r3, #0]
    7efe:	str.w	fp, [r7, #8]
    7f02:	add	r1, r9
    7f04:	cmp	r4, r7
    7f06:	str.w	r2, [fp, #4]
    7f0a:	str	r1, [r3, #0]
    7f0c:	ldr.w	r9, [pc, #164]	; 7fb4 <_malloc_r+0x360>
    7f10:	beq.n	7f40 <_malloc_r+0x2ec>
    7f12:	cmp.w	r8, #15
    7f16:	bls.w	8114 <_malloc_r+0x4c0>
    7f1a:	ldr	r2, [r4, #4]
    7f1c:	sub.w	r3, r8, #12
    7f20:	bic.w	r3, r3, #7
    7f24:	adds	r0, r4, r3
    7f26:	and.w	r2, r2, #1
    7f2a:	mov.w	lr, #5
    7f2e:	orrs	r2, r3
    7f30:	cmp	r3, #15
    7f32:	str	r2, [r4, #4]
    7f34:	str.w	lr, [r0, #4]
    7f38:	str.w	lr, [r0, #8]
    7f3c:	bhi.w	8178 <_malloc_r+0x524>
    7f40:	ldr	r3, [pc, #116]	; (7fb8 <_malloc_r+0x364>)
    7f42:	ldr	r4, [r7, #8]
    7f44:	ldr	r2, [r3, #0]
    7f46:	cmp	r1, r2
    7f48:	it	hi
    7f4a:	strhi	r1, [r3, #0]
    7f4c:	ldr	r3, [pc, #108]	; (7fbc <_malloc_r+0x368>)
    7f4e:	ldr	r2, [r3, #0]
    7f50:	cmp	r1, r2
    7f52:	ldr	r2, [r4, #4]
    7f54:	it	hi
    7f56:	strhi	r1, [r3, #0]
    7f58:	bic.w	r2, r2, #3
    7f5c:	cmp	r5, r2
    7f5e:	sub.w	r3, r2, r5
    7f62:	bhi.n	7f68 <_malloc_r+0x314>
    7f64:	cmp	r3, #15
    7f66:	bgt.n	7f72 <_malloc_r+0x31e>
    7f68:	mov	r0, r6
    7f6a:	bl	8358 <__malloc_unlock>
    7f6e:	movs	r4, #0
    7f70:	b.n	7de4 <_malloc_r+0x190>
    7f72:	adds	r2, r4, r5
    7f74:	orr.w	r3, r3, #1
    7f78:	orr.w	r5, r5, #1
    7f7c:	str	r5, [r4, #4]
    7f7e:	mov	r0, r6
    7f80:	str	r2, [r7, #8]
    7f82:	str	r3, [r2, #4]
    7f84:	bl	8358 <__malloc_unlock>
    7f88:	adds	r4, #8
    7f8a:	mov	r0, r4
    7f8c:	add	sp, #12
    7f8e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7f92:	cmp	r3, #20
    7f94:	bls.n	807a <_malloc_r+0x426>
    7f96:	cmp	r3, #84	; 0x54
    7f98:	bhi.w	80e4 <_malloc_r+0x490>
    7f9c:	lsrs	r0, r5, #12
    7f9e:	add.w	lr, r0, #111	; 0x6f
    7fa2:	mov.w	r3, lr, lsl #1
    7fa6:	adds	r0, #110	; 0x6e
    7fa8:	b.n	7c98 <_malloc_r+0x44>
    7faa:	nop
    7fac:	.word	0x200015c0
    7fb0:	.word	0x200020a8
    7fb4:	.word	0x200020ac
    7fb8:	.word	0x200020a4
    7fbc:	.word	0x200020a0
    7fc0:	.word	0x200019cc
    7fc4:	lsrs	r2, r3, #9
    7fc6:	cmp	r2, #4
    7fc8:	bls.n	8088 <_malloc_r+0x434>
    7fca:	cmp	r2, #20
    7fcc:	bhi.w	8136 <_malloc_r+0x4e2>
    7fd0:	add.w	r1, r2, #92	; 0x5c
    7fd4:	lsls	r1, r1, #1
    7fd6:	adds	r2, #91	; 0x5b
    7fd8:	add.w	ip, r7, r1, lsl #2
    7fdc:	ldr.w	r1, [r7, r1, lsl #2]
    7fe0:	ldr.w	r8, [pc, #476]	; 81c0 <_malloc_r+0x56c>
    7fe4:	sub.w	ip, ip, #8
    7fe8:	cmp	ip, r1
    7fea:	beq.w	80fe <_malloc_r+0x4aa>
    7fee:	ldr	r2, [r1, #4]
    7ff0:	bic.w	r2, r2, #3
    7ff4:	cmp	r3, r2
    7ff6:	bcs.n	7ffe <_malloc_r+0x3aa>
    7ff8:	ldr	r1, [r1, #8]
    7ffa:	cmp	ip, r1
    7ffc:	bne.n	7fee <_malloc_r+0x39a>
    7ffe:	ldr.w	ip, [r1, #12]
    8002:	ldr	r2, [r7, #4]
    8004:	str.w	ip, [r4, #12]
    8008:	str	r1, [r4, #8]
    800a:	str.w	r4, [ip, #8]
    800e:	str	r4, [r1, #12]
    8010:	b.n	7d24 <_malloc_r+0xd0>
    8012:	adds	r3, r4, r5
    8014:	orr.w	r7, r2, #1
    8018:	orr.w	r5, r5, #1
    801c:	str	r5, [r4, #4]
    801e:	mov	r0, r6
    8020:	str	r3, [r1, #20]
    8022:	str	r3, [r1, #16]
    8024:	str.w	lr, [r3, #12]
    8028:	str.w	lr, [r3, #8]
    802c:	str	r7, [r3, #4]
    802e:	str	r2, [r3, r2]
    8030:	adds	r4, #8
    8032:	bl	8358 <__malloc_unlock>
    8036:	b.n	7de4 <_malloc_r+0x190>
    8038:	ldr	r2, [r1, #4]
    803a:	b.n	7d24 <_malloc_r+0xd0>
    803c:	add.w	r8, r8, #1
    8040:	tst.w	r8, #3
    8044:	add.w	ip, ip, #8
    8048:	bne.w	7d4a <_malloc_r+0xf6>
    804c:	b.n	80b0 <_malloc_r+0x45c>
    804e:	ldr	r4, [r3, #12]
    8050:	cmp	r3, r4
    8052:	it	eq
    8054:	addeq	r0, #2
    8056:	beq.w	7cc4 <_malloc_r+0x70>
    805a:	b.n	7dc4 <_malloc_r+0x170>
    805c:	add	r3, r1
    805e:	mov	r4, r1
    8060:	ldr	r2, [r3, #4]
    8062:	ldr	r1, [r1, #12]
    8064:	ldr.w	r5, [r4, #8]!
    8068:	orr.w	r2, r2, #1
    806c:	str	r2, [r3, #4]
    806e:	mov	r0, r6
    8070:	str	r1, [r5, #12]
    8072:	str	r5, [r1, #8]
    8074:	bl	8358 <__malloc_unlock>
    8078:	b.n	7de4 <_malloc_r+0x190>
    807a:	add.w	lr, r3, #92	; 0x5c
    807e:	add.w	r0, r3, #91	; 0x5b
    8082:	mov.w	r3, lr, lsl #1
    8086:	b.n	7c98 <_malloc_r+0x44>
    8088:	lsrs	r2, r3, #6
    808a:	add.w	r1, r2, #57	; 0x39
    808e:	lsls	r1, r1, #1
    8090:	adds	r2, #56	; 0x38
    8092:	b.n	7fd8 <_malloc_r+0x384>
    8094:	cmp	r4, r7
    8096:	ldr	r3, [pc, #296]	; (81c0 <_malloc_r+0x56c>)
    8098:	beq.w	7e9c <_malloc_r+0x248>
    809c:	ldr	r4, [r3, #8]
    809e:	ldr	r2, [r4, #4]
    80a0:	bic.w	r2, r2, #3
    80a4:	b.n	7f5c <_malloc_r+0x308>
    80a6:	ldr.w	r3, [r9], #-8
    80aa:	cmp	r9, r3
    80ac:	bne.w	81b4 <_malloc_r+0x560>
    80b0:	tst.w	r0, #3
    80b4:	add.w	r0, r0, #4294967295
    80b8:	bne.n	80a6 <_malloc_r+0x452>
    80ba:	ldr	r3, [r7, #4]
    80bc:	bic.w	r3, r3, r4
    80c0:	str	r3, [r7, #4]
    80c2:	lsls	r4, r4, #1
    80c4:	cmp	r4, r3
    80c6:	bhi.w	7e44 <_malloc_r+0x1f0>
    80ca:	cmp	r4, #0
    80cc:	beq.w	7e44 <_malloc_r+0x1f0>
    80d0:	tst	r4, r3
    80d2:	mov	r0, r8
    80d4:	bne.w	7d42 <_malloc_r+0xee>
    80d8:	lsls	r4, r4, #1
    80da:	tst	r4, r3
    80dc:	add.w	r0, r0, #4
    80e0:	beq.n	80d8 <_malloc_r+0x484>
    80e2:	b.n	7d42 <_malloc_r+0xee>
    80e4:	cmp.w	r3, #340	; 0x154
    80e8:	bhi.n	811c <_malloc_r+0x4c8>
    80ea:	lsrs	r0, r5, #15
    80ec:	add.w	lr, r0, #120	; 0x78
    80f0:	mov.w	r3, lr, lsl #1
    80f4:	adds	r0, #119	; 0x77
    80f6:	b.n	7c98 <_malloc_r+0x44>
    80f8:	mov.w	r1, #4096	; 0x1000
    80fc:	b.n	7ed6 <_malloc_r+0x282>
    80fe:	movs	r1, #1
    8100:	ldr.w	r3, [r8, #4]
    8104:	asrs	r2, r2, #2
    8106:	lsl.w	r2, r1, r2
    810a:	orrs	r2, r3
    810c:	str.w	r2, [r8, #4]
    8110:	mov	r1, ip
    8112:	b.n	8004 <_malloc_r+0x3b0>
    8114:	movs	r3, #1
    8116:	str.w	r3, [fp, #4]
    811a:	b.n	7f68 <_malloc_r+0x314>
    811c:	movw	r2, #1364	; 0x554
    8120:	cmp	r3, r2
    8122:	bhi.n	8166 <_malloc_r+0x512>
    8124:	lsrs	r0, r5, #18
    8126:	add.w	lr, r0, #125	; 0x7d
    812a:	mov.w	r3, lr, lsl #1
    812e:	adds	r0, #124	; 0x7c
    8130:	b.n	7c98 <_malloc_r+0x44>
    8132:	adds	r2, #16
    8134:	b.n	7e80 <_malloc_r+0x22c>
    8136:	cmp	r2, #84	; 0x54
    8138:	bhi.n	8188 <_malloc_r+0x534>
    813a:	lsrs	r2, r3, #12
    813c:	add.w	r1, r2, #111	; 0x6f
    8140:	lsls	r1, r1, #1
    8142:	adds	r2, #110	; 0x6e
    8144:	b.n	7fd8 <_malloc_r+0x384>
    8146:	ldr	r4, [r7, #8]
    8148:	ldr	r2, [r4, #4]
    814a:	bic.w	r2, r2, #3
    814e:	b.n	7f5c <_malloc_r+0x308>
    8150:	ubfx	r0, sl, #0, #12
    8154:	cmp	r0, #0
    8156:	bne.w	7eaa <_malloc_r+0x256>
    815a:	add	r2, r8
    815c:	ldr	r3, [r7, #8]
    815e:	orr.w	r2, r2, #1
    8162:	str	r2, [r3, #4]
    8164:	b.n	7f40 <_malloc_r+0x2ec>
    8166:	movs	r3, #254	; 0xfe
    8168:	mov.w	lr, #127	; 0x7f
    816c:	movs	r0, #126	; 0x7e
    816e:	b.n	7c98 <_malloc_r+0x44>
    8170:	movs	r2, #1
    8172:	mov.w	r9, #0
    8176:	b.n	7efc <_malloc_r+0x2a8>
    8178:	add.w	r1, r4, #8
    817c:	mov	r0, r6
    817e:	bl	9c2c <_free_r>
    8182:	ldr.w	r1, [r9]
    8186:	b.n	7f40 <_malloc_r+0x2ec>
    8188:	cmp.w	r2, #340	; 0x154
    818c:	bhi.n	819a <_malloc_r+0x546>
    818e:	lsrs	r2, r3, #15
    8190:	add.w	r1, r2, #120	; 0x78
    8194:	lsls	r1, r1, #1
    8196:	adds	r2, #119	; 0x77
    8198:	b.n	7fd8 <_malloc_r+0x384>
    819a:	movw	r1, #1364	; 0x554
    819e:	cmp	r2, r1
    81a0:	bhi.n	81ae <_malloc_r+0x55a>
    81a2:	lsrs	r2, r3, #18
    81a4:	add.w	r1, r2, #125	; 0x7d
    81a8:	lsls	r1, r1, #1
    81aa:	adds	r2, #124	; 0x7c
    81ac:	b.n	7fd8 <_malloc_r+0x384>
    81ae:	movs	r1, #254	; 0xfe
    81b0:	movs	r2, #126	; 0x7e
    81b2:	b.n	7fd8 <_malloc_r+0x384>
    81b4:	ldr	r3, [r7, #4]
    81b6:	b.n	80c2 <_malloc_r+0x46e>
    81b8:	lsrs	r0, r5, #3
    81ba:	adds	r3, r0, #1
    81bc:	lsls	r3, r3, #1
    81be:	b.n	7db2 <_malloc_r+0x15e>
    81c0:	.word	0x200015c0

000081c4 <__ascii_mbtowc>:
    81c4:	sub	sp, #8
    81c6:	cbz	r1, 81dc <__ascii_mbtowc+0x18>
    81c8:	cbz	r2, 81e2 <__ascii_mbtowc+0x1e>
    81ca:	cbz	r3, 81e8 <__ascii_mbtowc+0x24>
    81cc:	ldrb	r3, [r2, #0]
    81ce:	str	r3, [r1, #0]
    81d0:	ldrb	r2, [r2, #0]
    81d2:	adds	r0, r2, #0
    81d4:	it	ne
    81d6:	movne	r0, #1
    81d8:	add	sp, #8
    81da:	bx	lr
    81dc:	add	r1, sp, #4
    81de:	cmp	r2, #0
    81e0:	bne.n	81ca <__ascii_mbtowc+0x6>
    81e2:	mov	r0, r2
    81e4:	add	sp, #8
    81e6:	bx	lr
    81e8:	mvn.w	r0, #1
    81ec:	b.n	81d8 <__ascii_mbtowc+0x14>
    81ee:	nop

000081f0 <memmove>:
    81f0:	cmp	r0, r1
    81f2:	push	{r4, r5, r6, r7, lr}
    81f4:	bls.n	8212 <memmove+0x22>
    81f6:	adds	r3, r1, r2
    81f8:	cmp	r0, r3
    81fa:	bcs.n	8212 <memmove+0x22>
    81fc:	adds	r1, r0, r2
    81fe:	cmp	r2, #0
    8200:	beq.n	82a6 <memmove+0xb6>
    8202:	subs	r2, r3, r2
    8204:	ldrb.w	r4, [r3, #-1]!
    8208:	strb.w	r4, [r1, #-1]!
    820c:	cmp	r3, r2
    820e:	bne.n	8204 <memmove+0x14>
    8210:	pop	{r4, r5, r6, r7, pc}
    8212:	cmp	r2, #15
    8214:	bls.n	82a8 <memmove+0xb8>
    8216:	orr.w	r3, r1, r0
    821a:	lsls	r3, r3, #30
    821c:	bne.n	82ac <memmove+0xbc>
    821e:	add.w	r4, r0, #16
    8222:	add.w	r3, r1, #16
    8226:	mov	r5, r2
    8228:	ldr.w	r6, [r3, #-16]
    822c:	str.w	r6, [r4, #-16]
    8230:	ldr.w	r6, [r3, #-12]
    8234:	str.w	r6, [r4, #-12]
    8238:	ldr.w	r6, [r3, #-8]
    823c:	str.w	r6, [r4, #-8]
    8240:	subs	r5, #16
    8242:	ldr.w	r6, [r3, #-4]
    8246:	str.w	r6, [r4, #-4]
    824a:	cmp	r5, #15
    824c:	add.w	r3, r3, #16
    8250:	add.w	r4, r4, #16
    8254:	bhi.n	8228 <memmove+0x38>
    8256:	sub.w	r3, r2, #16
    825a:	bic.w	r3, r3, #15
    825e:	and.w	lr, r2, #15
    8262:	adds	r3, #16
    8264:	cmp.w	lr, #3
    8268:	add	r1, r3
    826a:	add	r3, r0
    826c:	bls.n	82b2 <memmove+0xc2>
    826e:	subs	r6, r3, #4
    8270:	mov	r5, r1
    8272:	mov	r4, lr
    8274:	subs	r4, #4
    8276:	ldr.w	r7, [r5], #4
    827a:	str.w	r7, [r6, #4]!
    827e:	cmp	r4, #3
    8280:	bhi.n	8274 <memmove+0x84>
    8282:	sub.w	r4, lr, #4
    8286:	bic.w	r4, r4, #3
    828a:	adds	r4, #4
    828c:	add	r3, r4
    828e:	add	r1, r4
    8290:	and.w	r2, r2, #3
    8294:	cbz	r2, 82b0 <memmove+0xc0>
    8296:	subs	r3, #1
    8298:	add	r2, r1
    829a:	ldrb.w	r4, [r1], #1
    829e:	strb.w	r4, [r3, #1]!
    82a2:	cmp	r2, r1
    82a4:	bne.n	829a <memmove+0xaa>
    82a6:	pop	{r4, r5, r6, r7, pc}
    82a8:	mov	r3, r0
    82aa:	b.n	8294 <memmove+0xa4>
    82ac:	mov	r3, r0
    82ae:	b.n	8296 <memmove+0xa6>
    82b0:	pop	{r4, r5, r6, r7, pc}
    82b2:	mov	r2, lr
    82b4:	b.n	8294 <memmove+0xa4>
    82b6:	nop

000082b8 <memset>:
    82b8:	push	{r4, r5, r6}
    82ba:	lsls	r4, r0, #30
    82bc:	beq.n	834c <memset+0x94>
    82be:	subs	r4, r2, #1
    82c0:	cmp	r2, #0
    82c2:	beq.n	8348 <memset+0x90>
    82c4:	uxtb	r5, r1
    82c6:	mov	r3, r0
    82c8:	b.n	82d0 <memset+0x18>
    82ca:	subs	r2, r4, #1
    82cc:	cbz	r4, 8348 <memset+0x90>
    82ce:	mov	r4, r2
    82d0:	strb.w	r5, [r3], #1
    82d4:	lsls	r2, r3, #30
    82d6:	bne.n	82ca <memset+0x12>
    82d8:	cmp	r4, #3
    82da:	bls.n	833a <memset+0x82>
    82dc:	uxtb	r5, r1
    82de:	orr.w	r5, r5, r5, lsl #8
    82e2:	cmp	r4, #15
    82e4:	orr.w	r5, r5, r5, lsl #16
    82e8:	bls.n	831e <memset+0x66>
    82ea:	add.w	r2, r3, #16
    82ee:	mov	r6, r4
    82f0:	subs	r6, #16
    82f2:	cmp	r6, #15
    82f4:	str.w	r5, [r2, #-16]
    82f8:	str.w	r5, [r2, #-12]
    82fc:	str.w	r5, [r2, #-8]
    8300:	str.w	r5, [r2, #-4]
    8304:	add.w	r2, r2, #16
    8308:	bhi.n	82f0 <memset+0x38>
    830a:	sub.w	r2, r4, #16
    830e:	bic.w	r2, r2, #15
    8312:	and.w	r4, r4, #15
    8316:	adds	r2, #16
    8318:	cmp	r4, #3
    831a:	add	r3, r2
    831c:	bls.n	833a <memset+0x82>
    831e:	mov	r6, r3
    8320:	mov	r2, r4
    8322:	subs	r2, #4
    8324:	cmp	r2, #3
    8326:	str.w	r5, [r6], #4
    832a:	bhi.n	8322 <memset+0x6a>
    832c:	subs	r2, r4, #4
    832e:	bic.w	r2, r2, #3
    8332:	adds	r2, #4
    8334:	add	r3, r2
    8336:	and.w	r4, r4, #3
    833a:	cbz	r4, 8348 <memset+0x90>
    833c:	uxtb	r1, r1
    833e:	add	r4, r3
    8340:	strb.w	r1, [r3], #1
    8344:	cmp	r3, r4
    8346:	bne.n	8340 <memset+0x88>
    8348:	pop	{r4, r5, r6}
    834a:	bx	lr
    834c:	mov	r4, r2
    834e:	mov	r3, r0
    8350:	b.n	82d8 <memset+0x20>
    8352:	nop

00008354 <__malloc_lock>:
    8354:	bx	lr
    8356:	nop

00008358 <__malloc_unlock>:
    8358:	bx	lr
    835a:	nop

0000835c <_realloc_r>:
    835c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8360:	mov	r7, r2
    8362:	sub	sp, #12
    8364:	cmp	r1, #0
    8366:	beq.w	84ec <_realloc_r+0x190>
    836a:	mov	r6, r1
    836c:	mov	r9, r0
    836e:	add.w	r5, r7, #11
    8372:	bl	8354 <__malloc_lock>
    8376:	ldr.w	lr, [r6, #-4]
    837a:	cmp	r5, #22
    837c:	bic.w	r4, lr, #3
    8380:	sub.w	r8, r6, #8
    8384:	bhi.n	8408 <_realloc_r+0xac>
    8386:	movs	r2, #16
    8388:	mov	r5, r2
    838a:	cmp	r7, r5
    838c:	bhi.n	8412 <_realloc_r+0xb6>
    838e:	cmp	r4, r2
    8390:	bge.n	847e <_realloc_r+0x122>
    8392:	ldr	r3, [pc, #804]	; (86b8 <_realloc_r+0x35c>)
    8394:	ldr	r1, [r3, #8]
    8396:	add.w	r0, r8, r4
    839a:	cmp	r0, r1
    839c:	ldr	r1, [r0, #4]
    839e:	beq.w	8554 <_realloc_r+0x1f8>
    83a2:	bic.w	r3, r1, #1
    83a6:	add	r3, r0
    83a8:	ldr	r3, [r3, #4]
    83aa:	lsls	r3, r3, #31
    83ac:	bpl.n	84aa <_realloc_r+0x14e>
    83ae:	tst.w	lr, #1
    83b2:	beq.n	8420 <_realloc_r+0xc4>
    83b4:	mov	r1, r7
    83b6:	mov	r0, r9
    83b8:	bl	7c54 <_malloc_r>
    83bc:	mov	r7, r0
    83be:	cbz	r0, 83fa <_realloc_r+0x9e>
    83c0:	ldr.w	r3, [r6, #-4]
    83c4:	bic.w	r3, r3, #1
    83c8:	add	r3, r8
    83ca:	sub.w	r2, r0, #8
    83ce:	cmp	r2, r3
    83d0:	beq.w	865c <_realloc_r+0x300>
    83d4:	subs	r2, r4, #4
    83d6:	cmp	r2, #36	; 0x24
    83d8:	bhi.w	863e <_realloc_r+0x2e2>
    83dc:	cmp	r2, #19
    83de:	bhi.w	85ea <_realloc_r+0x28e>
    83e2:	mov	r3, r0
    83e4:	mov	r2, r6
    83e6:	ldr	r1, [r2, #0]
    83e8:	str	r1, [r3, #0]
    83ea:	ldr	r1, [r2, #4]
    83ec:	str	r1, [r3, #4]
    83ee:	ldr	r2, [r2, #8]
    83f0:	str	r2, [r3, #8]
    83f2:	mov	r1, r6
    83f4:	mov	r0, r9
    83f6:	bl	9c2c <_free_r>
    83fa:	mov	r0, r9
    83fc:	bl	8358 <__malloc_unlock>
    8400:	mov	r0, r7
    8402:	add	sp, #12
    8404:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8408:	bic.w	r5, r5, #7
    840c:	cmp	r5, #0
    840e:	mov	r2, r5
    8410:	bge.n	838a <_realloc_r+0x2e>
    8412:	movs	r3, #12
    8414:	movs	r0, #0
    8416:	str.w	r3, [r9]
    841a:	add	sp, #12
    841c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8420:	ldr.w	r3, [r6, #-8]
    8424:	rsb	sl, r3, r8
    8428:	ldr.w	r3, [sl, #4]
    842c:	bic.w	ip, r3, #3
    8430:	add.w	r3, r4, ip
    8434:	cmp	r3, r2
    8436:	blt.n	83b4 <_realloc_r+0x58>
    8438:	mov	r7, sl
    843a:	ldr.w	r1, [sl, #12]
    843e:	ldr.w	r0, [r7, #8]!
    8442:	subs	r2, r4, #4
    8444:	cmp	r2, #36	; 0x24
    8446:	str	r1, [r0, #12]
    8448:	str	r0, [r1, #8]
    844a:	bhi.w	867c <_realloc_r+0x320>
    844e:	cmp	r2, #19
    8450:	bls.w	8678 <_realloc_r+0x31c>
    8454:	ldr	r1, [r6, #0]
    8456:	str.w	r1, [sl, #8]
    845a:	ldr	r1, [r6, #4]
    845c:	str.w	r1, [sl, #12]
    8460:	cmp	r2, #27
    8462:	bhi.w	86bc <_realloc_r+0x360>
    8466:	adds	r6, #8
    8468:	add.w	r2, sl, #16
    846c:	ldr	r1, [r6, #0]
    846e:	str	r1, [r2, #0]
    8470:	ldr	r1, [r6, #4]
    8472:	str	r1, [r2, #4]
    8474:	ldr	r1, [r6, #8]
    8476:	str	r1, [r2, #8]
    8478:	mov	r6, r7
    847a:	mov	r4, r3
    847c:	mov	r8, sl
    847e:	subs	r3, r4, r5
    8480:	cmp	r3, #15
    8482:	bhi.n	84c0 <_realloc_r+0x164>
    8484:	ldr.w	r3, [r8, #4]
    8488:	and.w	r3, r3, #1
    848c:	orrs	r3, r4
    848e:	add	r4, r8
    8490:	str.w	r3, [r8, #4]
    8494:	ldr	r3, [r4, #4]
    8496:	orr.w	r3, r3, #1
    849a:	str	r3, [r4, #4]
    849c:	mov	r0, r9
    849e:	bl	8358 <__malloc_unlock>
    84a2:	mov	r0, r6
    84a4:	add	sp, #12
    84a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    84aa:	bic.w	r1, r1, #3
    84ae:	add	r1, r4
    84b0:	cmp	r1, r2
    84b2:	blt.n	84f8 <_realloc_r+0x19c>
    84b4:	ldr	r3, [r0, #12]
    84b6:	ldr	r2, [r0, #8]
    84b8:	mov	r4, r1
    84ba:	str	r3, [r2, #12]
    84bc:	str	r2, [r3, #8]
    84be:	b.n	847e <_realloc_r+0x122>
    84c0:	ldr.w	r2, [r8, #4]
    84c4:	add.w	r1, r8, r5
    84c8:	and.w	r2, r2, #1
    84cc:	orrs	r5, r2
    84ce:	orr.w	r2, r3, #1
    84d2:	add	r3, r1
    84d4:	str.w	r5, [r8, #4]
    84d8:	str	r2, [r1, #4]
    84da:	ldr	r2, [r3, #4]
    84dc:	orr.w	r2, r2, #1
    84e0:	adds	r1, #8
    84e2:	str	r2, [r3, #4]
    84e4:	mov	r0, r9
    84e6:	bl	9c2c <_free_r>
    84ea:	b.n	849c <_realloc_r+0x140>
    84ec:	mov	r1, r2
    84ee:	add	sp, #12
    84f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    84f4:	b.w	7c54 <_malloc_r>
    84f8:	tst.w	lr, #1
    84fc:	bne.w	83b4 <_realloc_r+0x58>
    8500:	ldr.w	r3, [r6, #-8]
    8504:	rsb	sl, r3, r8
    8508:	ldr.w	r3, [sl, #4]
    850c:	bic.w	ip, r3, #3
    8510:	add.w	lr, r1, ip
    8514:	cmp	lr, r2
    8516:	blt.n	8430 <_realloc_r+0xd4>
    8518:	ldr	r3, [r0, #12]
    851a:	ldr	r2, [r0, #8]
    851c:	mov	r7, sl
    851e:	str	r3, [r2, #12]
    8520:	str	r2, [r3, #8]
    8522:	ldr.w	r1, [r7, #8]!
    8526:	ldr.w	r3, [sl, #12]
    852a:	str	r3, [r1, #12]
    852c:	subs	r2, r4, #4
    852e:	cmp	r2, #36	; 0x24
    8530:	str	r1, [r3, #8]
    8532:	bhi.w	8668 <_realloc_r+0x30c>
    8536:	cmp	r2, #19
    8538:	bls.n	8600 <_realloc_r+0x2a4>
    853a:	ldr	r3, [r6, #0]
    853c:	str.w	r3, [sl, #8]
    8540:	ldr	r3, [r6, #4]
    8542:	str.w	r3, [sl, #12]
    8546:	cmp	r2, #27
    8548:	bhi.w	868c <_realloc_r+0x330>
    854c:	adds	r6, #8
    854e:	add.w	r3, sl, #16
    8552:	b.n	8602 <_realloc_r+0x2a6>
    8554:	bic.w	fp, r1, #3
    8558:	add	fp, r4
    855a:	add.w	r0, r5, #16
    855e:	cmp	fp, r0
    8560:	bge.n	8616 <_realloc_r+0x2ba>
    8562:	tst.w	lr, #1
    8566:	bne.w	83b4 <_realloc_r+0x58>
    856a:	ldr.w	r1, [r6, #-8]
    856e:	rsb	sl, r1, r8
    8572:	ldr.w	r1, [sl, #4]
    8576:	bic.w	ip, r1, #3
    857a:	add	fp, ip
    857c:	cmp	r0, fp
    857e:	bgt.w	8430 <_realloc_r+0xd4>
    8582:	mov	r7, sl
    8584:	ldr.w	r1, [sl, #12]
    8588:	ldr.w	r0, [r7, #8]!
    858c:	subs	r2, r4, #4
    858e:	cmp	r2, #36	; 0x24
    8590:	str	r1, [r0, #12]
    8592:	str	r0, [r1, #8]
    8594:	bhi.w	8700 <_realloc_r+0x3a4>
    8598:	cmp	r2, #19
    859a:	bls.w	86e8 <_realloc_r+0x38c>
    859e:	ldr	r1, [r6, #0]
    85a0:	str.w	r1, [sl, #8]
    85a4:	ldr	r1, [r6, #4]
    85a6:	str.w	r1, [sl, #12]
    85aa:	cmp	r2, #27
    85ac:	bhi.w	870e <_realloc_r+0x3b2>
    85b0:	adds	r6, #8
    85b2:	add.w	r2, sl, #16
    85b6:	ldr	r1, [r6, #0]
    85b8:	str	r1, [r2, #0]
    85ba:	ldr	r1, [r6, #4]
    85bc:	str	r1, [r2, #4]
    85be:	ldr	r1, [r6, #8]
    85c0:	str	r1, [r2, #8]
    85c2:	add.w	r1, sl, r5
    85c6:	rsb	r2, r5, fp
    85ca:	orr.w	r2, r2, #1
    85ce:	str	r1, [r3, #8]
    85d0:	str	r2, [r1, #4]
    85d2:	ldr.w	r3, [sl, #4]
    85d6:	and.w	r3, r3, #1
    85da:	orrs	r5, r3
    85dc:	mov	r0, r9
    85de:	str.w	r5, [sl, #4]
    85e2:	bl	8358 <__malloc_unlock>
    85e6:	mov	r0, r7
    85e8:	b.n	84a4 <_realloc_r+0x148>
    85ea:	ldr	r3, [r6, #0]
    85ec:	str	r3, [r0, #0]
    85ee:	ldr	r3, [r6, #4]
    85f0:	str	r3, [r0, #4]
    85f2:	cmp	r2, #27
    85f4:	bhi.n	8646 <_realloc_r+0x2ea>
    85f6:	add.w	r3, r0, #8
    85fa:	add.w	r2, r6, #8
    85fe:	b.n	83e6 <_realloc_r+0x8a>
    8600:	mov	r3, r7
    8602:	ldr	r2, [r6, #0]
    8604:	str	r2, [r3, #0]
    8606:	ldr	r2, [r6, #4]
    8608:	str	r2, [r3, #4]
    860a:	ldr	r2, [r6, #8]
    860c:	str	r2, [r3, #8]
    860e:	mov	r6, r7
    8610:	mov	r4, lr
    8612:	mov	r8, sl
    8614:	b.n	847e <_realloc_r+0x122>
    8616:	add.w	r1, r8, r5
    861a:	rsb	fp, r5, fp
    861e:	orr.w	r2, fp, #1
    8622:	str	r1, [r3, #8]
    8624:	str	r2, [r1, #4]
    8626:	ldr.w	r3, [r6, #-4]
    862a:	and.w	r3, r3, #1
    862e:	orrs	r5, r3
    8630:	mov	r0, r9
    8632:	str.w	r5, [r6, #-4]
    8636:	bl	8358 <__malloc_unlock>
    863a:	mov	r0, r6
    863c:	b.n	84a4 <_realloc_r+0x148>
    863e:	mov	r1, r6
    8640:	bl	81f0 <memmove>
    8644:	b.n	83f2 <_realloc_r+0x96>
    8646:	ldr	r3, [r6, #8]
    8648:	str	r3, [r0, #8]
    864a:	ldr	r3, [r6, #12]
    864c:	str	r3, [r0, #12]
    864e:	cmp	r2, #36	; 0x24
    8650:	beq.n	86a4 <_realloc_r+0x348>
    8652:	add.w	r3, r0, #16
    8656:	add.w	r2, r6, #16
    865a:	b.n	83e6 <_realloc_r+0x8a>
    865c:	ldr.w	r3, [r0, #-4]
    8660:	bic.w	r3, r3, #3
    8664:	add	r4, r3
    8666:	b.n	847e <_realloc_r+0x122>
    8668:	mov	r1, r6
    866a:	mov	r0, r7
    866c:	mov	r4, lr
    866e:	mov	r8, sl
    8670:	bl	81f0 <memmove>
    8674:	mov	r6, r7
    8676:	b.n	847e <_realloc_r+0x122>
    8678:	mov	r2, r7
    867a:	b.n	846c <_realloc_r+0x110>
    867c:	mov	r1, r6
    867e:	mov	r0, r7
    8680:	mov	r4, r3
    8682:	mov	r8, sl
    8684:	bl	81f0 <memmove>
    8688:	mov	r6, r7
    868a:	b.n	847e <_realloc_r+0x122>
    868c:	ldr	r3, [r6, #8]
    868e:	str.w	r3, [sl, #16]
    8692:	ldr	r3, [r6, #12]
    8694:	str.w	r3, [sl, #20]
    8698:	cmp	r2, #36	; 0x24
    869a:	beq.n	86d4 <_realloc_r+0x378>
    869c:	adds	r6, #16
    869e:	add.w	r3, sl, #24
    86a2:	b.n	8602 <_realloc_r+0x2a6>
    86a4:	ldr	r3, [r6, #16]
    86a6:	str	r3, [r0, #16]
    86a8:	ldr	r3, [r6, #20]
    86aa:	str	r3, [r0, #20]
    86ac:	add.w	r2, r6, #24
    86b0:	add.w	r3, r0, #24
    86b4:	b.n	83e6 <_realloc_r+0x8a>
    86b6:	nop
    86b8:	.word	0x200015c0
    86bc:	ldr	r1, [r6, #8]
    86be:	str.w	r1, [sl, #16]
    86c2:	ldr	r1, [r6, #12]
    86c4:	str.w	r1, [sl, #20]
    86c8:	cmp	r2, #36	; 0x24
    86ca:	beq.n	86ec <_realloc_r+0x390>
    86cc:	adds	r6, #16
    86ce:	add.w	r2, sl, #24
    86d2:	b.n	846c <_realloc_r+0x110>
    86d4:	ldr	r3, [r6, #16]
    86d6:	str.w	r3, [sl, #24]
    86da:	ldr	r3, [r6, #20]
    86dc:	str.w	r3, [sl, #28]
    86e0:	adds	r6, #24
    86e2:	add.w	r3, sl, #32
    86e6:	b.n	8602 <_realloc_r+0x2a6>
    86e8:	mov	r2, r7
    86ea:	b.n	85b6 <_realloc_r+0x25a>
    86ec:	ldr	r2, [r6, #16]
    86ee:	str.w	r2, [sl, #24]
    86f2:	ldr	r2, [r6, #20]
    86f4:	str.w	r2, [sl, #28]
    86f8:	adds	r6, #24
    86fa:	add.w	r2, sl, #32
    86fe:	b.n	846c <_realloc_r+0x110>
    8700:	mov	r1, r6
    8702:	mov	r0, r7
    8704:	str	r3, [sp, #4]
    8706:	bl	81f0 <memmove>
    870a:	ldr	r3, [sp, #4]
    870c:	b.n	85c2 <_realloc_r+0x266>
    870e:	ldr	r1, [r6, #8]
    8710:	str.w	r1, [sl, #16]
    8714:	ldr	r1, [r6, #12]
    8716:	str.w	r1, [sl, #20]
    871a:	cmp	r2, #36	; 0x24
    871c:	beq.n	8726 <_realloc_r+0x3ca>
    871e:	adds	r6, #16
    8720:	add.w	r2, sl, #24
    8724:	b.n	85b6 <_realloc_r+0x25a>
    8726:	ldr	r2, [r6, #16]
    8728:	str.w	r2, [sl, #24]
    872c:	ldr	r2, [r6, #20]
    872e:	str.w	r2, [sl, #28]
    8732:	adds	r6, #24
    8734:	add.w	r2, sl, #32
    8738:	b.n	85b6 <_realloc_r+0x25a>
    873a:	nop

0000873c <_sbrk_r>:
    873c:	push	{r3, r4, r5, lr}
    873e:	ldr	r4, [pc, #28]	; (875c <_sbrk_r+0x20>)
    8740:	movs	r3, #0
    8742:	mov	r5, r0
    8744:	mov	r0, r1
    8746:	str	r3, [r4, #0]
    8748:	bl	2c54 <_sbrk>
    874c:	adds	r3, r0, #1
    874e:	beq.n	8752 <_sbrk_r+0x16>
    8750:	pop	{r3, r4, r5, pc}
    8752:	ldr	r3, [r4, #0]
    8754:	cmp	r3, #0
    8756:	beq.n	8750 <_sbrk_r+0x14>
    8758:	str	r3, [r5, #0]
    875a:	pop	{r3, r4, r5, pc}
    875c:	.word	0x20004290
	...

00008780 <strlen>:
    8780:	pld	[r0]
    8784:	strd	r4, r5, [sp, #-8]!
    8788:	bic.w	r1, r0, #7
    878c:	mvn.w	ip, #0
    8790:	ands.w	r4, r0, #7
    8794:	pld	[r1, #32]
    8798:	bne.w	882e <strlen+0xae>
    879c:	mov.w	r4, #0
    87a0:	mvn.w	r0, #7
    87a4:	ldrd	r2, r3, [r1]
    87a8:	pld	[r1, #64]	; 0x40
    87ac:	add.w	r0, r0, #8
    87b0:	uadd8	r2, r2, ip
    87b4:	sel	r2, r4, ip
    87b8:	uadd8	r3, r3, ip
    87bc:	sel	r3, r2, ip
    87c0:	cbnz	r3, 8816 <strlen+0x96>
    87c2:	ldrd	r2, r3, [r1, #8]
    87c6:	uadd8	r2, r2, ip
    87ca:	add.w	r0, r0, #8
    87ce:	sel	r2, r4, ip
    87d2:	uadd8	r3, r3, ip
    87d6:	sel	r3, r2, ip
    87da:	cbnz	r3, 8816 <strlen+0x96>
    87dc:	ldrd	r2, r3, [r1, #16]
    87e0:	uadd8	r2, r2, ip
    87e4:	add.w	r0, r0, #8
    87e8:	sel	r2, r4, ip
    87ec:	uadd8	r3, r3, ip
    87f0:	sel	r3, r2, ip
    87f4:	cbnz	r3, 8816 <strlen+0x96>
    87f6:	ldrd	r2, r3, [r1, #24]
    87fa:	add.w	r1, r1, #32
    87fe:	uadd8	r2, r2, ip
    8802:	add.w	r0, r0, #8
    8806:	sel	r2, r4, ip
    880a:	uadd8	r3, r3, ip
    880e:	sel	r3, r2, ip
    8812:	cmp	r3, #0
    8814:	beq.n	87a4 <strlen+0x24>
    8816:	cmp	r2, #0
    8818:	itt	eq
    881a:	addeq	r0, #4
    881c:	moveq	r2, r3
    881e:	rev	r2, r2
    8820:	clz	r2, r2
    8824:	ldrd	r4, r5, [sp], #8
    8828:	add.w	r0, r0, r2, lsr #3
    882c:	bx	lr
    882e:	ldrd	r2, r3, [r1]
    8832:	and.w	r5, r4, #3
    8836:	rsb	r0, r4, #0
    883a:	mov.w	r5, r5, lsl #3
    883e:	tst.w	r4, #4
    8842:	pld	[r1, #64]	; 0x40
    8846:	lsl.w	r5, ip, r5
    884a:	orn	r2, r2, r5
    884e:	itt	ne
    8850:	ornne	r3, r3, r5
    8854:	movne	r2, ip
    8856:	mov.w	r4, #0
    885a:	b.n	87b0 <strlen+0x30>

0000885c <__sprint_r.part.0>:
    885c:	ldr	r3, [r1, #100]	; 0x64
    885e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8862:	lsls	r4, r3, #18
    8864:	mov	sl, r2
    8866:	bpl.n	88c2 <__sprint_r.part.0+0x66>
    8868:	ldr	r3, [r2, #8]
    886a:	ldr	r2, [r2, #0]
    886c:	cbz	r3, 88be <__sprint_r.part.0+0x62>
    886e:	mov	r7, r1
    8870:	mov	r8, r0
    8872:	add.w	r9, r2, #8
    8876:	ldmdb	r9, {r5, r6}
    887a:	lsrs	r6, r6, #2
    887c:	beq.n	88ae <__sprint_r.part.0+0x52>
    887e:	subs	r5, #4
    8880:	movs	r4, #0
    8882:	b.n	8888 <__sprint_r.part.0+0x2c>
    8884:	cmp	r6, r4
    8886:	beq.n	88aa <__sprint_r.part.0+0x4e>
    8888:	mov	r2, r7
    888a:	ldr.w	r1, [r5, #4]!
    888e:	mov	r0, r8
    8890:	bl	9b68 <_fputwc_r>
    8894:	adds	r3, r0, #1
    8896:	add.w	r4, r4, #1
    889a:	bne.n	8884 <__sprint_r.part.0+0x28>
    889c:	movs	r3, #0
    889e:	str.w	r3, [sl, #8]
    88a2:	str.w	r3, [sl, #4]
    88a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    88aa:	ldr.w	r3, [sl, #8]
    88ae:	sub.w	r3, r3, r6, lsl #2
    88b2:	str.w	r3, [sl, #8]
    88b6:	add.w	r9, r9, #8
    88ba:	cmp	r3, #0
    88bc:	bne.n	8876 <__sprint_r.part.0+0x1a>
    88be:	movs	r0, #0
    88c0:	b.n	889c <__sprint_r.part.0+0x40>
    88c2:	bl	9dfc <__sfvwrite_r>
    88c6:	movs	r3, #0
    88c8:	str.w	r3, [sl, #8]
    88cc:	str.w	r3, [sl, #4]
    88d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000088d4 <_vfiprintf_r>:
    88d4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    88d8:	sub	sp, #172	; 0xac
    88da:	mov	r4, r3
    88dc:	str	r1, [sp, #0]
    88de:	mov	r8, r2
    88e0:	str	r3, [sp, #16]
    88e2:	str	r0, [sp, #20]
    88e4:	cbz	r0, 88ee <_vfiprintf_r+0x1a>
    88e6:	ldr	r3, [r0, #56]	; 0x38
    88e8:	cmp	r3, #0
    88ea:	beq.w	8aaa <_vfiprintf_r+0x1d6>
    88ee:	ldr	r0, [sp, #0]
    88f0:	ldrsh.w	r1, [r0, #12]
    88f4:	uxth	r2, r1
    88f6:	lsls	r5, r2, #18
    88f8:	bmi.n	890a <_vfiprintf_r+0x36>
    88fa:	ldr	r3, [r0, #100]	; 0x64
    88fc:	orr.w	r2, r1, #8192	; 0x2000
    8900:	bic.w	r3, r3, #8192	; 0x2000
    8904:	strh	r2, [r0, #12]
    8906:	str	r3, [r0, #100]	; 0x64
    8908:	uxth	r2, r2
    890a:	lsls	r1, r2, #28
    890c:	bpl.w	8a72 <_vfiprintf_r+0x19e>
    8910:	ldr	r3, [sp, #0]
    8912:	ldr	r3, [r3, #16]
    8914:	cmp	r3, #0
    8916:	beq.w	8a72 <_vfiprintf_r+0x19e>
    891a:	and.w	r2, r2, #26
    891e:	cmp	r2, #10
    8920:	beq.w	8a8e <_vfiprintf_r+0x1ba>
    8924:	movs	r3, #0
    8926:	add.w	fp, sp, #104	; 0x68
    892a:	str	r3, [sp, #8]
    892c:	str	r3, [sp, #60]	; 0x3c
    892e:	str	r3, [sp, #56]	; 0x38
    8930:	str.w	fp, [sp, #52]	; 0x34
    8934:	mov	sl, fp
    8936:	ldrb.w	r3, [r8]
    893a:	mov	r4, r8
    893c:	cbz	r3, 897e <_vfiprintf_r+0xaa>
    893e:	cmp	r3, #37	; 0x25
    8940:	bne.n	8948 <_vfiprintf_r+0x74>
    8942:	b.n	897e <_vfiprintf_r+0xaa>
    8944:	cmp	r3, #37	; 0x25
    8946:	beq.n	8950 <_vfiprintf_r+0x7c>
    8948:	ldrb.w	r3, [r4, #1]!
    894c:	cmp	r3, #0
    894e:	bne.n	8944 <_vfiprintf_r+0x70>
    8950:	rsb	r5, r8, r4
    8954:	cbz	r5, 897e <_vfiprintf_r+0xaa>
    8956:	ldr	r3, [sp, #56]	; 0x38
    8958:	ldr	r2, [sp, #60]	; 0x3c
    895a:	str.w	r8, [sl]
    895e:	adds	r3, #1
    8960:	add	r2, r5
    8962:	cmp	r3, #7
    8964:	str.w	r5, [sl, #4]
    8968:	str	r2, [sp, #60]	; 0x3c
    896a:	str	r3, [sp, #56]	; 0x38
    896c:	ble.n	8a66 <_vfiprintf_r+0x192>
    896e:	cmp	r2, #0
    8970:	bne.w	93c4 <_vfiprintf_r+0xaf0>
    8974:	ldr	r3, [sp, #8]
    8976:	str	r2, [sp, #56]	; 0x38
    8978:	add	r3, r5
    897a:	mov	sl, fp
    897c:	str	r3, [sp, #8]
    897e:	ldrb	r3, [r4, #0]
    8980:	cmp	r3, #0
    8982:	beq.w	9202 <_vfiprintf_r+0x92e>
    8986:	movs	r1, #0
    8988:	mov.w	r3, #0
    898c:	mov.w	r2, #4294967295
    8990:	strb.w	r3, [sp, #47]	; 0x2f
    8994:	add.w	r8, r4, #1
    8998:	ldrb	r3, [r4, #1]
    899a:	str	r2, [sp, #4]
    899c:	mov	r0, r1
    899e:	mov	r6, r1
    89a0:	mov	r4, r1
    89a2:	add.w	r8, r8, #1
    89a6:	sub.w	r2, r3, #32
    89aa:	cmp	r2, #88	; 0x58
    89ac:	bhi.w	90d6 <_vfiprintf_r+0x802>
    89b0:	tbh	[pc, r2, lsl #1]
    89b4:	.word	0x03910346
    89b8:	.word	0x034e0391
    89bc:	.word	0x03910391
    89c0:	.word	0x03910391
    89c4:	.word	0x03910391
    89c8:	.word	0x02670289
    89cc:	.word	0x00800391
    89d0:	.word	0x0391026c
    89d4:	.word	0x025901c6
    89d8:	.word	0x02590259
    89dc:	.word	0x02590259
    89e0:	.word	0x02590259
    89e4:	.word	0x02590259
    89e8:	.word	0x03910391
    89ec:	.word	0x03910391
    89f0:	.word	0x03910391
    89f4:	.word	0x03910391
    89f8:	.word	0x03910391
    89fc:	.word	0x039101cb
    8a00:	.word	0x03910391
    8a04:	.word	0x03910391
    8a08:	.word	0x03910391
    8a0c:	.word	0x03910391
    8a10:	.word	0x02140391
    8a14:	.word	0x03910391
    8a18:	.word	0x03910391
    8a1c:	.word	0x02ee0391
    8a20:	.word	0x03910391
    8a24:	.word	0x03910311
    8a28:	.word	0x03910391
    8a2c:	.word	0x03910391
    8a30:	.word	0x03910391
    8a34:	.word	0x03910391
    8a38:	.word	0x03340391
    8a3c:	.word	0x0391038a
    8a40:	.word	0x03910391
    8a44:	.word	0x038a0367
    8a48:	.word	0x03910391
    8a4c:	.word	0x0391036c
    8a50:	.word	0x02950379
    8a54:	.word	0x02e90085
    8a58:	.word	0x029b0391
    8a5c:	.word	0x02ba0391
    8a60:	.word	0x03910391
    8a64:	.short	0x0353
    8a66:	add.w	sl, sl, #8
    8a6a:	ldr	r3, [sp, #8]
    8a6c:	add	r3, r5
    8a6e:	str	r3, [sp, #8]
    8a70:	b.n	897e <_vfiprintf_r+0xaa>
    8a72:	ldr	r1, [sp, #0]
    8a74:	ldr	r0, [sp, #20]
    8a76:	bl	9784 <__swsetup_r>
    8a7a:	cmp	r0, #0
    8a7c:	bne.w	9530 <_vfiprintf_r+0xc5c>
    8a80:	ldr	r3, [sp, #0]
    8a82:	ldrh	r2, [r3, #12]
    8a84:	and.w	r2, r2, #26
    8a88:	cmp	r2, #10
    8a8a:	bne.w	8924 <_vfiprintf_r+0x50>
    8a8e:	ldr	r1, [sp, #0]
    8a90:	ldrsh.w	r3, [r1, #14]
    8a94:	cmp	r3, #0
    8a96:	blt.w	8924 <_vfiprintf_r+0x50>
    8a9a:	mov	r3, r4
    8a9c:	mov	r2, r8
    8a9e:	ldr	r0, [sp, #20]
    8aa0:	bl	96d0 <__sbprintf>
    8aa4:	add	sp, #172	; 0xac
    8aa6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8aaa:	bl	9abc <__sinit>
    8aae:	b.n	88ee <_vfiprintf_r+0x1a>
    8ab0:	negs	r4, r4
    8ab2:	str	r3, [sp, #16]
    8ab4:	orr.w	r6, r6, #4
    8ab8:	ldrb.w	r3, [r8]
    8abc:	b.n	89a2 <_vfiprintf_r+0xce>
    8abe:	movs	r1, #48	; 0x30
    8ac0:	ldr	r0, [sp, #16]
    8ac2:	strb.w	r1, [sp, #48]	; 0x30
    8ac6:	ldr	r1, [sp, #4]
    8ac8:	str	r4, [sp, #24]
    8aca:	mov.w	r3, #0
    8ace:	movs	r2, #120	; 0x78
    8ad0:	strb.w	r3, [sp, #47]	; 0x2f
    8ad4:	cmp	r1, #0
    8ad6:	mov	r3, r0
    8ad8:	strb.w	r2, [sp, #49]	; 0x31
    8adc:	ldr	r4, [r0, #0]
    8ade:	add.w	r3, r3, #4
    8ae2:	mov.w	r5, #0
    8ae6:	orr.w	r2, r6, #2
    8aea:	blt.w	9538 <_vfiprintf_r+0xc64>
    8aee:	bic.w	r6, r6, #128	; 0x80
    8af2:	orrs.w	r2, r4, r5
    8af6:	orr.w	r6, r6, #2
    8afa:	str	r3, [sp, #16]
    8afc:	bne.w	947e <_vfiprintf_r+0xbaa>
    8b00:	ldr	r0, [pc, #716]	; (8dd0 <_vfiprintf_r+0x4fc>)
    8b02:	ldr	r3, [sp, #4]
    8b04:	cmp	r3, #0
    8b06:	bne.w	9342 <_vfiprintf_r+0xa6e>
    8b0a:	mov	r9, r3
    8b0c:	movs	r3, #0
    8b0e:	str	r3, [sp, #4]
    8b10:	str	r3, [sp, #12]
    8b12:	mov	r7, fp
    8b14:	ldr	r3, [sp, #4]
    8b16:	ldr	r2, [sp, #12]
    8b18:	cmp	r3, r2
    8b1a:	it	lt
    8b1c:	movlt	r3, r2
    8b1e:	mov	r5, r3
    8b20:	cmp.w	r9, #0
    8b24:	beq.n	8b28 <_vfiprintf_r+0x254>
    8b26:	adds	r5, #1
    8b28:	ands.w	r3, r6, #2
    8b2c:	str	r3, [sp, #28]
    8b2e:	it	ne
    8b30:	addne	r5, #2
    8b32:	ands.w	r3, r6, #132	; 0x84
    8b36:	str	r3, [sp, #32]
    8b38:	bne.w	911e <_vfiprintf_r+0x84a>
    8b3c:	ldr	r3, [sp, #24]
    8b3e:	subs	r4, r3, r5
    8b40:	cmp	r4, #0
    8b42:	ble.w	911e <_vfiprintf_r+0x84a>
    8b46:	cmp	r4, #16
    8b48:	ble.w	95f8 <_vfiprintf_r+0xd24>
    8b4c:	ldr.w	r9, [pc, #644]	; 8dd4 <_vfiprintf_r+0x500>
    8b50:	ldr.w	lr, [sp, #56]	; 0x38
    8b54:	ldr	r2, [sp, #60]	; 0x3c
    8b56:	mov	ip, sl
    8b58:	movs	r3, #16
    8b5a:	mov	sl, r8
    8b5c:	mov	r0, lr
    8b5e:	mov	r8, r5
    8b60:	mov	r5, r9
    8b62:	ldr.w	r9, [sp, #20]
    8b66:	b.n	8b78 <_vfiprintf_r+0x2a4>
    8b68:	add.w	lr, r0, #2
    8b6c:	add.w	ip, ip, #8
    8b70:	mov	r0, r1
    8b72:	subs	r4, #16
    8b74:	cmp	r4, #16
    8b76:	ble.n	8ba0 <_vfiprintf_r+0x2cc>
    8b78:	adds	r1, r0, #1
    8b7a:	adds	r2, #16
    8b7c:	cmp	r1, #7
    8b7e:	str	r2, [sp, #60]	; 0x3c
    8b80:	str.w	r5, [ip]
    8b84:	str.w	r3, [ip, #4]
    8b88:	str	r1, [sp, #56]	; 0x38
    8b8a:	ble.n	8b68 <_vfiprintf_r+0x294>
    8b8c:	cmp	r2, #0
    8b8e:	bne.w	9100 <_vfiprintf_r+0x82c>
    8b92:	subs	r4, #16
    8b94:	cmp	r4, #16
    8b96:	mov	r0, r2
    8b98:	mov.w	lr, #1
    8b9c:	mov	ip, fp
    8b9e:	bgt.n	8b78 <_vfiprintf_r+0x2a4>
    8ba0:	mov	r9, r5
    8ba2:	mov	r0, lr
    8ba4:	mov	r5, r8
    8ba6:	mov	r8, sl
    8ba8:	mov	sl, ip
    8baa:	add	r2, r4
    8bac:	cmp	r0, #7
    8bae:	str	r2, [sp, #60]	; 0x3c
    8bb0:	str.w	r9, [sl]
    8bb4:	str.w	r4, [sl, #4]
    8bb8:	str	r0, [sp, #56]	; 0x38
    8bba:	bgt.w	92a8 <_vfiprintf_r+0x9d4>
    8bbe:	ldrb.w	r3, [sp, #47]	; 0x2f
    8bc2:	add.w	sl, sl, #8
    8bc6:	add.w	lr, r0, #1
    8bca:	cmp	r3, #0
    8bcc:	bne.w	9130 <_vfiprintf_r+0x85c>
    8bd0:	ldr	r3, [sp, #28]
    8bd2:	cmp	r3, #0
    8bd4:	beq.w	915e <_vfiprintf_r+0x88a>
    8bd8:	adds	r2, #2
    8bda:	add	r1, sp, #48	; 0x30
    8bdc:	movs	r3, #2
    8bde:	cmp.w	lr, #7
    8be2:	str	r2, [sp, #60]	; 0x3c
    8be4:	str.w	lr, [sp, #56]	; 0x38
    8be8:	stmia.w	sl, {r1, r3}
    8bec:	ble.w	92e0 <_vfiprintf_r+0xa0c>
    8bf0:	cmp	r2, #0
    8bf2:	bne.w	940a <_vfiprintf_r+0xb36>
    8bf6:	ldr	r3, [sp, #32]
    8bf8:	cmp	r3, #128	; 0x80
    8bfa:	mov.w	lr, #1
    8bfe:	mov	r0, r2
    8c00:	mov	sl, fp
    8c02:	bne.w	9166 <_vfiprintf_r+0x892>
    8c06:	ldr	r3, [sp, #24]
    8c08:	subs	r4, r3, r5
    8c0a:	cmp	r4, #0
    8c0c:	ble.w	9166 <_vfiprintf_r+0x892>
    8c10:	cmp	r4, #16
    8c12:	ldr.w	r9, [pc, #452]	; 8dd8 <_vfiprintf_r+0x504>
    8c16:	ble.w	9630 <_vfiprintf_r+0xd5c>
    8c1a:	mov	lr, sl
    8c1c:	movs	r3, #16
    8c1e:	mov	sl, r8
    8c20:	mov	r8, r5
    8c22:	mov	r5, r9
    8c24:	ldr.w	r9, [sp, #20]
    8c28:	b.n	8c3a <_vfiprintf_r+0x366>
    8c2a:	add.w	ip, r0, #2
    8c2e:	add.w	lr, lr, #8
    8c32:	mov	r0, r1
    8c34:	subs	r4, #16
    8c36:	cmp	r4, #16
    8c38:	ble.n	8c62 <_vfiprintf_r+0x38e>
    8c3a:	adds	r1, r0, #1
    8c3c:	adds	r2, #16
    8c3e:	cmp	r1, #7
    8c40:	str	r2, [sp, #60]	; 0x3c
    8c42:	str.w	r5, [lr]
    8c46:	str.w	r3, [lr, #4]
    8c4a:	str	r1, [sp, #56]	; 0x38
    8c4c:	ble.n	8c2a <_vfiprintf_r+0x356>
    8c4e:	cmp	r2, #0
    8c50:	bne.w	927e <_vfiprintf_r+0x9aa>
    8c54:	subs	r4, #16
    8c56:	cmp	r4, #16
    8c58:	mov.w	ip, #1
    8c5c:	mov	r0, r2
    8c5e:	mov	lr, fp
    8c60:	bgt.n	8c3a <_vfiprintf_r+0x366>
    8c62:	mov	r9, r5
    8c64:	mov	r5, r8
    8c66:	mov	r8, sl
    8c68:	mov	sl, lr
    8c6a:	add	r2, r4
    8c6c:	cmp.w	ip, #7
    8c70:	str	r2, [sp, #60]	; 0x3c
    8c72:	str.w	r9, [sl]
    8c76:	str.w	r4, [sl, #4]
    8c7a:	str.w	ip, [sp, #56]	; 0x38
    8c7e:	bgt.w	9426 <_vfiprintf_r+0xb52>
    8c82:	ldr	r3, [sp, #4]
    8c84:	ldr	r1, [sp, #12]
    8c86:	subs	r4, r3, r1
    8c88:	cmp	r4, #0
    8c8a:	add.w	sl, sl, #8
    8c8e:	add.w	lr, ip, #1
    8c92:	mov	r0, ip
    8c94:	bgt.w	9172 <_vfiprintf_r+0x89e>
    8c98:	ldr	r1, [sp, #12]
    8c9a:	str.w	r7, [sl]
    8c9e:	add	r2, r1
    8ca0:	cmp.w	lr, #7
    8ca4:	str	r2, [sp, #60]	; 0x3c
    8ca6:	str.w	r1, [sl, #4]
    8caa:	str.w	lr, [sp, #56]	; 0x38
    8cae:	ble.w	924e <_vfiprintf_r+0x97a>
    8cb2:	cmp	r2, #0
    8cb4:	bne.w	932c <_vfiprintf_r+0xa58>
    8cb8:	lsls	r0, r6, #29
    8cba:	str	r2, [sp, #56]	; 0x38
    8cbc:	bpl.n	8d30 <_vfiprintf_r+0x45c>
    8cbe:	ldr	r3, [sp, #24]
    8cc0:	subs	r4, r3, r5
    8cc2:	cmp	r4, #0
    8cc4:	ble.n	8d30 <_vfiprintf_r+0x45c>
    8cc6:	mov	sl, fp
    8cc8:	cmp	r4, #16
    8cca:	ble.w	9624 <_vfiprintf_r+0xd50>
    8cce:	ldr.w	r9, [pc, #260]	; 8dd4 <_vfiprintf_r+0x500>
    8cd2:	ldr	r1, [sp, #56]	; 0x38
    8cd4:	mov	r7, r9
    8cd6:	movs	r6, #16
    8cd8:	ldr.w	r9, [sp, #20]
    8cdc:	b.n	8cec <_vfiprintf_r+0x418>
    8cde:	adds	r0, r1, #2
    8ce0:	add.w	sl, sl, #8
    8ce4:	mov	r1, r3
    8ce6:	subs	r4, #16
    8ce8:	cmp	r4, #16
    8cea:	ble.n	8d14 <_vfiprintf_r+0x440>
    8cec:	adds	r3, r1, #1
    8cee:	adds	r2, #16
    8cf0:	cmp	r3, #7
    8cf2:	str	r2, [sp, #60]	; 0x3c
    8cf4:	str.w	r7, [sl]
    8cf8:	str.w	r6, [sl, #4]
    8cfc:	str	r3, [sp, #56]	; 0x38
    8cfe:	ble.n	8cde <_vfiprintf_r+0x40a>
    8d00:	cmp	r2, #0
    8d02:	bne.w	9222 <_vfiprintf_r+0x94e>
    8d06:	subs	r4, #16
    8d08:	cmp	r4, #16
    8d0a:	mov.w	r0, #1
    8d0e:	mov	r1, r2
    8d10:	mov	sl, fp
    8d12:	bgt.n	8cec <_vfiprintf_r+0x418>
    8d14:	mov	r9, r7
    8d16:	add	r2, r4
    8d18:	cmp	r0, #7
    8d1a:	str	r2, [sp, #60]	; 0x3c
    8d1c:	str.w	r9, [sl]
    8d20:	str.w	r4, [sl, #4]
    8d24:	str	r0, [sp, #56]	; 0x38
    8d26:	ble.w	9260 <_vfiprintf_r+0x98c>
    8d2a:	cmp	r2, #0
    8d2c:	bne.w	957a <_vfiprintf_r+0xca6>
    8d30:	ldr	r3, [sp, #8]
    8d32:	ldr	r2, [sp, #24]
    8d34:	cmp	r2, r5
    8d36:	ite	ge
    8d38:	addge	r3, r3, r2
    8d3a:	addlt	r3, r3, r5
    8d3c:	str	r3, [sp, #8]
    8d3e:	b.n	9274 <_vfiprintf_r+0x9a0>
    8d40:	orr.w	r6, r6, #128	; 0x80
    8d44:	ldrb.w	r3, [r8]
    8d48:	b.n	89a2 <_vfiprintf_r+0xce>
    8d4a:	str	r4, [sp, #24]
    8d4c:	cmp	r1, #0
    8d4e:	bne.w	96b0 <_vfiprintf_r+0xddc>
    8d52:	orr.w	r6, r6, #16
    8d56:	lsls	r3, r6, #26
    8d58:	bpl.w	9380 <_vfiprintf_r+0xaac>
    8d5c:	ldr	r1, [sp, #16]
    8d5e:	adds	r1, #7
    8d60:	bic.w	r1, r1, #7
    8d64:	ldrd	r2, r3, [r1]
    8d68:	adds	r1, #8
    8d6a:	str	r1, [sp, #16]
    8d6c:	mov	r4, r2
    8d6e:	mov	r5, r3
    8d70:	cmp	r2, #0
    8d72:	sbcs.w	r3, r3, #0
    8d76:	blt.w	9486 <_vfiprintf_r+0xbb2>
    8d7a:	ldr	r3, [sp, #4]
    8d7c:	ldrb.w	r9, [sp, #47]	; 0x2f
    8d80:	cmp	r3, #0
    8d82:	blt.w	93ba <_vfiprintf_r+0xae6>
    8d86:	orrs.w	r3, r4, r5
    8d8a:	bic.w	r6, r6, #128	; 0x80
    8d8e:	beq.w	8f6c <_vfiprintf_r+0x698>
    8d92:	cmp	r5, #0
    8d94:	it	eq
    8d96:	cmpeq	r4, #10
    8d98:	bcc.w	8f76 <_vfiprintf_r+0x6a2>
    8d9c:	mov	r7, fp
    8d9e:	mov	r0, r4
    8da0:	mov	r1, r5
    8da2:	movs	r2, #10
    8da4:	movs	r3, #0
    8da6:	bl	a5b4 <__aeabi_uldivmod>
    8daa:	adds	r2, #48	; 0x30
    8dac:	strb.w	r2, [r7, #-1]!
    8db0:	mov	r0, r4
    8db2:	mov	r1, r5
    8db4:	movs	r3, #0
    8db6:	movs	r2, #10
    8db8:	bl	a5b4 <__aeabi_uldivmod>
    8dbc:	mov	r4, r0
    8dbe:	mov	r5, r1
    8dc0:	orrs.w	r3, r4, r5
    8dc4:	bne.n	8d9e <_vfiprintf_r+0x4ca>
    8dc6:	rsb	r3, r7, fp
    8dca:	str	r3, [sp, #12]
    8dcc:	b.n	8b14 <_vfiprintf_r+0x240>
    8dce:	nop
    8dd0:	.word	0x20000ecc
    8dd4:	.word	0x20000ea8
    8dd8:	.word	0x20000e98
    8ddc:	str	r4, [sp, #24]
    8dde:	cmp	r1, #0
    8de0:	bne.w	96a8 <_vfiprintf_r+0xdd4>
    8de4:	orr.w	r6, r6, #16
    8de8:	ands.w	r3, r6, #32
    8dec:	beq.w	934c <_vfiprintf_r+0xa78>
    8df0:	ldr	r3, [sp, #16]
    8df2:	adds	r3, #7
    8df4:	bic.w	r3, r3, #7
    8df8:	mov.w	r2, #0
    8dfc:	strb.w	r2, [sp, #47]	; 0x2f
    8e00:	ldrd	r4, r5, [r3]
    8e04:	add.w	r2, r3, #8
    8e08:	ldr	r3, [sp, #4]
    8e0a:	str	r2, [sp, #16]
    8e0c:	cmp	r3, #0
    8e0e:	blt.w	90fa <_vfiprintf_r+0x826>
    8e12:	orrs.w	r3, r4, r5
    8e16:	bic.w	r6, r6, #128	; 0x80
    8e1a:	bne.w	90fa <_vfiprintf_r+0x826>
    8e1e:	ldr	r3, [sp, #4]
    8e20:	cmp	r3, #0
    8e22:	beq.w	9686 <_vfiprintf_r+0xdb2>
    8e26:	mov.w	r9, #0
    8e2a:	movs	r4, #0
    8e2c:	movs	r5, #0
    8e2e:	mov	r7, fp
    8e30:	lsrs	r2, r4, #3
    8e32:	orr.w	r2, r2, r5, lsl #29
    8e36:	lsrs	r1, r5, #3
    8e38:	and.w	r3, r4, #7
    8e3c:	mov	r5, r1
    8e3e:	mov	r4, r2
    8e40:	adds	r3, #48	; 0x30
    8e42:	orrs.w	r2, r4, r5
    8e46:	strb.w	r3, [r7, #-1]!
    8e4a:	bne.n	8e30 <_vfiprintf_r+0x55c>
    8e4c:	lsls	r4, r6, #31
    8e4e:	bpl.n	8dc6 <_vfiprintf_r+0x4f2>
    8e50:	cmp	r3, #48	; 0x30
    8e52:	beq.n	8dc6 <_vfiprintf_r+0x4f2>
    8e54:	movs	r2, #48	; 0x30
    8e56:	subs	r3, r7, #1
    8e58:	strb.w	r2, [r7, #-1]
    8e5c:	rsb	r2, r3, fp
    8e60:	str	r2, [sp, #12]
    8e62:	mov	r7, r3
    8e64:	b.n	8b14 <_vfiprintf_r+0x240>
    8e66:	sub.w	r2, r3, #48	; 0x30
    8e6a:	movs	r4, #0
    8e6c:	ldrb.w	r3, [r8], #1
    8e70:	add.w	r4, r4, r4, lsl #2
    8e74:	add.w	r4, r2, r4, lsl #1
    8e78:	sub.w	r2, r3, #48	; 0x30
    8e7c:	cmp	r2, #9
    8e7e:	bls.n	8e6c <_vfiprintf_r+0x598>
    8e80:	b.n	89a6 <_vfiprintf_r+0xd2>
    8e82:	ldrb.w	r3, [r8]
    8e86:	movs	r1, #1
    8e88:	movs	r0, #43	; 0x2b
    8e8a:	b.n	89a2 <_vfiprintf_r+0xce>
    8e8c:	ldrb.w	r3, [r8]
    8e90:	cmp	r3, #42	; 0x2a
    8e92:	add.w	r5, r8, #1
    8e96:	beq.w	9654 <_vfiprintf_r+0xd80>
    8e9a:	sub.w	r2, r3, #48	; 0x30
    8e9e:	cmp	r2, #9
    8ea0:	mov	r8, r5
    8ea2:	it	ls
    8ea4:	movls	r5, #0
    8ea6:	bhi.w	9646 <_vfiprintf_r+0xd72>
    8eaa:	ldrb.w	r3, [r8], #1
    8eae:	add.w	r5, r5, r5, lsl #2
    8eb2:	add.w	r5, r2, r5, lsl #1
    8eb6:	sub.w	r2, r3, #48	; 0x30
    8eba:	cmp	r2, #9
    8ebc:	bls.n	8eaa <_vfiprintf_r+0x5d6>
    8ebe:	orr.w	r2, r5, r5, asr #31
    8ec2:	str	r2, [sp, #4]
    8ec4:	b.n	89a6 <_vfiprintf_r+0xd2>
    8ec6:	ldr	r2, [sp, #16]
    8ec8:	ldr	r4, [r2, #0]
    8eca:	mov	r3, r2
    8ecc:	cmp	r4, #0
    8ece:	add.w	r3, r3, #4
    8ed2:	blt.w	8ab0 <_vfiprintf_r+0x1dc>
    8ed6:	str	r3, [sp, #16]
    8ed8:	ldrb.w	r3, [r8]
    8edc:	b.n	89a2 <_vfiprintf_r+0xce>
    8ede:	str	r4, [sp, #24]
    8ee0:	cmp	r1, #0
    8ee2:	beq.n	8de8 <_vfiprintf_r+0x514>
    8ee4:	strb.w	r0, [sp, #47]	; 0x2f
    8ee8:	b.n	8de8 <_vfiprintf_r+0x514>
    8eea:	ldr	r2, [sp, #16]
    8eec:	str	r4, [sp, #24]
    8eee:	ldr	r7, [r2, #0]
    8ef0:	mov.w	r3, #0
    8ef4:	strb.w	r3, [sp, #47]	; 0x2f
    8ef8:	adds	r4, r2, #4
    8efa:	ldr	r3, [sp, #4]
    8efc:	cmp	r7, #0
    8efe:	beq.w	960e <_vfiprintf_r+0xd3a>
    8f02:	cmp	r3, #0
    8f04:	blt.w	95c6 <_vfiprintf_r+0xcf2>
    8f08:	mov	r2, r3
    8f0a:	movs	r1, #0
    8f0c:	mov	r0, r7
    8f0e:	bl	a240 <memchr>
    8f12:	cmp	r0, #0
    8f14:	beq.w	9636 <_vfiprintf_r+0xd62>
    8f18:	subs	r3, r0, r7
    8f1a:	str	r3, [sp, #12]
    8f1c:	movs	r3, #0
    8f1e:	str	r4, [sp, #16]
    8f20:	ldrb.w	r9, [sp, #47]	; 0x2f
    8f24:	str	r3, [sp, #4]
    8f26:	b.n	8b14 <_vfiprintf_r+0x240>
    8f28:	str	r4, [sp, #24]
    8f2a:	cmp	r1, #0
    8f2c:	bne.w	96a2 <_vfiprintf_r+0xdce>
    8f30:	ands.w	r9, r6, #32
    8f34:	bne.n	8fa2 <_vfiprintf_r+0x6ce>
    8f36:	ands.w	r3, r6, #16
    8f3a:	bne.n	8f44 <_vfiprintf_r+0x670>
    8f3c:	ands.w	r9, r6, #64	; 0x40
    8f40:	bne.w	9598 <_vfiprintf_r+0xcc4>
    8f44:	ldr	r2, [sp, #16]
    8f46:	mov	r3, r2
    8f48:	ldr	r4, [r2, #0]
    8f4a:	ldr	r2, [sp, #4]
    8f4c:	strb.w	r9, [sp, #47]	; 0x2f
    8f50:	cmp	r2, #0
    8f52:	add.w	r3, r3, #4
    8f56:	mov.w	r5, #0
    8f5a:	blt.w	95c2 <_vfiprintf_r+0xcee>
    8f5e:	orrs.w	r2, r4, r5
    8f62:	bic.w	r6, r6, #128	; 0x80
    8f66:	str	r3, [sp, #16]
    8f68:	bne.w	8d92 <_vfiprintf_r+0x4be>
    8f6c:	ldr	r3, [sp, #4]
    8f6e:	cmp	r3, #0
    8f70:	beq.w	8b0c <_vfiprintf_r+0x238>
    8f74:	movs	r4, #0
    8f76:	add	r7, sp, #168	; 0xa8
    8f78:	adds	r4, #48	; 0x30
    8f7a:	strb.w	r4, [r7, #-65]!
    8f7e:	rsb	r3, r7, fp
    8f82:	str	r3, [sp, #12]
    8f84:	b.n	8b14 <_vfiprintf_r+0x240>
    8f86:	orr.w	r6, r6, #32
    8f8a:	ldrb.w	r3, [r8]
    8f8e:	b.n	89a2 <_vfiprintf_r+0xce>
    8f90:	str	r4, [sp, #24]
    8f92:	cmp	r1, #0
    8f94:	bne.w	9674 <_vfiprintf_r+0xda0>
    8f98:	orr.w	r6, r6, #16
    8f9c:	ands.w	r9, r6, #32
    8fa0:	beq.n	8f36 <_vfiprintf_r+0x662>
    8fa2:	ldr	r3, [sp, #16]
    8fa4:	adds	r3, #7
    8fa6:	bic.w	r3, r3, #7
    8faa:	mov.w	r2, #0
    8fae:	strb.w	r2, [sp, #47]	; 0x2f
    8fb2:	ldrd	r4, r5, [r3]
    8fb6:	add.w	r2, r3, #8
    8fba:	ldr	r3, [sp, #4]
    8fbc:	str	r2, [sp, #16]
    8fbe:	cmp	r3, #0
    8fc0:	blt.w	93b6 <_vfiprintf_r+0xae2>
    8fc4:	orrs.w	r3, r4, r5
    8fc8:	bic.w	r6, r6, #128	; 0x80
    8fcc:	mov.w	r9, #0
    8fd0:	bne.w	8d92 <_vfiprintf_r+0x4be>
    8fd4:	b.n	8f6c <_vfiprintf_r+0x698>
    8fd6:	str	r4, [sp, #24]
    8fd8:	cmp	r1, #0
    8fda:	bne.w	9680 <_vfiprintf_r+0xdac>
    8fde:	lsls	r2, r6, #26
    8fe0:	ldr	r0, [pc, #696]	; (929c <_vfiprintf_r+0x9c8>)
    8fe2:	bpl.n	9068 <_vfiprintf_r+0x794>
    8fe4:	ldr	r2, [sp, #16]
    8fe6:	adds	r2, #7
    8fe8:	bic.w	r2, r2, #7
    8fec:	ldrd	r4, r5, [r2]
    8ff0:	add.w	r1, r2, #8
    8ff4:	str	r1, [sp, #16]
    8ff6:	ands.w	r9, r6, #1
    8ffa:	beq.w	92ec <_vfiprintf_r+0xa18>
    8ffe:	orrs.w	r2, r4, r5
    9002:	bne.w	9452 <_vfiprintf_r+0xb7e>
    9006:	mov.w	r3, #0
    900a:	strb.w	r3, [sp, #47]	; 0x2f
    900e:	ldr	r3, [sp, #4]
    9010:	cmp	r3, #0
    9012:	blt.w	9342 <_vfiprintf_r+0xa6e>
    9016:	bic.w	r6, r6, #128	; 0x80
    901a:	b.n	8b02 <_vfiprintf_r+0x22e>
    901c:	ldr	r2, [sp, #16]
    901e:	str	r4, [sp, #24]
    9020:	ldr	r3, [r2, #0]
    9022:	strb.w	r3, [sp, #64]	; 0x40
    9026:	mov	r3, r2
    9028:	mov.w	r1, #0
    902c:	movs	r5, #1
    902e:	adds	r3, #4
    9030:	strb.w	r1, [sp, #47]	; 0x2f
    9034:	str	r3, [sp, #16]
    9036:	str	r5, [sp, #12]
    9038:	add	r7, sp, #64	; 0x40
    903a:	movs	r3, #0
    903c:	str	r3, [sp, #4]
    903e:	b.n	8b28 <_vfiprintf_r+0x254>
    9040:	ldrb.w	r3, [r8]
    9044:	cmp	r0, #0
    9046:	bne.w	89a2 <_vfiprintf_r+0xce>
    904a:	movs	r1, #1
    904c:	movs	r0, #32
    904e:	b.n	89a2 <_vfiprintf_r+0xce>
    9050:	orr.w	r6, r6, #1
    9054:	ldrb.w	r3, [r8]
    9058:	b.n	89a2 <_vfiprintf_r+0xce>
    905a:	str	r4, [sp, #24]
    905c:	cmp	r1, #0
    905e:	bne.w	967a <_vfiprintf_r+0xda6>
    9062:	lsls	r2, r6, #26
    9064:	ldr	r0, [pc, #568]	; (92a0 <_vfiprintf_r+0x9cc>)
    9066:	bmi.n	8fe4 <_vfiprintf_r+0x710>
    9068:	ldr	r1, [sp, #16]
    906a:	lsls	r7, r6, #27
    906c:	mov	r2, r1
    906e:	bmi.w	93ac <_vfiprintf_r+0xad8>
    9072:	lsls	r5, r6, #25
    9074:	bpl.w	93ac <_vfiprintf_r+0xad8>
    9078:	adds	r2, #4
    907a:	ldrh	r4, [r1, #0]
    907c:	str	r2, [sp, #16]
    907e:	movs	r5, #0
    9080:	b.n	8ff6 <_vfiprintf_r+0x722>
    9082:	orr.w	r6, r6, #64	; 0x40
    9086:	ldrb.w	r3, [r8]
    908a:	b.n	89a2 <_vfiprintf_r+0xce>
    908c:	ldrb.w	r3, [r8]
    9090:	cmp	r3, #108	; 0x6c
    9092:	ittte	eq
    9094:	ldrbeq.w	r3, [r8, #1]
    9098:	orreq.w	r6, r6, #32
    909c:	addeq.w	r8, r8, #1
    90a0:	orrne.w	r6, r6, #16
    90a4:	b.n	89a2 <_vfiprintf_r+0xce>
    90a6:	cmp	r1, #0
    90a8:	bne.w	96be <_vfiprintf_r+0xdea>
    90ac:	lsls	r4, r6, #26
    90ae:	bpl.w	94ea <_vfiprintf_r+0xc16>
    90b2:	ldr	r2, [sp, #16]
    90b4:	ldr	r1, [sp, #8]
    90b6:	ldr	r3, [r2, #0]
    90b8:	asrs	r5, r1, #31
    90ba:	mov	r0, r1
    90bc:	adds	r2, #4
    90be:	mov	r1, r5
    90c0:	str	r2, [sp, #16]
    90c2:	strd	r0, r1, [r3]
    90c6:	b.n	8936 <_vfiprintf_r+0x62>
    90c8:	str	r4, [sp, #24]
    90ca:	cmp	r1, #0
    90cc:	beq.w	8d56 <_vfiprintf_r+0x482>
    90d0:	strb.w	r0, [sp, #47]	; 0x2f
    90d4:	b.n	8d56 <_vfiprintf_r+0x482>
    90d6:	str	r4, [sp, #24]
    90d8:	cmp	r1, #0
    90da:	bne.w	96b8 <_vfiprintf_r+0xde4>
    90de:	cmp	r3, #0
    90e0:	beq.w	9202 <_vfiprintf_r+0x92e>
    90e4:	movs	r5, #1
    90e6:	strb.w	r3, [sp, #64]	; 0x40
    90ea:	mov.w	r3, #0
    90ee:	strb.w	r3, [sp, #47]	; 0x2f
    90f2:	str	r5, [sp, #12]
    90f4:	add	r7, sp, #64	; 0x40
    90f6:	b.n	903a <_vfiprintf_r+0x766>
    90f8:	str	r3, [sp, #16]
    90fa:	mov.w	r9, #0
    90fe:	b.n	8e2e <_vfiprintf_r+0x55a>
    9100:	add	r2, sp, #52	; 0x34
    9102:	ldr	r1, [sp, #0]
    9104:	str	r3, [sp, #36]	; 0x24
    9106:	mov	r0, r9
    9108:	bl	885c <__sprint_r.part.0>
    910c:	cmp	r0, #0
    910e:	bne.n	9210 <_vfiprintf_r+0x93c>
    9110:	ldr	r0, [sp, #56]	; 0x38
    9112:	ldr	r2, [sp, #60]	; 0x3c
    9114:	ldr	r3, [sp, #36]	; 0x24
    9116:	add.w	lr, r0, #1
    911a:	mov	ip, fp
    911c:	b.n	8b72 <_vfiprintf_r+0x29e>
    911e:	ldr	r0, [sp, #56]	; 0x38
    9120:	ldr	r2, [sp, #60]	; 0x3c
    9122:	add.w	lr, r0, #1
    9126:	ldrb.w	r3, [sp, #47]	; 0x2f
    912a:	cmp	r3, #0
    912c:	beq.w	8bd0 <_vfiprintf_r+0x2fc>
    9130:	adds	r2, #1
    9132:	add.w	r1, sp, #47	; 0x2f
    9136:	movs	r3, #1
    9138:	cmp.w	lr, #7
    913c:	str	r2, [sp, #60]	; 0x3c
    913e:	str.w	lr, [sp, #56]	; 0x38
    9142:	stmia.w	sl, {r1, r3}
    9146:	ble.w	92c8 <_vfiprintf_r+0x9f4>
    914a:	cmp	r2, #0
    914c:	bne.w	93ec <_vfiprintf_r+0xb18>
    9150:	ldr	r1, [sp, #28]
    9152:	cmp	r1, #0
    9154:	bne.w	92d4 <_vfiprintf_r+0xa00>
    9158:	mov	lr, r3
    915a:	mov	r0, r2
    915c:	mov	sl, fp
    915e:	ldr	r3, [sp, #32]
    9160:	cmp	r3, #128	; 0x80
    9162:	beq.w	8c06 <_vfiprintf_r+0x332>
    9166:	ldr	r3, [sp, #4]
    9168:	ldr	r1, [sp, #12]
    916a:	subs	r4, r3, r1
    916c:	cmp	r4, #0
    916e:	ble.w	8c98 <_vfiprintf_r+0x3c4>
    9172:	cmp	r4, #16
    9174:	ldr.w	r9, [pc, #300]	; 92a4 <_vfiprintf_r+0x9d0>
    9178:	ble.n	91c6 <_vfiprintf_r+0x8f2>
    917a:	mov	ip, sl
    917c:	movs	r3, #16
    917e:	mov	sl, r8
    9180:	mov	r8, r5
    9182:	mov	r5, r9
    9184:	ldr.w	r9, [sp, #20]
    9188:	b.n	919a <_vfiprintf_r+0x8c6>
    918a:	add.w	lr, r0, #2
    918e:	add.w	ip, ip, #8
    9192:	mov	r0, r1
    9194:	subs	r4, #16
    9196:	cmp	r4, #16
    9198:	ble.n	91be <_vfiprintf_r+0x8ea>
    919a:	adds	r1, r0, #1
    919c:	adds	r2, #16
    919e:	cmp	r1, #7
    91a0:	str	r2, [sp, #60]	; 0x3c
    91a2:	str.w	r5, [ip]
    91a6:	str.w	r3, [ip, #4]
    91aa:	str	r1, [sp, #56]	; 0x38
    91ac:	ble.n	918a <_vfiprintf_r+0x8b6>
    91ae:	cbnz	r2, 91e6 <_vfiprintf_r+0x912>
    91b0:	subs	r4, #16
    91b2:	cmp	r4, #16
    91b4:	mov.w	lr, #1
    91b8:	mov	r0, r2
    91ba:	mov	ip, fp
    91bc:	bgt.n	919a <_vfiprintf_r+0x8c6>
    91be:	mov	r9, r5
    91c0:	mov	r5, r8
    91c2:	mov	r8, sl
    91c4:	mov	sl, ip
    91c6:	add	r2, r4
    91c8:	cmp.w	lr, #7
    91cc:	str	r2, [sp, #60]	; 0x3c
    91ce:	str.w	r9, [sl]
    91d2:	str.w	r4, [sl, #4]
    91d6:	str.w	lr, [sp, #56]	; 0x38
    91da:	bgt.n	923a <_vfiprintf_r+0x966>
    91dc:	add.w	sl, sl, #8
    91e0:	add.w	lr, lr, #1
    91e4:	b.n	8c98 <_vfiprintf_r+0x3c4>
    91e6:	add	r2, sp, #52	; 0x34
    91e8:	ldr	r1, [sp, #0]
    91ea:	str	r3, [sp, #4]
    91ec:	mov	r0, r9
    91ee:	bl	885c <__sprint_r.part.0>
    91f2:	cbnz	r0, 9210 <_vfiprintf_r+0x93c>
    91f4:	ldr	r0, [sp, #56]	; 0x38
    91f6:	ldr	r2, [sp, #60]	; 0x3c
    91f8:	ldr	r3, [sp, #4]
    91fa:	add.w	lr, r0, #1
    91fe:	mov	ip, fp
    9200:	b.n	9194 <_vfiprintf_r+0x8c0>
    9202:	ldr	r3, [sp, #60]	; 0x3c
    9204:	cbz	r3, 9210 <_vfiprintf_r+0x93c>
    9206:	ldr	r0, [sp, #20]
    9208:	ldr	r1, [sp, #0]
    920a:	add	r2, sp, #52	; 0x34
    920c:	bl	885c <__sprint_r.part.0>
    9210:	ldr	r3, [sp, #0]
    9212:	ldrh	r3, [r3, #12]
    9214:	lsls	r2, r3, #25
    9216:	bmi.w	9530 <_vfiprintf_r+0xc5c>
    921a:	ldr	r0, [sp, #8]
    921c:	add	sp, #172	; 0xac
    921e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9222:	add	r2, sp, #52	; 0x34
    9224:	ldr	r1, [sp, #0]
    9226:	mov	r0, r9
    9228:	bl	885c <__sprint_r.part.0>
    922c:	cmp	r0, #0
    922e:	bne.n	9210 <_vfiprintf_r+0x93c>
    9230:	ldr	r1, [sp, #56]	; 0x38
    9232:	ldr	r2, [sp, #60]	; 0x3c
    9234:	adds	r0, r1, #1
    9236:	mov	sl, fp
    9238:	b.n	8ce6 <_vfiprintf_r+0x412>
    923a:	cmp	r2, #0
    923c:	bne.w	9436 <_vfiprintf_r+0xb62>
    9240:	ldr	r2, [sp, #12]
    9242:	str	r2, [sp, #108]	; 0x6c
    9244:	movs	r3, #1
    9246:	str	r2, [sp, #60]	; 0x3c
    9248:	str	r7, [sp, #104]	; 0x68
    924a:	str	r3, [sp, #56]	; 0x38
    924c:	mov	sl, fp
    924e:	add.w	sl, sl, #8
    9252:	lsls	r1, r6, #29
    9254:	bpl.n	9260 <_vfiprintf_r+0x98c>
    9256:	ldr	r3, [sp, #24]
    9258:	subs	r4, r3, r5
    925a:	cmp	r4, #0
    925c:	bgt.w	8cc8 <_vfiprintf_r+0x3f4>
    9260:	ldr	r3, [sp, #8]
    9262:	ldr	r1, [sp, #24]
    9264:	cmp	r1, r5
    9266:	ite	ge
    9268:	addge	r3, r3, r1
    926a:	addlt	r3, r3, r5
    926c:	str	r3, [sp, #8]
    926e:	cmp	r2, #0
    9270:	bne.w	93da <_vfiprintf_r+0xb06>
    9274:	movs	r3, #0
    9276:	str	r3, [sp, #56]	; 0x38
    9278:	mov	sl, fp
    927a:	b.w	8936 <_vfiprintf_r+0x62>
    927e:	add	r2, sp, #52	; 0x34
    9280:	ldr	r1, [sp, #0]
    9282:	str	r3, [sp, #28]
    9284:	mov	r0, r9
    9286:	bl	885c <__sprint_r.part.0>
    928a:	cmp	r0, #0
    928c:	bne.n	9210 <_vfiprintf_r+0x93c>
    928e:	ldr	r0, [sp, #56]	; 0x38
    9290:	ldr	r2, [sp, #60]	; 0x3c
    9292:	ldr	r3, [sp, #28]
    9294:	add.w	ip, r0, #1
    9298:	mov	lr, fp
    929a:	b.n	8c34 <_vfiprintf_r+0x360>
    929c:	.word	0x20000eb8
    92a0:	.word	0x20000ecc
    92a4:	.word	0x20000e98
    92a8:	cmp	r2, #0
    92aa:	bne.w	9514 <_vfiprintf_r+0xc40>
    92ae:	ldrb.w	r3, [sp, #47]	; 0x2f
    92b2:	cmp	r3, #0
    92b4:	beq.w	94a2 <_vfiprintf_r+0xbce>
    92b8:	movs	r3, #1
    92ba:	add.w	r1, sp, #47	; 0x2f
    92be:	mov	r2, r3
    92c0:	str	r3, [sp, #108]	; 0x6c
    92c2:	mov	lr, r3
    92c4:	str	r1, [sp, #104]	; 0x68
    92c6:	mov	sl, fp
    92c8:	mov	r0, lr
    92ca:	add.w	sl, sl, #8
    92ce:	add.w	lr, lr, #1
    92d2:	b.n	8bd0 <_vfiprintf_r+0x2fc>
    92d4:	add	r1, sp, #48	; 0x30
    92d6:	movs	r2, #2
    92d8:	mov	lr, r3
    92da:	str	r1, [sp, #104]	; 0x68
    92dc:	str	r2, [sp, #108]	; 0x6c
    92de:	mov	sl, fp
    92e0:	mov	r0, lr
    92e2:	add.w	sl, sl, #8
    92e6:	add.w	lr, lr, #1
    92ea:	b.n	915e <_vfiprintf_r+0x88a>
    92ec:	ldr	r3, [sp, #4]
    92ee:	strb.w	r9, [sp, #47]	; 0x2f
    92f2:	cmp	r3, #0
    92f4:	blt.w	954c <_vfiprintf_r+0xc78>
    92f8:	orrs.w	r3, r4, r5
    92fc:	bic.w	r6, r6, #128	; 0x80
    9300:	beq.w	8b02 <_vfiprintf_r+0x22e>
    9304:	mov	r7, fp
    9306:	lsrs	r3, r4, #4
    9308:	and.w	r1, r4, #15
    930c:	orr.w	r3, r3, r5, lsl #28
    9310:	lsrs	r2, r5, #4
    9312:	mov	r4, r3
    9314:	mov	r5, r2
    9316:	ldrb	r3, [r0, r1]
    9318:	strb.w	r3, [r7, #-1]!
    931c:	orrs.w	r3, r4, r5
    9320:	bne.n	9306 <_vfiprintf_r+0xa32>
    9322:	rsb	r3, r7, fp
    9326:	str	r3, [sp, #12]
    9328:	b.w	8b14 <_vfiprintf_r+0x240>
    932c:	add	r2, sp, #52	; 0x34
    932e:	ldr	r1, [sp, #0]
    9330:	ldr	r0, [sp, #20]
    9332:	bl	885c <__sprint_r.part.0>
    9336:	cmp	r0, #0
    9338:	bne.w	9210 <_vfiprintf_r+0x93c>
    933c:	ldr	r2, [sp, #60]	; 0x3c
    933e:	mov	sl, fp
    9340:	b.n	9252 <_vfiprintf_r+0x97e>
    9342:	mov.w	r9, #0
    9346:	movs	r4, #0
    9348:	movs	r5, #0
    934a:	b.n	9304 <_vfiprintf_r+0xa30>
    934c:	ands.w	r2, r6, #16
    9350:	beq.w	94b8 <_vfiprintf_r+0xbe4>
    9354:	ldr	r1, [sp, #16]
    9356:	strb.w	r3, [sp, #47]	; 0x2f
    935a:	mov	r2, r1
    935c:	ldr	r4, [r1, #0]
    935e:	ldr	r1, [sp, #4]
    9360:	cmp	r1, #0
    9362:	add.w	r2, r2, #4
    9366:	mov.w	r5, #0
    936a:	blt.w	9620 <_vfiprintf_r+0xd4c>
    936e:	orrs.w	r1, r4, r5
    9372:	bic.w	r6, r6, #128	; 0x80
    9376:	str	r2, [sp, #16]
    9378:	beq.w	8e1e <_vfiprintf_r+0x54a>
    937c:	mov	r9, r3
    937e:	b.n	8e2e <_vfiprintf_r+0x55a>
    9380:	lsls	r7, r6, #27
    9382:	bmi.n	939a <_vfiprintf_r+0xac6>
    9384:	lsls	r5, r6, #25
    9386:	bpl.n	939a <_vfiprintf_r+0xac6>
    9388:	ldr	r1, [sp, #16]
    938a:	ldrsh.w	r4, [r1]
    938e:	adds	r1, #4
    9390:	asrs	r5, r4, #31
    9392:	mov	r2, r4
    9394:	mov	r3, r5
    9396:	str	r1, [sp, #16]
    9398:	b.n	8d70 <_vfiprintf_r+0x49c>
    939a:	ldr	r2, [sp, #16]
    939c:	ldr	r4, [r2, #0]
    939e:	mov	r3, r2
    93a0:	adds	r3, #4
    93a2:	asrs	r5, r4, #31
    93a4:	str	r3, [sp, #16]
    93a6:	mov	r2, r4
    93a8:	mov	r3, r5
    93aa:	b.n	8d70 <_vfiprintf_r+0x49c>
    93ac:	ldr	r4, [r2, #0]
    93ae:	adds	r2, #4
    93b0:	str	r2, [sp, #16]
    93b2:	movs	r5, #0
    93b4:	b.n	8ff6 <_vfiprintf_r+0x722>
    93b6:	mov.w	r9, #0
    93ba:	orrs.w	r3, r4, r5
    93be:	bne.w	8d92 <_vfiprintf_r+0x4be>
    93c2:	b.n	8f76 <_vfiprintf_r+0x6a2>
    93c4:	add	r2, sp, #52	; 0x34
    93c6:	ldr	r1, [sp, #0]
    93c8:	ldr	r0, [sp, #20]
    93ca:	bl	885c <__sprint_r.part.0>
    93ce:	cmp	r0, #0
    93d0:	bne.w	9210 <_vfiprintf_r+0x93c>
    93d4:	mov	sl, fp
    93d6:	b.w	8a6a <_vfiprintf_r+0x196>
    93da:	add	r2, sp, #52	; 0x34
    93dc:	ldr	r1, [sp, #0]
    93de:	ldr	r0, [sp, #20]
    93e0:	bl	885c <__sprint_r.part.0>
    93e4:	cmp	r0, #0
    93e6:	beq.w	9274 <_vfiprintf_r+0x9a0>
    93ea:	b.n	9210 <_vfiprintf_r+0x93c>
    93ec:	add	r2, sp, #52	; 0x34
    93ee:	ldr	r1, [sp, #0]
    93f0:	ldr	r0, [sp, #20]
    93f2:	bl	885c <__sprint_r.part.0>
    93f6:	cmp	r0, #0
    93f8:	bne.w	9210 <_vfiprintf_r+0x93c>
    93fc:	ldr	r0, [sp, #56]	; 0x38
    93fe:	ldr	r2, [sp, #60]	; 0x3c
    9400:	add.w	lr, r0, #1
    9404:	mov	sl, fp
    9406:	b.w	8bd0 <_vfiprintf_r+0x2fc>
    940a:	add	r2, sp, #52	; 0x34
    940c:	ldr	r1, [sp, #0]
    940e:	ldr	r0, [sp, #20]
    9410:	bl	885c <__sprint_r.part.0>
    9414:	cmp	r0, #0
    9416:	bne.w	9210 <_vfiprintf_r+0x93c>
    941a:	ldr	r0, [sp, #56]	; 0x38
    941c:	ldr	r2, [sp, #60]	; 0x3c
    941e:	add.w	lr, r0, #1
    9422:	mov	sl, fp
    9424:	b.n	915e <_vfiprintf_r+0x88a>
    9426:	cmp	r2, #0
    9428:	bne.w	95dc <_vfiprintf_r+0xd08>
    942c:	mov.w	lr, #1
    9430:	mov	r0, r2
    9432:	mov	sl, fp
    9434:	b.n	9166 <_vfiprintf_r+0x892>
    9436:	add	r2, sp, #52	; 0x34
    9438:	ldr	r1, [sp, #0]
    943a:	ldr	r0, [sp, #20]
    943c:	bl	885c <__sprint_r.part.0>
    9440:	cmp	r0, #0
    9442:	bne.w	9210 <_vfiprintf_r+0x93c>
    9446:	ldr	r3, [sp, #56]	; 0x38
    9448:	ldr	r2, [sp, #60]	; 0x3c
    944a:	add.w	lr, r3, #1
    944e:	mov	sl, fp
    9450:	b.n	8c98 <_vfiprintf_r+0x3c4>
    9452:	movs	r2, #48	; 0x30
    9454:	strb.w	r2, [sp, #48]	; 0x30
    9458:	ldr	r2, [sp, #4]
    945a:	strb.w	r3, [sp, #49]	; 0x31
    945e:	cmp	r2, #0
    9460:	mov.w	r3, #0
    9464:	strb.w	r3, [sp, #47]	; 0x2f
    9468:	orr.w	r3, r6, #2
    946c:	blt.w	9606 <_vfiprintf_r+0xd32>
    9470:	bic.w	r6, r6, #128	; 0x80
    9474:	orr.w	r6, r6, #2
    9478:	mov.w	r9, #0
    947c:	b.n	9304 <_vfiprintf_r+0xa30>
    947e:	mov.w	r9, #0
    9482:	ldr	r0, [pc, #576]	; (96c4 <_vfiprintf_r+0xdf0>)
    9484:	b.n	9304 <_vfiprintf_r+0xa30>
    9486:	ldr	r3, [sp, #4]
    9488:	negs	r4, r4
    948a:	mov.w	r9, #45	; 0x2d
    948e:	sbc.w	r5, r5, r5, lsl #1
    9492:	cmp	r3, #0
    9494:	strb.w	r9, [sp, #47]	; 0x2f
    9498:	blt.w	8d92 <_vfiprintf_r+0x4be>
    949c:	bic.w	r6, r6, #128	; 0x80
    94a0:	b.n	8d92 <_vfiprintf_r+0x4be>
    94a2:	ldr	r3, [sp, #28]
    94a4:	cmp	r3, #0
    94a6:	beq.n	958e <_vfiprintf_r+0xcba>
    94a8:	add	r3, sp, #48	; 0x30
    94aa:	movs	r2, #2
    94ac:	str	r3, [sp, #104]	; 0x68
    94ae:	str	r2, [sp, #108]	; 0x6c
    94b0:	mov.w	lr, #1
    94b4:	mov	sl, fp
    94b6:	b.n	92e0 <_vfiprintf_r+0xa0c>
    94b8:	ands.w	r9, r6, #64	; 0x40
    94bc:	beq.n	9550 <_vfiprintf_r+0xc7c>
    94be:	ldr	r1, [sp, #16]
    94c0:	strb.w	r2, [sp, #47]	; 0x2f
    94c4:	mov	r3, r1
    94c6:	ldrh	r4, [r1, #0]
    94c8:	ldr	r1, [sp, #4]
    94ca:	cmp	r1, #0
    94cc:	add.w	r3, r3, #4
    94d0:	mov.w	r5, #0
    94d4:	blt.w	90f8 <_vfiprintf_r+0x824>
    94d8:	orrs.w	r1, r4, r5
    94dc:	bic.w	r6, r6, #128	; 0x80
    94e0:	str	r3, [sp, #16]
    94e2:	beq.w	8e1e <_vfiprintf_r+0x54a>
    94e6:	mov	r9, r2
    94e8:	b.n	8e2e <_vfiprintf_r+0x55a>
    94ea:	lsls	r0, r6, #27
    94ec:	bmi.n	9504 <_vfiprintf_r+0xc30>
    94ee:	lsls	r1, r6, #25
    94f0:	bpl.n	9504 <_vfiprintf_r+0xc30>
    94f2:	ldr	r2, [sp, #16]
    94f4:	ldr	r3, [r2, #0]
    94f6:	adds	r2, #4
    94f8:	str	r2, [sp, #16]
    94fa:	ldrh.w	r2, [sp, #8]
    94fe:	strh	r2, [r3, #0]
    9500:	b.w	8936 <_vfiprintf_r+0x62>
    9504:	ldr	r2, [sp, #16]
    9506:	ldr	r3, [r2, #0]
    9508:	adds	r2, #4
    950a:	str	r2, [sp, #16]
    950c:	ldr	r2, [sp, #8]
    950e:	str	r2, [r3, #0]
    9510:	b.w	8936 <_vfiprintf_r+0x62>
    9514:	add	r2, sp, #52	; 0x34
    9516:	ldr	r1, [sp, #0]
    9518:	ldr	r0, [sp, #20]
    951a:	bl	885c <__sprint_r.part.0>
    951e:	cmp	r0, #0
    9520:	bne.w	9210 <_vfiprintf_r+0x93c>
    9524:	ldr	r0, [sp, #56]	; 0x38
    9526:	ldr	r2, [sp, #60]	; 0x3c
    9528:	add.w	lr, r0, #1
    952c:	mov	sl, fp
    952e:	b.n	9126 <_vfiprintf_r+0x852>
    9530:	mov.w	r0, #4294967295
    9534:	b.w	8aa4 <_vfiprintf_r+0x1d0>
    9538:	ldr	r0, [pc, #392]	; (96c4 <_vfiprintf_r+0xdf0>)
    953a:	mov	r6, r2
    953c:	orrs.w	r2, r4, r5
    9540:	str	r3, [sp, #16]
    9542:	mov.w	r9, #0
    9546:	bne.w	9304 <_vfiprintf_r+0xa30>
    954a:	b.n	9346 <_vfiprintf_r+0xa72>
    954c:	ldr	r3, [sp, #16]
    954e:	b.n	953c <_vfiprintf_r+0xc68>
    9550:	ldr	r2, [sp, #16]
    9552:	strb.w	r9, [sp, #47]	; 0x2f
    9556:	mov	r3, r2
    9558:	ldr	r4, [r2, #0]
    955a:	ldr	r2, [sp, #4]
    955c:	cmp	r2, #0
    955e:	add.w	r3, r3, #4
    9562:	mov.w	r5, #0
    9566:	blt.w	90f8 <_vfiprintf_r+0x824>
    956a:	orrs.w	r2, r4, r5
    956e:	bic.w	r6, r6, #128	; 0x80
    9572:	str	r3, [sp, #16]
    9574:	bne.w	8e2e <_vfiprintf_r+0x55a>
    9578:	b.n	8e1e <_vfiprintf_r+0x54a>
    957a:	add	r2, sp, #52	; 0x34
    957c:	ldr	r1, [sp, #0]
    957e:	ldr	r0, [sp, #20]
    9580:	bl	885c <__sprint_r.part.0>
    9584:	cmp	r0, #0
    9586:	bne.w	9210 <_vfiprintf_r+0x93c>
    958a:	ldr	r2, [sp, #60]	; 0x3c
    958c:	b.n	9260 <_vfiprintf_r+0x98c>
    958e:	mov	r0, r2
    9590:	mov.w	lr, #1
    9594:	mov	sl, fp
    9596:	b.n	9166 <_vfiprintf_r+0x892>
    9598:	ldr	r1, [sp, #16]
    959a:	strb.w	r3, [sp, #47]	; 0x2f
    959e:	mov	r2, r1
    95a0:	ldrh	r4, [r1, #0]
    95a2:	ldr	r1, [sp, #4]
    95a4:	cmp	r1, #0
    95a6:	add.w	r2, r2, #4
    95aa:	mov.w	r5, #0
    95ae:	blt.n	964e <_vfiprintf_r+0xd7a>
    95b0:	orrs.w	r1, r4, r5
    95b4:	bic.w	r6, r6, #128	; 0x80
    95b8:	str	r2, [sp, #16]
    95ba:	mov	r9, r3
    95bc:	bne.w	8d92 <_vfiprintf_r+0x4be>
    95c0:	b.n	8f6c <_vfiprintf_r+0x698>
    95c2:	str	r3, [sp, #16]
    95c4:	b.n	93ba <_vfiprintf_r+0xae6>
    95c6:	mov	r0, r7
    95c8:	str	r4, [sp, #16]
    95ca:	bl	8780 <strlen>
    95ce:	movs	r3, #0
    95d0:	str	r0, [sp, #12]
    95d2:	ldrb.w	r9, [sp, #47]	; 0x2f
    95d6:	str	r3, [sp, #4]
    95d8:	b.w	8b14 <_vfiprintf_r+0x240>
    95dc:	add	r2, sp, #52	; 0x34
    95de:	ldr	r1, [sp, #0]
    95e0:	ldr	r0, [sp, #20]
    95e2:	bl	885c <__sprint_r.part.0>
    95e6:	cmp	r0, #0
    95e8:	bne.w	9210 <_vfiprintf_r+0x93c>
    95ec:	ldr	r0, [sp, #56]	; 0x38
    95ee:	ldr	r2, [sp, #60]	; 0x3c
    95f0:	add.w	lr, r0, #1
    95f4:	mov	sl, fp
    95f6:	b.n	9166 <_vfiprintf_r+0x892>
    95f8:	ldr	r0, [sp, #56]	; 0x38
    95fa:	ldr	r2, [sp, #60]	; 0x3c
    95fc:	ldr.w	r9, [pc, #204]	; 96cc <_vfiprintf_r+0xdf8>
    9600:	adds	r0, #1
    9602:	b.w	8baa <_vfiprintf_r+0x2d6>
    9606:	mov	r6, r3
    9608:	mov.w	r9, #0
    960c:	b.n	9304 <_vfiprintf_r+0xa30>
    960e:	cmp	r3, #6
    9610:	it	cs
    9612:	movcs	r3, #6
    9614:	str	r3, [sp, #12]
    9616:	str	r4, [sp, #16]
    9618:	bic.w	r5, r3, r3, asr #31
    961c:	ldr	r7, [pc, #168]	; (96c8 <_vfiprintf_r+0xdf4>)
    961e:	b.n	903a <_vfiprintf_r+0x766>
    9620:	str	r2, [sp, #16]
    9622:	b.n	90fa <_vfiprintf_r+0x826>
    9624:	ldr	r0, [sp, #56]	; 0x38
    9626:	ldr.w	r9, [pc, #164]	; 96cc <_vfiprintf_r+0xdf8>
    962a:	adds	r0, #1
    962c:	b.w	8d16 <_vfiprintf_r+0x442>
    9630:	mov	ip, lr
    9632:	b.w	8c6a <_vfiprintf_r+0x396>
    9636:	ldr	r3, [sp, #4]
    9638:	ldrb.w	r9, [sp, #47]	; 0x2f
    963c:	str	r3, [sp, #12]
    963e:	str	r4, [sp, #16]
    9640:	str	r0, [sp, #4]
    9642:	b.w	8b14 <_vfiprintf_r+0x240>
    9646:	movs	r2, #0
    9648:	str	r2, [sp, #4]
    964a:	b.w	89a6 <_vfiprintf_r+0xd2>
    964e:	str	r2, [sp, #16]
    9650:	mov	r9, r3
    9652:	b.n	93ba <_vfiprintf_r+0xae6>
    9654:	ldr	r2, [sp, #16]
    9656:	ldr	r3, [r2, #0]
    9658:	str	r3, [sp, #4]
    965a:	adds	r2, #4
    965c:	cmp	r3, #0
    965e:	str	r2, [sp, #16]
    9660:	ldrb.w	r3, [r8, #1]
    9664:	mov	r8, r5
    9666:	bge.w	89a2 <_vfiprintf_r+0xce>
    966a:	mov.w	r2, #4294967295
    966e:	str	r2, [sp, #4]
    9670:	b.w	89a2 <_vfiprintf_r+0xce>
    9674:	strb.w	r0, [sp, #47]	; 0x2f
    9678:	b.n	8f98 <_vfiprintf_r+0x6c4>
    967a:	strb.w	r0, [sp, #47]	; 0x2f
    967e:	b.n	9062 <_vfiprintf_r+0x78e>
    9680:	strb.w	r0, [sp, #47]	; 0x2f
    9684:	b.n	8fde <_vfiprintf_r+0x70a>
    9686:	mov	r9, r3
    9688:	lsls	r3, r6, #31
    968a:	bpl.n	9698 <_vfiprintf_r+0xdc4>
    968c:	add	r7, sp, #168	; 0xa8
    968e:	movs	r3, #48	; 0x30
    9690:	strb.w	r3, [r7, #-65]!
    9694:	b.w	8dc6 <_vfiprintf_r+0x4f2>
    9698:	ldr	r3, [sp, #4]
    969a:	str	r3, [sp, #12]
    969c:	mov	r7, fp
    969e:	b.w	8b14 <_vfiprintf_r+0x240>
    96a2:	strb.w	r0, [sp, #47]	; 0x2f
    96a6:	b.n	8f30 <_vfiprintf_r+0x65c>
    96a8:	strb.w	r0, [sp, #47]	; 0x2f
    96ac:	b.w	8de4 <_vfiprintf_r+0x510>
    96b0:	strb.w	r0, [sp, #47]	; 0x2f
    96b4:	b.w	8d52 <_vfiprintf_r+0x47e>
    96b8:	strb.w	r0, [sp, #47]	; 0x2f
    96bc:	b.n	90de <_vfiprintf_r+0x80a>
    96be:	strb.w	r0, [sp, #47]	; 0x2f
    96c2:	b.n	90ac <_vfiprintf_r+0x7d8>
    96c4:	.word	0x20000ecc
    96c8:	.word	0x20000ee0
    96cc:	.word	0x20000ea8

000096d0 <__sbprintf>:
    96d0:	push	{r4, r5, r6, r7, lr}
    96d2:	mov	r4, r1
    96d4:	subw	sp, sp, #1132	; 0x46c
    96d8:	ldrh	r1, [r1, #12]
    96da:	ldr	r6, [r4, #100]	; 0x64
    96dc:	ldrh	r5, [r4, #14]
    96de:	str	r6, [sp, #100]	; 0x64
    96e0:	bic.w	r1, r1, #2
    96e4:	ldr	r6, [r4, #36]	; 0x24
    96e6:	strh.w	r5, [sp, #14]
    96ea:	movs	r5, #0
    96ec:	ldr	r7, [r4, #28]
    96ee:	strh.w	r1, [sp, #12]
    96f2:	str	r6, [sp, #36]	; 0x24
    96f4:	str	r5, [sp, #24]
    96f6:	add	r6, sp, #104	; 0x68
    96f8:	mov.w	r5, #1024	; 0x400
    96fc:	mov	r1, sp
    96fe:	str	r6, [sp, #0]
    9700:	str	r6, [sp, #16]
    9702:	str	r5, [sp, #8]
    9704:	str	r5, [sp, #20]
    9706:	str	r7, [sp, #28]
    9708:	mov	r6, r0
    970a:	bl	88d4 <_vfiprintf_r>
    970e:	subs	r5, r0, #0
    9710:	blt.n	9722 <__sbprintf+0x52>
    9712:	mov	r0, r6
    9714:	mov	r1, sp
    9716:	bl	9994 <_fflush_r>
    971a:	cmp	r0, #0
    971c:	it	ne
    971e:	movne.w	r5, #4294967295
    9722:	ldrh.w	r3, [sp, #12]
    9726:	lsls	r3, r3, #25
    9728:	bpl.n	9732 <__sbprintf+0x62>
    972a:	ldrh	r3, [r4, #12]
    972c:	orr.w	r3, r3, #64	; 0x40
    9730:	strh	r3, [r4, #12]
    9732:	mov	r0, r5
    9734:	addw	sp, sp, #1132	; 0x46c
    9738:	pop	{r4, r5, r6, r7, pc}
    973a:	nop

0000973c <__ascii_wctomb>:
    973c:	cbz	r1, 9748 <__ascii_wctomb+0xc>
    973e:	cmp	r2, #255	; 0xff
    9740:	bhi.n	974c <__ascii_wctomb+0x10>
    9742:	strb	r2, [r1, #0]
    9744:	movs	r0, #1
    9746:	bx	lr
    9748:	mov	r0, r1
    974a:	bx	lr
    974c:	movs	r3, #138	; 0x8a
    974e:	str	r3, [r0, #0]
    9750:	mov.w	r0, #4294967295
    9754:	bx	lr
    9756:	nop

00009758 <_write_r>:
    9758:	push	{r4, r5, r6, lr}
    975a:	mov	r5, r1
    975c:	ldr	r4, [pc, #32]	; (9780 <_write_r+0x28>)
    975e:	mov	r1, r2
    9760:	mov	r6, r0
    9762:	mov	r2, r3
    9764:	mov	r0, r5
    9766:	movs	r3, #0
    9768:	str	r3, [r4, #0]
    976a:	bl	4024 <_write>
    976e:	adds	r3, r0, #1
    9770:	beq.n	9774 <_write_r+0x1c>
    9772:	pop	{r4, r5, r6, pc}
    9774:	ldr	r3, [r4, #0]
    9776:	cmp	r3, #0
    9778:	beq.n	9772 <_write_r+0x1a>
    977a:	str	r3, [r6, #0]
    977c:	pop	{r4, r5, r6, pc}
    977e:	nop
    9780:	.word	0x20004290

00009784 <__swsetup_r>:
    9784:	push	{r3, r4, r5, lr}
    9786:	ldr	r3, [pc, #192]	; (9848 <__swsetup_r+0xc4>)
    9788:	ldr	r3, [r3, #0]
    978a:	mov	r5, r0
    978c:	mov	r4, r1
    978e:	cbz	r3, 9796 <__swsetup_r+0x12>
    9790:	ldr	r2, [r3, #56]	; 0x38
    9792:	cmp	r2, #0
    9794:	beq.n	9808 <__swsetup_r+0x84>
    9796:	ldrsh.w	r2, [r4, #12]
    979a:	uxth	r3, r2
    979c:	lsls	r0, r3, #28
    979e:	bpl.n	97ba <__swsetup_r+0x36>
    97a0:	ldr	r0, [r4, #16]
    97a2:	cbz	r0, 97d0 <__swsetup_r+0x4c>
    97a4:	ands.w	r2, r3, #1
    97a8:	beq.n	97e8 <__swsetup_r+0x64>
    97aa:	ldr	r3, [r4, #20]
    97ac:	movs	r2, #0
    97ae:	negs	r3, r3
    97b0:	str	r3, [r4, #24]
    97b2:	str	r2, [r4, #8]
    97b4:	cbz	r0, 97f4 <__swsetup_r+0x70>
    97b6:	movs	r0, #0
    97b8:	pop	{r3, r4, r5, pc}
    97ba:	lsls	r1, r3, #27
    97bc:	bpl.n	9838 <__swsetup_r+0xb4>
    97be:	lsls	r0, r3, #29
    97c0:	bmi.n	9810 <__swsetup_r+0x8c>
    97c2:	ldr	r0, [r4, #16]
    97c4:	orr.w	r3, r2, #8
    97c8:	strh	r3, [r4, #12]
    97ca:	uxth	r3, r3
    97cc:	cmp	r0, #0
    97ce:	bne.n	97a4 <__swsetup_r+0x20>
    97d0:	and.w	r2, r3, #640	; 0x280
    97d4:	cmp.w	r2, #512	; 0x200
    97d8:	beq.n	97a4 <__swsetup_r+0x20>
    97da:	mov	r0, r5
    97dc:	mov	r1, r4
    97de:	bl	a1b4 <__smakebuf_r>
    97e2:	ldrh	r3, [r4, #12]
    97e4:	ldr	r0, [r4, #16]
    97e6:	b.n	97a4 <__swsetup_r+0x20>
    97e8:	lsls	r1, r3, #30
    97ea:	it	pl
    97ec:	ldrpl	r2, [r4, #20]
    97ee:	str	r2, [r4, #8]
    97f0:	cmp	r0, #0
    97f2:	bne.n	97b6 <__swsetup_r+0x32>
    97f4:	ldrsh.w	r3, [r4, #12]
    97f8:	lsls	r2, r3, #24
    97fa:	bpl.n	97b8 <__swsetup_r+0x34>
    97fc:	orr.w	r3, r3, #64	; 0x40
    9800:	strh	r3, [r4, #12]
    9802:	mov.w	r0, #4294967295
    9806:	pop	{r3, r4, r5, pc}
    9808:	mov	r0, r3
    980a:	bl	9abc <__sinit>
    980e:	b.n	9796 <__swsetup_r+0x12>
    9810:	ldr	r1, [r4, #48]	; 0x30
    9812:	cbz	r1, 982a <__swsetup_r+0xa6>
    9814:	add.w	r3, r4, #64	; 0x40
    9818:	cmp	r1, r3
    981a:	beq.n	9826 <__swsetup_r+0xa2>
    981c:	mov	r0, r5
    981e:	bl	9c2c <_free_r>
    9822:	ldrsh.w	r2, [r4, #12]
    9826:	movs	r3, #0
    9828:	str	r3, [r4, #48]	; 0x30
    982a:	movs	r3, #0
    982c:	ldr	r0, [r4, #16]
    982e:	str	r3, [r4, #4]
    9830:	bic.w	r2, r2, #36	; 0x24
    9834:	str	r0, [r4, #0]
    9836:	b.n	97c4 <__swsetup_r+0x40>
    9838:	orr.w	r2, r2, #64	; 0x40
    983c:	movs	r3, #9
    983e:	str	r3, [r5, #0]
    9840:	mov.w	r0, #4294967295
    9844:	strh	r2, [r4, #12]
    9846:	pop	{r3, r4, r5, pc}
    9848:	.word	0x20001450

0000984c <__sflush_r>:
    984c:	ldrsh.w	r3, [r1, #12]
    9850:	uxth	r2, r3
    9852:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9856:	mov	r5, r1
    9858:	lsls	r1, r2, #28
    985a:	mov	r8, r0
    985c:	bmi.n	98d8 <__sflush_r+0x8c>
    985e:	ldr	r2, [r5, #4]
    9860:	orr.w	r3, r3, #2048	; 0x800
    9864:	cmp	r2, #0
    9866:	strh	r3, [r5, #12]
    9868:	ble.n	9952 <__sflush_r+0x106>
    986a:	ldr	r4, [r5, #40]	; 0x28
    986c:	cmp	r4, #0
    986e:	beq.n	9908 <__sflush_r+0xbc>
    9870:	uxth	r3, r3
    9872:	and.w	r2, r3, #4096	; 0x1000
    9876:	movs	r1, #0
    9878:	uxth	r2, r2
    987a:	ldr.w	r6, [r8]
    987e:	str.w	r1, [r8]
    9882:	cmp	r2, #0
    9884:	beq.n	995a <__sflush_r+0x10e>
    9886:	ldr	r2, [r5, #80]	; 0x50
    9888:	lsls	r7, r3, #29
    988a:	bpl.n	9898 <__sflush_r+0x4c>
    988c:	ldr	r1, [r5, #4]
    988e:	ldr	r3, [r5, #48]	; 0x30
    9890:	subs	r2, r2, r1
    9892:	cbz	r3, 9898 <__sflush_r+0x4c>
    9894:	ldr	r3, [r5, #60]	; 0x3c
    9896:	subs	r2, r2, r3
    9898:	movs	r3, #0
    989a:	ldr	r1, [r5, #28]
    989c:	mov	r0, r8
    989e:	blx	r4
    98a0:	adds	r4, r0, #1
    98a2:	beq.n	991e <__sflush_r+0xd2>
    98a4:	ldrsh.w	r3, [r5, #12]
    98a8:	ldr	r2, [r5, #16]
    98aa:	str	r2, [r5, #0]
    98ac:	bic.w	r3, r3, #2048	; 0x800
    98b0:	movs	r2, #0
    98b2:	strh	r3, [r5, #12]
    98b4:	lsls	r3, r3, #19
    98b6:	str	r2, [r5, #4]
    98b8:	bmi.n	994e <__sflush_r+0x102>
    98ba:	ldr	r1, [r5, #48]	; 0x30
    98bc:	str.w	r6, [r8]
    98c0:	cbz	r1, 9908 <__sflush_r+0xbc>
    98c2:	add.w	r3, r5, #64	; 0x40
    98c6:	cmp	r1, r3
    98c8:	beq.n	98d0 <__sflush_r+0x84>
    98ca:	mov	r0, r8
    98cc:	bl	9c2c <_free_r>
    98d0:	movs	r0, #0
    98d2:	str	r0, [r5, #48]	; 0x30
    98d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    98d8:	ldr	r6, [r5, #16]
    98da:	cbz	r6, 9908 <__sflush_r+0xbc>
    98dc:	ldr	r4, [r5, #0]
    98de:	str	r6, [r5, #0]
    98e0:	lsls	r0, r2, #30
    98e2:	ite	eq
    98e4:	ldreq	r3, [r5, #20]
    98e6:	movne	r3, #0
    98e8:	subs	r4, r4, r6
    98ea:	str	r3, [r5, #8]
    98ec:	b.n	9904 <__sflush_r+0xb8>
    98ee:	mov	r3, r4
    98f0:	mov	r2, r6
    98f2:	ldr	r7, [r5, #36]	; 0x24
    98f4:	ldr	r1, [r5, #28]
    98f6:	mov	r0, r8
    98f8:	blx	r7
    98fa:	cmp	r0, #0
    98fc:	sub.w	r4, r4, r0
    9900:	add	r6, r0
    9902:	ble.n	990e <__sflush_r+0xc2>
    9904:	cmp	r4, #0
    9906:	bgt.n	98ee <__sflush_r+0xa2>
    9908:	movs	r0, #0
    990a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    990e:	ldrh	r3, [r5, #12]
    9910:	orr.w	r3, r3, #64	; 0x40
    9914:	strh	r3, [r5, #12]
    9916:	mov.w	r0, #4294967295
    991a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    991e:	ldr.w	r2, [r8]
    9922:	cmp	r2, #29
    9924:	bhi.n	990e <__sflush_r+0xc2>
    9926:	ldr	r3, [pc, #104]	; (9990 <__sflush_r+0x144>)
    9928:	lsrs	r3, r2
    992a:	and.w	r3, r3, #1
    992e:	eor.w	r4, r3, #1
    9932:	cmp	r3, #0
    9934:	beq.n	990e <__sflush_r+0xc2>
    9936:	ldrsh.w	r3, [r5, #12]
    993a:	ldr	r1, [r5, #16]
    993c:	str	r1, [r5, #0]
    993e:	bic.w	r3, r3, #2048	; 0x800
    9942:	lsls	r1, r3, #19
    9944:	str	r4, [r5, #4]
    9946:	strh	r3, [r5, #12]
    9948:	bpl.n	98ba <__sflush_r+0x6e>
    994a:	cmp	r2, #0
    994c:	bne.n	98ba <__sflush_r+0x6e>
    994e:	str	r0, [r5, #80]	; 0x50
    9950:	b.n	98ba <__sflush_r+0x6e>
    9952:	ldr	r2, [r5, #60]	; 0x3c
    9954:	cmp	r2, #0
    9956:	bgt.n	986a <__sflush_r+0x1e>
    9958:	b.n	9908 <__sflush_r+0xbc>
    995a:	movs	r3, #1
    995c:	ldr	r1, [r5, #28]
    995e:	mov	r0, r8
    9960:	blx	r4
    9962:	adds	r3, r0, #1
    9964:	mov	r2, r0
    9966:	beq.n	996e <__sflush_r+0x122>
    9968:	ldrh	r3, [r5, #12]
    996a:	ldr	r4, [r5, #40]	; 0x28
    996c:	b.n	9888 <__sflush_r+0x3c>
    996e:	ldr.w	r3, [r8]
    9972:	cmp	r3, #0
    9974:	beq.n	9968 <__sflush_r+0x11c>
    9976:	cmp	r3, #29
    9978:	beq.n	997e <__sflush_r+0x132>
    997a:	cmp	r3, #22
    997c:	bne.n	9984 <__sflush_r+0x138>
    997e:	str.w	r6, [r8]
    9982:	b.n	9908 <__sflush_r+0xbc>
    9984:	ldrh	r3, [r5, #12]
    9986:	orr.w	r3, r3, #64	; 0x40
    998a:	strh	r3, [r5, #12]
    998c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9990:	.word	0x20400001

00009994 <_fflush_r>:
    9994:	push	{r4, lr}
    9996:	mov	r4, r0
    9998:	sub	sp, #8
    999a:	cbz	r0, 99a0 <_fflush_r+0xc>
    999c:	ldr	r3, [r0, #56]	; 0x38
    999e:	cbz	r3, 99b6 <_fflush_r+0x22>
    99a0:	ldrsh.w	r0, [r1, #12]
    99a4:	cbnz	r0, 99aa <_fflush_r+0x16>
    99a6:	add	sp, #8
    99a8:	pop	{r4, pc}
    99aa:	mov	r0, r4
    99ac:	add	sp, #8
    99ae:	ldmia.w	sp!, {r4, lr}
    99b2:	b.w	984c <__sflush_r>
    99b6:	str	r1, [sp, #4]
    99b8:	bl	9abc <__sinit>
    99bc:	ldr	r1, [sp, #4]
    99be:	b.n	99a0 <_fflush_r+0xc>

000099c0 <_cleanup_r>:
    99c0:	ldr	r1, [pc, #4]	; (99c8 <_cleanup_r+0x8>)
    99c2:	b.w	a100 <_fwalk_reent>
    99c6:	nop
    99c8:	.word	0x0000a48d

000099cc <__sinit.part.1>:
    99cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    99d0:	ldr	r3, [pc, #212]	; (9aa8 <__sinit.part.1+0xdc>)
    99d2:	ldr	r5, [r0, #4]
    99d4:	str	r3, [r0, #60]	; 0x3c
    99d6:	movs	r4, #0
    99d8:	mov	r7, r0
    99da:	add.w	r2, r0, #748	; 0x2ec
    99de:	movs	r3, #4
    99e0:	movs	r1, #3
    99e2:	str.w	r1, [r0, #740]	; 0x2e4
    99e6:	str.w	r2, [r0, #744]	; 0x2e8
    99ea:	str.w	r4, [r0, #736]	; 0x2e0
    99ee:	sub	sp, #12
    99f0:	str	r4, [r5, #0]
    99f2:	str	r4, [r5, #4]
    99f4:	str	r4, [r5, #8]
    99f6:	str	r4, [r5, #100]	; 0x64
    99f8:	strh	r4, [r5, #14]
    99fa:	str	r4, [r5, #16]
    99fc:	str	r4, [r5, #20]
    99fe:	str	r4, [r5, #24]
    9a00:	strh	r3, [r5, #12]
    9a02:	mov	r1, r4
    9a04:	add.w	r0, r5, #92	; 0x5c
    9a08:	movs	r2, #8
    9a0a:	bl	82b8 <memset>
    9a0e:	ldr	r6, [r7, #8]
    9a10:	ldr.w	fp, [pc, #152]	; 9aac <__sinit.part.1+0xe0>
    9a14:	ldr.w	sl, [pc, #152]	; 9ab0 <__sinit.part.1+0xe4>
    9a18:	ldr.w	r9, [pc, #152]	; 9ab4 <__sinit.part.1+0xe8>
    9a1c:	ldr.w	r8, [pc, #152]	; 9ab8 <__sinit.part.1+0xec>
    9a20:	str.w	fp, [r5, #32]
    9a24:	movs	r3, #1
    9a26:	movs	r2, #9
    9a28:	str.w	sl, [r5, #36]	; 0x24
    9a2c:	str.w	r9, [r5, #40]	; 0x28
    9a30:	str.w	r8, [r5, #44]	; 0x2c
    9a34:	str	r5, [r5, #28]
    9a36:	mov	r1, r4
    9a38:	strh	r3, [r6, #14]
    9a3a:	strh	r2, [r6, #12]
    9a3c:	add.w	r0, r6, #92	; 0x5c
    9a40:	str	r4, [r6, #0]
    9a42:	str	r4, [r6, #4]
    9a44:	str	r4, [r6, #8]
    9a46:	str	r4, [r6, #100]	; 0x64
    9a48:	str	r4, [r6, #16]
    9a4a:	str	r4, [r6, #20]
    9a4c:	str	r4, [r6, #24]
    9a4e:	movs	r2, #8
    9a50:	str	r3, [sp, #4]
    9a52:	bl	82b8 <memset>
    9a56:	ldr	r5, [r7, #12]
    9a58:	str	r6, [r6, #28]
    9a5a:	movs	r0, #18
    9a5c:	movs	r2, #2
    9a5e:	str.w	fp, [r6, #32]
    9a62:	str.w	sl, [r6, #36]	; 0x24
    9a66:	str.w	r9, [r6, #40]	; 0x28
    9a6a:	str.w	r8, [r6, #44]	; 0x2c
    9a6e:	mov	r1, r4
    9a70:	strh	r0, [r5, #12]
    9a72:	strh	r2, [r5, #14]
    9a74:	str	r4, [r5, #0]
    9a76:	str	r4, [r5, #4]
    9a78:	str	r4, [r5, #8]
    9a7a:	str	r4, [r5, #100]	; 0x64
    9a7c:	str	r4, [r5, #16]
    9a7e:	str	r4, [r5, #20]
    9a80:	str	r4, [r5, #24]
    9a82:	add.w	r0, r5, #92	; 0x5c
    9a86:	movs	r2, #8
    9a88:	bl	82b8 <memset>
    9a8c:	ldr	r3, [sp, #4]
    9a8e:	str	r5, [r5, #28]
    9a90:	str.w	fp, [r5, #32]
    9a94:	str.w	sl, [r5, #36]	; 0x24
    9a98:	str.w	r9, [r5, #40]	; 0x28
    9a9c:	str.w	r8, [r5, #44]	; 0x2c
    9aa0:	str	r3, [r7, #56]	; 0x38
    9aa2:	add	sp, #12
    9aa4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9aa8:	.word	0x000099c1
    9aac:	.word	0x0000a2e1
    9ab0:	.word	0x0000a305
    9ab4:	.word	0x0000a341
    9ab8:	.word	0x0000a361

00009abc <__sinit>:
    9abc:	ldr	r3, [r0, #56]	; 0x38
    9abe:	cbz	r3, 9ac2 <__sinit+0x6>
    9ac0:	bx	lr
    9ac2:	b.w	99cc <__sinit.part.1>
    9ac6:	nop

00009ac8 <__sfp_lock_acquire>:
    9ac8:	bx	lr
    9aca:	nop

00009acc <__sfp_lock_release>:
    9acc:	bx	lr
    9ace:	nop

00009ad0 <__fputwc>:
    9ad0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9ad4:	sub	sp, #8
    9ad6:	mov	r8, r0
    9ad8:	mov	r9, r1
    9ada:	mov	r4, r2
    9adc:	bl	7c38 <__locale_mb_cur_max>
    9ae0:	cmp	r0, #1
    9ae2:	beq.n	9b4c <__fputwc+0x7c>
    9ae4:	add.w	r3, r4, #92	; 0x5c
    9ae8:	mov	r2, r9
    9aea:	add	r1, sp, #4
    9aec:	mov	r0, r8
    9aee:	bl	a414 <_wcrtomb_r>
    9af2:	cmp.w	r0, #4294967295
    9af6:	mov	sl, r0
    9af8:	beq.n	9b3e <__fputwc+0x6e>
    9afa:	cbz	r0, 9b60 <__fputwc+0x90>
    9afc:	ldrb.w	r6, [sp, #4]
    9b00:	movs	r5, #0
    9b02:	b.n	9b16 <__fputwc+0x46>
    9b04:	ldr	r3, [r4, #0]
    9b06:	adds	r2, r3, #1
    9b08:	str	r2, [r4, #0]
    9b0a:	strb	r6, [r3, #0]
    9b0c:	adds	r5, #1
    9b0e:	cmp	r5, sl
    9b10:	bcs.n	9b60 <__fputwc+0x90>
    9b12:	add	r3, sp, #4
    9b14:	ldrb	r6, [r3, r5]
    9b16:	ldr	r3, [r4, #8]
    9b18:	subs	r3, #1
    9b1a:	cmp	r3, #0
    9b1c:	str	r3, [r4, #8]
    9b1e:	bge.n	9b04 <__fputwc+0x34>
    9b20:	ldr	r7, [r4, #24]
    9b22:	cmp	r3, r7
    9b24:	mov	r1, r6
    9b26:	mov	r2, r4
    9b28:	mov	r0, r8
    9b2a:	blt.n	9b30 <__fputwc+0x60>
    9b2c:	cmp	r6, #10
    9b2e:	bne.n	9b04 <__fputwc+0x34>
    9b30:	bl	a368 <__swbuf_r>
    9b34:	adds	r3, r0, #1
    9b36:	bne.n	9b0c <__fputwc+0x3c>
    9b38:	add	sp, #8
    9b3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9b3e:	ldrh	r3, [r4, #12]
    9b40:	orr.w	r3, r3, #64	; 0x40
    9b44:	strh	r3, [r4, #12]
    9b46:	add	sp, #8
    9b48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9b4c:	add.w	r3, r9, #4294967295
    9b50:	cmp	r3, #254	; 0xfe
    9b52:	bhi.n	9ae4 <__fputwc+0x14>
    9b54:	uxtb.w	r6, r9
    9b58:	mov	sl, r0
    9b5a:	strb.w	r6, [sp, #4]
    9b5e:	b.n	9b00 <__fputwc+0x30>
    9b60:	mov	r0, r9
    9b62:	add	sp, #8
    9b64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00009b68 <_fputwc_r>:
    9b68:	ldrsh.w	r3, [r2, #12]
    9b6c:	tst.w	r3, #8192	; 0x2000
    9b70:	bne.n	9b8a <_fputwc_r+0x22>
    9b72:	push	{r4}
    9b74:	ldr	r4, [r2, #100]	; 0x64
    9b76:	orr.w	r3, r3, #8192	; 0x2000
    9b7a:	orr.w	r4, r4, #8192	; 0x2000
    9b7e:	str	r4, [r2, #100]	; 0x64
    9b80:	strh	r3, [r2, #12]
    9b82:	ldr.w	r4, [sp], #4
    9b86:	b.w	9ad0 <__fputwc>
    9b8a:	b.w	9ad0 <__fputwc>
    9b8e:	nop

00009b90 <_malloc_trim_r>:
    9b90:	push	{r3, r4, r5, r6, r7, lr}
    9b92:	ldr	r7, [pc, #140]	; (9c20 <_malloc_trim_r+0x90>)
    9b94:	mov	r4, r1
    9b96:	mov	r6, r0
    9b98:	bl	8354 <__malloc_lock>
    9b9c:	ldr	r3, [r7, #8]
    9b9e:	ldr	r5, [r3, #4]
    9ba0:	bic.w	r5, r5, #3
    9ba4:	subs	r1, r5, r4
    9ba6:	addw	r1, r1, #4079	; 0xfef
    9baa:	bic.w	r1, r1, #4080	; 0xff0
    9bae:	bic.w	r1, r1, #15
    9bb2:	sub.w	r4, r1, #4096	; 0x1000
    9bb6:	cmp.w	r4, #4096	; 0x1000
    9bba:	blt.n	9bcc <_malloc_trim_r+0x3c>
    9bbc:	movs	r1, #0
    9bbe:	mov	r0, r6
    9bc0:	bl	873c <_sbrk_r>
    9bc4:	ldr	r3, [r7, #8]
    9bc6:	add	r3, r5
    9bc8:	cmp	r0, r3
    9bca:	beq.n	9bd6 <_malloc_trim_r+0x46>
    9bcc:	mov	r0, r6
    9bce:	bl	8358 <__malloc_unlock>
    9bd2:	movs	r0, #0
    9bd4:	pop	{r3, r4, r5, r6, r7, pc}
    9bd6:	negs	r1, r4
    9bd8:	mov	r0, r6
    9bda:	bl	873c <_sbrk_r>
    9bde:	adds	r0, #1
    9be0:	beq.n	9bfe <_malloc_trim_r+0x6e>
    9be2:	ldr	r3, [pc, #64]	; (9c24 <_malloc_trim_r+0x94>)
    9be4:	ldr	r2, [r7, #8]
    9be6:	ldr	r1, [r3, #0]
    9be8:	subs	r5, r5, r4
    9bea:	orr.w	r5, r5, #1
    9bee:	mov	r0, r6
    9bf0:	subs	r1, r1, r4
    9bf2:	str	r5, [r2, #4]
    9bf4:	str	r1, [r3, #0]
    9bf6:	bl	8358 <__malloc_unlock>
    9bfa:	movs	r0, #1
    9bfc:	pop	{r3, r4, r5, r6, r7, pc}
    9bfe:	movs	r1, #0
    9c00:	mov	r0, r6
    9c02:	bl	873c <_sbrk_r>
    9c06:	ldr	r2, [r7, #8]
    9c08:	subs	r3, r0, r2
    9c0a:	cmp	r3, #15
    9c0c:	ble.n	9bcc <_malloc_trim_r+0x3c>
    9c0e:	ldr	r4, [pc, #24]	; (9c28 <_malloc_trim_r+0x98>)
    9c10:	ldr	r1, [pc, #16]	; (9c24 <_malloc_trim_r+0x94>)
    9c12:	ldr	r4, [r4, #0]
    9c14:	orr.w	r3, r3, #1
    9c18:	subs	r0, r0, r4
    9c1a:	str	r3, [r2, #4]
    9c1c:	str	r0, [r1, #0]
    9c1e:	b.n	9bcc <_malloc_trim_r+0x3c>
    9c20:	.word	0x200015c0
    9c24:	.word	0x200020ac
    9c28:	.word	0x200019cc

00009c2c <_free_r>:
    9c2c:	cmp	r1, #0
    9c2e:	beq.n	9cbc <_free_r+0x90>
    9c30:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9c34:	mov	r5, r1
    9c36:	mov	r8, r0
    9c38:	bl	8354 <__malloc_lock>
    9c3c:	ldr.w	r7, [r5, #-4]
    9c40:	ldr	r1, [pc, #424]	; (9dec <_free_r+0x1c0>)
    9c42:	bic.w	r3, r7, #1
    9c46:	sub.w	r4, r5, #8
    9c4a:	adds	r2, r4, r3
    9c4c:	ldr	r6, [r1, #8]
    9c4e:	ldr	r0, [r2, #4]
    9c50:	cmp	r2, r6
    9c52:	bic.w	r0, r0, #3
    9c56:	beq.n	9d1e <_free_r+0xf2>
    9c58:	lsls	r6, r7, #31
    9c5a:	str	r0, [r2, #4]
    9c5c:	bmi.n	9c76 <_free_r+0x4a>
    9c5e:	ldr.w	r7, [r5, #-8]
    9c62:	subs	r4, r4, r7
    9c64:	add.w	lr, r1, #8
    9c68:	ldr	r5, [r4, #8]
    9c6a:	cmp	r5, lr
    9c6c:	add	r3, r7
    9c6e:	beq.n	9d50 <_free_r+0x124>
    9c70:	ldr	r7, [r4, #12]
    9c72:	str	r7, [r5, #12]
    9c74:	str	r5, [r7, #8]
    9c76:	adds	r5, r2, r0
    9c78:	ldr	r5, [r5, #4]
    9c7a:	lsls	r5, r5, #31
    9c7c:	bpl.n	9d04 <_free_r+0xd8>
    9c7e:	orr.w	r2, r3, #1
    9c82:	str	r2, [r4, #4]
    9c84:	str	r3, [r4, r3]
    9c86:	cmp.w	r3, #512	; 0x200
    9c8a:	bcs.n	9cbe <_free_r+0x92>
    9c8c:	lsrs	r3, r3, #3
    9c8e:	adds	r2, r3, #1
    9c90:	ldr	r5, [r1, #4]
    9c92:	ldr.w	r7, [r1, r2, lsl #3]
    9c96:	str	r7, [r4, #8]
    9c98:	movs	r0, #1
    9c9a:	asrs	r3, r3, #2
    9c9c:	lsl.w	r3, r0, r3
    9ca0:	add.w	r0, r1, r2, lsl #3
    9ca4:	orrs	r5, r3
    9ca6:	subs	r0, #8
    9ca8:	str	r0, [r4, #12]
    9caa:	str	r5, [r1, #4]
    9cac:	str.w	r4, [r1, r2, lsl #3]
    9cb0:	str	r4, [r7, #12]
    9cb2:	mov	r0, r8
    9cb4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    9cb8:	b.w	8358 <__malloc_unlock>
    9cbc:	bx	lr
    9cbe:	lsrs	r2, r3, #9
    9cc0:	cmp	r2, #4
    9cc2:	bhi.n	9d6c <_free_r+0x140>
    9cc4:	lsrs	r2, r3, #6
    9cc6:	add.w	r7, r2, #57	; 0x39
    9cca:	lsls	r7, r7, #1
    9ccc:	add.w	r5, r2, #56	; 0x38
    9cd0:	add.w	r0, r1, r7, lsl #2
    9cd4:	ldr.w	r2, [r1, r7, lsl #2]
    9cd8:	ldr	r1, [pc, #272]	; (9dec <_free_r+0x1c0>)
    9cda:	subs	r0, #8
    9cdc:	cmp	r0, r2
    9cde:	beq.n	9d7c <_free_r+0x150>
    9ce0:	ldr	r1, [r2, #4]
    9ce2:	bic.w	r1, r1, #3
    9ce6:	cmp	r3, r1
    9ce8:	bcs.n	9cf0 <_free_r+0xc4>
    9cea:	ldr	r2, [r2, #8]
    9cec:	cmp	r0, r2
    9cee:	bne.n	9ce0 <_free_r+0xb4>
    9cf0:	ldr	r0, [r2, #12]
    9cf2:	str	r0, [r4, #12]
    9cf4:	str	r2, [r4, #8]
    9cf6:	str	r4, [r0, #8]
    9cf8:	str	r4, [r2, #12]
    9cfa:	mov	r0, r8
    9cfc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    9d00:	b.w	8358 <__malloc_unlock>
    9d04:	ldr	r5, [r2, #8]
    9d06:	ldr	r7, [pc, #232]	; (9df0 <_free_r+0x1c4>)
    9d08:	cmp	r5, r7
    9d0a:	add	r3, r0
    9d0c:	beq.n	9d8e <_free_r+0x162>
    9d0e:	ldr	r0, [r2, #12]
    9d10:	str	r0, [r5, #12]
    9d12:	orr.w	r2, r3, #1
    9d16:	str	r5, [r0, #8]
    9d18:	str	r2, [r4, #4]
    9d1a:	str	r3, [r4, r3]
    9d1c:	b.n	9c86 <_free_r+0x5a>
    9d1e:	lsls	r7, r7, #31
    9d20:	add	r3, r0
    9d22:	bmi.n	9d34 <_free_r+0x108>
    9d24:	ldr.w	r2, [r5, #-8]
    9d28:	subs	r4, r4, r2
    9d2a:	add	r3, r2
    9d2c:	ldr	r0, [r4, #8]
    9d2e:	ldr	r2, [r4, #12]
    9d30:	str	r2, [r0, #12]
    9d32:	str	r0, [r2, #8]
    9d34:	ldr	r2, [pc, #188]	; (9df4 <_free_r+0x1c8>)
    9d36:	ldr	r2, [r2, #0]
    9d38:	orr.w	r0, r3, #1
    9d3c:	cmp	r3, r2
    9d3e:	str	r0, [r4, #4]
    9d40:	str	r4, [r1, #8]
    9d42:	bcc.n	9cb2 <_free_r+0x86>
    9d44:	ldr	r3, [pc, #176]	; (9df8 <_free_r+0x1cc>)
    9d46:	mov	r0, r8
    9d48:	ldr	r1, [r3, #0]
    9d4a:	bl	9b90 <_malloc_trim_r>
    9d4e:	b.n	9cb2 <_free_r+0x86>
    9d50:	adds	r1, r2, r0
    9d52:	ldr	r1, [r1, #4]
    9d54:	lsls	r1, r1, #31
    9d56:	bmi.n	9de2 <_free_r+0x1b6>
    9d58:	ldr	r1, [r2, #8]
    9d5a:	ldr	r2, [r2, #12]
    9d5c:	str	r2, [r1, #12]
    9d5e:	add	r3, r0
    9d60:	orr.w	r0, r3, #1
    9d64:	str	r1, [r2, #8]
    9d66:	str	r0, [r4, #4]
    9d68:	str	r3, [r4, r3]
    9d6a:	b.n	9cb2 <_free_r+0x86>
    9d6c:	cmp	r2, #20
    9d6e:	bhi.n	9da0 <_free_r+0x174>
    9d70:	add.w	r7, r2, #92	; 0x5c
    9d74:	lsls	r7, r7, #1
    9d76:	add.w	r5, r2, #91	; 0x5b
    9d7a:	b.n	9cd0 <_free_r+0xa4>
    9d7c:	asrs	r2, r5, #2
    9d7e:	ldr	r3, [r1, #4]
    9d80:	movs	r5, #1
    9d82:	lsl.w	r2, r5, r2
    9d86:	orrs	r3, r2
    9d88:	str	r3, [r1, #4]
    9d8a:	mov	r2, r0
    9d8c:	b.n	9cf2 <_free_r+0xc6>
    9d8e:	orr.w	r2, r3, #1
    9d92:	str	r4, [r1, #20]
    9d94:	str	r4, [r1, #16]
    9d96:	str	r5, [r4, #12]
    9d98:	str	r5, [r4, #8]
    9d9a:	str	r2, [r4, #4]
    9d9c:	str	r3, [r4, r3]
    9d9e:	b.n	9cb2 <_free_r+0x86>
    9da0:	cmp	r2, #84	; 0x54
    9da2:	bhi.n	9db2 <_free_r+0x186>
    9da4:	lsrs	r2, r3, #12
    9da6:	add.w	r7, r2, #111	; 0x6f
    9daa:	lsls	r7, r7, #1
    9dac:	add.w	r5, r2, #110	; 0x6e
    9db0:	b.n	9cd0 <_free_r+0xa4>
    9db2:	cmp.w	r2, #340	; 0x154
    9db6:	bhi.n	9dc6 <_free_r+0x19a>
    9db8:	lsrs	r2, r3, #15
    9dba:	add.w	r7, r2, #120	; 0x78
    9dbe:	lsls	r7, r7, #1
    9dc0:	add.w	r5, r2, #119	; 0x77
    9dc4:	b.n	9cd0 <_free_r+0xa4>
    9dc6:	movw	r0, #1364	; 0x554
    9dca:	cmp	r2, r0
    9dcc:	bhi.n	9ddc <_free_r+0x1b0>
    9dce:	lsrs	r2, r3, #18
    9dd0:	add.w	r7, r2, #125	; 0x7d
    9dd4:	lsls	r7, r7, #1
    9dd6:	add.w	r5, r2, #124	; 0x7c
    9dda:	b.n	9cd0 <_free_r+0xa4>
    9ddc:	movs	r7, #254	; 0xfe
    9dde:	movs	r5, #126	; 0x7e
    9de0:	b.n	9cd0 <_free_r+0xa4>
    9de2:	orr.w	r2, r3, #1
    9de6:	str	r2, [r4, #4]
    9de8:	str	r3, [r4, r3]
    9dea:	b.n	9cb2 <_free_r+0x86>
    9dec:	.word	0x200015c0
    9df0:	.word	0x200015c8
    9df4:	.word	0x200019c8
    9df8:	.word	0x200020a8

00009dfc <__sfvwrite_r>:
    9dfc:	ldr	r3, [r2, #8]
    9dfe:	cmp	r3, #0
    9e00:	beq.n	9ef0 <__sfvwrite_r+0xf4>
    9e02:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9e06:	ldrh	r3, [r1, #12]
    9e08:	sub	sp, #20
    9e0a:	mov	r4, r1
    9e0c:	lsls	r1, r3, #28
    9e0e:	str	r0, [sp, #4]
    9e10:	mov	r6, r2
    9e12:	bpl.n	9e68 <__sfvwrite_r+0x6c>
    9e14:	ldr	r2, [r4, #16]
    9e16:	cbz	r2, 9e68 <__sfvwrite_r+0x6c>
    9e18:	and.w	r8, r3, #2
    9e1c:	uxth.w	r0, r8
    9e20:	ldr	r5, [r6, #0]
    9e22:	cmp	r0, #0
    9e24:	beq.n	9e86 <__sfvwrite_r+0x8a>
    9e26:	mov.w	r9, #0
    9e2a:	ldr	r7, [pc, #720]	; (a0fc <__sfvwrite_r+0x300>)
    9e2c:	mov	r8, r9
    9e2e:	mov	sl, r6
    9e30:	cmp	r8, r7
    9e32:	mov	r3, r8
    9e34:	mov	r2, r9
    9e36:	it	cs
    9e38:	movcs	r3, r7
    9e3a:	ldr	r0, [sp, #4]
    9e3c:	cmp.w	r8, #0
    9e40:	beq.n	9ee4 <__sfvwrite_r+0xe8>
    9e42:	ldr	r1, [r4, #28]
    9e44:	ldr	r6, [r4, #36]	; 0x24
    9e46:	blx	r6
    9e48:	cmp	r0, #0
    9e4a:	ble.n	9f30 <__sfvwrite_r+0x134>
    9e4c:	ldr.w	r3, [sl, #8]
    9e50:	subs	r3, r3, r0
    9e52:	add	r9, r0
    9e54:	rsb	r8, r0, r8
    9e58:	str.w	r3, [sl, #8]
    9e5c:	cmp	r3, #0
    9e5e:	bne.n	9e30 <__sfvwrite_r+0x34>
    9e60:	movs	r0, #0
    9e62:	add	sp, #20
    9e64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9e68:	mov	r1, r4
    9e6a:	ldr	r0, [sp, #4]
    9e6c:	bl	9784 <__swsetup_r>
    9e70:	cmp	r0, #0
    9e72:	bne.w	a0ea <__sfvwrite_r+0x2ee>
    9e76:	ldrh	r3, [r4, #12]
    9e78:	ldr	r5, [r6, #0]
    9e7a:	and.w	r8, r3, #2
    9e7e:	uxth.w	r0, r8
    9e82:	cmp	r0, #0
    9e84:	bne.n	9e26 <__sfvwrite_r+0x2a>
    9e86:	ands.w	r9, r3, #1
    9e8a:	bne.n	9f44 <__sfvwrite_r+0x148>
    9e8c:	mov	r7, r9
    9e8e:	str	r6, [sp, #8]
    9e90:	cbz	r7, 9eda <__sfvwrite_r+0xde>
    9e92:	lsls	r2, r3, #22
    9e94:	ldr.w	r8, [r4, #8]
    9e98:	bpl.n	9ef4 <__sfvwrite_r+0xf8>
    9e9a:	cmp	r7, r8
    9e9c:	mov	sl, r8
    9e9e:	bcc.w	9fea <__sfvwrite_r+0x1ee>
    9ea2:	tst.w	r3, #1152	; 0x480
    9ea6:	bne.w	a00c <__sfvwrite_r+0x210>
    9eaa:	ldr	r0, [r4, #0]
    9eac:	mov	r2, sl
    9eae:	mov	r1, r9
    9eb0:	bl	81f0 <memmove>
    9eb4:	ldr	r0, [r4, #8]
    9eb6:	ldr	r3, [r4, #0]
    9eb8:	rsb	r0, r8, r0
    9ebc:	add	r3, sl
    9ebe:	str	r0, [r4, #8]
    9ec0:	str	r3, [r4, #0]
    9ec2:	mov	r0, r7
    9ec4:	ldr	r2, [sp, #8]
    9ec6:	ldr	r3, [r2, #8]
    9ec8:	subs	r3, r3, r0
    9eca:	add	r9, r0
    9ecc:	subs	r7, r7, r0
    9ece:	str	r3, [r2, #8]
    9ed0:	cmp	r3, #0
    9ed2:	beq.n	9e60 <__sfvwrite_r+0x64>
    9ed4:	ldrh	r3, [r4, #12]
    9ed6:	cmp	r7, #0
    9ed8:	bne.n	9e92 <__sfvwrite_r+0x96>
    9eda:	ldr.w	r9, [r5]
    9ede:	ldr	r7, [r5, #4]
    9ee0:	adds	r5, #8
    9ee2:	b.n	9e90 <__sfvwrite_r+0x94>
    9ee4:	ldr.w	r9, [r5]
    9ee8:	ldr.w	r8, [r5, #4]
    9eec:	adds	r5, #8
    9eee:	b.n	9e30 <__sfvwrite_r+0x34>
    9ef0:	movs	r0, #0
    9ef2:	bx	lr
    9ef4:	ldr	r0, [r4, #0]
    9ef6:	ldr	r3, [r4, #16]
    9ef8:	cmp	r0, r3
    9efa:	bhi.n	9f04 <__sfvwrite_r+0x108>
    9efc:	ldr	r1, [r4, #20]
    9efe:	cmp	r7, r1
    9f00:	bcs.w	a072 <__sfvwrite_r+0x276>
    9f04:	cmp	r8, r7
    9f06:	it	cs
    9f08:	movcs	r8, r7
    9f0a:	mov	r2, r8
    9f0c:	mov	r1, r9
    9f0e:	bl	81f0 <memmove>
    9f12:	ldr	r3, [r4, #8]
    9f14:	ldr	r2, [r4, #0]
    9f16:	rsb	r3, r8, r3
    9f1a:	add	r2, r8
    9f1c:	str	r3, [r4, #8]
    9f1e:	str	r2, [r4, #0]
    9f20:	cmp	r3, #0
    9f22:	bne.n	9fb8 <__sfvwrite_r+0x1bc>
    9f24:	mov	r1, r4
    9f26:	ldr	r0, [sp, #4]
    9f28:	bl	9994 <_fflush_r>
    9f2c:	cmp	r0, #0
    9f2e:	beq.n	9fb8 <__sfvwrite_r+0x1bc>
    9f30:	ldrsh.w	r3, [r4, #12]
    9f34:	orr.w	r3, r3, #64	; 0x40
    9f38:	mov.w	r0, #4294967295
    9f3c:	strh	r3, [r4, #12]
    9f3e:	add	sp, #20
    9f40:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9f44:	mov	r8, r0
    9f46:	str	r0, [sp, #8]
    9f48:	mov	sl, r0
    9f4a:	mov	r9, r0
    9f4c:	cmp.w	r9, #0
    9f50:	beq.n	9fa8 <__sfvwrite_r+0x1ac>
    9f52:	ldr	r3, [sp, #8]
    9f54:	cmp	r3, #0
    9f56:	beq.n	9ff2 <__sfvwrite_r+0x1f6>
    9f58:	ldr	r0, [r4, #0]
    9f5a:	ldr	r3, [r4, #16]
    9f5c:	ldr	r2, [r4, #20]
    9f5e:	cmp	r8, r9
    9f60:	mov	fp, r8
    9f62:	it	cs
    9f64:	movcs	fp, r9
    9f66:	cmp	r0, r3
    9f68:	mov	r7, fp
    9f6a:	bls.n	9f76 <__sfvwrite_r+0x17a>
    9f6c:	ldr	r3, [r4, #8]
    9f6e:	add	r3, r2
    9f70:	cmp	fp, r3
    9f72:	bgt.w	a096 <__sfvwrite_r+0x29a>
    9f76:	cmp	fp, r2
    9f78:	blt.n	9fbc <__sfvwrite_r+0x1c0>
    9f7a:	mov	r3, r2
    9f7c:	ldr	r7, [r4, #36]	; 0x24
    9f7e:	ldr	r1, [r4, #28]
    9f80:	ldr	r0, [sp, #4]
    9f82:	mov	r2, sl
    9f84:	blx	r7
    9f86:	subs	r7, r0, #0
    9f88:	ble.n	9f30 <__sfvwrite_r+0x134>
    9f8a:	subs.w	r8, r8, r7
    9f8e:	beq.n	9fd8 <__sfvwrite_r+0x1dc>
    9f90:	ldr	r3, [r6, #8]
    9f92:	subs	r3, r3, r7
    9f94:	add	sl, r7
    9f96:	rsb	r9, r7, r9
    9f9a:	str	r3, [r6, #8]
    9f9c:	cmp	r3, #0
    9f9e:	beq.w	9e60 <__sfvwrite_r+0x64>
    9fa2:	cmp.w	r9, #0
    9fa6:	bne.n	9f52 <__sfvwrite_r+0x156>
    9fa8:	movs	r3, #0
    9faa:	ldr.w	sl, [r5]
    9fae:	ldr.w	r9, [r5, #4]
    9fb2:	str	r3, [sp, #8]
    9fb4:	adds	r5, #8
    9fb6:	b.n	9f4c <__sfvwrite_r+0x150>
    9fb8:	mov	r0, r8
    9fba:	b.n	9ec4 <__sfvwrite_r+0xc8>
    9fbc:	mov	r2, fp
    9fbe:	mov	r1, sl
    9fc0:	bl	81f0 <memmove>
    9fc4:	ldr	r2, [r4, #8]
    9fc6:	ldr	r3, [r4, #0]
    9fc8:	rsb	r2, fp, r2
    9fcc:	add	r3, fp
    9fce:	subs.w	r8, r8, r7
    9fd2:	str	r2, [r4, #8]
    9fd4:	str	r3, [r4, #0]
    9fd6:	bne.n	9f90 <__sfvwrite_r+0x194>
    9fd8:	mov	r1, r4
    9fda:	ldr	r0, [sp, #4]
    9fdc:	bl	9994 <_fflush_r>
    9fe0:	cmp	r0, #0
    9fe2:	bne.n	9f30 <__sfvwrite_r+0x134>
    9fe4:	str.w	r8, [sp, #8]
    9fe8:	b.n	9f90 <__sfvwrite_r+0x194>
    9fea:	ldr	r0, [r4, #0]
    9fec:	mov	r8, r7
    9fee:	mov	sl, r7
    9ff0:	b.n	9eac <__sfvwrite_r+0xb0>
    9ff2:	mov	r2, r9
    9ff4:	movs	r1, #10
    9ff6:	mov	r0, sl
    9ff8:	bl	a240 <memchr>
    9ffc:	cmp	r0, #0
    9ffe:	beq.n	a0e0 <__sfvwrite_r+0x2e4>
    a000:	adds	r0, #1
    a002:	movs	r3, #1
    a004:	rsb	r8, sl, r0
    a008:	str	r3, [sp, #8]
    a00a:	b.n	9f58 <__sfvwrite_r+0x15c>
    a00c:	ldr	r2, [r4, #20]
    a00e:	ldr	r0, [r4, #0]
    a010:	ldr	r1, [r4, #16]
    a012:	add.w	r8, r2, r2, lsl #1
    a016:	rsb	sl, r1, r0
    a01a:	add.w	r8, r8, r8, lsr #31
    a01e:	add.w	r0, sl, #1
    a022:	mov.w	r8, r8, asr #1
    a026:	add	r0, r7
    a028:	cmp	r0, r8
    a02a:	mov	r2, r8
    a02c:	itt	hi
    a02e:	movhi	r8, r0
    a030:	movhi	r2, r8
    a032:	lsls	r3, r3, #21
    a034:	bpl.n	a0bc <__sfvwrite_r+0x2c0>
    a036:	mov	r1, r2
    a038:	ldr	r0, [sp, #4]
    a03a:	bl	7c54 <_malloc_r>
    a03e:	mov	fp, r0
    a040:	cmp	r0, #0
    a042:	beq.n	a0f0 <__sfvwrite_r+0x2f4>
    a044:	mov	r2, sl
    a046:	ldr	r1, [r4, #16]
    a048:	bl	2a74 <memcpy>
    a04c:	ldrh	r3, [r4, #12]
    a04e:	bic.w	r3, r3, #1152	; 0x480
    a052:	orr.w	r3, r3, #128	; 0x80
    a056:	strh	r3, [r4, #12]
    a058:	rsb	r3, sl, r8
    a05c:	add.w	r0, fp, sl
    a060:	str.w	r8, [r4, #20]
    a064:	str.w	fp, [r4, #16]
    a068:	str	r0, [r4, #0]
    a06a:	str	r3, [r4, #8]
    a06c:	mov	r8, r7
    a06e:	mov	sl, r7
    a070:	b.n	9eac <__sfvwrite_r+0xb0>
    a072:	mvn.w	r3, #2147483648	; 0x80000000
    a076:	cmp	r3, r7
    a078:	it	cs
    a07a:	movcs	r3, r7
    a07c:	mov	r2, r9
    a07e:	sdiv	r3, r3, r1
    a082:	ldr	r0, [sp, #4]
    a084:	ldr	r6, [r4, #36]	; 0x24
    a086:	mul.w	r3, r1, r3
    a08a:	ldr	r1, [r4, #28]
    a08c:	blx	r6
    a08e:	cmp	r0, #0
    a090:	bgt.w	9ec4 <__sfvwrite_r+0xc8>
    a094:	b.n	9f30 <__sfvwrite_r+0x134>
    a096:	mov	r2, r3
    a098:	mov	r1, sl
    a09a:	str	r3, [sp, #12]
    a09c:	bl	81f0 <memmove>
    a0a0:	ldr	r2, [r4, #0]
    a0a2:	ldr	r3, [sp, #12]
    a0a4:	ldr	r0, [sp, #4]
    a0a6:	add	r2, r3
    a0a8:	str	r2, [r4, #0]
    a0aa:	mov	r1, r4
    a0ac:	bl	9994 <_fflush_r>
    a0b0:	ldr	r3, [sp, #12]
    a0b2:	cmp	r0, #0
    a0b4:	bne.w	9f30 <__sfvwrite_r+0x134>
    a0b8:	mov	r7, r3
    a0ba:	b.n	9f8a <__sfvwrite_r+0x18e>
    a0bc:	ldr	r0, [sp, #4]
    a0be:	bl	835c <_realloc_r>
    a0c2:	mov	fp, r0
    a0c4:	cmp	r0, #0
    a0c6:	bne.n	a058 <__sfvwrite_r+0x25c>
    a0c8:	ldr	r5, [sp, #4]
    a0ca:	ldr	r1, [r4, #16]
    a0cc:	mov	r0, r5
    a0ce:	bl	9c2c <_free_r>
    a0d2:	ldrsh.w	r3, [r4, #12]
    a0d6:	movs	r2, #12
    a0d8:	bic.w	r3, r3, #128	; 0x80
    a0dc:	str	r2, [r5, #0]
    a0de:	b.n	9f34 <__sfvwrite_r+0x138>
    a0e0:	movs	r3, #1
    a0e2:	add.w	r8, r9, #1
    a0e6:	str	r3, [sp, #8]
    a0e8:	b.n	9f58 <__sfvwrite_r+0x15c>
    a0ea:	mov.w	r0, #4294967295
    a0ee:	b.n	9e62 <__sfvwrite_r+0x66>
    a0f0:	ldr	r2, [sp, #4]
    a0f2:	movs	r3, #12
    a0f4:	str	r3, [r2, #0]
    a0f6:	ldrsh.w	r3, [r4, #12]
    a0fa:	b.n	9f34 <__sfvwrite_r+0x138>
    a0fc:	.word	0x7ffffc00

0000a100 <_fwalk_reent>:
    a100:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a104:	adds.w	r7, r0, #736	; 0x2e0
    a108:	beq.n	a14a <_fwalk_reent+0x4a>
    a10a:	mov	r8, r1
    a10c:	mov	r6, r0
    a10e:	mov.w	r9, #0
    a112:	ldr	r5, [r7, #4]
    a114:	ldr	r4, [r7, #8]
    a116:	subs	r5, #1
    a118:	bmi.n	a13e <_fwalk_reent+0x3e>
    a11a:	ldrh	r3, [r4, #12]
    a11c:	cmp	r3, #1
    a11e:	add.w	r5, r5, #4294967295
    a122:	bls.n	a136 <_fwalk_reent+0x36>
    a124:	ldrsh.w	r3, [r4, #14]
    a128:	adds	r3, #1
    a12a:	mov	r1, r4
    a12c:	mov	r0, r6
    a12e:	beq.n	a136 <_fwalk_reent+0x36>
    a130:	blx	r8
    a132:	orr.w	r9, r9, r0
    a136:	adds	r3, r5, #1
    a138:	add.w	r4, r4, #104	; 0x68
    a13c:	bne.n	a11a <_fwalk_reent+0x1a>
    a13e:	ldr	r7, [r7, #0]
    a140:	cmp	r7, #0
    a142:	bne.n	a112 <_fwalk_reent+0x12>
    a144:	mov	r0, r9
    a146:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a14a:	mov	r9, r7
    a14c:	mov	r0, r9
    a14e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a152:	nop

0000a154 <__swhatbuf_r>:
    a154:	push	{r4, r5, r6, lr}
    a156:	mov	r5, r1
    a158:	ldrsh.w	r1, [r1, #14]
    a15c:	cmp	r1, #0
    a15e:	sub	sp, #64	; 0x40
    a160:	mov	r4, r2
    a162:	mov	r6, r3
    a164:	blt.n	a190 <__swhatbuf_r+0x3c>
    a166:	add	r2, sp, #4
    a168:	bl	a510 <_fstat_r>
    a16c:	cmp	r0, #0
    a16e:	blt.n	a190 <__swhatbuf_r+0x3c>
    a170:	ldr	r2, [sp, #8]
    a172:	and.w	r2, r2, #61440	; 0xf000
    a176:	sub.w	r2, r2, #8192	; 0x2000
    a17a:	clz	r2, r2
    a17e:	lsrs	r2, r2, #5
    a180:	mov.w	r3, #1024	; 0x400
    a184:	mov.w	r0, #2048	; 0x800
    a188:	str	r2, [r6, #0]
    a18a:	str	r3, [r4, #0]
    a18c:	add	sp, #64	; 0x40
    a18e:	pop	{r4, r5, r6, pc}
    a190:	ldrh	r0, [r5, #12]
    a192:	and.w	r0, r0, #128	; 0x80
    a196:	uxth	r2, r0
    a198:	movs	r0, #0
    a19a:	str	r0, [r6, #0]
    a19c:	cbz	r2, a1a6 <__swhatbuf_r+0x52>
    a19e:	movs	r3, #64	; 0x40
    a1a0:	str	r3, [r4, #0]
    a1a2:	add	sp, #64	; 0x40
    a1a4:	pop	{r4, r5, r6, pc}
    a1a6:	mov.w	r3, #1024	; 0x400
    a1aa:	mov	r0, r2
    a1ac:	str	r3, [r4, #0]
    a1ae:	add	sp, #64	; 0x40
    a1b0:	pop	{r4, r5, r6, pc}
    a1b2:	nop

0000a1b4 <__smakebuf_r>:
    a1b4:	ldrh	r2, [r1, #12]
    a1b6:	lsls	r2, r2, #30
    a1b8:	mov	r3, r1
    a1ba:	bpl.n	a1ca <__smakebuf_r+0x16>
    a1bc:	add.w	r2, r1, #67	; 0x43
    a1c0:	movs	r1, #1
    a1c2:	str	r2, [r3, #0]
    a1c4:	str	r2, [r3, #16]
    a1c6:	str	r1, [r3, #20]
    a1c8:	bx	lr
    a1ca:	push	{r4, r5, r6, r7, lr}
    a1cc:	sub	sp, #12
    a1ce:	add	r3, sp, #4
    a1d0:	mov	r2, sp
    a1d2:	mov	r4, r1
    a1d4:	mov	r5, r0
    a1d6:	bl	a154 <__swhatbuf_r>
    a1da:	ldr	r1, [sp, #0]
    a1dc:	mov	r6, r0
    a1de:	mov	r0, r5
    a1e0:	bl	7c54 <_malloc_r>
    a1e4:	ldrsh.w	r3, [r4, #12]
    a1e8:	cbz	r0, a220 <__smakebuf_r+0x6c>
    a1ea:	ldr	r2, [sp, #4]
    a1ec:	ldr	r7, [pc, #72]	; (a238 <__smakebuf_r+0x84>)
    a1ee:	ldr	r1, [sp, #0]
    a1f0:	str	r7, [r5, #60]	; 0x3c
    a1f2:	orr.w	r3, r3, #128	; 0x80
    a1f6:	strh	r3, [r4, #12]
    a1f8:	str	r0, [r4, #0]
    a1fa:	str	r0, [r4, #16]
    a1fc:	str	r1, [r4, #20]
    a1fe:	cbnz	r2, a208 <__smakebuf_r+0x54>
    a200:	orrs	r3, r6
    a202:	strh	r3, [r4, #12]
    a204:	add	sp, #12
    a206:	pop	{r4, r5, r6, r7, pc}
    a208:	mov	r0, r5
    a20a:	ldrsh.w	r1, [r4, #14]
    a20e:	bl	a538 <_isatty_r>
    a212:	ldrsh.w	r3, [r4, #12]
    a216:	cmp	r0, #0
    a218:	beq.n	a200 <__smakebuf_r+0x4c>
    a21a:	orr.w	r3, r3, #1
    a21e:	b.n	a200 <__smakebuf_r+0x4c>
    a220:	lsls	r2, r3, #22
    a222:	bmi.n	a204 <__smakebuf_r+0x50>
    a224:	add.w	r2, r4, #67	; 0x43
    a228:	orr.w	r3, r3, #2
    a22c:	movs	r1, #1
    a22e:	strh	r3, [r4, #12]
    a230:	str	r2, [r4, #0]
    a232:	str	r2, [r4, #16]
    a234:	str	r1, [r4, #20]
    a236:	b.n	a204 <__smakebuf_r+0x50>
    a238:	.word	0x000099c1
    a23c:	.word	0x00000000

0000a240 <memchr>:
    a240:	and.w	r1, r1, #255	; 0xff
    a244:	cmp	r2, #16
    a246:	blt.n	a2a0 <memchr+0x60>
    a248:	tst.w	r0, #7
    a24c:	beq.n	a260 <memchr+0x20>
    a24e:	ldrb.w	r3, [r0], #1
    a252:	subs	r2, #1
    a254:	cmp	r3, r1
    a256:	beq.n	a2b4 <memchr+0x74>
    a258:	tst.w	r0, #7
    a25c:	cbz	r2, a2b0 <memchr+0x70>
    a25e:	bne.n	a24e <memchr+0xe>
    a260:	push	{r4, r5, r6, r7}
    a262:	orr.w	r1, r1, r1, lsl #8
    a266:	orr.w	r1, r1, r1, lsl #16
    a26a:	bic.w	r4, r2, #7
    a26e:	mvns.w	r7, #0
    a272:	movs	r3, #0
    a274:	ldrd	r5, r6, [r0], #8
    a278:	subs	r4, #8
    a27a:	eor.w	r5, r5, r1
    a27e:	eor.w	r6, r6, r1
    a282:	uadd8	r5, r5, r7
    a286:	sel	r5, r3, r7
    a28a:	uadd8	r6, r6, r7
    a28e:	sel	r6, r5, r7
    a292:	cbnz	r6, a2b8 <memchr+0x78>
    a294:	bne.n	a274 <memchr+0x34>
    a296:	pop	{r4, r5, r6, r7}
    a298:	and.w	r1, r1, #255	; 0xff
    a29c:	and.w	r2, r2, #7
    a2a0:	cbz	r2, a2b0 <memchr+0x70>
    a2a2:	ldrb.w	r3, [r0], #1
    a2a6:	subs	r2, #1
    a2a8:	eor.w	r3, r3, r1
    a2ac:	cbz	r3, a2b4 <memchr+0x74>
    a2ae:	bne.n	a2a2 <memchr+0x62>
    a2b0:	movs	r0, #0
    a2b2:	bx	lr
    a2b4:	subs	r0, #1
    a2b6:	bx	lr
    a2b8:	cmp	r5, #0
    a2ba:	itte	eq
    a2bc:	moveq	r5, r6
    a2be:	subeq	r0, #3
    a2c0:	subne	r0, #7
    a2c2:	tst.w	r5, #1
    a2c6:	bne.n	a2d8 <memchr+0x98>
    a2c8:	adds	r0, #1
    a2ca:	tst.w	r5, #256	; 0x100
    a2ce:	ittt	eq
    a2d0:	addeq	r0, #1
    a2d2:	tsteq.w	r5, #98304	; 0x18000
    a2d6:	addeq	r0, #1
    a2d8:	pop	{r4, r5, r6, r7}
    a2da:	subs	r0, #1
    a2dc:	bx	lr
    a2de:	nop

0000a2e0 <__sread>:
    a2e0:	push	{r4, lr}
    a2e2:	mov	r4, r1
    a2e4:	ldrsh.w	r1, [r1, #14]
    a2e8:	bl	a588 <_read_r>
    a2ec:	cmp	r0, #0
    a2ee:	blt.n	a2f8 <__sread+0x18>
    a2f0:	ldr	r3, [r4, #80]	; 0x50
    a2f2:	add	r3, r0
    a2f4:	str	r3, [r4, #80]	; 0x50
    a2f6:	pop	{r4, pc}
    a2f8:	ldrh	r3, [r4, #12]
    a2fa:	bic.w	r3, r3, #4096	; 0x1000
    a2fe:	strh	r3, [r4, #12]
    a300:	pop	{r4, pc}
    a302:	nop

0000a304 <__swrite>:
    a304:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a308:	mov	r6, r2
    a30a:	ldrsh.w	r2, [r1, #12]
    a30e:	mov	r7, r3
    a310:	lsls	r3, r2, #23
    a312:	mov	r4, r1
    a314:	mov	r5, r0
    a316:	bpl.n	a328 <__swrite+0x24>
    a318:	movs	r2, #0
    a31a:	movs	r3, #2
    a31c:	ldrsh.w	r1, [r1, #14]
    a320:	bl	a55c <_lseek_r>
    a324:	ldrsh.w	r2, [r4, #12]
    a328:	ldrsh.w	r1, [r4, #14]
    a32c:	bic.w	r2, r2, #4096	; 0x1000
    a330:	strh	r2, [r4, #12]
    a332:	mov	r3, r7
    a334:	mov	r2, r6
    a336:	mov	r0, r5
    a338:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a33c:	b.w	9758 <_write_r>

0000a340 <__sseek>:
    a340:	push	{r4, lr}
    a342:	mov	r4, r1
    a344:	ldrsh.w	r1, [r1, #14]
    a348:	bl	a55c <_lseek_r>
    a34c:	ldrh	r3, [r4, #12]
    a34e:	adds	r2, r0, #1
    a350:	itee	eq
    a352:	biceq.w	r3, r3, #4096	; 0x1000
    a356:	orrne.w	r3, r3, #4096	; 0x1000
    a35a:	strne	r0, [r4, #80]	; 0x50
    a35c:	strh	r3, [r4, #12]
    a35e:	pop	{r4, pc}

0000a360 <__sclose>:
    a360:	ldrsh.w	r1, [r1, #14]
    a364:	b.w	a468 <_close_r>

0000a368 <__swbuf_r>:
    a368:	push	{r3, r4, r5, r6, r7, lr}
    a36a:	mov	r5, r1
    a36c:	mov	r4, r2
    a36e:	mov	r6, r0
    a370:	cbz	r0, a378 <__swbuf_r+0x10>
    a372:	ldr	r3, [r0, #56]	; 0x38
    a374:	cmp	r3, #0
    a376:	beq.n	a40e <__swbuf_r+0xa6>
    a378:	ldrsh.w	r2, [r4, #12]
    a37c:	ldr	r3, [r4, #24]
    a37e:	str	r3, [r4, #8]
    a380:	uxth	r1, r2
    a382:	lsls	r0, r1, #28
    a384:	bpl.n	a3f8 <__swbuf_r+0x90>
    a386:	ldr	r3, [r4, #16]
    a388:	cmp	r3, #0
    a38a:	beq.n	a3f8 <__swbuf_r+0x90>
    a38c:	lsls	r1, r1, #18
    a38e:	uxtb	r7, r5
    a390:	bpl.n	a3be <__swbuf_r+0x56>
    a392:	ldr	r2, [r4, #0]
    a394:	ldr	r1, [r4, #20]
    a396:	subs	r3, r2, r3
    a398:	cmp	r3, r1
    a39a:	bge.n	a3d6 <__swbuf_r+0x6e>
    a39c:	adds	r3, #1
    a39e:	ldr	r1, [r4, #8]
    a3a0:	adds	r0, r2, #1
    a3a2:	subs	r1, #1
    a3a4:	str	r1, [r4, #8]
    a3a6:	str	r0, [r4, #0]
    a3a8:	strb	r5, [r2, #0]
    a3aa:	ldr	r2, [r4, #20]
    a3ac:	cmp	r2, r3
    a3ae:	beq.n	a3e6 <__swbuf_r+0x7e>
    a3b0:	ldrh	r3, [r4, #12]
    a3b2:	lsls	r3, r3, #31
    a3b4:	bpl.n	a3ba <__swbuf_r+0x52>
    a3b6:	cmp	r7, #10
    a3b8:	beq.n	a3e6 <__swbuf_r+0x7e>
    a3ba:	mov	r0, r7
    a3bc:	pop	{r3, r4, r5, r6, r7, pc}
    a3be:	ldr	r1, [r4, #100]	; 0x64
    a3c0:	orr.w	r2, r2, #8192	; 0x2000
    a3c4:	bic.w	r1, r1, #8192	; 0x2000
    a3c8:	strh	r2, [r4, #12]
    a3ca:	ldr	r2, [r4, #0]
    a3cc:	str	r1, [r4, #100]	; 0x64
    a3ce:	ldr	r1, [r4, #20]
    a3d0:	subs	r3, r2, r3
    a3d2:	cmp	r3, r1
    a3d4:	blt.n	a39c <__swbuf_r+0x34>
    a3d6:	mov	r1, r4
    a3d8:	mov	r0, r6
    a3da:	bl	9994 <_fflush_r>
    a3de:	cbnz	r0, a3f2 <__swbuf_r+0x8a>
    a3e0:	ldr	r2, [r4, #0]
    a3e2:	movs	r3, #1
    a3e4:	b.n	a39e <__swbuf_r+0x36>
    a3e6:	mov	r1, r4
    a3e8:	mov	r0, r6
    a3ea:	bl	9994 <_fflush_r>
    a3ee:	cmp	r0, #0
    a3f0:	beq.n	a3ba <__swbuf_r+0x52>
    a3f2:	mov.w	r7, #4294967295
    a3f6:	b.n	a3ba <__swbuf_r+0x52>
    a3f8:	mov	r1, r4
    a3fa:	mov	r0, r6
    a3fc:	bl	9784 <__swsetup_r>
    a400:	cmp	r0, #0
    a402:	bne.n	a3f2 <__swbuf_r+0x8a>
    a404:	ldrsh.w	r2, [r4, #12]
    a408:	ldr	r3, [r4, #16]
    a40a:	uxth	r1, r2
    a40c:	b.n	a38c <__swbuf_r+0x24>
    a40e:	bl	9abc <__sinit>
    a412:	b.n	a378 <__swbuf_r+0x10>

0000a414 <_wcrtomb_r>:
    a414:	push	{r4, r5, r6, r7, lr}
    a416:	mov	r6, r0
    a418:	sub	sp, #20
    a41a:	mov	r7, r3
    a41c:	cbz	r1, a442 <_wcrtomb_r+0x2e>
    a41e:	ldr	r4, [pc, #64]	; (a460 <_wcrtomb_r+0x4c>)
    a420:	ldr	r5, [pc, #64]	; (a464 <_wcrtomb_r+0x50>)
    a422:	ldr	r4, [r4, #0]
    a424:	ldr	r4, [r4, #52]	; 0x34
    a426:	cmp	r4, #0
    a428:	it	eq
    a42a:	moveq	r4, r5
    a42c:	ldr.w	r4, [r4, #224]	; 0xe0
    a430:	blx	r4
    a432:	adds	r3, r0, #1
    a434:	bne.n	a43e <_wcrtomb_r+0x2a>
    a436:	movs	r2, #0
    a438:	movs	r3, #138	; 0x8a
    a43a:	str	r2, [r7, #0]
    a43c:	str	r3, [r6, #0]
    a43e:	add	sp, #20
    a440:	pop	{r4, r5, r6, r7, pc}
    a442:	mov	r4, r1
    a444:	ldr	r1, [pc, #24]	; (a460 <_wcrtomb_r+0x4c>)
    a446:	ldr	r2, [pc, #28]	; (a464 <_wcrtomb_r+0x50>)
    a448:	ldr	r1, [r1, #0]
    a44a:	ldr	r1, [r1, #52]	; 0x34
    a44c:	cmp	r1, #0
    a44e:	it	eq
    a450:	moveq	r1, r2
    a452:	mov	r2, r4
    a454:	ldr.w	r4, [r1, #224]	; 0xe0
    a458:	add	r1, sp, #4
    a45a:	blx	r4
    a45c:	b.n	a432 <_wcrtomb_r+0x1e>
    a45e:	nop
    a460:	.word	0x20001450
    a464:	.word	0x20001454

0000a468 <_close_r>:
    a468:	push	{r3, r4, r5, lr}
    a46a:	ldr	r4, [pc, #28]	; (a488 <_close_r+0x20>)
    a46c:	movs	r3, #0
    a46e:	mov	r5, r0
    a470:	mov	r0, r1
    a472:	str	r3, [r4, #0]
    a474:	bl	2c88 <_close>
    a478:	adds	r3, r0, #1
    a47a:	beq.n	a47e <_close_r+0x16>
    a47c:	pop	{r3, r4, r5, pc}
    a47e:	ldr	r3, [r4, #0]
    a480:	cmp	r3, #0
    a482:	beq.n	a47c <_close_r+0x14>
    a484:	str	r3, [r5, #0]
    a486:	pop	{r3, r4, r5, pc}
    a488:	.word	0x20004290

0000a48c <_fclose_r>:
    a48c:	cmp	r1, #0
    a48e:	beq.n	a50c <_fclose_r+0x80>
    a490:	push	{r4, r5, r6, lr}
    a492:	mov	r5, r0
    a494:	mov	r4, r1
    a496:	cbz	r0, a49c <_fclose_r+0x10>
    a498:	ldr	r3, [r0, #56]	; 0x38
    a49a:	cbz	r3, a4fc <_fclose_r+0x70>
    a49c:	ldrsh.w	r3, [r4, #12]
    a4a0:	cbnz	r3, a4a6 <_fclose_r+0x1a>
    a4a2:	movs	r0, #0
    a4a4:	pop	{r4, r5, r6, pc}
    a4a6:	mov	r1, r4
    a4a8:	mov	r0, r5
    a4aa:	bl	984c <__sflush_r>
    a4ae:	ldr	r3, [r4, #44]	; 0x2c
    a4b0:	mov	r6, r0
    a4b2:	cbz	r3, a4c2 <_fclose_r+0x36>
    a4b4:	ldr	r1, [r4, #28]
    a4b6:	mov	r0, r5
    a4b8:	blx	r3
    a4ba:	cmp	r0, #0
    a4bc:	it	lt
    a4be:	movlt.w	r6, #4294967295
    a4c2:	ldrh	r3, [r4, #12]
    a4c4:	lsls	r3, r3, #24
    a4c6:	bmi.n	a502 <_fclose_r+0x76>
    a4c8:	ldr	r1, [r4, #48]	; 0x30
    a4ca:	cbz	r1, a4de <_fclose_r+0x52>
    a4cc:	add.w	r3, r4, #64	; 0x40
    a4d0:	cmp	r1, r3
    a4d2:	beq.n	a4da <_fclose_r+0x4e>
    a4d4:	mov	r0, r5
    a4d6:	bl	9c2c <_free_r>
    a4da:	movs	r3, #0
    a4dc:	str	r3, [r4, #48]	; 0x30
    a4de:	ldr	r1, [r4, #68]	; 0x44
    a4e0:	cbz	r1, a4ec <_fclose_r+0x60>
    a4e2:	mov	r0, r5
    a4e4:	bl	9c2c <_free_r>
    a4e8:	movs	r3, #0
    a4ea:	str	r3, [r4, #68]	; 0x44
    a4ec:	bl	9ac8 <__sfp_lock_acquire>
    a4f0:	movs	r3, #0
    a4f2:	strh	r3, [r4, #12]
    a4f4:	bl	9acc <__sfp_lock_release>
    a4f8:	mov	r0, r6
    a4fa:	pop	{r4, r5, r6, pc}
    a4fc:	bl	9abc <__sinit>
    a500:	b.n	a49c <_fclose_r+0x10>
    a502:	ldr	r1, [r4, #16]
    a504:	mov	r0, r5
    a506:	bl	9c2c <_free_r>
    a50a:	b.n	a4c8 <_fclose_r+0x3c>
    a50c:	movs	r0, #0
    a50e:	bx	lr

0000a510 <_fstat_r>:
    a510:	push	{r3, r4, r5, lr}
    a512:	mov	r3, r1
    a514:	ldr	r4, [pc, #28]	; (a534 <_fstat_r+0x24>)
    a516:	mov	r5, r0
    a518:	mov	r1, r2
    a51a:	mov	r0, r3
    a51c:	movs	r3, #0
    a51e:	str	r3, [r4, #0]
    a520:	bl	2c90 <_fstat>
    a524:	adds	r3, r0, #1
    a526:	beq.n	a52a <_fstat_r+0x1a>
    a528:	pop	{r3, r4, r5, pc}
    a52a:	ldr	r3, [r4, #0]
    a52c:	cmp	r3, #0
    a52e:	beq.n	a528 <_fstat_r+0x18>
    a530:	str	r3, [r5, #0]
    a532:	pop	{r3, r4, r5, pc}
    a534:	.word	0x20004290

0000a538 <_isatty_r>:
    a538:	push	{r3, r4, r5, lr}
    a53a:	ldr	r4, [pc, #28]	; (a558 <_isatty_r+0x20>)
    a53c:	movs	r3, #0
    a53e:	mov	r5, r0
    a540:	mov	r0, r1
    a542:	str	r3, [r4, #0]
    a544:	bl	2c9c <_isatty>
    a548:	adds	r3, r0, #1
    a54a:	beq.n	a54e <_isatty_r+0x16>
    a54c:	pop	{r3, r4, r5, pc}
    a54e:	ldr	r3, [r4, #0]
    a550:	cmp	r3, #0
    a552:	beq.n	a54c <_isatty_r+0x14>
    a554:	str	r3, [r5, #0]
    a556:	pop	{r3, r4, r5, pc}
    a558:	.word	0x20004290

0000a55c <_lseek_r>:
    a55c:	push	{r4, r5, r6, lr}
    a55e:	mov	r5, r1
    a560:	ldr	r4, [pc, #32]	; (a584 <_lseek_r+0x28>)
    a562:	mov	r1, r2
    a564:	mov	r6, r0
    a566:	mov	r2, r3
    a568:	mov	r0, r5
    a56a:	movs	r3, #0
    a56c:	str	r3, [r4, #0]
    a56e:	bl	2ca0 <_lseek>
    a572:	adds	r3, r0, #1
    a574:	beq.n	a578 <_lseek_r+0x1c>
    a576:	pop	{r4, r5, r6, pc}
    a578:	ldr	r3, [r4, #0]
    a57a:	cmp	r3, #0
    a57c:	beq.n	a576 <_lseek_r+0x1a>
    a57e:	str	r3, [r6, #0]
    a580:	pop	{r4, r5, r6, pc}
    a582:	nop
    a584:	.word	0x20004290

0000a588 <_read_r>:
    a588:	push	{r4, r5, r6, lr}
    a58a:	mov	r5, r1
    a58c:	ldr	r4, [pc, #32]	; (a5b0 <_read_r+0x28>)
    a58e:	mov	r1, r2
    a590:	mov	r6, r0
    a592:	mov	r2, r3
    a594:	mov	r0, r5
    a596:	movs	r3, #0
    a598:	str	r3, [r4, #0]
    a59a:	bl	2c84 <_read>
    a59e:	adds	r3, r0, #1
    a5a0:	beq.n	a5a4 <_read_r+0x1c>
    a5a2:	pop	{r4, r5, r6, pc}
    a5a4:	ldr	r3, [r4, #0]
    a5a6:	cmp	r3, #0
    a5a8:	beq.n	a5a2 <_read_r+0x1a>
    a5aa:	str	r3, [r6, #0]
    a5ac:	pop	{r4, r5, r6, pc}
    a5ae:	nop
    a5b0:	.word	0x20004290

0000a5b4 <__aeabi_uldivmod>:
    a5b4:	cbnz	r3, a5cc <__aeabi_uldivmod+0x18>
    a5b6:	cbnz	r2, a5cc <__aeabi_uldivmod+0x18>
    a5b8:	cmp	r1, #0
    a5ba:	it	eq
    a5bc:	cmpeq	r0, #0
    a5be:	itt	ne
    a5c0:	movne.w	r1, #4294967295
    a5c4:	movne.w	r0, #4294967295
    a5c8:	b.w	a8c8 <__aeabi_idiv0>
    a5cc:	sub.w	ip, sp, #8
    a5d0:	strd	ip, lr, [sp, #-16]!
    a5d4:	bl	a5e4 <__udivmoddi4>
    a5d8:	ldr.w	lr, [sp, #4]
    a5dc:	ldrd	r2, r3, [sp, #8]
    a5e0:	add	sp, #16
    a5e2:	bx	lr

0000a5e4 <__udivmoddi4>:
    a5e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a5e8:	mov	ip, r1
    a5ea:	mov	r6, r1
    a5ec:	mov	r4, r0
    a5ee:	ldr	r5, [sp, #32]
    a5f0:	cmp	r3, #0
    a5f2:	bne.n	a696 <__udivmoddi4+0xb2>
    a5f4:	cmp	r2, r1
    a5f6:	mov	r7, r2
    a5f8:	bls.n	a6d4 <__udivmoddi4+0xf0>
    a5fa:	clz	lr, r2
    a5fe:	cmp.w	lr, #0
    a602:	beq.n	a61c <__udivmoddi4+0x38>
    a604:	rsb	r4, lr, #32
    a608:	lsr.w	r4, r0, r4
    a60c:	lsl.w	r6, r1, lr
    a610:	orr.w	ip, r4, r6
    a614:	lsl.w	r7, r2, lr
    a618:	lsl.w	r4, r0, lr
    a61c:	mov.w	r9, r7, lsr #16
    a620:	lsrs	r2, r4, #16
    a622:	udiv	r0, ip, r9
    a626:	uxth.w	r8, r7
    a62a:	mls	r6, r9, r0, ip
    a62e:	orr.w	r6, r2, r6, lsl #16
    a632:	mul.w	r3, r0, r8
    a636:	cmp	r3, r6
    a638:	bls.n	a64e <__udivmoddi4+0x6a>
    a63a:	adds	r6, r6, r7
    a63c:	add.w	r2, r0, #4294967295
    a640:	bcs.w	a888 <__udivmoddi4+0x2a4>
    a644:	cmp	r3, r6
    a646:	bls.w	a888 <__udivmoddi4+0x2a4>
    a64a:	subs	r0, #2
    a64c:	add	r6, r7
    a64e:	subs	r6, r6, r3
    a650:	uxth	r2, r4
    a652:	udiv	r3, r6, r9
    a656:	mls	r6, r9, r3, r6
    a65a:	orr.w	r4, r2, r6, lsl #16
    a65e:	mul.w	r8, r3, r8
    a662:	cmp	r8, r4
    a664:	bls.n	a67a <__udivmoddi4+0x96>
    a666:	adds	r4, r4, r7
    a668:	add.w	r2, r3, #4294967295
    a66c:	bcs.w	a884 <__udivmoddi4+0x2a0>
    a670:	cmp	r8, r4
    a672:	bls.w	a884 <__udivmoddi4+0x2a0>
    a676:	subs	r3, #2
    a678:	add	r4, r7
    a67a:	rsb	r4, r8, r4
    a67e:	orr.w	r0, r3, r0, lsl #16
    a682:	movs	r1, #0
    a684:	cmp	r5, #0
    a686:	beq.n	a74e <__udivmoddi4+0x16a>
    a688:	lsr.w	r4, r4, lr
    a68c:	movs	r3, #0
    a68e:	str	r4, [r5, #0]
    a690:	str	r3, [r5, #4]
    a692:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a696:	cmp	r3, r1
    a698:	bls.n	a6aa <__udivmoddi4+0xc6>
    a69a:	cmp	r5, #0
    a69c:	beq.n	a74a <__udivmoddi4+0x166>
    a69e:	movs	r1, #0
    a6a0:	stmia.w	r5, {r0, r6}
    a6a4:	mov	r0, r1
    a6a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a6aa:	clz	r1, r3
    a6ae:	cmp	r1, #0
    a6b0:	bne.w	a7d4 <__udivmoddi4+0x1f0>
    a6b4:	cmp	r3, r6
    a6b6:	bcc.n	a6be <__udivmoddi4+0xda>
    a6b8:	cmp	r2, r0
    a6ba:	bhi.w	a8ae <__udivmoddi4+0x2ca>
    a6be:	subs	r4, r0, r2
    a6c0:	sbc.w	r6, r6, r3
    a6c4:	movs	r0, #1
    a6c6:	mov	ip, r6
    a6c8:	cmp	r5, #0
    a6ca:	beq.n	a74e <__udivmoddi4+0x16a>
    a6cc:	stmia.w	r5, {r4, ip}
    a6d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a6d4:	cbnz	r2, a6dc <__udivmoddi4+0xf8>
    a6d6:	movs	r7, #1
    a6d8:	udiv	r7, r7, r2
    a6dc:	clz	lr, r7
    a6e0:	cmp.w	lr, #0
    a6e4:	bne.n	a752 <__udivmoddi4+0x16e>
    a6e6:	subs	r3, r6, r7
    a6e8:	mov.w	r8, r7, lsr #16
    a6ec:	uxth.w	ip, r7
    a6f0:	movs	r1, #1
    a6f2:	udiv	r0, r3, r8
    a6f6:	lsrs	r2, r4, #16
    a6f8:	mls	r6, r8, r0, r3
    a6fc:	orr.w	r6, r2, r6, lsl #16
    a700:	mul.w	r3, ip, r0
    a704:	cmp	r3, r6
    a706:	bls.n	a718 <__udivmoddi4+0x134>
    a708:	adds	r6, r6, r7
    a70a:	add.w	r2, r0, #4294967295
    a70e:	bcs.n	a716 <__udivmoddi4+0x132>
    a710:	cmp	r3, r6
    a712:	bhi.w	a8b2 <__udivmoddi4+0x2ce>
    a716:	mov	r0, r2
    a718:	subs	r6, r6, r3
    a71a:	uxth	r2, r4
    a71c:	udiv	r3, r6, r8
    a720:	mls	r6, r8, r3, r6
    a724:	orr.w	r4, r2, r6, lsl #16
    a728:	mul.w	ip, ip, r3
    a72c:	cmp	ip, r4
    a72e:	bls.n	a740 <__udivmoddi4+0x15c>
    a730:	adds	r4, r4, r7
    a732:	add.w	r2, r3, #4294967295
    a736:	bcs.n	a73e <__udivmoddi4+0x15a>
    a738:	cmp	ip, r4
    a73a:	bhi.w	a8a8 <__udivmoddi4+0x2c4>
    a73e:	mov	r3, r2
    a740:	rsb	r4, ip, r4
    a744:	orr.w	r0, r3, r0, lsl #16
    a748:	b.n	a684 <__udivmoddi4+0xa0>
    a74a:	mov	r1, r5
    a74c:	mov	r0, r5
    a74e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a752:	rsb	r1, lr, #32
    a756:	lsl.w	r3, r6, lr
    a75a:	lsl.w	r7, r7, lr
    a75e:	lsr.w	r9, r0, r1
    a762:	mov.w	r8, r7, lsr #16
    a766:	lsrs	r6, r1
    a768:	orr.w	r9, r9, r3
    a76c:	udiv	sl, r6, r8
    a770:	mov.w	r4, r9, lsr #16
    a774:	mls	r6, r8, sl, r6
    a778:	uxth.w	ip, r7
    a77c:	orr.w	r3, r4, r6, lsl #16
    a780:	mul.w	r2, sl, ip
    a784:	cmp	r2, r3
    a786:	lsl.w	r4, r0, lr
    a78a:	bls.n	a7a2 <__udivmoddi4+0x1be>
    a78c:	adds	r3, r3, r7
    a78e:	add.w	r1, sl, #4294967295
    a792:	bcs.w	a8a4 <__udivmoddi4+0x2c0>
    a796:	cmp	r2, r3
    a798:	bls.w	a8a4 <__udivmoddi4+0x2c0>
    a79c:	sub.w	sl, sl, #2
    a7a0:	add	r3, r7
    a7a2:	subs	r3, r3, r2
    a7a4:	uxth.w	r9, r9
    a7a8:	udiv	r1, r3, r8
    a7ac:	mls	r3, r8, r1, r3
    a7b0:	orr.w	r3, r9, r3, lsl #16
    a7b4:	mul.w	r6, r1, ip
    a7b8:	cmp	r6, r3
    a7ba:	bls.n	a7cc <__udivmoddi4+0x1e8>
    a7bc:	adds	r3, r3, r7
    a7be:	add.w	r2, r1, #4294967295
    a7c2:	bcs.n	a89c <__udivmoddi4+0x2b8>
    a7c4:	cmp	r6, r3
    a7c6:	bls.n	a89c <__udivmoddi4+0x2b8>
    a7c8:	subs	r1, #2
    a7ca:	add	r3, r7
    a7cc:	subs	r3, r3, r6
    a7ce:	orr.w	r1, r1, sl, lsl #16
    a7d2:	b.n	a6f2 <__udivmoddi4+0x10e>
    a7d4:	rsb	lr, r1, #32
    a7d8:	lsr.w	r4, r2, lr
    a7dc:	lsls	r3, r1
    a7de:	orrs	r3, r4
    a7e0:	lsr.w	r7, r0, lr
    a7e4:	lsl.w	r4, r6, r1
    a7e8:	mov.w	ip, r3, lsr #16
    a7ec:	lsr.w	r6, r6, lr
    a7f0:	orrs	r4, r7
    a7f2:	udiv	r9, r6, ip
    a7f6:	lsrs	r7, r4, #16
    a7f8:	mls	r6, ip, r9, r6
    a7fc:	uxth.w	r8, r3
    a800:	orr.w	r6, r7, r6, lsl #16
    a804:	mul.w	r7, r9, r8
    a808:	cmp	r7, r6
    a80a:	lsl.w	r2, r2, r1
    a80e:	lsl.w	sl, r0, r1
    a812:	bls.n	a826 <__udivmoddi4+0x242>
    a814:	adds	r6, r6, r3
    a816:	add.w	r0, r9, #4294967295
    a81a:	bcs.n	a8a0 <__udivmoddi4+0x2bc>
    a81c:	cmp	r7, r6
    a81e:	bls.n	a8a0 <__udivmoddi4+0x2bc>
    a820:	sub.w	r9, r9, #2
    a824:	add	r6, r3
    a826:	subs	r6, r6, r7
    a828:	uxth	r0, r4
    a82a:	udiv	r4, r6, ip
    a82e:	mls	r6, ip, r4, r6
    a832:	orr.w	r7, r0, r6, lsl #16
    a836:	mul.w	r8, r4, r8
    a83a:	cmp	r8, r7
    a83c:	bls.n	a84e <__udivmoddi4+0x26a>
    a83e:	adds	r7, r7, r3
    a840:	add.w	r0, r4, #4294967295
    a844:	bcs.n	a898 <__udivmoddi4+0x2b4>
    a846:	cmp	r8, r7
    a848:	bls.n	a898 <__udivmoddi4+0x2b4>
    a84a:	subs	r4, #2
    a84c:	add	r7, r3
    a84e:	orr.w	r0, r4, r9, lsl #16
    a852:	rsb	r7, r8, r7
    a856:	umull	r8, r9, r0, r2
    a85a:	cmp	r7, r9
    a85c:	mov	r4, r8
    a85e:	mov	r6, r9
    a860:	bcc.n	a88c <__udivmoddi4+0x2a8>
    a862:	beq.n	a8b8 <__udivmoddi4+0x2d4>
    a864:	cbz	r5, a8c0 <__udivmoddi4+0x2dc>
    a866:	subs.w	r3, sl, r4
    a86a:	sbc.w	r7, r7, r6
    a86e:	lsl.w	lr, r7, lr
    a872:	lsrs	r3, r1
    a874:	lsrs	r7, r1
    a876:	orr.w	r3, lr, r3
    a87a:	stmia.w	r5, {r3, r7}
    a87e:	movs	r1, #0
    a880:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a884:	mov	r3, r2
    a886:	b.n	a67a <__udivmoddi4+0x96>
    a888:	mov	r0, r2
    a88a:	b.n	a64e <__udivmoddi4+0x6a>
    a88c:	subs.w	r4, r8, r2
    a890:	sbc.w	r6, r9, r3
    a894:	subs	r0, #1
    a896:	b.n	a864 <__udivmoddi4+0x280>
    a898:	mov	r4, r0
    a89a:	b.n	a84e <__udivmoddi4+0x26a>
    a89c:	mov	r1, r2
    a89e:	b.n	a7cc <__udivmoddi4+0x1e8>
    a8a0:	mov	r9, r0
    a8a2:	b.n	a826 <__udivmoddi4+0x242>
    a8a4:	mov	sl, r1
    a8a6:	b.n	a7a2 <__udivmoddi4+0x1be>
    a8a8:	subs	r3, #2
    a8aa:	add	r4, r7
    a8ac:	b.n	a740 <__udivmoddi4+0x15c>
    a8ae:	mov	r0, r1
    a8b0:	b.n	a6c8 <__udivmoddi4+0xe4>
    a8b2:	subs	r0, #2
    a8b4:	add	r6, r7
    a8b6:	b.n	a718 <__udivmoddi4+0x134>
    a8b8:	cmp	sl, r8
    a8ba:	bcc.n	a88c <__udivmoddi4+0x2a8>
    a8bc:	mov	r6, r7
    a8be:	b.n	a864 <__udivmoddi4+0x280>
    a8c0:	mov	r1, r5
    a8c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a8c6:	nop

0000a8c8 <__aeabi_idiv0>:
    a8c8:	bx	lr
    a8ca:	nop
    a8cc:	movs	r0, r0
	...

0000a8d0 <___init_veneer>:
    a8d0:	ldr.w	pc, [pc]	; a8d4 <___init_veneer+0x4>
    a8d4:	.word	0x600016e9
	...

Disassembly of section .fini:

0000a8e0 <_fini>:
    a8e0:	push	{r3, r4, r5, r6, r7, lr}
    a8e2:	nop
